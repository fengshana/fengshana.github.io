<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fsn</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fengshana.github.io/"/>
  <updated>2020-05-17T17:24:01.183Z</updated>
  <id>https://fengshana.github.io/</id>
  
  <author>
    <name>Fsn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MicroservicesGuide-走近微服务词汇</title>
    <link href="https://fengshana.github.io/2020/05/16/%E9%9D%A2%E8%AF%95/MicroservicesGuide-%E8%B5%B0%E8%BF%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AF%8D%E6%B1%87/"/>
    <id>https://fengshana.github.io/2020/05/16/%E9%9D%A2%E8%AF%95/MicroservicesGuide-%E8%B5%B0%E8%BF%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AF%8D%E6%B1%87/</id>
    <published>2020-05-16T08:17:39.710Z</published>
    <updated>2020-05-17T17:24:01.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Microservices-Guide-微服务指南词汇导读"><a href="#Microservices-Guide-微服务指南词汇导读" class="headerlink" title="Microservices Guide 微服务指南词汇导读"></a>Microservices Guide 微服务指南词汇导读</h2><p>我觉得我对有道词典的翻译有点迷…..<br>感觉怪怪的；  </p><p><strong>software</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">so : f : t : wa : re ( 英 /ˈsɒftweə(r)/  )</span><br><span class="line">n. 软件</span><br><span class="line">网络释义 软件；软件；软件；软设备</span><br><span class="line">Software 软件；软件；软件；软设备</span><br><span class="line">free software 自由软件；自由软体；免费软件；自在软件</span><br><span class="line">software framework 软件框架；软体框架；软件架构</span><br><span class="line">software development 软件开发</span><br><span class="line">software design 软件设计；软件开发</span><br><span class="line">software<span class="built_in"> system </span>软件系统</span><br></pre></td></tr></table></figure><p><strong>development</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">de</span> : <span class="string">ve : lo : p : men : t ( 英 /dɪˈveləpmənt/  )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">发展；开发；发育；住宅小区（专指由同一开发商开发的）；[摄]显影</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">developments</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">开发；发展；发育；进化；</span></span><br><span class="line"><span class="attr">Development</span> <span class="string">开发；发展；发育；进化</span></span><br><span class="line"><span class="attr">Software</span> <span class="string">Development 软件开发；软体开发；软件发展；软件研发</span></span><br><span class="line"><span class="attr">Career</span> <span class="string">Development 生涯规划；职业规划；生涯发展；事业发展</span></span><br><span class="line"><span class="attr">sustainable</span> <span class="string">development 可持续发展</span></span><br><span class="line"><span class="attr">economic</span> <span class="string">development 经济发展；经济开发</span></span><br><span class="line"><span class="attr">with</span> <span class="string">the development of 随着 ... 发展</span></span><br></pre></td></tr></table></figure><p><strong>young</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">young</span> <span class="string">( 英 /jʌŋ/ )</span></span><br><span class="line"><span class="meta">adj.</span> <span class="string">年轻的；初期的；没有经验的</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">年轻人；（动物的）崽，仔</span></span><br><span class="line"><span class="meta">比较级</span> <span class="string">younger</span></span><br><span class="line"><span class="meta">最高级</span> <span class="string">youngest</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">youngs</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">年轻人；青年版；杨格</span></span><br><span class="line"><span class="attr">Young</span> <span class="string">年轻人；青年版；杨格</span></span><br><span class="line"><span class="attr">Neil</span> <span class="string">Young 尼尔 杨；尼尔杨</span></span><br><span class="line"><span class="attr">Brigham</span> <span class="string">Young 杨百翰；杨百翰大学；</span></span><br></pre></td></tr></table></figure><p><strong>profession</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">p</span> : <span class="string">ro : fe : ssion ( 英 /prəˈfeʃn/ )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">职业；专业；声明；宣布；表白</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">professions</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">职业；专业；专业；行业</span></span><br><span class="line"><span class="attr">profession</span> <span class="string">职业；专业；专业；行业</span></span><br><span class="line"><span class="attr">caring</span> <span class="string">profession 护理行业；照顾他人的职业</span></span><br><span class="line"><span class="attr">Profession</span> <span class="string">informationization 行业信息化</span></span><br><span class="line"><span class="attr">profession</span> <span class="string">of 宣称（感情、信念等）；表白</span></span><br><span class="line"><span class="attr">legal</span> <span class="string">profession 法律界；法律专业</span></span><br><span class="line"><span class="attr">medical</span> <span class="string">profession 医疗职业</span></span><br></pre></td></tr></table></figure><p><strong>still</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span> : <span class="string">t : ill ( 英 /stɪl/  )</span></span><br><span class="line"><span class="meta">adv.</span> <span class="string">仍然；更；静止地</span></span><br><span class="line"><span class="meta">adj.</span> <span class="string">静止的；不动的；寂静的；平静的；不起泡的</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">寂静；剧照；蒸馏室</span></span><br><span class="line"><span class="meta">conj.</span> <span class="string">仍然；但是；尽管如此</span></span><br><span class="line"><span class="meta">vt.</span> <span class="string">蒸馏；使...静止；使....平静下来</span></span><br><span class="line"><span class="meta">vi.</span> <span class="string">静止；平静；蒸馏</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">静止；仍然；蒸馏釜；依然</span></span><br><span class="line"><span class="attr">still</span> <span class="string">静止；仍然；蒸馏釜；依然</span></span><br><span class="line"><span class="attr">still</span> <span class="string">camera 静物照相机；静物摄影集；拍照机</span></span><br><span class="line"><span class="attr">Still</span> <span class="string">wine 静止葡萄酒；静态葡萄酒；无气葡萄酒；平静葡萄酒</span></span><br><span class="line"><span class="attr">still</span> <span class="string">on 仍在进行</span></span><br><span class="line"><span class="attr">still</span> <span class="string">remains 仍然是</span></span><br><span class="line"><span class="attr">sit</span> <span class="string">still 安静地坐着</span></span><br></pre></td></tr></table></figure><p><strong>learning</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lear</span> : <span class="string">ning ( 英 /ˈlɜːnɪŋ/  )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">学习；学问</span></span><br><span class="line"><span class="meta">v.</span> <span class="string">学习（learn的现在分词）</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">学习；学习；学问；知识</span></span><br><span class="line"><span class="attr">learning</span> <span class="string">学习；学习；学问；知识</span></span><br><span class="line"><span class="attr">ensemble</span> <span class="string">learning 集成学习；围绕中心点的划分；组合算法</span></span><br><span class="line"><span class="attr">Blended</span> <span class="string">Learning 混合式学习；混合学习；混合式教学</span></span><br><span class="line"><span class="attr">learning</span> <span class="string">English 学习英语</span></span><br><span class="line"><span class="attr">higher</span> <span class="string">learning n. 高等教育；高深学问；（电影名称）校园大冲突</span></span><br><span class="line"><span class="attr">language</span> <span class="string">learning 语言学习</span></span><br></pre></td></tr></table></figure><p><strong>techniques</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">te</span> : <span class="string">chi : ni : qu : es ( chi 读 k 的音；qu 读 k 的音； 英 /tekˈni:ks/ )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">技术（technique的复数）；方法；技巧</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">技法；技术；技巧；网站架构</span></span><br><span class="line"><span class="attr">Techniques</span> <span class="string">技法；技术；技巧；网站架构</span></span><br><span class="line"><span class="attr">Sampling</span> <span class="string">techniques 采样技术；抽样技术；取样技术；采样妙技</span></span><br><span class="line"><span class="attr">Metallographic</span> <span class="string">Techniques 金相技术</span></span><br><span class="line"><span class="attr">application</span> <span class="string">Techniques 涂装技术</span></span><br><span class="line"><span class="attr">selling</span> <span class="string">techniques 推销技术</span></span><br><span class="line"><span class="attr">motivational</span> <span class="string">techniques 激励技能；激励方法（motivational technique 的复数）</span></span><br></pre></td></tr></table></figure><p><strong>building</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bu </span>: il : ding ( 英 /ˈ<span class="keyword">bɪldɪŋ/ </span> )</span><br><span class="line"><span class="symbol">n.</span> 建筑；建筑物</span><br><span class="line"><span class="symbol">v.</span> 建筑；建立；增加（<span class="keyword">build的ing形式）</span></span><br><span class="line"><span class="keyword">复数 </span><span class="keyword">buildings</span></span><br><span class="line"><span class="keyword">网络释义 </span>建筑物；大楼；号楼；房屋</span><br><span class="line"><span class="keyword">building </span>建筑物；大楼；号楼；房屋</span><br><span class="line"><span class="symbol">green</span> <span class="keyword">building </span>绿色建筑；绿色生态建筑；绿色修建</span><br><span class="line"><span class="symbol">Chrysler</span> <span class="keyword">Building </span>克莱斯勒大厦；克莱斯勒大楼；美国克莱斯勒大厦；克莱斯勒</span><br><span class="line"><span class="keyword">building </span>up 建造；装配；堆焊；建立增长</span><br><span class="line"><span class="symbol">office</span> <span class="keyword">building </span>办公大楼（等于office <span class="keyword">block）</span></span><br><span class="line"><span class="keyword">building </span>material 建筑材料</span><br></pre></td></tr></table></figure><p><strong>tools</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">too : l : s ( 英 /tuːlz/  )</span><br><span class="line">n. [计]工具，工具菜单；工具箱（tool的复数形式）</span><br><span class="line">v. 用工具加工<span class="built_in">..</span>. (tool的第三人称单数形式)</span><br><span class="line">网络释义 工具；刀具；面板；工具栏</span><br><span class="line">Tools 工具；刀具；面板；工具栏</span><br><span class="line">Game Tools 游戏常用工具；游戏常用支持工具集合；游戏开发工具；游戏工具</span><br><span class="line">Debugging Tools 调试工具；翟工具；排错工具；除错工具；</span><br><span class="line">hardware tools 五金工具；日用五金</span><br><span class="line">new tools 新工具</span><br><span class="line">machines <span class="keyword">and</span> tools 机具</span><br></pre></td></tr></table></figure><p><strong>effectively</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e : <span class="type">ffe</span> : <span class="type">c</span> : <span class="type">ti</span> : <span class="type">ve</span> : <span class="type">ly</span> ( 英 /ɪˈfektɪvli/ )</span><br><span class="line">adv. 有效地；生效地；有力地；实际上</span><br><span class="line">网络释义 有效地；起作用地；实际上；有用地</span><br><span class="line">effectively 有效地；起作用地；实际上；有用地</span><br><span class="line">effectively grounded 直接接地；有效被接地；有效接地；有效接地的</span><br><span class="line"><span class="keyword">use</span> effectively 有效利用；有效地利用</span><br></pre></td></tr></table></figure><p><strong>involved</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">in</span> : <span class="string">vol : ve : d (ve 读 v 的音 英 /ɪnˈvɒlvd/  )</span></span><br><span class="line"><span class="meta">adj.</span> <span class="string">有关的；卷入的；复杂的</span></span><br><span class="line"><span class="meta">v.</span> <span class="string">涉及；使参与；包含（involve的过去时和过去分词）</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">卷入；涉案；涉足；所涉及</span></span><br><span class="line"><span class="attr">Involved</span> <span class="string">卷入；涉案；涉足；所涉及</span></span><br><span class="line"><span class="attr">parties</span> <span class="string">involved 交换中的各方；当事人；当事者；互换中的各方</span></span><br><span class="line"><span class="attr">get</span> <span class="string">involved 介入；加入我们；项目介绍；参与</span></span><br><span class="line"><span class="attr">involved</span> <span class="string">in 涉及；包含；牵涉进...</span></span><br><span class="line"><span class="attr">involved</span> <span class="string">with 涉及；与...有关联</span></span><br><span class="line"><span class="attr">get</span> <span class="string">involved in 涉及；卷入</span></span><br></pre></td></tr></table></figure><p><strong>activity</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span> : <span class="string">c : ti : vi : ty ( 英 /ækˈtɪvəti/ )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">活动；行动；活跃</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">activities</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">活动；活性；活度；活动</span></span><br><span class="line"><span class="attr">Activity</span> <span class="string">活动；活性；活度；活动</span></span><br><span class="line"><span class="attr">logistics</span> <span class="string">activity 物流活动；物流</span></span><br><span class="line"><span class="attr">physical</span> <span class="string">activity 体力活动；体育活动；体能活动</span></span><br><span class="line"><span class="attr">economic</span> <span class="string">activity 经济活动</span></span><br><span class="line"><span class="attr">catalytic</span> <span class="string">activity 催化活性</span></span><br><span class="line"><span class="attr">physical</span> <span class="string">activity 身体活动；体育活动；体力活动</span></span><br></pre></td></tr></table></figure><p><strong>over</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">o : v : er ( 英 /ˈəʊvə(r)/  )</span><br><span class="line">adv. 倒下；翻转；穿过；完全覆盖；以上；大于；再；结束；改变；完毕；仔细地</span><br><span class="line">prep. 在<span class="params">...</span>上面；从<span class="params">...</span>上方；穿越；在<span class="params">...</span>的另一边；在<span class="params">...</span>的远端；从<span class="params">...</span>落下；遍及；多于；在<span class="params">...</span>期间；渡过；由于；关于；利用；通过；声音大于；高于；级别在<span class="params">...</span>之上；优先于；超过</span><br><span class="line">n. （板球）一轮投球</span><br><span class="line">adj. 倒下的；折起来的；结束的；剩下的</span><br><span class="line">v. 越过</span><br><span class="line">网络释义 结束；越过；超过</span><br><span class="line">over 结束；越过；超过</span><br><span class="line">hand over 移交；交出；让与</span><br><span class="line">Over There 那时那地；在那边；在那里；那边</span><br><span class="line"><span class="literal">all</span> over 到处；遍及；浑身；全部结束</span><br><span class="line">over there adv. 在那里</span><br><span class="line">over <span class="literal">and</span> over 反复；再三</span><br></pre></td></tr></table></figure><p><strong>decades</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">n.</span> <span class="string">数十年（decade的复数）</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">十年；几十年；几十年来；台阶</span></span><br><span class="line"><span class="attr">decades</span> <span class="string">十年；几十年；几十年来；台阶</span></span><br><span class="line"><span class="attr">Mixed</span> <span class="string">Decades 某某年代风</span></span><br><span class="line"><span class="attr">Frogger</span> <span class="string">Decades 青蛙过河纪念版</span></span><br><span class="line"><span class="attr">over</span> <span class="string">the past decade 在过去的十年里</span></span><br></pre></td></tr></table></figure><p><strong>writing</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wri</span> : <span class="string">ting ( 英 /ˈraɪtɪŋ/  )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">书写；写作技能；著书立说；写作的职业；作品；著作；文字；笔迹</span></span><br><span class="line"><span class="meta">v.</span> <span class="string">书写；写作（write的现在分词）</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">writings</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">写作；书写；文字</span></span><br><span class="line"><span class="attr">Writing</span> <span class="string">写作；书写；文字</span></span><br><span class="line"><span class="attr">Nature</span> <span class="string">Writing 自然写作；自然书写；自然文学</span></span><br><span class="line"><span class="attr">English</span> <span class="string">Writing 英语写作；英文写作；英文书面表达；写作</span></span><br><span class="line"><span class="attr">in</span> <span class="string">writing 书面；书面的；用书面写</span></span><br><span class="line"><span class="attr">writing</span> <span class="string">ability 写作能力；书写能力</span></span><br><span class="line"><span class="attr">writing</span> <span class="string">skill 写作技巧；书写技能；笔头</span></span><br></pre></td></tr></table></figure><p><strong>in the last two</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在最后两个</span><br><span class="line"><span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">last</span> <span class="literal">two</span> months 在过去的两个月；在最后两个月</span><br><span class="line">In <span class="keyword">the</span> <span class="keyword">last</span> <span class="literal">two</span> years 在最后两年中</span><br><span class="line">In <span class="keyword">the</span> <span class="keyword">last</span> <span class="literal">two</span> decades 在最近二十年</span><br></pre></td></tr></table></figure><p><strong>website</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">we</span> : <span class="string">b : si : te ( 英 /ˈwebsaɪt/ )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">网站（全球资讯网的主机站）</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">websites</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">网站；网址；网站建设；站点</span></span><br><span class="line"><span class="attr">Website</span> <span class="string">网站；网址；网站建设；站点</span></span><br><span class="line"><span class="attr">Website</span> <span class="string">Design 网站设计；网页设计；网站建设；品牌网站形象设计</span></span><br><span class="line"><span class="attr">Website</span> <span class="string">Promotion 网站推广；网站推广常识；网站推广知识；企业网站网络推广；</span></span><br><span class="line"><span class="attr">website</span> <span class="string">design 网站设计</span></span><br><span class="line"><span class="attr">website</span> <span class="string">promotion 网站推广</span></span><br><span class="line"><span class="attr">website</span> <span class="string">development 网站开发；网页设计</span></span><br></pre></td></tr></table></figure><p><strong>patterns</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pa</span> : <span class="string">tter : n : s</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">模式（pattern的复数形式）</span></span><br><span class="line"><span class="meta">v.</span> <span class="string">摹制；用图案装饰；复写（pattern的第三人称单数形式）</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">花样；模型；木模；形态</span></span><br><span class="line"><span class="attr">patterns</span> <span class="string">花样；模型；木模；形态</span></span><br><span class="line"><span class="attr">fashionable</span> <span class="string">patterns 花色入时；花样进时；时尚模式；花样入时</span></span><br><span class="line"><span class="attr">Corrective</span> <span class="string">Patterns 调整浪形态；调剂浪形态</span></span><br><span class="line"><span class="attr">development</span> <span class="string">patterns 发展模式</span></span><br></pre></td></tr></table></figure><p><strong>practices</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">p :</span> <span class="string">ra :</span> <span class="string">c :</span> <span class="string">ti :</span> <span class="string">ce :</span> s ( 英 <span class="regexp">/ˈpræktɪsɪs/</span>  )</span><br><span class="line">n. 实践（practice 的复数）；练习</span><br><span class="line">v. 练习（practice的第三人称单数形式）</span><br><span class="line">网络释义 客户专区；业务中心</span><br><span class="line">Practices 客户专区；业务中心</span><br><span class="line">Disciplinazy Practices 惩戒性措施；性措施</span><br><span class="line">Agricultural practices 农业方式；耕作方法；农业方法</span><br><span class="line">cultural practices 文化实践；栽培技术</span><br><span class="line">foreign corrupt practices act 反国外行贿法规</span><br></pre></td></tr></table></figure><p><strong>easier</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ea</span> : <span class="string">si : er ( 英 /'iːzɪə/  )</span></span><br><span class="line"><span class="meta">adj.</span> <span class="string">更简单；容易些（easy 的比较级形式）；较早的</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">知易行难；更简单；更容易的；更便捷</span></span><br><span class="line"><span class="attr">Easier</span> <span class="string">知易行难；更简单；更容易的；更便捷</span></span><br><span class="line"><span class="attr">EASIER</span> <span class="string">RIDER 更逍遥的骑士</span></span><br><span class="line"><span class="attr">Work</span> <span class="string">easier 工作比较轻松</span></span><br><span class="line"><span class="attr">easier</span> <span class="string">said than done 说来容易做起来难</span></span><br><span class="line"><span class="attr">make</span> <span class="string">life easier 日子会过得更潇洒；生活变得更加舒适</span></span><br></pre></td></tr></table></figure><p><strong>useful</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">u</span> : <span class="string">se : ful ( 英 /ˈjuːsfl/  )</span></span><br><span class="line"><span class="meta">adj.</span> <span class="string">有用的；有益的；有帮助的</span></span><br><span class="line"><span class="meta">比较级</span> <span class="string">more useful；</span></span><br><span class="line"><span class="meta">最高级</span> <span class="string">most useful</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">有用的；有益；软碟通软件；有效的</span></span><br><span class="line"><span class="attr">useful</span> <span class="string">有用的；有益；软碟通软件；有效的</span></span><br><span class="line"><span class="attr">Useful</span> <span class="string">numbers 常用电话号码；常用电话；常用德律风号码；经常使用电话号头</span></span><br><span class="line"><span class="attr">useful</span> <span class="string">resistance 有益阻力</span></span><br><span class="line"><span class="attr">be</span> <span class="string">useful to 对...有用；具有...用途</span></span><br><span class="line"><span class="attr">useful</span> <span class="string">life 使用寿命；有效期</span></span><br><span class="line"><span class="attr">useful</span> <span class="string">data 有用数据和资料</span></span><br></pre></td></tr></table></figure><p><strong>began</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">be </span>: gan ( 英 /<span class="keyword">bɪˈɡæn/ </span>)</span><br><span class="line"><span class="symbol">v.</span> 开始；创建；着手于（<span class="keyword">begin的过去式）</span></span><br><span class="line"><span class="keyword">网络释义 </span>开始；贝加；开始了；才开始；</span><br><span class="line"><span class="keyword">began </span>开始；贝加；开始了；才开始</span><br><span class="line"><span class="keyword">Began </span>menopause 开始更年期</span><br><span class="line"><span class="symbol">Passion</span> <span class="keyword">began </span>翻译公司开始</span><br><span class="line"><span class="keyword">begin </span>with 以...开始；开始于...</span><br><span class="line"><span class="keyword">begin </span>at 几点开始；从..开始</span><br><span class="line"><span class="keyword">begin </span>again 重新开始；重做</span><br></pre></td></tr></table></figure><p><strong>place</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">p</span> : <span class="string">la : ce ( 英 /pleɪs/  )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">地方；住所；座位</span></span><br><span class="line"><span class="meta">vt.</span> <span class="string">放置；任命；寄予</span></span><br><span class="line"><span class="meta">vi.</span> <span class="string">名列前茅；取得名次</span></span><br><span class="line"><span class="meta">过去式</span> <span class="string">placed</span></span><br><span class="line"><span class="meta">过去分词</span> <span class="string">placed</span></span><br><span class="line"><span class="meta">现在分词</span> <span class="string">placing</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">places</span></span><br><span class="line"><span class="meta">第三人称单数</span> <span class="string">places</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">渠道；地方；放置；地点</span></span><br><span class="line"><span class="attr">Place</span> <span class="string">渠道；地方；放置；地点</span></span><br><span class="line"><span class="attr">Lanham</span> <span class="string">Place 朗豪坊；朗豪酒店；朗豪坊商场；朗豪酒店</span></span><br><span class="line"><span class="attr">Martin</span> <span class="string">Place 马丁广场；牛；火车站</span></span><br><span class="line"><span class="attr">in</span> <span class="string">place 适当；适当的；在适当的地方；在适当的位置</span></span><br><span class="line"><span class="attr">place</span> <span class="string">in 安排；放置</span></span><br><span class="line"><span class="attr">take</span> <span class="string">place 发生；举行</span></span><br></pre></td></tr></table></figure><p><strong>publish</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pub</span> : <span class="string">li : sh ( 英 /ˈpʌblɪʃ/  )</span></span><br><span class="line"><span class="meta">vt.</span> <span class="string">出版；发表；公布</span></span><br><span class="line"><span class="meta">vi.</span> <span class="string">出版；发行；刊印</span></span><br><span class="line"><span class="meta">过去式</span> <span class="string">published</span></span><br><span class="line"><span class="meta">过去分词</span> <span class="string">published</span></span><br><span class="line"><span class="meta">现在分词</span> <span class="string">publishing</span></span><br><span class="line"><span class="meta">第三人称单数</span> <span class="string">publishes</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">出版；公布；发布</span></span><br><span class="line"><span class="attr">publish</span> <span class="string">出版；公布；发布</span></span><br><span class="line"><span class="attr">publish</span> <span class="string">connections 发布连接</span></span><br><span class="line"><span class="attr">Publish</span> <span class="string">Entry 发布项；宣布项</span></span><br></pre></td></tr></table></figure><p><strong>articles</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ar</span> : <span class="string">ti : cle : s</span></span><br><span class="line"><span class="attr">n.[语]文章；物品；[法]条款（article的复数）；[语]冠词</span></span><br><span class="line"><span class="meta">v.</span> <span class="string">使受协议条款的约束；指控（article的三单形式）</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">冠词；文章；各条；本刊</span></span><br><span class="line"><span class="attr">Articles</span> <span class="string">冠词；文章；各条；本刊</span></span><br><span class="line"><span class="attr">Instant</span> <span class="string">Articles 即时文章；新闻快读；即时文汇；文章快手</span></span><br><span class="line"><span class="attr">Plastic</span> <span class="string">Articles 塑料制品；塑料件；整形篇；主要进口商品英文</span></span><br><span class="line"><span class="attr">articles</span> <span class="string">of association 公司章程；组织章程</span></span><br><span class="line"><span class="attr">articles</span> <span class="string">for daily use 生活用品</span></span><br><span class="line"><span class="attr">original</span> <span class="string">articles 原作；研究文章</span></span><br></pre></td></tr></table></figure><p><strong>colleagues</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">co</span> : <span class="string">lle : gu : es</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">同事；同行（colleague的复数）</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">同仁；同人；同事；同事之间</span></span><br><span class="line"><span class="attr">Colleagues</span> <span class="string">同仁；同人；同事；同事之间</span></span><br><span class="line"><span class="attr">Visiting</span> <span class="string">Colleagues 拜访同事；造访同事</span></span><br><span class="line"><span class="attr">Complimenting</span> <span class="string">Colleagues 赞美同事；赞誉同事</span></span><br></pre></td></tr></table></figure><p><strong>joined</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jo</span> : <span class="string">in : ed ( 英 /dʒɔind/  )</span></span><br><span class="line"><span class="meta">v.</span> <span class="string">加入；参加（join的过去式；过去分词）；[计]连接</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">加入；客户留言；连接；招生简章</span></span><br><span class="line"><span class="attr">joined</span> <span class="string">加入；客户留言；连接；招生简章</span></span><br><span class="line"><span class="attr">JOINED</span> <span class="string">Strategy 连接策略</span></span><br><span class="line"><span class="attr">joined</span> <span class="string">field 将两个表中连接字段</span></span><br><span class="line"><span class="attr">join</span> <span class="string">hands 携手；联手；齐心协力</span></span><br><span class="line"><span class="attr">join</span> <span class="string">in 加入；参加</span></span><br><span class="line"><span class="attr">join</span> <span class="string">hands with 握手；同...联合</span></span><br></pre></td></tr></table></figure><p><strong>ThoughtWorks</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>role</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ro : le ( 英 /rəʊl/  )</span><br><span class="line">n. 角色；任务</span><br><span class="line">网络释义 角色；作用；社会角色；任务</span><br><span class="line"><span class="keyword">Role</span> <span class="title">角色；作用；社会角色；任务</span></span><br><span class="line"><span class="title">role</span> playing 角色扮演；角色扮演法；职能演习；角色表演</span><br><span class="line"><span class="keyword">role</span> <span class="title">model</span> 行为榜样；角色模型；榜样；模范</span><br><span class="line"><span class="keyword">role</span> <span class="title">of</span> ....的角色</span><br><span class="line">play an important <span class="keyword">role</span> <span class="title">起到重要作用</span></span><br><span class="line"><span class="title">leading</span> <span class="keyword">role</span> <span class="title">主导作用；主导地位</span></span><br></pre></td></tr></table></figure><p><strong>learn</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lear</span> : <span class="string">n ( 英 /lɜːn/  )</span></span><br><span class="line"><span class="meta">vt.</span> <span class="string">学习；得知；认识到</span></span><br><span class="line"><span class="meta">vi.</span> <span class="string">学习；获悉</span></span><br><span class="line"><span class="meta">过去式</span> <span class="string">learned 或 learnt</span></span><br><span class="line"><span class="meta">过去分词</span> <span class="string">learned 或 learnt</span></span><br><span class="line"><span class="meta">现在分词</span> <span class="string">learning</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">学会；得知</span></span><br><span class="line"><span class="attr">Learn</span> <span class="string">学会；得知</span></span><br><span class="line"><span class="attr">learn</span> <span class="string">about 了解；得知；获悉；听到</span></span><br><span class="line"><span class="attr">learn</span> <span class="string">of 听到；获悉；获悉的事；听说</span></span><br><span class="line"><span class="attr">learn</span> <span class="string">from 向...学习</span></span><br><span class="line"><span class="attr">learn</span> <span class="string">English 学习英语</span></span><br><span class="line"><span class="attr">learn</span> <span class="string">about 了解；学习</span></span><br></pre></td></tr></table></figure><p><strong>deliver</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">de</span> : <span class="string">li : ver ( 英 /dɪˈlɪvə(r)/  )</span></span><br><span class="line"><span class="meta">vt.</span> <span class="string">交付；发表；递送；释放；给予（打击）；给...接生</span></span><br><span class="line"><span class="meta">vi.</span> <span class="string">实现；传送；履行；投递</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">投球</span></span><br><span class="line"><span class="meta">过去式</span> <span class="string">delivered</span></span><br><span class="line"><span class="meta">过去分词</span> <span class="string">delivered</span></span><br><span class="line"><span class="meta">现在分词</span> <span class="string">delivering</span></span><br><span class="line"><span class="meta">第三人称单数</span> <span class="string">delivers</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">投递；交付；发出；发表</span></span><br><span class="line"><span class="attr">deliver</span> <span class="string">投递；交付；发出；发表</span></span><br><span class="line"><span class="attr">deliver</span> <span class="string">value 价值传递；传递价值</span></span><br><span class="line"><span class="attr">Deliver</span> <span class="string">Hope 传递希望；递送希望</span></span><br><span class="line"><span class="attr">deliver</span> <span class="string">the goods 交货；履行诺言</span></span><br><span class="line"><span class="attr">deliver</span> <span class="string">a speech 发表演讲；发表讲话</span></span><br></pre></td></tr></table></figure><p><strong>clients</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c : lien : ts</span><br><span class="line">n. 顾客；客户端；委托方（client的复数）；救济对象；应受账款</span><br><span class="line">网络释义 客户；客户端；案例；合作客户</span><br><span class="line">Clients 客户；客户端；案例；合作客户</span><br><span class="line">major clients 大客户；主要客户；客户</span><br><span class="line">Entertaining Clients 招待客户；款待客户；宴请客户；接待客户</span><br><span class="line">client<span class="built_in"> service </span>客户服务；向委托部门提供服务</span><br><span class="line">client base 客户群；基本顾客</span><br><span class="line">client side 客户端；使用端</span><br></pre></td></tr></table></figure><p><strong>pass</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pa</span> : <span class="string">ss ( 英 /pɑːs/  )</span></span><br><span class="line"><span class="meta">v.</span> <span class="string">通过；经过；沿某方向前进；使达到（某位置）；传递；传球；遗留给；超过；变化；推移；度过；终止；几个；经表决通过（法律等）；允许；宣布；过；排泄；流通；放弃</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">及格；经过；通行证；道路，山口；传球；飞跃；阶段；鱼道；（桥牌）不叫；（击剑中的）戳刺；变戏法；（计算机）一次浏览</span></span><br><span class="line"><span class="meta">过去式</span> <span class="string">passed</span></span><br><span class="line"><span class="meta">过去分词</span> <span class="string">passed</span></span><br><span class="line"><span class="meta">现在分词</span> <span class="string">passing</span></span><br><span class="line"><span class="meta">第三人称单数</span> <span class="string">passes</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">传球；通过；经过；传递</span></span><br><span class="line"><span class="attr">Pass</span> <span class="string">传球；通过；经过；传递</span></span><br><span class="line"><span class="attr">scissor</span> <span class="string">pass 交叉传球；交织传球；穿插传球；传球</span></span><br><span class="line"><span class="attr">Khyber</span> <span class="string">Pass 开伯尔山口；开伯尔通道；咖喱王</span></span><br><span class="line"><span class="attr">pass</span> <span class="string">through 穿过....；通过...</span></span><br><span class="line"><span class="attr">come</span> <span class="string">to pass 实现；发生</span></span><br><span class="line"><span class="attr">pass</span> <span class="string">on 传递；继续；去世</span></span><br></pre></td></tr></table></figure><p><strong>wider</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wi</span> : <span class="string">d : er ( 英 /waɪdə(r)/  )</span></span><br><span class="line"><span class="meta">adj.</span> <span class="string">宽的；广阔的（wide的比较级形式）</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">快尔达；世界发展经济研究所；宽的</span></span><br><span class="line"><span class="attr">WIDER</span> <span class="string">快尔达；世界发展经济研究所；宽的</span></span><br><span class="line"><span class="attr">wider</span> <span class="string">margin 较大差幅；俏利</span></span><br><span class="line"><span class="attr">wider</span> <span class="string">spreading 更大的穿电</span></span><br></pre></td></tr></table></figure><p><strong>industry</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">in</span> : <span class="string">du : s : try ( 英 /ˈɪndəstri/  )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">产业；工业；勤勉</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">industries</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">产业；工业；职业；行业</span></span><br><span class="line"><span class="attr">industry</span> <span class="string">产业；工业；职业；行业</span></span><br><span class="line"><span class="attr">water</span> <span class="string">industry 水利产业；水产业；水工业</span></span><br><span class="line"><span class="attr">automobile</span> <span class="string">industry 汽车工业；汽车产业；汽车业；汽车制造业</span></span><br><span class="line"><span class="attr">industry</span> <span class="string">and commerce 工商业</span></span><br><span class="line"><span class="attr">chemical</span> <span class="string">industry 化学工业</span></span><br><span class="line"><span class="attr">manufacturing</span> <span class="string">industry 制造业；制造工业</span></span><br></pre></td></tr></table></figure><p><strong>site</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">si</span> : <span class="string">te ( 英 /saɪt/ )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">地点；位置；场所</span></span><br><span class="line"><span class="meta">vt.</span> <span class="string">设置；为...选址</span></span><br><span class="line"><span class="meta">过去式</span> <span class="string">sited</span></span><br><span class="line"><span class="meta">过去分词</span> <span class="string">sited</span></span><br><span class="line"><span class="meta">现在分词</span> <span class="string">siting</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">sites</span></span><br><span class="line"><span class="meta">第三人称单数</span> <span class="string">sites</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">站点；场地；现场；场所</span></span><br><span class="line"><span class="attr">Site</span> <span class="string">站点；场地；现场；场所</span></span><br><span class="line"><span class="attr">Site</span> <span class="string">planning 敷地计划；总平面设计；场地规划</span></span><br><span class="line"><span class="attr">Site</span> <span class="string">Selection 选址；基地选择；场地选择</span></span><br><span class="line"><span class="attr">web</span> <span class="string">site 网页；网址</span></span><br><span class="line"><span class="attr">on</span> <span class="string">site 现场；原地；原位</span></span><br><span class="line"><span class="attr">construction</span> <span class="string">site 建筑工地；施工场地</span></span><br></pre></td></tr></table></figure><p><strong>developed</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">de : ve : lo : p : ed ( 英 /dɪˈveləpt/ )</span><br><span class="line">adj. 发达的（国家或地区）；成熟的</span><br><span class="line">网络释义 发达；自主开发；研制出；成熟的</span><br><span class="line">Developed 发达；自主开发；研制出；成熟的</span><br><span class="line">developed countries 发达国家；已开发国家；已发展国家；发达国家或工业化国家</span><br><span class="line">developed dimension 展开尺寸</span><br><span class="line">developed country n.发达国家</span><br><span class="line">developed<span class="built_in"> area </span>[计]展开面积</span><br><span class="line">less developed 欠发达地区；不发达的</span><br></pre></td></tr></table></figure><p><strong>respected</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">re :</span> <span class="string">s :</span> <span class="string">pe :</span> <span class="string">c :</span> <span class="string">te :</span> d ( 英 <span class="regexp">/ri'spektid/</span>  )</span><br><span class="line">adj. 受尊敬的</span><br><span class="line">v. 尊敬；重视（respect的过去式和过去分词）</span><br><span class="line">网络释义 推崇；受尊敬的；德高望重；受人尊敬</span><br><span class="line">Respected 推崇；受尊敬的；德高望重；受人尊敬</span><br><span class="line">Are respected 很受尊敬</span><br><span class="line">Respected person 德高望重的人</span><br><span class="line">respected ideas 公认理论；权威理论</span><br><span class="line">be respected <span class="keyword">as</span> 被尊为...</span><br></pre></td></tr></table></figure><p><strong>platform</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p : la : t : <span class="keyword">for</span> : m ( 英 /ˈplætfɔːm/  )</span><br><span class="line">n. 平台；月台；站台；坛；讲台；厚底松糕鞋</span><br><span class="line">网络释义 平台；站台；台；平台</span><br><span class="line">platform 平台；站台；台；平台</span><br><span class="line">side platform 侧式站台；侧式月台；侧向式站台；侧向收割台</span><br><span class="line">fixed platform 固定平台；固定式平台；固定式钻井平台</span><br><span class="line">service platform 工作台；操作平台</span><br><span class="line">offshore platform 海上平台；近海平台</span><br><span class="line">open platform 开放平台</span><br></pre></td></tr></table></figure><p><strong>edited</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">e</span> : <span class="keyword">di</span> :<span class="keyword">te</span> : <span class="keyword">d</span> ( 英 /'<span class="keyword">ed</span>ɪtɪ<span class="keyword">d</span>/  )</span><br><span class="line">adj. 编辑过的</span><br><span class="line">v. 编辑；校订；剪接；主编（<span class="keyword">edit</span>的过去式和过去分词）</span><br><span class="line">网络释义 编辑过的；编辑；分钟；已编辑</span><br><span class="line">Edited 编辑过的；编辑；分钟；已编辑</span><br><span class="line">Edited Books 编辑书籍</span><br><span class="line">SpinnBox Edited 旋转方块</span><br><span class="line"><span class="keyword">edit</span> box [计]编辑框</span><br><span class="line"><span class="keyword">edit</span> mode [计]编辑方式</span><br><span class="line"><span class="keyword">edit</span> <span class="keyword">window</span> 编辑窗口</span><br></pre></td></tr></table></figure><p><strong>published</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adj. 已发布的</span><br><span class="line">v. 出版；发行（publish的过去式）</span><br><span class="line">网络释义 刊登；刊出；刊发；刊载</span><br><span class="line">Published 刊登；刊出；刊发；刊载</span><br><span class="line">published<span class="built_in"> interface </span>已发布接口；发布接口</span><br><span class="line">published angle 预定</span><br><span class="line">published price 图书零售价；定价；公布价格</span><br></pre></td></tr></table></figure><p><strong>ThoughtWorkers</strong></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">**others**</span><br></pre></td></tr></table></figure><p>  o : ther : s ( 英 /ˈʌðə(r)z/   )<br>  pron. 其他人<br>  网络释义 其它；其他；全部信息；其他组件保养<br>  Others 其他；其它；全部信息；其他组件保养<br>  the others 小岛惊魂；神鬼第六感；其它<br>  Introduce Others 先容别人<br>  each other 彼此；互相<br>  on the other 另一方面<br>  on the other hand 另一方面</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*reach*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  rea : ch (  英 /riːtʃ/ )<br>  vi. 达到；延伸；伸出手；传开<br>  vt. 达到；影响；抵达；伸出<br>  n. 范围；延伸；河段；横风行驶<br>  第三人称单数 reaches<br>  过去式 reached<br>  过去分词 reached<br>  现在分词 reaching<br>  网络释义 到达；达到；到达率；化学品注册<br>  Reach 到达；达到；到达率；化学品注册<br>  Reach Me 书缘寻踪；抓住我；请与我联系；联系我<br>  reach out 伸出；提供援助；接纳我<br>  reach out vt. 伸出<br>  reach for 伸手去拿<br>  reach an agreement 达成协议；取得一致意见；达成共识</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*audience*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  au : di : en : ce ( 英 /ˈɔːdiəns/  )<br>  n. 观众；听众；读者；接见；正式会见；拜会<br>  网络释义 观众；听众；受众；阅听人<br>  Audience 观众；听众；受众；阅听人<br>  target audience 目标观众；目标消费者；目标大众；目标受众<br>  Audience area 听众区；看台区；观众区<br>  target audience 目标受众；目标观众；目标客户<br>  audience rating n. 收视率；试听率<br>  mass audience 大众受众</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*material*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  ma : te : ri : al ( 英 /məˈtɪəriəl/  )<br>  n. 材料；用具；（有指明特征的）人才；素材；曲目；布料<br>  adj. 物质的；身体需要的；和推理内容相关的；重要的；（证据或事实）决定性的；客观存在的；物欲的<br>  n. (Material)(意、美)妈特力娅丽（人名）<br>  复数 materials<br>  网络释义 材质；材料；物料；资料<br>  Material 材质；材料；物料；资料<br>  Material Girl 物质女孩；拜金女孩；物质女郎；拜金女郎<br>  insulating material 隔热材料；绝热材料；绝缘物<br>  raw material 原料<br>  teaching material 教学内容；教学资料<br>  new material 新材料</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*MicroServices*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  Mi: cro : Ser : vi : ce : s<br>  微服务；<br>  微服务架构<br>  网络释义 微服务；微服务架构<br>  Microservices 微服务；微服务架构<br>  cognitive microservices 认知微服务；认证微服务<br>  Microservices Architecture 微服务架构</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*Guide*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  gui : de  ( 英 /ɡaɪd/ )<br>  n. 指南；向导；入门书；<br>  vt. 引导；带领；操纵；<br>  vi. 担任向导；<br>  n.(Guide)人名；（法、葡）吉德<br>  过去式 guided；<br>  过去分词 guided；<br>  现在分词 guiding；<br>  复数 guides；<br>  第三人称单数 guides；<br>  网络释义 导游、指导、指南、领队<br>  Guide 导游；指导；指南；领队；<br>  guide post 路标；引导柱；导柱；导杆<br>  User Guide 说明书；用户指南；用户操作手册</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*In short*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  总之；<br>  简言之；<br>  网络释义 简言之；总之；简而言之；简单地说<br>  in short 简言之；总之；简而言之；简单地说<br>  in the short term 从短期来看<br>  in a short time 不久；在短时间内</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*architectural*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  ar : chi : te : c : tur : al（chi读ki的音，英 /ˌɑːkɪˈtektʃərəl/  ）<br>  adj. 建筑学的；建筑上的；符合建筑法的<br>  网络释义 建筑；建筑设计；建筑材质；建筑学的<br>  architectural 建筑；建筑设计；建筑材质；建筑学的<br>  architectural style 建筑风格；建筑形式；架构风格<br>  Architectural acoustics 建筑声学；建筑音响；构筑声学；建筑音响学</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*style*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  s : ty : le  （ 英 /staɪl/ ）<br>  n. 风格；时尚；类型；字体<br>  vt. 设计；称呼；使合潮流<br>  vi. 设计式样；用刻刀作装饰画<br>  n. (Style)人名；（英）斯泰尔<br>  过去式 styled；<br>  过去分词 styled；<br>  现在分词 styling；<br>  复数 styles；<br>  第三人称单数 styles；<br>  网络释义 风格；样式；款式；作风<br>  style 风格；样式；款式；作风<br>  Style 作风<br>  Text Style 字体样式；字布局；文字样式；文字布局</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="number">*a</span>pproach <span class="keyword">to</span>**</span><br></pre></td></tr></table></figure><p>  a : pp : roa : ch  （ 英 /əˈprəʊtʃ/  ）<br>  接近；约等于；通往…的方法<br>  网络释义 约等于；接近；类似；办法；<br>  approach to 约等于；接近；类似；办法<br>  approach h to criticality 接近临界<br>  approach h to 做某事的方法；约等于；接近；对…的态度</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*developing*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  de : ve : lo : ping  （ 英 /dɪˈveləpɪŋ/  ）<br>  adj. 发展中的；生长的；变化的<br>  n. 发展<br>  v. 发展；成长；产生；感受；使（摄影胶片）显影（develop的现在分词）<br>  网络释义 发展；发展中的；显影；开发<br>  Developing 发展；发展中的；显影；开发<br>  developing trend 发展趋势；发展走向；趋势<br>  developing machine 洗片机；显影机；头影机（这个头？我抄的有道词典上的）；显色机</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*single*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  sin : gle （ 英 /ˈsɪŋɡl/ ）<br>  adj. 单一的；单身的；单程的<br>  n. 一个；单打；单程票<br>  vt. 选出<br>  vi. 击出一垒安打<br>  过去式 singled<br>  过去分词 singled<br>  现在分词 singling<br>  复数 singles<br>  第三人称单数 singles<br>  网络释义 未婚；一垒安打；单曲；单一的；<br>  single 未婚；一垒安打；单曲；单一的<br>  single market 统一市场；北京市场；单一市场；同一市场<br>  single parent 单亲家庭；单亲；单父协同；单亲母亲</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="built_in">application</span>**</span><br></pre></td></tr></table></figure><p>  a : pp : li : ca : tion （ 英 /ˌæplɪˈkeɪʃn/  ）<br>  n. 应用；申请；应用程序；敷用；（对事物、学习等）投入<br>  网络释义 用途；应用软件；应用<br>  APPLICATION 用途；应用软件；应用<br>  application fee 申请费；报名费；申请费用；登记费<br>  patent application 专利申请；专利申请书；专利声请；专利申请说明书</p><p>  patent<br>  pa : ten : t  （英 /‘pæt(ə)nt; ‘peɪt(ə)nt/）<br>  n. 专利权；专利证；专利品；<br>  adj. 专利的；特许生产或销售的；显著的；公开的；（脉管等）开放的<br>  v. 取得…的专利权；授予专利<br>  复数 patents<br>  过去式 patented<br>  过去分词 patented<br>  现在分词 patenting<br>  第三人称单数 patents<br>  网络释义 专利权；专利；专利品；科技玩具<br>  patent 专利权；专利；专利品；科技玩具<br>  patent family 专利族；同族专利<br>  patent attorney 专利律师；专利代理人；称为专利法务人员</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">**a suite of**</span></span><br></pre></td></tr></table></figure><p>  s : ui : te（ui读wi的音， 英 /swiːt/ ）<br>  一系列<br>  网络释义 一套；一整组；详细翻译（详细翻译&gt;&gt;a suite of 一系列；一套…）<br>  a suite of 一套；一整组；详细翻译<br>  a suite of racks 一套机架<br>  a suite of paintings 一组从不同角度和层次反映同一中心思想和题材的绘画</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*small*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  s : ma : ll  （ 英 /smɔːl/  ）<br>  adj. 少的，小的；微弱的；几乎没有的；不重要的；幼小的<br>  adv. 小小地；卑鄙地<br>  n. 小件物品；矮小的人<br>  n. （Small）人名；（英）斯莫尔<br>  网络释义 小的；小型的；小码；卡片纸英国标准<br>  small 小的；小型的；小码；卡片纸英国标准<br>  small intestine 小肠<br>  small incision 小切口；隧道切口；微创；微小切口</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*services*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  s : er : vi : ce : s  （ 英 /‘sə:visis/ ）<br>  n. 服务；服务项目（service复数形式）<br>  v. 服务（service的第三人称单数）<br>  网络释义 服务；服务项目；服务范围；服务业<br>  Services 服务；服务项目；服务范围；服务业<br>  Services 服务<br>  Web Services 网络服务；Web服务；应用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="keyword">each</span>**</span><br></pre></td></tr></table></figure><p>  ea : ch  （ 英 /iːtʃ/  ）<br>  det. （两个或两个以上的人或物中）各自<br>  pron. （两个或两个以上的人或物中）每个<br>  adv. 每个地<br>  adj. 各自的<br>  网络释义 每个；各自；每次；每一<br>  Each 每个；各自；每次；每一<br>  each other 互相；彼此；相互；取长补短<br>  Each line 每行</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="built_in">running</span>**</span><br></pre></td></tr></table></figure><p>  run : ning  （ 英 /ˈrʌnɪŋ/  ）<br>  n. 运转；赛跑；流出<br>  adj. 连续的；流动的；跑者的，运转着的<br>  v. 跑；运转（run的ing形式）；行驶<br>  n. (Running)人名；（英）朗宁<br>  网络释义 跑步；跑；磨合；运行<br>  running 跑步；跑；磨合；运行<br>  Running Man 过关斩将；奔跑吧兄弟；落跑老爸；奔跑的男人<br>  running shoes 跑步鞋；慢跑鞋；竞走鞋</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*own*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  o : wn （ 英 /əʊn/  ）<br>  vt. 拥有；承认<br>  vi. 承认<br>  adj. 自己的；特有的<br>  n. 自己的<br>  n.（Own）人名；（阿拉伯）奥恩（我就服这些人名，不会读是吧，读这个中文式译音人名就会读了）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="built_in">process</span>**</span><br></pre></td></tr></table></figure><p>  p : ro : ce : ss  (  英 /prəˈses; (for n.) ˈprəʊses/ )<br>  n. （为达到某一目标的）过程；（自然变化的）工程；工艺流程；诉讼程序；传票；突起；进展；（发型）直发式<br>  v. 加工；审核；处理（数据）；队列行进；冲印（照片）；把（头发）弄成直发<br>  adj. 经过特殊加工的；照相板的；染印法的<br>  第三人称单数 processes<br>  过去式 processed<br>  过去分词 processed<br>  现在分词 processing<br>  复数 processes<br>  网络释义 进程；流程；过程<br>  process 进程；流程；过程<br>  Process Management 进程管理；过程管理；流程管理；进程管理<br>  Background Process 后台进程；背景程序；背景处理程序</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*communicating*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  com : mu : ni : ca : ting ( 英 /kə’mjʊnə,keɪtɪŋ/ )<br>  adj. （房间）相同的，相连的<br>  v. 交流；传递；传播（communicate的现在分词）<br>  网络释义 沟通；交流；通信的互通的；交流与通讯<br>  Communicating 沟通；交流；通信的互通的；交流与通讯<br>  communicating vessels 连通器；连通管<br>  Communicating junctions 通讯连接</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*lightweight*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  li : ght : wei : ght ( 英 /ˈlaɪtweɪt/ )<br>  n. 轻量级（拳击手）；比通常重量轻的人或东西；无足轻重的人（或事）<br>  adj. 轻量的；给人印象不深的；无足轻重的；比通常重量轻的；浅薄的；<br>  网络释义 轻量级；轻身的；轻量；轻量化；<br>  lightweight 轻量级；轻身的；轻量；轻量化<br>  lightweight 轻填料；轻质搀和料<br>  lightweight cover 轻型上盖；避雷保护</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*mechanisms*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  me : cha : ni : sm : s（cha 读 ke 的音，英 /‘mekənɪzəmz/ ）<br>  n. 机制；[计]机构（mechanism的复数）；机械；[机]机构学<br>  网络释义 发病机制；发生机制；机制；机构<br>  Mechanisms 发病机制；发生机制；机制；机构<br>  interaction mechanisms 互动机制；作用机制<br>  resistant mechanisms 耐药机制；抗病机制</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*often*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  o : f : ten ( 英 /ˈɒfn; ˈɒftən/  )<br>  adv. 常常；时常；往往，大多<br>  比较级 more often 或 oftener；<br>  最高级 most often 或 oftenest<br>  网络释义 经常；常常；时常；常有<br>  Often 进场；常常；时常；常有<br>  more often 更经常；经常；更多的时候；更多<br>  OFT OFTen 常常；再三</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*HTTP*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  H : T : T : P ( 英 /ˌeɪtʃ tiː tiː ˈpiː/  )<br>  abbr. 超文本传输协议（Hyper Text Transfer Protocol）<br>  网络释义 超文本传输协议（Hyper Text Transfer Protocol）；网站；平台；超文本传送协议</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*resource*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  re : sou : r : ce ( 英 /rɪˈsɔːs; rɪˈzɔːs/  )<br>  n. 资源，财力；办法；智谋<br>  vi. 向…提供资金<br>  网络释义 资源；资源类型；财力；办法<br>  Resource 资源；资源类型；财力；办法<br>  human resource 人力资源；激励；人事部<br>  computational resource 计算资源</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*API*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  A : P : I ( /ˌeɪ piː ˈaɪ/  )<br>  abbr. 空气污染指数（Air Pollution Index）；应用程序界面（Application Program Interface）；精确位置指示器（Accurate Position Indicator）；美国石油学会（American Petroleum Institute）；自动发音教学机（Automated Pronunciation Instructor）<br>  网络释义 美国石油协会；应用程序接口；美国石油学会；应用编程接口<br>  API 美国石油协会；应用程序接口；美国石油学会；应用编程接口<br>  Windows API 使用；调用；关于进程操作的；关于线程操作的<br>  Google API 谷歌应用界面；应用程序编程接口；网址二维码生成函数；应用程序接口</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*these*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  th : e : se ( 英 /ðiːz/  )<br>  det. 这些（this的复数）<br>  pron. 这些（this的复数）<br>  adj. 这些的（this的复数）<br>  网络释义 这些，此等；复数；这些个<br>  These 这些；此等；复数；这些个<br>  Know these 知其然；到知其然<br>  These payments 营养费</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*built*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  bu : il : t ( 英 /bɪlt/ )<br>  v. 建造，建立；逐步增强；把…嵌入（墙壁、物体等）（build的过去式和过去分词）<br>  adj. 有…体格的；身段优美的；….建成的<br>  网络释义 建起；比优丽；建有；建好<br>  Built 建起；比优丽；建有；建好<br>  Built NY 比优丽<br>  BLT Built 建造；制作<br>  built in 安装在里面的；装入的；机内的<br>  built up 组合<br>  built on 以…作基础</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="keyword">around</span>**</span><br></pre></td></tr></table></figure><p>  a : roun : d ( 英 /əˈraʊnd/  )<br>  adv. 在四周；朝对立面；到处；漫无目的的；在附近；大约；围绕；以圆周计算；现有；转弯<br>  prep. 围绕；在那边；绕着；同…一致；到处；以（已提及物）为中心；迂回<br>  网络释义 围绕；四处；在周围；大约<br>  Around 围绕；四处；在周围；大约；<br>  come around 苏醒；顺便来访；来访；复原<br>  stick around 在附近逗留或等待；在附近等着；在邻近勾留或等候；逗留<br>  all round 周围；到处，四处<br>  around here 附近；在这周围<br>  go around 四处走动；供应；（消息）流传</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*business*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  bu : si : ne : ss ( 英 /ˈbɪznəs/ )<br>  n. 商业，交易；生意；事务，业务；职业，行业；<br>  网络释义 商业；生意；企业；业务<br>  Business 商业；生意；企业；业务<br>  Business 业务<br>  business cycle 商业周期；经济周期；商业周期；景气循环<br>  business card 名片；商务名片<br>  in business 经商；在经营；在商界<br>  business philosophy 经营理念，经营哲学</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*capabilities*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  ca : pa : bi : li : ti : es ( 英 /ˌkeɪpəˈbɪlətɪs/  )<br>  n. 能力（capability的复数）；功能；性能<br>  网络释义 能力；功能；权限；责任<br>  capabilities 能力；功能；权限；责任<br>  economic capabilities 经济实力；经济能力<br>  defense capabilities 防卫作战能力；防务能力；防卫功能；<br>  process capability 加工能力；工序能力<br>  design capability 设计能力</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*independently*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  in : de : pen : den : t : ly ( 英 /ˌɪndɪˈpendəntli/  )<br>  adv. 独立地；自立地<br>  网络释义 各自地；独立地；独自地；自立地<br>  independently 各自地；独立地；独自地；自立地<br>  think independently 独立思考；独立的思考<br>  living independently 独立生活<br>  independently of 独立于…之外；与…无关</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*deployable*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  de : p : lo : y : a : ble<br>  adj. 可开展的<br>  网络释义 可开展的；散播性<br>  deployable 可开展性的；散播性<br>  Deployable Structures 折叠结构；可展结构<br>  deployable joint 运动关节</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*fully*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  fu : lly ( 英 /ˈfʊli/  )<br>  adv. 充分地；完全地；彻底地<br>  n. (Fully)人名；（法）菲利<br>  网络释义 完全地；彻底地；充分地；十分地<br>  fully 完全地；彻底地；充分地；十分地<br>  FULLY OPENING 全开口；全启齿；齐闭口<br>  fully  secured 足额担保；全额担保<br>  fully automatic 全自动的<br>  fully integrated 完全整合<br>  fully loaded 满载</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="built_in">auto</span>mated**</span><br></pre></td></tr></table></figure><p>  au : to : ma : te : d ( 英 /ˈɔːtəˌmeɪtɪd/  )<br>  adj. 自动化的；机械化的<br>  v. 自动化（automate的过去分词）；自动操作<br>  网络释义 自动化的；自动的；机械化的；自动化<br>  automated 自动化的；自动的；机械化的；自动化<br>  automated design 自动设计；自动化设计；自动想象<br>  Automated inspection 自动化检验；自动检验<br>  automated machine 自动化机械；自动化的机器<br>  automated teller machine 自动柜员机<br>  automated welding 自动焊接</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*deployment*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  de : p : lo : y : men : t ( 英 /dɪˈplɔɪmənt/ )<br>  n. 调度，部署<br>  复数 deployments<br>  网络释义 部署；展开；发布；布防<br>  Deployment 部署，展开；发布；布防<br>  Deployment Editors 部署编辑器；安排编纂器<br>  Resources deployment 资源配置<br>  disposition n.调度，部署</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*machinery*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  ma  chi : ne : ry ( 英 /məˈʃiːnəri/  )<br>  n. 机械；机器；机构；机械装置<br>  网络释义 机械；机器；机具<br>  machinery 机械；机器；机具<br>  packaging machinery 包装机械；包装设备；包装机器；放大器<br>  Electrical Machinery 电机学；电力机械；电机；电机驱动<br>  machinery and equipment 机器及设备<br>  construction machinery 建筑机械；施工机械<br>  agricultural machinery 农业机械</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*there*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  the : re ( 英 /ðeə(r)/  )<br>  adv. 在那里；在那边；在那点上；<br>  int. 你瞧<br>  n. 那个地方<br>  网络释义 那里；在那里；那儿；那<br>  There 那里；在那里；那儿；那<br>  Always There 永驻；守候一生；到约定的那时；总在我身旁<br>  There be 句型；的句子结构；存在句；结构<br>  out there 到战场；在那里<br>  over there adv. 在那里<br>  go there 去那里</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*bare*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  b : are ( 英 /beə(r)/ )<br>  adj. 空的；赤裸的；无遮蔽的<br>  vt. 露出；使赤裸<br>  n. (Bare)人名；（英）贝尔<br>  比较级 barer<br>  最高级 barest<br>  过去式 bared<br>  过去分词 bared<br>  现在分词 baring<br>  网络释义 赤裸的；光光；赤裸；仅仅的<br>  bare 赤裸的；光光；裸露；仅仅的<br>  bare mass 裸质量<br>  bare machine 裸机；硬件计算机；裸机<br>  bare of vt. 几乎没有，缺乏<br>  lay bare 揭发，暴露；公开<br>  bare feet 赤脚；光脚；光着脚</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*minimum*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  mi : ni : mum ( 英 /ˈmɪnɪməm/ )<br>  n. 最小值；最低限度；最小化；最小量<br>  adj.最小的；最低的<br>  复数 minimums 或 minima<br>  网络释义 最小的；最低；起码；最小量<br>  minimum 最小的；最低；起码；最小量<br>  minimum charge 最低费用；最低运费；最低收费<br>  minimum balance 最小库存余量；最低余额；存款限制；把费用减到最低限度</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="keyword">bare </span>minimum of**</span><br></pre></td></tr></table></figure><p>  最低限度的<br>  网络释义 Bare Minimum Of Expense 最低支出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*centralized*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  cen : tra : li : ze : d ( 英 /‘sentrəlaɪzd/  )<br>  adj. 集中的；中央集权的<br>  v. 集中（centralize的过去分词）<br>  网络释义 集中的，中央集权的；一致<br>  Centralized 集中的；中央集权的；一致<br>  centralized control 集中控制；中央控制；集中控制方式；中心控制<br>  Centralized Monitoring 集中监控；中化监查<br>  centralized management 集中式管理；集权管理<br>  centralized control 集中控制<br>  centralized processing 集中式处理</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*management*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  ma : na : ge : men : t ( 英 /ˈmænɪdʒmənt/  )<br>  n. 管理；管理人员；管理部门；操纵；经营手段<br>  复数 managements<br>  网络释义 管理；经营；管理学；管理层；<br>  Management 管理；经营；管理学；管理层<br>  Management Accounting 管理会计；管理会计学；治理会计；会计管理<br>  performance management 绩效管理；业绩管理；性能管理<br>  management system 管理系统；经营责任制<br>  quality management 质量管理<br>  project management 项目管理；专案管理</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*written*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  wri : tten ( 英 /ˈrɪtn/  )<br>  adj. 书面的，成文的，文字的<br>  v. 写（writen的过去分词）<br>  网络释义 写成；写给；书面；成文<br>  Written 写成；写给；书面；成文<br>  written English 书面英语；书面语；书面表达；英语书面语<br>  written notice 书面通知；面通知；书面通知<br>  written by 由…所写<br>  written english 书面英语<br>  written consent 书面同意；同意书</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*different*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  di : ffe : ren : t ( 英 /ˈdɪfrənt/  )<br>  adj. 不同的；个别的；与众不同的<br>  网络释义 不同；差异；两样<br>  Different 不同；差异；两样<br>  different from 不同于；两回事；不同；区别于<br>  Different Seasons 四季奇谭；不同的季节；肖申克的救赎；不同季节<br>  different from 与…不同，不同于<br>  different kinds 不同的种类<br>  in different ways 以不同方式；用不同方法；通过不同的方式</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*programming*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  pro : g : ram : ming ( 英 /ˈprəʊɡræmɪŋ/  )<br>  n. 设计；规划；编制程序；[计]程序编制<br>  网络释义 编程；程序设计；编程；程序编制<br>  programming 编程；程序设计；编程；程序编制<br>  Linear Programming 线性规划；第二十九章；线性程序编制；线性规划法<br>  generic programming 泛型；泛型编程；程序设计；类属编程<br>  linear programming n. 线性规划<br>  programming language 编程语言；程序设计语言<br>  dynamic programming 动态规划；动态程序设计</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*languages*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  lan : g : ua : ge : s ( 美 /‘læŋgwɪdʒ/ )<br>  n. 语系，语种；语言文字（language复数）<br>  网络释义 语文；语言；语言能力；语言学<br>  Languages 语文；语言；语言能力；语言学<br>  altaic languages 阿尔泰语系；阿尔泰语言<br>  Uralic languages 乌拉尔语系<br>  modern languages 现代语言（modern language的复数）<br>  foreign languages school 外语学校<br>  romance languages 罗曼斯语（由拉丁语演变而成的语言）</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="keyword">use</span>**</span><br></pre></td></tr></table></figure><p>  u : se ( 英 /juːz/  )<br>  n. 使用；用途；发挥<br>  vt. 利用；耗费<br>  vi. 使用，运用<br>  n.(Use)人名；（德）乌泽<br>  过去式 used<br>  过去分词 used<br>  现在分词 using<br>  复数 uses<br>  第三人称单数 using<br>  网络释义 使用；用途；利用；应用<br>  use 使用；用途；利用；应用<br>  use up 用完；用光；耗尽<br>  Use Case 用例；用例图<br>  make use of 使用；利用<br>  in use 在使用中<br>  of use 有用</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="class"><span class="keyword">data</span>**</span></span><br></pre></td></tr></table></figure><p>  da : ta ( 英 /ˈdeɪtə; ˈdɑːtə/  )<br>  n. 数据（datum的复数）；资料<br>  n. (Data)人名；(日)驮太 (姓)；(印、葡)达塔<br>  网络释义 数据；资料；数据区；参考数据<br>  data 数据；资料；数据区；参考数据<br>  Data Center 数据中心；资料中心；数据交互中心<br>  data collection 数据收集；数据采集；数据搜集；搜集资料<br>  data processing 数据处理<br>  experimental data 实验数据；试验数据<br>  data mining 数据挖掘技术（即指从资料中发掘咨询或知识）</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*storage*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  s : to : ra : ge ( 英 /ˈstɔːrɪdʒ/  )<br>  n. 存储；仓库；贮藏所<br>  复数 storages<br>  网络释义 存储；储存；保管；贮藏；<br>  Storage 存储；储存；保管；贮藏<br>  storage room 行李仓；储物室；储藏室；贮藏室<br>  cold storage 冷藏；冷藏库；冷库；冷藏公司<br>  data storage 数据存储<br>  storage system 存储系统；存储器存储系统<br>  energy storage 蓄能；能量储存；储能器</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*technologies*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  te : ch : no : lo : gi : es (  美 /tɛk’nɑlədʒi/  )<br>  n. 技术；科技（technology的复数）<br>  网络释义 姓；科技<br>  Technologies 姓；科技<br>  Agilent Technologies 安捷伦科技公司；安捷伦科技有限公司；安捷伦<br>  United Technologies 联合技术；联合技术公司；联合科技；联合科技公司<br>  united technologies 联合科技（财富500强公司之一，总部所在地美国，主要经营航空航天）<br>  cleaner technologies 净化技术；清洁技术<br>  lucent technologies 美国朗讯科技公司（财富500强公司之一）<br>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Microservices-Guide-微服务指南词汇导读&quot;&gt;&lt;a href=&quot;#Microservices-Guide-微服务指南词汇导读&quot; class=&quot;headerlink&quot; title=&quot;Microservices Guide 微服务指南词汇导读&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="词汇" scheme="https://fengshana.github.io/categories/%E8%AF%8D%E6%B1%87/"/>
    
    
      <category term="微服务" scheme="https://fengshana.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="词汇" scheme="https://fengshana.github.io/tags/%E8%AF%8D%E6%B1%87/"/>
    
  </entry>
  
  <entry>
    <title>这世间，唯有青春与梦想不可辜负</title>
    <link href="https://fengshana.github.io/2020/05/16/%E5%BF%83%E6%83%85/%E8%BF%99%E4%B8%96%E9%97%B4%EF%BC%8C%E5%94%AF%E6%9C%89%E9%9D%92%E6%98%A5%E4%B8%8E%E6%A2%A6%E6%83%B3%E4%B8%8D%E5%8F%AF%E8%BE%9C%E8%B4%9F/"/>
    <id>https://fengshana.github.io/2020/05/16/%E5%BF%83%E6%83%85/%E8%BF%99%E4%B8%96%E9%97%B4%EF%BC%8C%E5%94%AF%E6%9C%89%E9%9D%92%E6%98%A5%E4%B8%8E%E6%A2%A6%E6%83%B3%E4%B8%8D%E5%8F%AF%E8%BE%9C%E8%B4%9F/</id>
    <published>2020-05-15T16:13:48.915Z</published>
    <updated>2020-05-15T17:54:49.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：<a href="https://www.bilibili.com/video/BV1j4411j79x/?spm_id_from=trigger_reload" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1j4411j79x/?spm_id_from=trigger_reload</a>  </p><blockquote><p>衡水中学“学霸”励志演讲：这世间，唯有青春与梦想不可辜负</p></blockquote><p>这个是他的标题挺好的；<br>这个是我妹妹介绍我去看的，她们班上成人礼看了这个当时没看完，然后后面发烧回家把它又完整的看了一遍；我看了，然后本来是昨天看的，准备写些什么的；因为昨天一天面试了两轮，有点累；然后睡了昨天睡的很好；  </p><p>妹妹： 张锡锋<br>妹妹：原来我常常想，别人尊重我，是因为我很优秀；可是到了衡中才发现，别人尊重我，是因为别人很优秀，这是衡中学子独有的青春魅力。  </p><p>我跟我妹的关系，是一种十分平等的关系，就比如说推荐我或者说安利我看某个觉得意义非常大的一个视频什么的；或者是….总之我认为我现在和家人之间的一个相处的一个模式就是与家人都是一个平等的一个状态；我可以告诉你我现在的一个状态；你也向我倾诉你的心声；我觉得这种状态非常的好；好了不扯了；  </p><p>这个视频昨天看到后面其实我泪目了。<br>打动人心的地方可能在于的确有些话戳中心坎了。也有可能是我的心底还不够坚强坚硬吧。然后容易感动的缘故。  </p><p>总的来说我希望我，我认识我爱的人爱我的人不管年龄多少岁余生都能够朝着自己的一个目标而努力奋斗追逐着。  </p><p>下面是看视频的他的一个演讲的内容；我也是一边听一边写；对了其实我发现，就是在b站上面其实每天有50上下左右的人在看这个视频；其实他的这场演讲带来的力量也是很大的，能够做到一种就是正面积极向上在自己处于低糜或者是迷茫的这样一种状态下，然后给人一种就是正确的这样一个方向指引的作用是非常值得学习的；  </p><p>我也是其中的受益者即使我当前已经离开学校的生活步入社会了。  </p><p>好了不多说了，我这人就是容易比较话多有个时候自己跟自己说话都能说得睡不着觉。害，愁人。(｡•ˇ‸ˇ•｡)  </p><p>对了，建议请使用原速度进行播放，不要快进。（更有感觉）  </p><h2 id="演讲稿"><a href="#演讲稿" class="headerlink" title="演讲稿"></a>演讲稿</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">尊敬的老师，亲爱的同学们，大家好！（此时他鞠躬<span class="number">90</span>度，不错小伙子，哈哈哈哈哈~~~）</span><br><span class="line"></span><br><span class="line">我是<span class="number">838</span>班的张锡锋。</span><br><span class="line"></span><br><span class="line">相信很多同学应该认识我，在大家眼里，我扮演更多的通常是个谐星的角色。  </span><br><span class="line"></span><br><span class="line">可是大家似乎忘记了，在我这看似狂野，实则狂野的外表下（不哦老阿姨觉得你长的挺清秀的哦哈哈哈哈），也隐藏着一颗憧憬阳光的心。（很好）</span><br><span class="line"></span><br><span class="line">所以，我站在这里，与大家分享关于学习，（此处应该加个逗号，不然就变成了“学习我的看法” emm）我的看法。</span><br><span class="line"></span><br><span class="line">我演讲的主题是：青春与梦想。  </span><br><span class="line"></span><br><span class="line">话说这世间，唯有青春与梦想不可辜负。  </span><br><span class="line"></span><br><span class="line">花开正好，微风不燥，（我那句阳光正好微风不燥也是取自这里哈哈哈哈）我们扬帆，起航。  </span><br><span class="line"></span><br><span class="line">首先，青春，青春是什么颜色的？  </span><br><span class="line"></span><br><span class="line">是五月的花海，灿烂无比；是海边的浪花，永不停息；是仲夏的骄阳，激情四射。  </span><br><span class="line"></span><br><span class="line">青春在衡中，是绚丽多彩的；  </span><br><span class="line"></span><br><span class="line">原来啊，我常常想，别人尊重我，是因为，我很优秀。  </span><br><span class="line"></span><br><span class="line">可是，到了衡中才发现，别人尊重我，是因为，别人很优秀。  </span><br><span class="line"></span><br><span class="line">这，是衡中学子，独有的，青春魅力！  </span><br><span class="line"></span><br><span class="line">同样，正值青春，我们有犯错的权利。  </span><br><span class="line"></span><br><span class="line">记得第一次交改错本，我问老师要改多少？（好了，他在讲述他的二货经历了，跟我有的一比）</span><br><span class="line"></span><br><span class="line">老师说，根据个人情况，在精不在多。  </span><br><span class="line"></span><br><span class="line">哦呜？  </span><br><span class="line"></span><br><span class="line">是吗？</span><br><span class="line"></span><br><span class="line">这可是您说的。</span><br><span class="line"></span><br><span class="line">说时迟那时快，我顿时绽放了一个耀眼的笑容。（这个笑容可以想象）</span><br><span class="line"></span><br><span class="line">我心不在焉，草草了事。</span><br><span class="line"></span><br><span class="line">可是，改错发下来时却是，一片万紫千红的样子。  </span><br><span class="line"></span><br><span class="line">上面，有详细的批注，评语是这样的：这个改错改的不错，有些题改着改着就错了。（唉哟这个老师很皮哦）</span><br><span class="line"></span><br><span class="line">我们老师青春活泼的力量，就这样让学习生活妙趣横生。  </span><br><span class="line"></span><br><span class="line">其次，是这里青春的学习氛围（其实他这里停顿了一定时间，就是等着下面的同学渐渐静下来然后再说话，嗯，挺好的），当你满眼，都是追求卓越的字样时，便也，没理由落后了。  </span><br><span class="line"></span><br><span class="line">（好了，二货的自黑开始了）连我这个，被同学们誉为：古娜拉黑暗之神的人，也，早已经，在前往卓越的路上。</span><br><span class="line"></span><br><span class="line">我喜欢，在某个课间琢磨那些，优雅的，美丽的数学题。（的确，如果真的觉得诶这个的确十分有趣，其实是会慢慢的沉下去真正喜欢上这些以前觉得枯燥乏味的东西。比如说数据结构）</span><br><span class="line"></span><br><span class="line">（好了，二货长吸一口气，哈哈）小东西，真别致。（他这里又在等下面的声音静下来一点然后才开始说话，不错）</span><br><span class="line"></span><br><span class="line">我喜欢，在某天清晨头昏脑胀时，回想刚刚学过的，系统命名法。  </span><br><span class="line"></span><br><span class="line">哇，这一瞬间有一百万个可能。  </span><br><span class="line"></span><br><span class="line">我喜欢，某天晚上躺在床上，回想曾经背过的老子，“知人者智，自知者明。圣人者有力，自胜者强。” 我好困啊……</span><br><span class="line"></span><br><span class="line">第二，梦想。</span><br><span class="line"></span><br><span class="line">有一条路，人烟稀少寸步难行，但是，却不得不坚持前进，因为它的尽头，种着梦想。（这个时候我想到了一首纯音乐可以停下就是叫啥来着 the right path；然后通过这首纯音乐，我也发现了一首意义非常对于我而言非常好的一首小诗；黄色的树林里分出两条路 我选择了人迹更少的一条 从此决定了我一生的道路；同样也送给你们；有个时候听纯音乐，其实也是在听自己内心的声音。）</span><br><span class="line"></span><br><span class="line">同学们，你的梦想是什么？（我以前可能不知道，但是我现在知道了，也知道我前进的方向是什么了。）</span><br><span class="line"></span><br><span class="line">相信，很多人的回答都会是清北这样的顶尖名校。</span><br><span class="line"></span><br><span class="line">我们选择它们不仅仅因为它们是名校，还因为它们坐落的城市，它们美丽的传说。  </span><br><span class="line"></span><br><span class="line">对于痴迷于地理学科的我来说，外面的世界，外面的城市就是我的梦想。  </span><br><span class="line"></span><br><span class="line">这里，广东，对外开放的前沿，我把它做成卡贴随身携带；</span><br><span class="line"></span><br><span class="line">这里，上海，全中国最大的城市，我把它拍成照片贴在课桌上；  </span><br><span class="line"></span><br><span class="line">这里，西安，大唐不夜城，我做梦都会想起它。</span><br><span class="line"></span><br><span class="line">看完这些，不知道同学们心里有什么感触；（感触嘛，也有的，我也想去外面的世界多看看多走走多经历）</span><br><span class="line"></span><br><span class="line">此刻，你的心里是否充满了对未来的渴望？</span><br><span class="line"></span><br><span class="line">我问同学们一个问题，请大家伸出右手。</span><br><span class="line"></span><br><span class="line">看，它像什么？（他举起了右手，说实话吗？像手）</span><br><span class="line"></span><br><span class="line">像右手？</span><br><span class="line"></span><br><span class="line">这都被你发现了吗？（不错啊，都很皮，哈哈哈哈）</span><br><span class="line"></span><br><span class="line">同学们，果然见多识广啊！（那是那是，谦虚一点，自己人知道就行）</span><br><span class="line"></span><br><span class="line">请大家，五指并拢，放于腰间，慢慢高举，举过头顶，张开。</span><br><span class="line"></span><br><span class="line">成功了吗？那恭喜你！你给自己，放了个烟花。（不错的小伙子，哈哈哈哈）</span><br><span class="line"></span><br><span class="line">可是，烟花虽美，转瞬即逝。（我这个烟花不太美，五指太短了看不出来烟花的样子）</span><br><span class="line"></span><br><span class="line">现在，请同学们伸出你的烟花，把它攥成拳。</span><br><span class="line"></span><br><span class="line">大家看，它又像什么？（像石头）</span><br><span class="line"></span><br><span class="line">好，我们不要再来了。。</span><br><span class="line"></span><br><span class="line">请大家把你的右拳置于你的耳边，如果你能清楚地听到脉搏的律动，那么我告诉你：这，是生命。  </span><br><span class="line"></span><br><span class="line">我们梦想很美，很远大；</span><br><span class="line"></span><br><span class="line">但是只有把掌握成拳，用尽全力，挥向生活，这样，才是青春路上，该有的姿态。（不错，好样的，我怎么感觉我在，，创建我自己的弹幕。。。。）</span><br><span class="line"></span><br><span class="line">同学们，你，有没有感到一种震撼？</span><br><span class="line"></span><br><span class="line">相信，很多人都会跟我一样，因为这是一种念想。</span><br><span class="line"></span><br><span class="line">一种发自内心，由内而外的，对城市，对未来的渴望。</span><br><span class="line"></span><br><span class="line">少年们早已不想拘泥于这里，只能在所谓，抖音、电影里，去观望别人的生活。（是的，所以，我们要做的是过好自己的生活，而不是去羡慕别人，其实自己也可以）</span><br><span class="line"></span><br><span class="line">可是，为什么我们就只能做那个躲在阴暗的角落里，新鲜的舞台之上，光鲜亮丽的别人的那个，卑微的人。</span><br><span class="line"></span><br><span class="line">这样不行。</span><br><span class="line"></span><br><span class="line">一点儿都不好玩。（我也觉得，因为你不觉得干巴巴的看着别人的生活，只会让自己emm觉得自己的生活并没有，怎么说呢如果自己的三观并不是摆的很正的话，就会产生一种攀比的这样一种心理情绪，这样是非常不好的。）</span><br><span class="line"></span><br><span class="line">我们，会走出去，顺境也好逆境也好，人生，本就是一场与种种困难无休无尽的斗争，一场，敌众我寡的斗争。（卧槽，他这里好像念错了，念成了敌寡敌众的斗争，但是当前他并没有就是因为这个点的失误而后面演讲的不好，这一点很好其实，面对失误并不慌张而是顺利的接入下一句话这样子，不错小伙子）</span><br><span class="line"></span><br><span class="line">我曾把自己向往的大学热爱的城市，拍成照片贴在课桌上，每当我精疲力竭时，都要看一下它（方便找回自己当初的信念不会感到迷茫的这样一种方式，其实也是引导自己走出低落的这样一种情绪或者说避免低落；其实我也有，就是写一些话然后经常去看，鼓励自己的这样一种方式），然后质问自己，就这样啦，你就这点东西？（是的，我也这样傻逼式自嘲）你真的真的到了最后歇斯底里不能坚持的地步了吗？</span><br><span class="line"></span><br><span class="line">你的理想是诗，理想是梦，理想是远方的田野，是穿越世界的旅行！</span><br><span class="line"></span><br><span class="line">但现在你能做的所有，只是，把手握紧！（嗯）</span><br><span class="line"></span><br><span class="line">厚积薄发！（嗯）</span><br><span class="line"></span><br><span class="line">你，只有付出！（嗯）</span><br><span class="line"></span><br><span class="line">付出你的时间，赌上你的尊严，拿出你的全部！你的everything!（嗯，是的，努力了才有收获，不努力什么也没有）</span><br><span class="line"></span><br><span class="line">当别人打游戏时你在学习，当别人睡懒觉时你在学习，你含着泪在深夜里舞蹈，在回忆里奔跑！（其实这句话好像才是打动我的点，就是听了这些话很容易就联想到以前自己努力坚持的一些画面这样子）</span><br><span class="line"></span><br><span class="line">没有人，在年少时想成为一个普通人。</span><br><span class="line"></span><br><span class="line">尽管生活，它会剥夺你的所爱践踏你的尊严，把你踩在脚下遍体鳞伤。</span><br><span class="line"></span><br><span class="line">但你，怎能，倒下！（但我，怎能，倒下！）</span><br><span class="line"></span><br><span class="line">你的身后，是挚爱的人；</span><br><span class="line"></span><br><span class="line">那些受过的伤都将成为你的勋章，都是你，送给未来的自己最好的礼物！（是的，就像是我之前说，emm，希望自己能够成为未来的自己的一块垫脚石/踏脚石）</span><br><span class="line"></span><br><span class="line">我，也有梦想啊！（我的梦想是，在java开发这一行当中慢慢的沉淀自己，遇见更多更好的人）</span><br><span class="line"></span><br><span class="line">我告诉自己，总有一天，我会站在金色的舞台上，聚光灯打向我，摄像机对准我，所有人的目光注视着我，我能站在台上侃侃而谈。此刻，世界只有我一人！（emm不错）</span><br><span class="line"></span><br><span class="line">我要让平日里轻蔑我的对手知道，我要让他们亲口说出那三个字：（我爱你？对不起？我恨你？我可能平时emm肥皂去看多了？）</span><br><span class="line"></span><br><span class="line">你，赢了！（厉害）</span><br><span class="line"></span><br><span class="line">如果说，青春，是足迹，那梦想，一定，叫做远方。</span><br><span class="line"></span><br><span class="line">请同学们相信，生活明朗，万物可爱；（是的，我确实相信着这句话）</span><br><span class="line"></span><br><span class="line">人间值得，未来可期。（是的，人间值得，未来可期！）</span><br><span class="line"></span><br><span class="line">（加油，诶我刚把网页给叉掉了，他结尾其实好像也同样是鞠躬了<span class="number">90</span>度，不错。小伙子。）</span><br></pre></td></tr></table></figure><h2 id="未选择的路"><a href="#未选择的路" class="headerlink" title="未选择的路"></a>未选择的路</h2><p>从前可能觉得名人名言只会发生在名人身上，其实名人也只是将自己的所感表达了出来；来纾解自己的某一种情绪而已；其实很多的时候去读某一首小诗某一句经典名句再联想一下自己的生活，很多的时候是的确有很大的一个共同之处的。<br>这就是共鸣吧。<br>将自己的表达通过文字的形式温柔的表达了出来。  </p><p>好了不说了，今天面试问了微服务，我直接说我不会。现在挨打的时候到了。去看书去了。  </p><p>对了，读这首小诗的时候，bgm切换成 <strong>the right path</strong>跟配哦~（the right path其实有段时间，在去年吧，我循环了很久，因为本身去年是一个害怕成长但又渴望成长，迷茫的一个状态，挺丧的，所以说，这个时候要么找朋友倾诉要么，听纯音乐静下心来听听自己心底的声音。建议一定要将这种情绪排解出来，不要压抑自己，不好，因为经历过，所以知道，去学会坦诚学会怎么样去接受容纳自己。希望看文的道友们也能像演讲人一样，或许是此刻或许是未来的某一个时间点能够慢慢绽放属于自己的那一星光亮。）  </p><p>诶诶诶我突然发现，我拍的这个照片跟我这个选择的路，有点睛的这样一个作用，哈哈哈哈哈，你看，这时候我今天拍的云，很漂亮，不像一条道路吗？哈哈哈可能是我想多了哈哈哈哈。  </p><p>好了话不多说我撤了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">《未选择的路》</span><br><span class="line"></span><br><span class="line">罗伯特 弗罗斯特</span><br><span class="line"></span><br><span class="line">黄色的树林里分出两条路，</span><br><span class="line"></span><br><span class="line">可惜我不能同时去涉足，</span><br><span class="line"></span><br><span class="line">我在那路口久久伫立，</span><br><span class="line"></span><br><span class="line">我向着一条路极目望去，</span><br><span class="line"></span><br><span class="line">直到它消失在丛林深处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">但我却选择了另外一条路，</span><br><span class="line"></span><br><span class="line">它荒草凄凄，十分幽寂，</span><br><span class="line"></span><br><span class="line">显得更诱人，更美丽；</span><br><span class="line"></span><br><span class="line">虽然在这两条小路上，</span><br><span class="line"></span><br><span class="line">都很少留下旅人的足迹；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">虽然那天清晨落叶满地，</span><br><span class="line"></span><br><span class="line">两条路都未经脚印污染。</span><br><span class="line"></span><br><span class="line">啊，留下一条路等改日再见！</span><br><span class="line"></span><br><span class="line">但我知道路径延绵无尽头，</span><br><span class="line"></span><br><span class="line">恐怕我难以再返回。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">也许多少年后在某个地方，</span><br><span class="line"></span><br><span class="line">我将轻声叹息把往事回顾：</span><br><span class="line"></span><br><span class="line">一片树林里分出两条路，</span><br><span class="line"></span><br><span class="line">而我选择了人迹更少的一条，</span><br><span class="line"></span><br><span class="line">从此决定了我一生的道路。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看笔记：&lt;a href=&quot;https://www.bilibili.com/video/BV1j4411j79x/?spm_id_from
      
    
    </summary>
    
    
      <category term="心情" scheme="https://fengshana.github.io/categories/%E5%BF%83%E6%83%85/"/>
    
    
      <category term="心情" scheme="https://fengshana.github.io/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Redis-尚硅谷redis视频教程-尚硅谷-周阳</title>
    <link href="https://fengshana.github.io/2020/05/13/%E9%9D%A2%E8%AF%95/Redis-%E5%B0%9A%E7%A1%85%E8%B0%B7redis%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%91%A8%E9%98%B3/"/>
    <id>https://fengshana.github.io/2020/05/13/%E9%9D%A2%E8%AF%95/Redis-%E5%B0%9A%E7%A1%85%E8%B0%B7redis%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B-%E5%B0%9A%E7%A1%85%E8%B0%B7-%E5%91%A8%E9%98%B3/</id>
    <published>2020-05-13T13:49:09.207Z</published>
    <updated>2020-05-14T15:46:58.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：<a href="https://www.bilibili.com/video/BV1J4411x7U1?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1J4411x7U1?p=1</a>  </p><p>中途换视频：<a href="https://www.bilibili.com/video/BV1Cb411j7RA?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Cb411j7RA?p=1</a>  </p><h2 id="NoSQL入门概述-上"><a href="#NoSQL入门概述-上" class="headerlink" title="NoSQL入门概述-上"></a>NoSQL入门概述-上</h2><ul><li>NoSQL入门和概述</li><li>Redis入门介绍</li><li>Redis数据类型</li><li>解析配置文件redis.conf</li><li>Redis的持久化</li><li>Redis的事务</li><li>Redis的发布订阅</li><li>Redis的复制（Master/Slave）</li><li>Redis的Java客户端Jedis</li></ul><p>所有天上飞的理念都需要落地的实现。  </p><p>Redis和MongoDB都是NoSQL的思想典型产品构建；  </p><p>NoSQL是什么？  </p><ul><li>入门概述<ul><li>1.互联网时代背景下大机遇，为什么用NoSQL<ul><li>1）单机MySQL的美好年代</li><li>2）Memcached(缓存)+MySQL+垂直拆分</li><li>3）MySQL主从读写分离</li><li>4）分表分库+水平拆分+mysql集群</li><li>5）MySQL的扩展性瓶颈</li><li>6）今天是什么样子？</li><li>7）为什么用NoSQL</li></ul></li><li>2.NoSQL<strong>是什么</strong></li><li>3.NoSQL<strong>能干嘛</strong></li><li>4.Redis<strong>去哪</strong>里<strong>下</strong>载</li><li>5.Redis<strong>怎么玩</strong></li></ul></li><li>3V+3高</li><li>当下的NoSQL经典应用</li><li>NoSQL数据模型简介</li><li>NoSQL数据库的四大分类</li><li>在分布式数据库中CAP原理CAP+BASE</li></ul><ol><li>单机MySQL的美好年代</li></ol><p>在90年代，一个网站的访问量一般都不大，用单个数据库完全可以轻松应付。<br>在那个时候，更多的都是静态网页，动态交互类型的网站不多。  </p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------        -------------       ---------------</span><br><span class="line">|<span class="string">         </span>|<span class="string">         </span>|<span class="string">         </span>|<span class="string">         </span>|<span class="string">           </span>|</span><br><span class="line">|<span class="string">   APP   </span>|<span class="string"> -------&gt;</span>|<span class="string">   DAL   </span>|<span class="string"> -------&gt;</span>|<span class="string">   MySQL   </span>|</span><br><span class="line">|<span class="string">         </span>|<span class="string">         </span>|<span class="string">         </span>|<span class="string">         </span>|<span class="string"> Instance  </span>|</span><br><span class="line">------------       -------------       ---------------</span><br></pre></td></tr></table></figure><p>上述架构下，来看看数据存储的瓶颈是什么？  </p><ol><li>数据量的总大小      —-》一个机器放不下时</li><li>数据的索引（B+Tree）—-》一个机器的内存放不下时</li><li>访问量（读写混合）  —-》一个实例不能承受时</li></ol><h2 id="NoSQL入门概述-下"><a href="#NoSQL入门概述-下" class="headerlink" title="NoSQL入门概述-下"></a>NoSQL入门概述-下</h2><h2 id="当下NoSQL应用场景简介"><a href="#当下NoSQL应用场景简介" class="headerlink" title="当下NoSQL应用场景简介"></a>当下NoSQL应用场景简介</h2><h2 id="NoSQL数据模型简介"><a href="#NoSQL数据模型简介" class="headerlink" title="NoSQL数据模型简介"></a>NoSQL数据模型简介</h2><h2 id="NoSQL数据库的四大分类"><a href="#NoSQL数据库的四大分类" class="headerlink" title="NoSQL数据库的四大分类"></a>NoSQL数据库的四大分类</h2><h2 id="分布式数据库CAP原理"><a href="#分布式数据库CAP原理" class="headerlink" title="分布式数据库CAP原理"></a>分布式数据库CAP原理</h2><h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><h2 id="启动后杂项基础知识"><a href="#启动后杂项基础知识" class="headerlink" title="启动后杂项基础知识"></a>启动后杂项基础知识</h2><h2 id="常用五大数据类型简介"><a href="#常用五大数据类型简介" class="headerlink" title="常用五大数据类型简介"></a>常用五大数据类型简介</h2><h2 id="key关键字"><a href="#key关键字" class="headerlink" title="key关键字"></a>key关键字</h2><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><h2 id="配置文件介绍"><a href="#配置文件介绍" class="headerlink" title="配置文件介绍"></a>配置文件介绍</h2><h2 id="持久化之RDB"><a href="#持久化之RDB" class="headerlink" title="持久化之RDB"></a>持久化之RDB</h2><h2 id="持久化之AOF"><a href="#持久化之AOF" class="headerlink" title="持久化之AOF"></a>持久化之AOF</h2><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h2 id="消息订阅发布简介"><a href="#消息订阅发布简介" class="headerlink" title="消息订阅发布简介"></a>消息订阅发布简介</h2><h2 id="主从复制上"><a href="#主从复制上" class="headerlink" title="主从复制上"></a>主从复制上</h2><h2 id="主从复制下"><a href="#主从复制下" class="headerlink" title="主从复制下"></a>主从复制下</h2><h2 id="Jedis测试连通"><a href="#Jedis测试连通" class="headerlink" title="Jedis测试连通"></a>Jedis测试连通</h2><h2 id="Jedis常用API"><a href="#Jedis常用API" class="headerlink" title="Jedis常用API"></a>Jedis常用API</h2><h2 id="Jedis事务"><a href="#Jedis事务" class="headerlink" title="Jedis事务"></a>Jedis事务</h2><h2 id="Jedis主从复制"><a href="#Jedis主从复制" class="headerlink" title="Jedis主从复制"></a>Jedis主从复制</h2><h2 id="JedisPool"><a href="#JedisPool" class="headerlink" title="JedisPool"></a>JedisPool</h2><h2 id="Redis之技术的分类"><a href="#Redis之技术的分类" class="headerlink" title="Redis之技术的分类"></a>Redis之技术的分类</h2><h2 id="解决session的存储问题"><a href="#解决session的存储问题" class="headerlink" title="解决session的存储问题"></a>解决session的存储问题</h2><h2 id="NoSQL简介"><a href="#NoSQL简介" class="headerlink" title="NoSQL简介"></a>NoSQL简介</h2><h2 id="常用的NoSQL数据库-1"><a href="#常用的NoSQL数据库-1" class="headerlink" title="常用的NoSQL数据库(1)"></a>常用的NoSQL数据库(1)</h2><h2 id="常用的NoSQL数据库-2"><a href="#常用的NoSQL数据库-2" class="headerlink" title="常用的NoSQL数据库(2)"></a>常用的NoSQL数据库(2)</h2><h2 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h2><h2 id="Redis启动服务端和客户端"><a href="#Redis启动服务端和客户端" class="headerlink" title="Redis启动服务端和客户端"></a>Redis启动服务端和客户端</h2><h2 id="Redis单线程-多路IO复用"><a href="#Redis单线程-多路IO复用" class="headerlink" title="Redis单线程+多路IO复用"></a>Redis单线程+多路IO复用</h2><h2 id="Redis基本指令"><a href="#Redis基本指令" class="headerlink" title="Redis基本指令"></a>Redis基本指令</h2><h2 id="redis之string"><a href="#redis之string" class="headerlink" title="redis之string"></a>redis之string</h2><h2 id="redis之list"><a href="#redis之list" class="headerlink" title="redis之list"></a>redis之list</h2><h2 id="redis之set-1"><a href="#redis之set-1" class="headerlink" title="redis之set(1)"></a>redis之set(1)</h2><h2 id="redis之set-2"><a href="#redis之set-2" class="headerlink" title="redis之set(2)"></a>redis之set(2)</h2><h2 id="redis之hash"><a href="#redis之hash" class="headerlink" title="redis之hash"></a>redis之hash</h2><h2 id="redis之zset"><a href="#redis之zset" class="headerlink" title="redis之zset"></a>redis之zset</h2><h2 id="redis实现文章访问量的排序"><a href="#redis实现文章访问量的排序" class="headerlink" title="redis实现文章访问量的排序"></a>redis实现文章访问量的排序</h2><h2 id="redis之配置文件"><a href="#redis之配置文件" class="headerlink" title="redis之配置文件"></a>redis之配置文件</h2><h2 id="java连接redis"><a href="#java连接redis" class="headerlink" title="java连接redis"></a>java连接redis</h2><h2 id="Jedis实现手机号验证码"><a href="#Jedis实现手机号验证码" class="headerlink" title="Jedis实现手机号验证码"></a>Jedis实现手机号验证码</h2><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><h2 id="redis之事务"><a href="#redis之事务" class="headerlink" title="redis之事务"></a>redis之事务</h2><h2 id="秒杀案例"><a href="#秒杀案例" class="headerlink" title="秒杀案例"></a>秒杀案例</h2><h2 id="ab工具模拟并发"><a href="#ab工具模拟并发" class="headerlink" title="ab工具模拟并发"></a>ab工具模拟并发</h2><h2 id="解决超卖和库存遗留问题"><a href="#解决超卖和库存遗留问题" class="headerlink" title="解决超卖和库存遗留问题"></a>解决超卖和库存遗留问题</h2><h2 id="redis持久化之RDB"><a href="#redis持久化之RDB" class="headerlink" title="redis持久化之RDB"></a>redis持久化之RDB</h2><h2 id="redis持久化之AOF"><a href="#redis持久化之AOF" class="headerlink" title="redis持久化之AOF"></a>redis持久化之AOF</h2><h2 id="redis主从复制演示"><a href="#redis主从复制演示" class="headerlink" title="redis主从复制演示"></a>redis主从复制演示</h2><h2 id="redis主从复制之薪火相传"><a href="#redis主从复制之薪火相传" class="headerlink" title="redis主从复制之薪火相传"></a>redis主从复制之薪火相传</h2><h2 id="redis主从复制之哨兵模式"><a href="#redis主从复制之哨兵模式" class="headerlink" title="redis主从复制之哨兵模式"></a>redis主从复制之哨兵模式</h2><h2 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h2><h2 id="redis之JedisCluster"><a href="#redis之JedisCluster" class="headerlink" title="redis之JedisCluster"></a>redis之JedisCluster</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看笔记：&lt;a href=&quot;https://www.bilibili.com/video/BV1J4411x7U1?p=1&quot; target=
      
    
    </summary>
    
    
      <category term="面试" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="redis" scheme="https://fengshana.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>缓存四大问题</title>
    <link href="https://fengshana.github.io/2020/05/12/%E9%9D%A2%E8%AF%95/redis%E7%BC%93%E5%AD%984%E5%A4%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://fengshana.github.io/2020/05/12/%E9%9D%A2%E8%AF%95/redis%E7%BC%93%E5%AD%984%E5%A4%A7%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-12T14:42:25.316Z</published>
    <updated>2020-05-13T09:53:28.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：<a href="https://www.bilibili.com/video/BV1gZ4y1s7Aw" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1gZ4y1s7Aw</a></p><p>之前这个的视频下架了，我就没办法再回过头去再看一遍；现在知道了，一边看一定得一定得做笔记。不然下次悄悄地没有了。想哭都没地方。  </p><h2 id="缓存穿透详解及实战"><a href="#缓存穿透详解及实战" class="headerlink" title="缓存穿透详解及实战"></a>缓存穿透详解及实战</h2><ol><li><strong>如何使用缓存？</strong></li></ol><p>（思路十分简单）</p><p>controller层(对于数据的访问)：  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">OrderService orderService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">Integer <span class="title">insertOrder</span><span class="params">(Order order)</span></span>&#123; <span class="function"><span class="keyword">return</span> orderService.<span class="title">insertOrder</span><span class="params">(order)</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/updateOrder"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">Integer <span class="title">updateOrder</span><span class="params">(Order order)</span></span>&#123; <span class="function"><span class="keyword">return</span> orderService.<span class="title">updateOrder</span><span class="params">(order)</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于一条数据的访问；通过id进行查询数据；</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/selectid"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">R <span class="title">selectOrderById</span><span class="params">(Integer id)</span></span>&#123; <span class="function"><span class="keyword">return</span> orderService.<span class="title">selectOrderById</span><span class="params">(id)</span></span>;&#125;</span><br></pre></td></tr></table></figure><p>service层：  </p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.testcache.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="params">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> interface OrderService&#123;</span><br><span class="line">  <span class="built_in">Integer</span> insertOrder(<span class="keyword">Order</span> <span class="keyword">order</span>);</span><br><span class="line"></span><br><span class="line">  R selectOrderById(<span class="built_in">Integer</span> id);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="keyword">Order</span>&gt; selectOrderAll();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Integer</span> updateOrder(<span class="keyword">Order</span> <span class="keyword">order</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service impl（实现）层：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提高性能</span></span><br><span class="line"><span class="comment">//保护数据库</span></span><br><span class="line">public R select<span class="constructor">OrderById(Integer <span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//查询缓存；</span></span><br><span class="line">  <span class="comment">//第一次查询缓存，即查询redis；</span></span><br><span class="line">  <span class="comment">//valueOperations这个对象专门针对于redis当中String类型的一个操作；</span></span><br><span class="line">  <span class="comment">//valueOperations是与SpringBoot整合之后的一个对象；valueOperations的上级即为redis；</span></span><br><span class="line">  <span class="comment">//valueOperations专用于操作字符串String类型；</span></span><br><span class="line">  Object redisObj = valueOperations.get(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//命中缓存</span></span><br><span class="line">  <span class="comment">//如果缓存当中存在该对象则直接返回；</span></span><br><span class="line">  <span class="keyword">if</span>(redisObj != null)&#123;</span><br><span class="line">    <span class="comment">//正常返回数据</span></span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(200)</span>.set<span class="constructor">Data(<span class="params">redisObj</span>)</span>.set<span class="constructor">Msg(<span class="string">"OK"</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//否则如果缓存当中不存在该对象则查询数据库；</span></span><br><span class="line">  <span class="comment">//查询数据库之后，再将该数据加入到缓存当中；</span></span><br><span class="line">  <span class="comment">//方便下一次查询的时候更够查询得到该记录，该对象；</span></span><br><span class="line">  <span class="comment">//然后返回给前端</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      Order order = orderMapper.select<span class="constructor">OrderById(<span class="params">id</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span>(order != null)&#123;</span><br><span class="line">        valueOperations.set(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>, order, <span class="number">10</span>, TimeUnit.MINUTES);<span class="comment">// 加入缓存</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果数据库也查询不到；则返回前端：无此数据</span></span><br><span class="line">  return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"查询无果"</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//思路简单：缓存当中有则返回该记录给前端；缓存当中没有则再查询数据库；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper层：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.testcache.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="params">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> interface OrderMapper&#123;</span><br><span class="line">  </span><br><span class="line">    @<span class="keyword">Select</span>(<span class="string">"insert into t_order (id,name) values (#&#123;id&#125;, #&#123;name&#125;)"</span>)</span><br><span class="line">    <span class="built_in">Integer</span> insertOrder(<span class="keyword">Order</span> <span class="keyword">order</span>);</span><br><span class="line"></span><br><span class="line">    @<span class="keyword">Select</span>(<span class="string">"select * from t_order where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="keyword">Order</span> selectOrderById(<span class="built_in">Integer</span> id);</span><br><span class="line"></span><br><span class="line">    @<span class="keyword">Select</span>(<span class="string">"select * from t_order"</span>)</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="keyword">Order</span>&gt; selectOrderAll();</span><br><span class="line"></span><br><span class="line">    @Update(<span class="string">"update t_order set  `name`=#&#123;name&#125; where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="built_in">Integer</span> updateOrder(<span class="keyword">Order</span> <span class="keyword">order</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>为什么要使用缓存？</strong></li></ol><p>（1）<strong>提高性能</strong>；  </p><p><strong>查询redis比查询数据库快</strong>；<br>现在的nosql数据库一般多用为redis；<br>那么关系型数据库一般多用为mysql；<br>所以当前举例关系型数据库以mysql为主；<br>非关系型数据库以redis为主进行讲解；  </p><p>（2）<strong>保护数据库</strong>；  </p><p>如果没有缓存redis，则每一次请求都将要去访问数据库；<br>那么由此也就造成了<strong>数据库的访问压力</strong>；<br>特别是在一些大公司当中，其访问量特别特别多的；<br>那么如果此时所有的查询请求都去往数据库的话，那么服务器数据库的压力也是非常大的；<br>所以当使用缓存之后；可以看到使用了缓存则，大部分请求都将会在[ <strong>命中缓存</strong> ]该步骤时进行返回给前端（就不再去访问数据库了）；<br>第一次查询将查询数据库；第二次查询就不再会去查询数据库了而是会去查询缓存；  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提高性能</span></span><br><span class="line"><span class="comment">//保护数据库</span></span><br><span class="line">public R select<span class="constructor">OrderById(Integer <span class="params">id</span>)</span>&#123;</span><br><span class="line"><span class="comment">//查询缓存</span></span><br><span class="line">Object redisObj = valueOperations.get(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//命中缓存</span></span><br><span class="line"><span class="keyword">if</span>(redisObj != null)&#123;</span><br><span class="line">  <span class="comment">//正常返回数据</span></span><br><span class="line">  return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(200)</span>.set<span class="constructor">Data(<span class="params">redisObj</span>)</span>.set<span class="constructor">Msg(<span class="string">"OK"</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>一般对于加入到缓存当中的数据，会加一个过期时间；<br>比如当前有一个促销活动，需要卖出商品；<br>且该商品的促销时间只做三天；<br>那么就可以给该商品数据的缓存数据设置一个三天的过期时间；<br><strong>一般会给缓存当中的数据设置一个过期时间</strong>；  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valueOperations.set(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>, order, <span class="number">10</span>, TimeUnit.MINUTES);<span class="comment">// 加入缓存</span></span><br></pre></td></tr></table></figure><p>此段代码即普通程序员所写代码；<br>如果该段代码在中小型公司存在问题不大；<br>但是如果该段代码放在大公司当中，该段代码就不能够这样写了；  </p><p>因为大公司当中要求特别高（╮(╯▽╰)╭）；  </p><p>且该段代码当中存在缓存三大问题中的两大问题没有解决：第一个问题是<strong>缓存穿透</strong>；第二个问题就是<strong>缓存击穿</strong>；</p><ol start="3"><li><strong>缓存有三个问题？</strong>  </li></ol><p>（1） <strong>缓存穿透</strong></p><p>指的是 <strong>查询数据库和缓存当中都没有的数据</strong>（<strong>查询的为空数据</strong>）</p><p>（当前测试库当中的数据仅仅只有8条数据；但是现在查询数据id为2000的数据记录）</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//id</span>为2000的该数据在测试库当中并不存在</span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=2000  </span><br><span class="line"><span class="string">//</span>响应：&#123;<span class="string">"code"</span><span class="function">:500</span> , <span class="string">"data"</span>:&#123;&#125;, <span class="string">"msg"</span>:<span class="string">"查询无果"</span>&#125;</span><br><span class="line"><span class="string">//</span>尽管查询无果；但是该操作，即查询id为2000的该操作依然查询了数据库；</span><br><span class="line"><span class="string">//</span>前面说查询缓存，是为了保护数据库；</span><br><span class="line"><span class="string">//</span>但是现在一个不存在的数据，进行查询的时候每一次都进行查询了数据库；</span><br><span class="line"><span class="string">//</span>由于数据库当中不存在该数据记录行，那么缓存当中也肯定不会存在有该数据记录行</span><br><span class="line"></span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=1001</span><br><span class="line"><span class="string">//</span>响应：&#123;<span class="string">"code"</span><span class="function">:200</span> , <span class="string">"data"</span>:&#123;<span class="string">"id"</span><span class="function">:1001</span>, <span class="string">"name"</span>:<span class="string">"王昭君"</span>&#125;, <span class="string">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure><p>问题代码分析：<br>1、第一次查询缓存，查询无果之后，查询数据库；<br>2、数据库也查询不到则查询无果；<br>3、在数据记录行在数据库当中记录为空该情况下，该段代码每一次都将会去查询数据库；  </p><p>当前市面上有<strong>两种解决缓存穿透问题的方案</strong>：</p><p>（1）<strong>缓存空对象</strong>：代码简单，效果不好<br>（2）<strong>布隆过滤器</strong>：代码复杂，效果很好（一般用<strong>布隆过滤器</strong>）</p><p><strong>缓存空对象</strong>的实现思路：</p><p>当去查询一条在数据库当中不存在的数据记录行的时候；<br>不管该数据记录行在数据库当中查询得到或者查询不到，都将该信息交给缓存；  </p><p>service impl（实现）层：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提高性能</span></span><br><span class="line"><span class="comment">//保护数据库</span></span><br><span class="line">public R select<span class="constructor">OrderById(Integer <span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//查询缓存；</span></span><br><span class="line">  Object redisObj = valueOperations.get(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//命中缓存</span></span><br><span class="line">  <span class="keyword">if</span>(redisObj != null)&#123;</span><br><span class="line">    <span class="comment">//查询出来的对象进行判断是否其实例属于空对象</span></span><br><span class="line">    <span class="keyword">if</span>( redisObj instanceOf NullValueResultDO)&#123;</span><br><span class="line">      <span class="comment">//如果属于空对象则直接返回查询无果该响应结果</span></span><br><span class="line">      return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"查询无果"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常返回数据</span></span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(200)</span>.set<span class="constructor">Data(<span class="params">redisObj</span>)</span>.set<span class="constructor">Msg(<span class="string">"OK"</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      Order order = orderMapper.select<span class="constructor">OrderById(<span class="params">id</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span>(order != null)&#123;</span><br><span class="line">        valueOperations.set(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>, order, <span class="number">10</span>, TimeUnit.MINUTES);<span class="comment">// 加入缓存</span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处添加else判断，当该数据记录行在数据库当中查询不到的时候的处理操作</span></span><br><span class="line">        <span class="comment">//如果数据库当中查询不到，那么此时使用一个空对象加入到缓存当中去；</span></span><br><span class="line">        <span class="comment">//当加入的内容为空对象的时候，那么每次查询开头的时候也就同样需要判断；是否为空对象，如果为空对象则直接返回前端查询无果；就将不再去进行查询数据库这一操作了；</span></span><br><span class="line">        valueOperations.set(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>, <span class="keyword">new</span> <span class="constructor">NullValueResultDO()</span>, <span class="number">10</span>, TimeUnit.MINUTES);<span class="comment">//加入缓存</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"查询无果"</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>空对象</strong> NullValueResultDO(无属性):</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.testcache.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullValueResultDO</span>&#123;</span></span><br><span class="line">  <span class="comment">//private String name;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询数据记录行在数据库当中为空的情况分析：<br><strong>1、</strong> 第一次查询缓存，缓存当中没有命中，即缓存当中不存在该数据记录；</p><p><strong>2、</strong> 此时查询数据库，查询数据库中发现该数据行为空；则将该一个空对象加入到缓存当中，其id为查询的内容，其值为空对象；则此时进行返回</p><p><strong>3、</strong> 第二次进行查询缓存，同样查询的数据在数据库当中数据记录行为空；<br>则此时先进行查询缓存，缓存当中存在该数据记录行，也就是存在id为查询id的记录值；<br>则此时当缓存命中之后进行判断缓存的该实例是否为空对象;<br>如果为空对象则直接返回查询无果否则返回查询数据；</p><p><strong>缓存穿透</strong>该第一种解决方案（<strong>缓存空对象</strong>）的<strong>效果为什么不好</strong>？<br>原因：</p><ul><li>每一次换<strong>不同的查询</strong>，且每一次不同的查询（即id不同）明知该数据在数据库当中查询不到；但是<strong>都还是会去查询一次</strong>；</li><li>缓存空对象解决的问题是<strong>一个key</strong>（即一个id）<strong>对其进行多次访问</strong>的这样一个问题（当过期时间失效则又将会去查询一遍数据库）；</li><li>如果存在查询数据为大量空数据则将会导致redis当中<strong>存在有大量的空对象</strong>（空数据）（恶意大规模查询明知道数据库当中为记录行为空的数据（空数据）；）弊端就在于<strong>占用redis的内存</strong>；</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//id</span>为2000的该数据在测试库当中并不存在</span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=2000  </span><br><span class="line"><span class="string">//</span>响应：&#123;<span class="string">"code"</span><span class="function">:500</span> , <span class="string">"data"</span>:&#123;&#125;, <span class="string">"msg"</span>:<span class="string">"查询无果"</span>&#125;</span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=2000  </span><br><span class="line"><span class="string">//</span>此时响应的内容是查询的缓存当中的数据；</span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=2000  </span><br><span class="line"><span class="string">//</span>此时响应的内容是查询的缓存当中的数据；</span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=2000  </span><br><span class="line"><span class="string">//</span>此时响应的内容是查询的缓存当中的数据；</span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=2000  </span><br><span class="line"><span class="string">//</span>此时响应的内容是查询的缓存当中的数据；</span><br><span class="line"></span><br><span class="line"><span class="params">---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=2002</span><br><span class="line"><span class="string">//</span>第一次查询缓存当中不存在的内容就将会去查询一遍数据库；</span><br><span class="line"><span class="string">//</span>该数据在数据库当中不存在；</span><br><span class="line"><span class="string">//</span>响应：&#123;<span class="string">"code"</span><span class="function">:500</span> , <span class="string">"data"</span>:&#123;&#125;, <span class="string">"msg"</span>:<span class="string">"查询无果"</span>&#125;</span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=2003</span><br><span class="line"><span class="string">//</span>第一次查询缓存当中不存在的内容就将会去查询一遍数据库；</span><br><span class="line"><span class="string">//</span>该数据在数据库当中不存在；</span><br><span class="line"><span class="string">//</span>响应：&#123;<span class="string">"code"</span><span class="function">:500</span> , <span class="string">"data"</span>:&#123;&#125;, <span class="string">"msg"</span>:<span class="string">"查询无果"</span>&#125;</span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=2004</span><br><span class="line"><span class="string">//</span>第一次查询缓存当中不存在的内容就将会去查询一遍数据库；</span><br><span class="line"><span class="string">//</span>该数据在数据库当中不存在；</span><br><span class="line"><span class="string">//</span>响应：&#123;<span class="string">"code"</span><span class="function">:500</span> , <span class="string">"data"</span>:&#123;&#125;, <span class="string">"msg"</span>:<span class="string">"查询无果"</span>&#125;</span><br></pre></td></tr></table></figure><p>谷歌有一个框架叫做 <strong>Guava</strong>；在这个 <strong>Guava</strong> 框架当中已经写好了<strong>布隆过滤器</strong>；即已经提供了<strong>布隆过滤器</strong>；缺陷在于 <strong>Guava</strong> 框架当中的该<strong>布隆过滤器</strong>不支持分布式；</p><p><strong>布隆过滤器应用</strong></p><p>maven安装依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>27.0.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>安装依赖之后就可以直接使用；<br>调用其静态方法就可以直接创建出一个布隆过滤器；<br>如果对布隆过滤器没有认识的道友，可以将布隆过滤器理解为一个ArrayList集合，就理解为java当中的一个集合即可；  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBloomFilter</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//size         预计要插入多少条数据</span></span><br><span class="line"><span class="comment">//fpp          容错率--&gt;出现误判的概率是多少</span></span><br><span class="line"><span class="comment">//bloomFilter  位数组</span></span><br><span class="line"><span class="comment">//list         创建的是object数组</span></span><br><span class="line"><span class="comment">//bit          数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//位数组  21亿  JVM内存     数据不会进行持久化  256M</span></span><br><span class="line"><span class="comment">//redis   42亿  redis内存   redis的持久化数据   512M==42亿位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bit[]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), <span class="built_in">size</span>, <span class="number">0.001</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//List list = new ArrayList();</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Integer[] integers = new Integer[Integer.MAX_VALUE];</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//当前该循环会生成1~100,0000 当中所有的数值；</span></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; = <span class="built_in">size</span> ; i++ )&#123;</span><br><span class="line">    <span class="comment">//将这些1~100,0000的数值全部添加到布隆过滤器bloomFilter(集合)当中</span></span><br><span class="line">    bloomFilter.<span class="built_in">put</span>(i);</span><br><span class="line">    <span class="comment">//bloomFilter.put("老王");</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10000</span>);</span><br><span class="line">  <span class="comment">//故意取10000个不在过滤器里的值，看看有多少个会被认为在过滤器里</span></span><br><span class="line">  <span class="comment">//size + 10000 = 100,0000+1000;</span></span><br><span class="line">  <span class="comment">//size + 20000 = 100,0000+2000;</span></span><br><span class="line">  <span class="comment">//该数值肯定大于100,0000；肯定与第一次循环当中的数值相同；</span></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="built_in">size</span> + <span class="number">10000</span> ; i &lt; <span class="built_in">size</span> + <span class="number">20000</span> ; i++ )&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用该数值i在布隆过滤器当中是否存在的方法；如果存在则加入布隆过滤器；否则不加入布隆过滤器；</span></span><br><span class="line">    <span class="comment">//之前将布隆过滤器比喻为java当中的ArrayList集合；</span></span><br><span class="line">    <span class="comment">//则当前期望的是：此时当前该循环当中是不会任何一个数值加入到该布隆过滤器bloomFilter当中去的，也就是该ArrayList集合当中去；</span></span><br><span class="line">    <span class="keyword">if</span>(bloomFiilter.mightContain(i))&#123;<span class="comment">//误判</span></span><br><span class="line">      <span class="built_in">list</span>.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  System.out.<span class="built_in">println</span>(<span class="string">"误判的数量："</span>+<span class="built_in">list</span>.<span class="built_in">size</span>);</span><br><span class="line">  <span class="comment">//响应为：10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>布隆过滤器确确实实是一个集合对象</li><li>布隆过滤器当中仅存在两个方法，<ul><li>第一个方法是put(Object obj);（将数据取值加入到布隆过滤器当中）；</li><li>第二个方法是mightContain(Object obj);（判断数据取值是否在布隆过滤器当中存在）</li></ul></li><li>加入到布隆过滤器当中的数据无法被修改(update)被删除(delete)被取出来(get)；只能够进行添加(put)以及判断是否存在(mightContain);</li><li>mightContain 该方法有可能判断失误；</li><li>此时理解布隆过滤器可以理解为一个特殊的集合对象；</li></ul><p>定义布隆过滤器仅需要做（定义）：<br>(1) size 预计要插入多少数据（预计插入量）<br>(2) fpp  容错率（<strong>False positive probability</strong>）—&gt;出现误判的概率是多少（即上述当中误判的次数是可以由自己定义的；容错率是百分之百会有的；不能定义为0；如果定义为0就将会抱错）</p><p>误判：传一个key到该布隆过滤器（“ArrayList”）当中进行判断；该数据是否存在（mightContain）在该布隆过滤器当中；而该方法mightContain有可能会判断失误；而导致不存在在布隆过滤器当中的key也被判断出存在在该布隆过滤器当中了；（明明不存在，有可能会被判断为存在）  </p><p>判断的该<strong>容错率</strong>取值<strong>越低</strong>；其底层的<strong>内存消耗</strong>则将<strong>越大</strong>；<br>而<strong>容错率</strong>取值<strong>越高</strong>；则<strong>内存开销</strong>则<strong>小</strong>；</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> static <span class="built_in">int</span> size = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> static BloomFilter&lt;Integer&gt; bloomFilter=<span class="module-access"><span class="module"><span class="identifier">BloomFilter</span>.</span></span>create(<span class="module-access"><span class="module"><span class="identifier">Funnels</span>.</span></span>integer<span class="constructor">Funnel()</span>,size, <span class="number">0.001</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//此时第一次打印出现的误判次数为10次；</span></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">  <span class="keyword">private</span> static <span class="built_in">int</span> size = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> static BloomFilter&lt;Integer&gt; bloomFilter=<span class="module-access"><span class="module"><span class="identifier">BloomFilter</span>.</span></span>create(<span class="module-access"><span class="module"><span class="identifier">Funnels</span>.</span></span>integer<span class="constructor">Funnel()</span>,size, <span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//此时第二次打印出现的误判次数为1033次；</span></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">  <span class="keyword">private</span> static <span class="built_in">int</span> size = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> static BloomFilter&lt;Integer&gt; bloomFilter=<span class="module-access"><span class="module"><span class="identifier">BloomFilter</span>.</span></span>create(<span class="module-access"><span class="module"><span class="identifier">Funnels</span>.</span></span>integer<span class="constructor">Funnel()</span>,size, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//此时第二次打印出现的抛出异常，报错；</span></span><br><span class="line">  <span class="comment">//即布隆过滤器的容错率不能为0</span></span><br><span class="line">  <span class="comment">//java.lang.ExceptionInInitializerError</span></span><br><span class="line">  <span class="comment">//Caused by: java.lang.IllegalArgumentException:False positive probability(0.0) must be &gt; 0.0</span></span><br></pre></td></tr></table></figure><p><strong>布隆过滤器原理</strong><br>布隆过滤器的底层实现依赖于bit数组；<br>1个字节byte为8位；<br>1024个字节为1M；<br>所以其单位是很小；<br>512M=524288byte</p><p>由于位数组，即byte只有一位；所以其取值就只能够是0和1；<br>默认该数组当中的白色格子取值value全部为0；而蓝色格子取值value为1；</p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXy93sfkaGWRUBapr9y3pHbtQ6yRyawhbsd7*AS4G1K*c*Gb56IM9A4pA41f7IAo4fIom1PvvFF11WuEdaLRX51c!/r" alt="布隆过滤器"></p><p>左边即为往布隆过滤器当中进行put方法操作的结果（把数据加入到布隆过滤器）；</p><p>那么其位数组就会发生变化；<br>变化的表现有：</p><ul><li>该布隆过滤器其数组当中所有的key取值value默认都为0</li><li>当添加完一条数据（“老王”）之后，就会出现三个格子，变成黄色；也就代表着，该三个格子所处index位置（可以不为3个，只是说该图经过计算得为3个（举个例子不要当真）；<ul><li>为什么被计算出来为3个index位置的格子被改成了1；</li><li>其实也可以改下，将其改成10个index位置被改颜色为黄色，即将默认取值0改成1），其value值被改变称为1了；默认为0；</li></ul></li><li>如何修改的呢？<ul><li>上述为3个index位置被改变颜色为黄色，即将默认取值改变为1；</li><li>那么此时可以认为是3个hash函数对该加入到布隆过滤器当中的该取值“老王”进行了hash；</li><li>那么3个hash函数对“老王”该取值进行了hash之后，就会得到有一个数字；</li><li>打个比方：hash(“老王”)=1212121；hash某一字符串都将得到一个数值；</li><li>通过hash获取的到一个数值之后，在对该布隆过滤器该数组的长度进行<strong>取余</strong>；</li><li>比如说该布隆过滤器该数组的长度是40；</li><li>那么就会将对“老王”进行hash得到的数值 对 该布隆过滤器数组的长度进行 取余；即1212121%40=3；（该3是随意捏造的；不要当真；只是一个例子）</li><li>那么此时布隆过滤器就将会将index取值为3的该位置的默认取值0改为1；</li><li>步骤：首先对加入到布隆过滤器的数值进行hash，经过hash之后就会得到一个数值；将该数值进行取余该布隆过滤器数组的长度得到的数值就是在该布隆过滤器数组当中的一个下标；则将该下标的默认取值0进行修改为1；</li><li>当前为什么会有3个不同的位置被改变颜色为黄色呢（即改变默认取值为1）?原因就在于有3个不同的hash函数，存在有不同的hash函数则将有3个不同位置的数组index被改变默认取值0为1；（通过hash函数对加入到布隆过滤器当中的取值进行hash得到下标位置再进行取余数组长度得到在该数组当中的下标index位置）</li><li>使用了3个不同的hash函数对该put(Object obj) obj对象进行了hash</li><li>hash算法存在有多个，比如说hash32，hash16…(都是进行hash，只是hash的函数不一样；为什么是三个不同的hash呢？可以是10个100个n个不同的hash；自己设定；自己喜欢就好；喜欢多少个就多少个)</li><li>hash函数多并不一定导致容错率低，只能说是一种因素；</li></ul></li></ul><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX1IOvYMzL*IGr4hMfNmq0SLpSUjWiYQqv*cQR*MK3kZarTxU*24HFj0FaxTXP9dLIO.fiVY2eH4cPYFmojOxc8M!/r" alt="布隆过滤器mightContain判断是否存在"></p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX1nwjJZCSD2X9riQotNbwt9nUD*060h1sSAaCk5hI9WOQJEcFG3tGpPrepg4ztfFPKkDeVMefdqHGj9ns7B99jw!/r" alt="布隆过滤器put方法"></p><p>位数组（布隆过滤器）当中默认全部为0，当时当插入的数据量过大，即位数组当中将有大部分原本默认取值为0的index将被改变取值为1；</p><p>当前插入到布隆过滤器当中的数据有21条数据记录行：<br>1、2、3、4、5、6、7、8、9、10、11、12、13、14、15、16、17、18、19、20、老王</p><p><strong>可能存在（误判的原因）</strong><br>（1）当进行查找“老王”时，是可以查找得到的；<br>（2）当进行查找 1 时，是可以查找得到的；  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXw6xgVJROJh3BJY6xFr9VJp6l4Zz7Pw*B3XR97Ym8Flrt07pQJDvc4W*10SFkqDBy5AkMwUaqHzOjviy6g9514Q!/r" alt="bloomFilter插入数据量大进行数据判断时"></p><p>（3）当进行查找 111 时，也是可以查找得到的；此时就出现了<strong>误判</strong>；<br>该取值111并不是加入到布隆过滤器当中的数值；<br>而是21条数据添加通过3个不同的hash取余数组长度得到各个不同的在数组当中的下标位置index；<br>恰巧就将 111 该取值进行3个不同的hash函数得出的3个不同的数值取余数组长度得到的3个不同位置下标index的默认取值0进行了改值为1；<br>而111该数值的三个在布隆过滤器数组当中index下标位置取值默认为0被修改为1；<br>并非是111进行mightContain时进行修改的；<br>而是当添加21条数据记录时进行修改的；<br>也就是当[<strong>因素1</strong>]添加到布隆过滤器当中的数据量过大时，如果[<strong>因素2</strong>]有多个hash函数（<strong>hash冲突</strong>），那么布隆过滤器当中就可能存在多个下标位置index的取值由0改变为1的这种情况；  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX6G6Nkh9oP4j1AI.xWFqKAqs9pJ6hpqT9bcebJgsD1MnDW3AU*HyNTcnfjGcwoSGm1Y5nNUuczxo97CBCFXTZsA!/r" alt="bloomFilter插入数据量大误判情况的产生"></p><p>1、为什么布隆过滤器没有取出的方法即get方法；—&gt;因为其布隆过滤器底层没有进行保存其加入到布隆顾虑器当中真实的取值；只有位数组；<br>2、布隆过滤器也没有delete方法；—&gt;由于在布隆过滤器当中该位数组当中其下标位置index要删除的位置其位置，同一个位置也有可能是其他数值所占的下标位；（<strong>hash冲突</strong>）；如果将该下标位置index的取值改为0；那么也将会影响其他的数值的下标取值；也就是说；当其他的数据进行判断是否存在时，原本其他数据的下标位置index取值为1；当前因为有需要要进行删除的数据所以对该布隆过滤器的下标位置index取值进行更改为从1变为0；其他数据的下标位置与当前要删除的数据的下标位置相撞相同了（<strong>hash冲突</strong>）；如果当前要删除的数据将该布隆过滤器数组当中下标位置的取值改为了0；则其他数据下次进行mightContain判断的时候将会被判断为不存在；所以布隆过滤器没有删除delete该方法；<br>3、布隆过滤器为什么会出现误判？—&gt;<strong>误判</strong>的缘故就在于存在<strong>hash冲突</strong>  </p><p><strong>出现误判的概率，即容错率与什么因素有关？</strong>  </p><ul><li><strong>数组长度</strong></li><li><strong>hash算法的个数</strong></li></ul><p><strong>（1）</strong>首先，数组的长度是肯定会影响容错率的；如果数组的长度是100,0000；同样是添加21条数据；那么误判的概率就不会又这么高了（即111不存在的数据也能够判断mightContain为存在）；所以数组的长度是一个影响误判的因素；<br><strong>（2）</strong>第二，hash算法的个数；如果数组的长度是100,0000；且该布隆过滤器当中存在有10个hash算法<br>(不同hash函数越多，则误判的概率越小，即不同hash函数个数越多，即算的在布隆过滤器当中的下标位置越多，而只有当满足算出来的所有的下标位置的取自为1，才将返回可能存在；否则只要满足有一个算出来的index其下标取值不为1，即为0的这种情况则返回绝对不存在；)，</p><p>（不同hash个数函数取余数组长度所得出的位置必须是全部为1才能够判断其值<br>[即判断值是否存在在布隆过滤当中]存在于布隆过滤器当中；<br>即存在有3个不同的hash函数，查询数值117；<br>布隆过滤器数组当中仅只有2个位置可证明该117存在于布隆过滤器当中，即这两个下标位置取值value为1，还有一个index value为0；<br>而hash个数有3个，此时能够证明的只有2个，所以判断为绝对不存在；<br>即只有当查询的数值通过n个不同的hash算法在布隆过滤器数组当中需要有n个不同下标地址的index其取值value必须全部为1；<br>才能够判断为可能存在在该布隆过滤器数组当中；否则判断为绝对不存在；）</p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX1loeM8HGC*c1AuLK0zUPiHTgZ1ljiSnfjWcgvZCtpiFflSI8eyoV.J9xxKSa2wiJDTtvnfmwuqphXXn4wPQ7B4!/r" alt="bloomFilter数据量判断mightContain绝对不存在的情况"></p><p>即如果数组长度越小；而不同的hash函数个数越多；<br>则容错率就将会增大<br>（即误判的几率增大，也就是说在数组长度小的情况下，而hash函数多，即算出来的在布隆过滤器数组当中的下标位置越多，即这些算出来的下标位置的取值就都将会被改为1，到时候布隆过滤器数组当中的下标位置index就将会有大量取值变动由0变为1；这样就会增大误判的几率，也就是说容错率也就增大了；）</p><p>所以说；跟数组的长度以及hash函数的个数必须要配合使用才能够达到布隆过滤器最好的效果；（hash函数的个数必须要与数组长度相匹配；）</p><p>numBits 即Google Guava框架中创建出来的位数组的长度；<br>size：100,0000（预计插入数值记录行），fpp：0.001（容错率）===(创建出来)===&gt;numBits：14377587（位数组长度），numHashFunction：10（hash函数的个数）</p><p>size：100,0000（预计插入数值记录行），fpp：0.1（容错率）===(创建出来)===&gt;numBits：4792539（位数组长度），numHashFunction：3（hash函数的个数）</p><ul><li>hash个数越多（容错率越高），运算开销越大；（性能和容错率之间取一个）；  </li><li>要性能高则hash个数少点；要准确率越高则hash个数越多则容错率越高；<br>容错率低好还是高好?看具体业务需求；</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Preconditions</span>.</span></span>check<span class="constructor">NotNull(<span class="params">strategy</span>)</span>;</span><br><span class="line"><span class="keyword">if</span>(expectedInsertions<span class="operator"> == </span><span class="number">0L</span>)&#123;</span><br><span class="line">  expectedInsertions = <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//numBits 位数组长度</span></span><br><span class="line"><span class="comment">//expectInsertions 预计插入布隆过滤器数组的数据量</span></span><br><span class="line"><span class="comment">//fpp 容错率（判断出错的概率）</span></span><br><span class="line">long numBits = optimal<span class="constructor">NumOfBits(<span class="params">expectedInsertions</span>, <span class="params">fpp</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash函数个数</span></span><br><span class="line"><span class="built_in">int</span> numHashFunctions = optimal<span class="constructor">NumOfHashFunctions(<span class="params">expectedInsertions</span>, <span class="params">numBits</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//numBits与numHashFunctions 需要进行配合使用，一起使用更佳哦~</span></span><br><span class="line"><span class="comment">//只需要关注预计插入布隆过滤器数据记录行与容错率即可；位数组长度与hash函数个数不需要进行关心；因为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">BloomFilter(<span class="params">new</span> LockFreeBitArray(<span class="params">numBits</span>)</span>, numHashFunctions, funnel, strategy);</span><br><span class="line">&#125;catch(IllegalArgumentException var10)&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * long n   预计插入数据量</span></span><br><span class="line"><span class="comment">  * double m 容错率</span></span><br><span class="line"><span class="comment">  * description 算出hash函数个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">@VisibleForTesting</span><br><span class="line">static <span class="built_in">int</span> optimal<span class="constructor">NumOfHashFunctions(<span class="params">long</span> <span class="params">n</span>,<span class="params">double</span> <span class="params">m</span>)</span>&#123;</span><br><span class="line">  return <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(<span class="number">1</span>, (<span class="built_in">int</span>)<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>round( double(m)<span class="operator"> / </span>(double)n<span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>log(<span class="number">2.0</span>D) ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * long n   预计插入数据量</span></span><br><span class="line"><span class="comment">  * double p 容错率</span></span><br><span class="line"><span class="comment">  * description 算出位数组长度</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">@VisibleForTesting</span><br><span class="line">static long optimal<span class="constructor">NumOfBits(<span class="params">long</span> <span class="params">n</span>,<span class="params">double</span> <span class="params">p</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p<span class="operator"> == </span><span class="number">0.0</span>D)&#123;</span><br><span class="line">    p = <span class="number">4.9E-324</span>D;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (long)((double)(-n)<span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>log(p)<span class="operator"> / </span>(<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>log(<span class="number">2.0</span>D)<span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>log(<span class="number">2.0</span>D) ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己手写<strong>分布式的布隆过滤器</strong></p><p>手写布隆过滤器之前；怎么来实现；</p><ul><li>需要有一个位数组<ul><li>该位数组如何来的呢?</li><li>其实redis当中也存在有布隆过滤器；redis当中的位数组；redis当中的位数组哪里来；即首先redis当中需要存在这样一个数据结构；</li></ul></li></ul><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FLUSHALL</span><br><span class="line"></span><br><span class="line"><span class="built_in">keys</span> *</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> laowang abc #<span class="built_in">key</span>:laowang；<span class="built_in">value</span>:abc</span><br><span class="line"></span><br><span class="line"># <span class="built_in">set</span> api底层如何如何存储<span class="built_in">value</span>的取值（redis底层如何来存储该<span class="built_in">key</span>：laowang的取值<span class="built_in">value</span> abc的？）</span><br><span class="line"># redis底层进行存储<span class="built_in">key</span>的取值<span class="built_in">value</span>是通过位数组来进行存储的；</span><br></pre></td></tr></table></figure><p>首先将 abc 该字符串转换为二进制取值；</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/**</span></span><br><span class="line">  <span class="string">*</span>  <span class="string">a</span> <span class="string">~</span> <span class="string">z</span> <span class="number">97</span> <span class="string">~</span> <span class="number">122</span></span><br><span class="line">  <span class="string">*</span>  <span class="string">第</span> <span class="number">33</span> <span class="string">~</span> <span class="number">126</span> <span class="string">号（共</span> <span class="number">94</span> <span class="string">个）是字符，其中第</span> <span class="number">48</span> <span class="string">~</span> <span class="number">57</span> <span class="string">号为</span> <span class="number">0</span> <span class="string">~</span> <span class="number">9</span> <span class="string">这十个阿拉伯数字</span></span><br><span class="line">  <span class="string">*/</span></span><br><span class="line"><span class="string">public</span> <span class="string">static</span> <span class="string">void</span> <span class="string">main(String[]</span> <span class="string">args)&#123;</span></span><br><span class="line">  <span class="string">toBinary("abc");//</span> <span class="number">24</span><span class="string">---999</span>   <span class="number">0</span>   <span class="number">1000</span>  <span class="number">1</span></span><br><span class="line">  <span class="string">//打印结果为</span> <span class="number">1100001</span> <span class="number">1100010</span> <span class="number">1100011</span></span><br><span class="line">  <span class="string">//1100001和1100010类似，其实在二进制当中a和b只需要将第六位和第七位调换一下顺序即可；</span></span><br><span class="line">  <span class="string">//redis用位数组，二进制的方式来进行保存set</span> <span class="string">key所对应的value取值</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>验证redis使用位数组（二进制）进行保存key的取值value;</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setbit laowang <span class="number">6</span> <span class="number">1</span> # 设置key为laowang其value值的二进制位；设置其value值的二进制位的第<span class="number">6</span>位取值为<span class="number">1</span>；</span><br><span class="line"></span><br><span class="line">setbit laowang <span class="number">7</span> <span class="number">0</span> # 设置key为laowang其value值的二进制位；设置其value值的二进制位的第<span class="number">7</span>位取值为<span class="number">0</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> laowang # 获取redis当中key为laowang的取值value</span><br><span class="line">#当前响应为 “bbc”</span><br><span class="line"></span><br><span class="line"># 原本key:laowang存储的value取值为：abc</span><br><span class="line"># abc 在redis底层存储结构为位数组，即二进制数值；即为<span class="number">1100001</span> <span class="number">1100010</span> <span class="number">1100011</span></span><br><span class="line"># 当前setbit这两个操作即将 <span class="number">1100001</span> <span class="number">1100010</span> 这两个进行了修改为 <span class="number">11000011</span> <span class="number">1100011</span></span><br><span class="line"># 所以redis再次查询的时候其取值变为了 “bbc”</span><br></pre></td></tr></table></figure><p>在redis当中，String类型的value值其在redis底层，就是通过位数组来进行保存存储的；<br>在底层当中，当前“abc” or “bbc” 其在redis底层当中位数长度为 3 * 8 = 24 位；<br>底层的位数组的长度只有这么长；</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setbit laowang <span class="number">1000</span> <span class="number">0</span> # 设置进行修改key为laowang 其value值在redis底层的位数组（二进制）的第<span class="number">1000</span>个位置，即下标为<span class="number">999</span>的这个位置index修改取值为<span class="number">0</span>；</span><br><span class="line"># 当时当前 key:laowang 该value值在redis底层的其位数组长度是没有<span class="number">1000</span>的；</span><br><span class="line"># 在java当中，执行setbit laowang <span class="number">1000</span> <span class="number">0</span> 就将会造成数组越界</span><br><span class="line"># 那么在redis当中，当进行设置第<span class="number">1000</span>个位置上取值为<span class="number">0</span>时，abc 该value字符串在redis底层的位数组（二进制）是如何保存的就依然是如何保存，即依然保存为<span class="number">1100001</span> <span class="number">1100010</span> <span class="number">1100011</span>；</span><br><span class="line"># redis底层会自动进行扩容的操作；即abc的位数组长度为<span class="number">24</span>；所占据的index为<span class="number">0</span> ~ <span class="number">23</span>，即前面index为 <span class="number">0</span> ~ <span class="number">23</span>时，存储二进制值依然为 <span class="number">1100001</span> <span class="number">1100010</span> <span class="number">1100011</span> ； 那么即从index为<span class="number">24</span>开始到<span class="number">999</span>，这之间则全部用<span class="number">0</span>进行代替；（index为<span class="number">999</span>即为第<span class="number">1000</span>个位置的index）</span><br><span class="line">#setbit laowang <span class="number">1000</span> <span class="number">1</span> #即index为<span class="number">24</span>到<span class="number">998</span>全部为<span class="number">0</span>，而下标为<span class="number">999</span>（即第<span class="number">1000</span>个位置）的取值为<span class="number">1</span>；</span><br><span class="line"># 中间扩容的取值全部使用 <span class="number">0</span> 这一默认取值来进行代替；</span><br><span class="line"></span><br><span class="line">get laowang<span class="comment">;</span></span><br><span class="line"><span class="comment">#此时响应为“bbc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\\x00\x00\x00\x00\x00\x00\x00\x00\x00....”</span></span><br><span class="line"><span class="comment">#redis底层进行扩容，扩容其默认取值为0；即扩容时是扩容的位数组，因为其二进制全部是0；而转化出来之后就是该结果</span></span><br></pre></td></tr></table></figure><p>现在位数组已经找到了，且还能够进行自动扩容；也就是redis底层对String类型操作set key value这一api，底层所使用的的数据结构（位数组）；</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setbit laowang666 <span class="number">10000</span> <span class="number">0</span></span><br><span class="line"><span class="meta"># key:laowang666 ; value: 相当于创建了一个length为 10000 的位数组；并且其底层的value值为 0(二进制取自)；即到第10000位置之前二进制数值全部是0；</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 在redis当中称之为 位图；本质还是属于String类型；</span></span><br><span class="line"><span class="meta"># redis版本5.0.5</span></span><br><span class="line">keys *</span><br><span class="line"><span class="meta"># laowang666</span></span><br><span class="line"><span class="meta"># laowang</span></span><br></pre></td></tr></table></figure><p>实现</p><p>application.yml  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span></span><br><span class="line"><span class="attr">bloom:</span></span><br><span class="line">  <span class="attr">filter:</span></span><br><span class="line">    <span class="attr">expectedInsertions:</span> <span class="number">1000</span></span><br><span class="line">    <span class="attr">fpp:</span> <span class="number">0.</span><span class="string">001F</span></span><br></pre></td></tr></table></figure><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.testcache.<span class="built_in">filter</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line">#ConfigurationProperties 自动装配属性</span><br><span class="line">@ConfigurationProperties(<span class="string">"bloom.filter"</span>)</span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">public</span> class RedisBloomFilter&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//预计插入量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> expectedInsertions;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//误判率</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> fpp;</span><br><span class="line"></span><br><span class="line">  @Autowired</span><br><span class="line">  <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//bit数组长度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> numBits;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//hash函数数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> numHashFunctions;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">long</span> getExpectedInsertions()&#123;<span class="keyword">return</span> expectedInsertions;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> setExpectedInsertions(<span class="keyword">long</span> expectedInsertions)&#123;<span class="keyword">this</span>.expectedInsertions = expectedInsertions;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> getFpp()&#123;<span class="keyword">return</span> fpp;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> setFpp(<span class="keyword">double</span> fpp)&#123;<span class="keyword">this</span>.fpp = fpp;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//@PostConstruct</span></span><br><span class="line">  <span class="comment">//即Spring容器初始化的时候</span></span><br><span class="line">  <span class="comment">//在该类进行初始化的时候，就将会回调该方法init；对numBits以及numHashFunctions进行初始化值</span></span><br><span class="line">  @PostConstruct</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> init()&#123;</span><br><span class="line">    <span class="keyword">this</span>.numBits = optimalNumOfBits(expectedInsertions, fpp);</span><br><span class="line">    <span class="keyword">this</span>.numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, fpp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算hash函数个数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * long n   预计插入数据量</span></span><br><span class="line"><span class="comment">  * double m 容错率</span></span><br><span class="line"><span class="comment">  * description 算出hash函数个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> optimalNumOfHashFunctions(<span class="keyword">long</span> n,<span class="keyword">double</span> m)&#123;</span><br><span class="line">  <span class="keyword">return</span> Math.<span class="built_in">max</span>(<span class="number">1</span>, (<span class="built_in">int</span>)Math.<span class="built_in">round</span>( <span class="keyword">double</span>(m) / (<span class="keyword">double</span>)n * Math.<span class="built_in">log</span>(<span class="number">2.0</span>D) ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算bit数组长度</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * long n   预计插入数据量</span></span><br><span class="line"><span class="comment">  * double p 容错率</span></span><br><span class="line"><span class="comment">  * description 算出位数组长度</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> optimalNumOfBits(<span class="keyword">long</span> n,<span class="keyword">double</span> p)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p == <span class="number">0.0</span>D)&#123;</span><br><span class="line">    p = <span class="number">4.9E-324</span>D;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">long</span>)((<span class="keyword">double</span>)(-n) * Math.<span class="built_in">log</span>(p) / (Math.<span class="built_in">log</span>(<span class="number">2.0</span>D) * Math.<span class="built_in">log</span>(<span class="number">2.0</span>D) ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 判断 keys 是否存在于集合，</span></span><br><span class="line"><span class="comment">  * 是 则返回 true</span></span><br><span class="line"><span class="comment">  * 否 则返回 false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">boolean</span> isExists(<span class="keyword">String</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">    <span class="keyword">long</span>[] indexs = getIndexs(<span class="built_in">key</span>);</span><br><span class="line">    List list = redisTemplate.executePipelined(<span class="keyword">new</span> RedisCallback&lt;<span class="keyword">Object</span>&gt;()&#123;</span><br><span class="line"></span><br><span class="line">      @Nullable</span><br><span class="line">      @Override</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">Object</span> doInRedis(RedisConnection redisConnection) <span class="keyword">throws</span> DataAccessException&#123;</span><br><span class="line">        redisConnection.openPipeline();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> index : indexs)&#123;</span><br><span class="line">          redisConnection.getBit(<span class="string">"bf:laowang"</span>.getBytes(),index);</span><br><span class="line">        &#125;</span><br><span class="line">        redisConnection.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !list.contains(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将 key 存入 redis bitmap 位图</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> put(<span class="keyword">String</span> <span class="built_in">key</span>)&#123;<span class="comment">// 老王laowang</span></span><br><span class="line">  <span class="keyword">long</span>[] indexs = getIndexs(<span class="built_in">key</span>);</span><br><span class="line">  redisTemplate.executePipeline(<span class="keyword">new</span> RedisCallback&lt;<span class="keyword">Object</span>&gt;()&#123;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Object</span> doInRedis(RedisConnection redisConnection) <span class="keyword">throws</span> DataAccessException&#123;</span><br><span class="line">      redisConnection.openPipeline();<span class="comment">//打开管道，提高效率</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">long</span> index:indexs)&#123;</span><br><span class="line">        redisConnection.setBit(<span class="string">"bf:laowang"</span>.getBytes(), index, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//setbit laowang 7262 1</span></span><br><span class="line">        <span class="comment">//此时key写死；</span></span><br><span class="line">        <span class="comment">//index将修改的动态的index下标位置；</span></span><br><span class="line">        <span class="comment">//0代表false；1代表true；即与扩容默认为0修改取值为1做法一致；在redis当中0是位数组进行扩容时的默认值；1则为put进来的数据其位置下标index就需要改变该index上的取值0变成1；在java当中true即代表1；false即代表0</span></span><br><span class="line">      &#125;</span><br><span class="line">      redisConnection.close();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据 key 获取 bitmap 下标； 一个hash函数对 20+1  20+2 3个不同的hash函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span>[] getIndexs(<span class="keyword">String</span> <span class="built_in">key</span>)&#123; <span class="comment">//laowang 老王</span></span><br><span class="line">    <span class="keyword">long</span> hash1 = hash(<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">long</span> hash2 = hash1 &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">long</span>[] result = <span class="keyword">new</span> <span class="keyword">long</span>[numHashFunctions]; <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; numHashFunctions ; i++ )&#123; <span class="comment">//numHashFunctions hash函数的数量</span></span><br><span class="line">    <span class="keyword">long</span> combinedHash = hash1 + i * hash2;</span><br><span class="line">    <span class="comment">//i 动态值，所以2个不同的hash再加上该一个带有动态值i则将会有三个不同的取值</span></span><br><span class="line">    <span class="comment">//引用三个不同的hash算法对同一个字符串key进行运算也可以的；</span></span><br><span class="line">    <span class="keyword">if</span>(combinedHash &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        combinedHash = ^combinedHash;</span><br><span class="line">    &#125;</span><br><span class="line">    result[i] = combinedHash % numBits;<span class="comment">//对数组的长度numBits进行取余</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expectedInsertions</span> = <span class="number">1000</span></span><br><span class="line"><span class="attr">fpp</span> = <span class="number">0.001</span></span><br><span class="line"><span class="attr">numBits</span> = <span class="number">14377</span></span><br><span class="line"><span class="attr">numHashFunctions</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">key</span> = <span class="string">"1001"</span></span><br><span class="line"><span class="attr">indexs</span> = &#123;long[<span class="number">10</span>]@<span class="number">7667</span>&#125;</span><br><span class="line"><span class="attr">0</span> = <span class="number">7262</span></span><br><span class="line"><span class="attr">1</span> = <span class="number">6438</span></span><br><span class="line"><span class="attr">2</span> = <span class="number">5614</span></span><br><span class="line"><span class="attr">3</span> = <span class="number">4790</span></span><br><span class="line"><span class="attr">4</span> = <span class="number">3966</span></span><br><span class="line"><span class="attr">5</span> = <span class="number">3142</span></span><br><span class="line"><span class="attr">6</span> = <span class="number">2318</span></span><br><span class="line"><span class="attr">7</span> = <span class="number">1494</span></span><br><span class="line"><span class="attr">8</span> = <span class="number">670</span></span><br><span class="line"><span class="attr">9</span> = <span class="number">14223</span></span><br><span class="line"><span class="comment"># 0 ~ 9 ：10个下标</span></span><br></pre></td></tr></table></figure><p>RedisDataInit</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.testcache.datainit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDataInit</span>&#123;</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  OrderService orderService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  RedisBloomFilter redisBloomFilter;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> init()&#123;</span><br><span class="line">    List&lt;Order&gt; orders = orderService.selectOrderAll();</span><br><span class="line">    <span class="keyword">for</span>(Order <span class="string">order:</span>orders)&#123;</span><br><span class="line">      redisBloomFilter.put(String.valueOf(order.getId));<span class="comment">//订单表的id</span></span><br><span class="line">      <span class="comment">//将订单表中的id添加到布隆过滤器当中在容器启动的时候</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行查询</p><p>service impl（实现）层：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提高性能</span></span><br><span class="line"><span class="comment">//保护数据库</span></span><br><span class="line">public R select<span class="constructor">OrderById(Integer <span class="params">id</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//解决缓存穿透</span></span><br><span class="line">  <span class="comment">//如果布隆过滤器当中存在id则说明数据库当中存在该条记录；则可以继续往下走</span></span><br><span class="line">  <span class="comment">//返回false说明布隆过滤器当中并不存在该id也就说明数据库以及缓存当中都不会有该条数据id</span></span><br><span class="line">  <span class="comment">//此处布隆过滤器由于存在误判的情况也就是容错率；但是现在应用的场景是缓存穿透也就是避免去进行查询数据库；而布隆过滤器误判的结果也就是仅仅让数据库多查一次而已；所以设想下如果有100000个恶意查询空对象请求；那么相比于100000个恶意查询空对象请求而言，布隆过滤器则要显得十分优越了；即便是存在有误判也比100000好；也需要看容错率的概率是多少；</span></span><br><span class="line">  <span class="keyword">if</span> (!bloomFilter.is<span class="constructor">Exist(String.<span class="params">valueOf</span>(<span class="params">id</span>)</span>))&#123;</span><br><span class="line">      return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"非法访问"</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查询缓存；</span></span><br><span class="line">  Object redisObj = valueOperations.get(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//命中缓存</span></span><br><span class="line">  <span class="keyword">if</span>(redisObj != null)&#123;</span><br><span class="line">    <span class="comment">//正常返回数据</span></span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(200)</span>.set<span class="constructor">Data(<span class="params">redisObj</span>)</span>.set<span class="constructor">Msg(<span class="string">"OK"</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      Order order = orderMapper.select<span class="constructor">OrderById(<span class="params">id</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span>(order != null)&#123;</span><br><span class="line">        valueOperations.set(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>, order, <span class="number">10</span>, TimeUnit.MINUTES);<span class="comment">// 加入缓存</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"查询无果"</span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">localhost<span class="function">:8080</span>/selectid?id=2002</span><br><span class="line"><span class="string">//</span>由于有布隆过滤器的存在将不会去进行查询redis缓存也不会去查询数据库</span><br><span class="line"><span class="string">//</span>该数据在数据库当中不存在；</span><br><span class="line"><span class="string">//</span>响应：&#123;<span class="string">"code"</span><span class="function">:600</span> , <span class="string">"data"</span>:&#123;&#125;, <span class="string">"msg"</span>:<span class="string">"非法访问"</span>&#125;</span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=2003</span><br><span class="line"><span class="string">//</span>由于有布隆过滤器的存在将不会去进行查询redis缓存也不会去查询数据库</span><br><span class="line"><span class="string">//</span>该数据在数据库当中不存在；</span><br><span class="line"><span class="string">//</span>响应：&#123;<span class="string">"code"</span><span class="function">:600</span> , <span class="string">"data"</span>:&#123;&#125;, <span class="string">"msg"</span>:<span class="string">"非法访问"</span>&#125;</span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=2004</span><br><span class="line"><span class="string">//</span>由于有布隆过滤器的存在将不会去进行查询redis缓存也不会去查询数据库</span><br><span class="line"><span class="string">//</span>该数据在数据库当中不存在；</span><br><span class="line"><span class="string">//</span>响应：&#123;<span class="string">"code"</span><span class="function">:600</span> , <span class="string">"data"</span>:&#123;&#125;, <span class="string">"msg"</span>:<span class="string">"非法访问"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="params">------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=1001</span><br><span class="line"><span class="string">//</span>响应：&#123;<span class="string">"code"</span><span class="function">:200</span> , <span class="string">"data"</span>:&#123;<span class="string">"id"</span><span class="function">:1001</span>, <span class="string">"name"</span>:<span class="string">"老王1"</span>&#125;, <span class="string">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=1002</span><br><span class="line"><span class="string">//</span>响应：&#123;<span class="string">"code"</span><span class="function">:200</span> , <span class="string">"data"</span>:&#123;<span class="string">"id"</span><span class="function">:1002</span>, <span class="string">"name"</span>:<span class="string">"老王2"</span>&#125;, <span class="string">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=1003</span><br><span class="line"><span class="string">//</span>响应：&#123;<span class="string">"code"</span><span class="function">:200</span> , <span class="string">"data"</span>:&#123;<span class="string">"id"</span><span class="function">:1003</span>, <span class="string">"name"</span>:<span class="string">"老王3"</span>&#125;, <span class="string">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=1004</span><br><span class="line"><span class="string">//</span>响应：&#123;<span class="string">"code"</span><span class="function">:200</span> , <span class="string">"data"</span>:&#123;<span class="string">"id"</span><span class="function">:1004</span>, <span class="string">"name"</span>:<span class="string">"老王4"</span>&#125;, <span class="string">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br><span class="line">localhost<span class="function">:8080</span>/selectid?id=1005</span><br><span class="line"><span class="string">//</span>响应：&#123;<span class="string">"code"</span><span class="function">:200</span> , <span class="string">"data"</span>:&#123;<span class="string">"id"</span><span class="function">:1005</span>, <span class="string">"name"</span>:<span class="string">"老王5"</span>&#125;, <span class="string">"msg"</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure><p>复杂：</p><ul><li>维护麻烦</li><li>往数据库当中进行添加数据时，同时也需要往布隆过滤器当中进行添加put；不然的就就会被布隆过滤器当做是非法请求被拦截下来；</li><li>如果订单表当中存在10万的数据；删除了8万的数据量；现在仅剩下2万的数据量；但是布隆过滤器没有办法进行删除；这个时候就需要进行考虑重建布隆过滤器即重新初始化该布隆过滤器；即从头到尾的再去跑一边put方法，即又重新将订单表当中的记录进行查询出来将其order id重新put入布隆过滤器当中</li><li>这个重建布隆过滤器得使用定时任务来进行；定时任务多少合适需要看删除的数据量大小多不多；</li></ul><h2 id="缓存击穿详解及实战"><a href="#缓存击穿详解及实战" class="headerlink" title="缓存击穿详解及实战"></a>缓存击穿详解及实战</h2><p>上述代码存在两大问题，一是缓存穿透；二是缓存击穿；<br>缓存击穿问题也就是对于热点数据访问的问题；</p><p><strong>缓存击穿</strong>：在查询时，数据库有数据，缓存当中没有（数据刚好失效）；</p><p>情况分析：</p><p>（1）这条数据没有人访问过；说明该数据并非为热点数据；<br>（2）一般为数据刚好失效（由于将数据加入到缓存当中时，会加入一个过期时间；比如该数据当好面临过期时间失效，即理解为redis自动将该数据进行删除了[“自动删除”需要加双引号；涉及到redis当中的一个删除特点；可以先这么认为redis现在自动将该数据进行了删除]，但是来了<strong>并发访问</strong>，由于该数据又是一个热点数据）；</p><p>缓存击穿和缓存穿透是两个不同的问题；</p><p>模拟热点数据失效访问情形：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keys *</span><br><span class="line"><span class="meta">#laowang666</span></span><br><span class="line"><span class="meta">#laowang</span></span><br><span class="line"><span class="meta">#bf:laowang</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.testcache.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@org</span>.junit.Test</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    TicketsRunBle ticketsRunBle = <span class="keyword">new</span> TicketsRunBle();</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">99</span> ; i++)&#123;</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(ticketsRunBle, <span class="string">"窗口"</span>);</span><br><span class="line">      thread.start();</span><br><span class="line">      countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.currentThread.join();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketsRunBle</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      countDownLatch.await();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    try&#123;</span></span><br><span class="line"><span class="comment">//        Socket socket = new Socket("127.0.0.1", 1333);</span></span><br><span class="line"><span class="comment">//    &#125;catch(IOException e)&#123;</span></span><br><span class="line"><span class="comment">//      e.printStackTrace();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    List&lt;HttpMessageConverter&lt;?&gt;&gt; fastJsonHttpMessageConverters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    fastJsonHttpMessageConverters.add(<span class="keyword">new</span> FastJsonHttpMessageConverters);</span><br><span class="line">    restTemplate.setMessageConverters(fastJsonHttpMessageConverters);</span><br><span class="line">    R forObject = restTemplate.getForObject(<span class="string">"http://localhost:8080/selectid?id=1001"</span>,R<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(forObject);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可以认为该段代码被99个人（线程）同时执行；</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//99个线程同时进行布隆过滤器的判断</span></span><br><span class="line"><span class="keyword">if</span> (!bloomFilter.is<span class="constructor">Exist(String.<span class="params">valueOf</span>(<span class="params">id</span>)</span>))&#123;</span><br><span class="line">     return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"非法访问"</span>)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//99个线程同时查询缓存；</span></span><br><span class="line"> Object redisObj = valueOperations.get(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//当热点数据失效时，则此时redisObj则为空</span></span><br><span class="line"> <span class="comment">//命中缓存</span></span><br><span class="line"> <span class="keyword">if</span>(redisObj != null)&#123;</span><br><span class="line">   <span class="comment">//正常返回数据</span></span><br><span class="line">   return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(200)</span>.set<span class="constructor">Data(<span class="params">redisObj</span>)</span>.set<span class="constructor">Msg(<span class="string">"OK"</span>)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//所以此时就会有99个线程同时去查询数据库；</span></span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">     Order order = orderMapper.select<span class="constructor">OrderById(<span class="params">id</span>)</span>;</span><br><span class="line">     <span class="keyword">if</span>(order != null)&#123;</span><br><span class="line">       valueOperations.set(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>, order, <span class="number">10</span>, TimeUnit.MINUTES);<span class="comment">// 加入缓存</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;finally&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"查询无果"</span>)</span>;</span><br></pre></td></tr></table></figure><p>即上述代码将会有99次进行查询数据库的记录；</p><p>解决方案<br>使用分布式锁，即查询数据库之前进行加锁；<br>OrderServiceImpl</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">valueOperations valueOperations;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">CacheTemplate cacheTemplate;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">RedisBloomFilter RedisBloomFilter;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> RedisLock redisLock;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">SendMessageUtil sendMessageUtil;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Integer insert<span class="constructor">Order(Order <span class="params">order</span>)</span>&#123;</span><br><span class="line">  Integer integer = orderMapper.insert<span class="constructor">Order(<span class="params">order</span>)</span>;</span><br><span class="line">  return integer;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//提高性能</span></span><br><span class="line"><span class="comment">//保护数据库</span></span><br><span class="line">public R select<span class="constructor">OrderById(Integer <span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//解决缓存穿透</span></span><br><span class="line">  <span class="keyword">if</span> (!bloomFilter.is<span class="constructor">Exist(String.<span class="params">valueOf</span>(<span class="params">id</span>)</span>))&#123;</span><br><span class="line">      return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"非法访问"</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查询缓存；</span></span><br><span class="line">  Object redisObj = valueOperations.get(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//命中缓存</span></span><br><span class="line">  <span class="keyword">if</span>(redisObj != null)&#123;</span><br><span class="line">    <span class="keyword">if</span>( redisObj instanceOf NullValueResultDO)&#123;</span><br><span class="line">      return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"查询无果"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常返回数据</span></span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(200)</span>.set<span class="constructor">Data(<span class="params">redisObj</span>)</span>.set<span class="constructor">Msg(<span class="string">"OK"</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在查询数据库之前进行加锁</span></span><br><span class="line">  redisLock.lock(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询缓存；</span></span><br><span class="line">    redisObj = valueOperations.get(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line">    <span class="comment">//命中缓存</span></span><br><span class="line">    <span class="keyword">if</span>(redisObj != null)&#123;</span><br><span class="line">      <span class="keyword">if</span>( redisObj instanceOf NullValueResultDO)&#123;</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"查询无果"</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//正常返回数据</span></span><br><span class="line">      return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(200)</span>.set<span class="constructor">Data(<span class="params">redisObj</span>)</span>.set<span class="constructor">Msg(<span class="string">"OK"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//查询数据库</span></span><br><span class="line">      Order order = orderMapper.select<span class="constructor">OrderById(<span class="params">id</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span>(order != null)&#123;</span><br><span class="line">        valueOperations.set(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>, order, <span class="number">10</span>, TimeUnit.MINUTES);<span class="comment">// 加入缓存</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        redisLock.unlock(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"查询无果"</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大并发访问数据库最容易导致数据库崩掉；</p><p>测试并模拟；</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">keys</span> <span class="string">*</span></span><br><span class="line"><span class="attr">del</span> <span class="string">1001</span></span><br></pre></td></tr></table></figure><p>上述代码仅会有1次访问数据库的机会；<br>分析：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提高性能</span></span><br><span class="line"><span class="comment">//保护数据库</span></span><br><span class="line">public R select<span class="constructor">OrderById(Integer <span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//99个线程同时访问布隆过滤器判断该id是否非法访问</span></span><br><span class="line">  <span class="keyword">if</span> (!bloomFilter.is<span class="constructor">Exist(String.<span class="params">valueOf</span>(<span class="params">id</span>)</span>))&#123;</span><br><span class="line">      return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"非法访问"</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//99个线程同时查询缓存；</span></span><br><span class="line">  Object redisObj = valueOperations.get(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//由于热点数据的失效；所以导致99个线程同时都没有命中缓存</span></span><br><span class="line">  <span class="comment">//命中缓存</span></span><br><span class="line">  <span class="keyword">if</span>(redisObj != null)&#123;</span><br><span class="line">    <span class="keyword">if</span>( redisObj instanceOf NullValueResultDO)&#123;</span><br><span class="line">      return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"查询无果"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常返回数据</span></span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(200)</span>.set<span class="constructor">Data(<span class="params">redisObj</span>)</span>.set<span class="constructor">Msg(<span class="string">"OK"</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//由于在查询数据库之前进行加锁，所以此时99个线程将会依次进行查询数据库操作；（并发）</span></span><br><span class="line">  <span class="comment">//即此时有一个线程拿着锁进入了代码块；还有98个线程在外面等着；</span></span><br><span class="line">  redisLock.lock(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//相当于99个线程中第一个进入代码块的那一个线程会查询两次redis缓存；查询一次数据库；查询完成之后将数据加入到缓存当中去；finally最后进行解锁；紧接着98个线程第二个线程又会拿着锁进来；.....</span></span><br><span class="line">      <span class="comment">//转折点就在这里；当第一个进来的线程将数据查询完成并加入到缓存之后；后面的98个线程再次到redis缓存当中进行取值的时候那么这个时候就能够有值获取出来了；由于第一个线程已经查询过数据库并将取值加入到了缓存当中去了；</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//虽然有锁阻塞，但是却只有一次操作数据库此处；98个线程都去进行操作缓存；所以说这个效率是十分明显的；非常快；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询缓存；</span></span><br><span class="line">    redisObj = valueOperations.get(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line">    <span class="comment">//命中缓存</span></span><br><span class="line">    <span class="keyword">if</span>(redisObj != null)&#123;</span><br><span class="line">      <span class="keyword">if</span>( redisObj instanceOf NullValueResultDO)&#123;</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"查询无果"</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//正常返回数据</span></span><br><span class="line">      return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(200)</span>.set<span class="constructor">Data(<span class="params">redisObj</span>)</span>.set<span class="constructor">Msg(<span class="string">"OK"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//查询数据库</span></span><br><span class="line">      Order order = orderMapper.select<span class="constructor">OrderById(<span class="params">id</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span>(order != null)&#123;</span><br><span class="line">        valueOperations.set(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>, order, <span class="number">10</span>, TimeUnit.MINUTES);<span class="comment">// 加入缓存</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        redisLock.unlock(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"查询无果"</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此处没有使用分布式锁而是使用的synchronized则；selectOrderById查询数据为1001、1002、1003、1004、1005查询id不同，查询数据并不相同，但是却还是会被阻塞；这个效率就很低了；<br>而刚刚那种处理方式是：redisLock.lock(String.valueOf(id));是对查询id相同；即该这一类都是查询相同同一个id的并发请求的锁；<br>针对的是对于同一个查询内容的多个线程进行阻塞；<br>而对于不同查询内容的多个线程是进行分别阻塞的；<br>也就是说假设有99*2个线程，该99个线程都是进行查询id为1001的查询请求；则redisLock则对该98个线程进行阻塞，其中一个线程拿着id为1001的锁先进入代码块进行查询；（此时id为1001的数据过期失效）<br>而另外99个线程都是进行查询id为1002的查询请求所以此时这另外的这99个线程（查询id为1002的这99个线程），也会存在有一个线程拿着id为1002的锁先进入代码块，而其余的98个线程在外等候，阻塞；（此时id为1001的数据过期失效）</p><p>synchronized与redisLock这两者锁的粒度不一样；  </p><p>RedisLock</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLock用于保存某个线程共享变量</span></span><br><span class="line"><span class="comment">//对于同一个static ThreadLocl，不同线程只能从中get，set，remove自己的变量，而不会影响其他的线程</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal&lt;<span class="keyword">String</span>&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> lock(<span class="keyword">String</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">  <span class="built_in">boolean</span> b = tryLock(<span class="built_in">key</span>);</span><br><span class="line">  <span class="keyword">if</span>(b)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      Thread.sleep(<span class="number">50</span>);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  lock(<span class="built_in">key</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> tryLock(<span class="keyword">String</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">  <span class="keyword">String</span> uuid = UUID.randomUUID().toString();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码封装<br>OrderServiceImpl</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> R selectOrderById(<span class="built_in">Integer</span> id)&#123;</span><br><span class="line">  <span class="keyword">return</span> cacheTemplate.redisFindCache(<span class="built_in">String</span>.valueOf(id), <span class="number">10</span>, TimeUnit.MINUTES, <span class="literal">new</span> CacheLoadble&#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Order</span> load()&#123;</span><br><span class="line">      <span class="keyword">return</span> orderMapper.selectOrderById(id);<span class="comment">//此处仅需要写自己的业务逻辑即可</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="params">...</span></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="keyword">Order</span>&gt; selectOrderAll()&#123; <span class="keyword">return</span> orderMapper.selectOrderAll();&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">Integer</span> updateOrder(<span class="keyword">Order</span> <span class="keyword">order</span>)&#123;</span><br><span class="line">  redisTemplate.delete(<span class="built_in">String</span>.value(<span class="keyword">order</span>.getId()));</span><br><span class="line">  <span class="built_in">Integer</span> <span class="built_in">integer</span> = orderMapper.updateOrder(<span class="keyword">order</span>);</span><br><span class="line">  <span class="keyword">order</span>.setName(<span class="string">"0"</span>);</span><br><span class="line">  sendMessageUtil.placeOrderMessage(<span class="keyword">order</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">integer</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CacheTemplate</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.testcache.template;</span><br><span class="line"></span><br><span class="line">import ...</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public <span class="keyword">class</span> CacheTemplate&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> ValueOperations valueOperations;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">RedisBloomFilter redisBloomFilter;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> Redisson redisson;</span><br><span class="line"></span><br><span class="line"><span class="comment">//private Lock lock = new ReentrantLock();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询缓存  有     直接返回前端</span></span><br><span class="line"><span class="comment">//          没有   查询数据库，加入缓存放回</span></span><br><span class="line"><span class="comment">//为什么要使用缓存：保护数据库；提高性能</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * key 键</span></span><br><span class="line"><span class="comment">  * expire 过期时间</span></span><br><span class="line"><span class="comment">  * unit 过期时间单位</span></span><br><span class="line"><span class="comment">  * cacheLoadble 回调接口方法</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">public R redis<span class="constructor">FindCache(String <span class="params">key</span>, <span class="params">long</span> <span class="params">expire</span>, TimeUnit <span class="params">unit</span>, CacheLoadble&lt;T&gt; <span class="params">cacheLoadble</span>, <span class="params">boolean</span> <span class="params">b</span>)</span>&#123;</span><br><span class="line"> <span class="comment">//--------------------- 缓存穿透-------------------------------------</span></span><br><span class="line">  <span class="comment">//解决缓存穿透</span></span><br><span class="line">  <span class="keyword">if</span>(!bloomFilter.is<span class="constructor">Exist(<span class="params">key</span>)</span>)&#123;</span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(600)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"非法访问"</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查询缓存</span></span><br><span class="line">  Object redisObj = valueOperations.get(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------缓存击穿--------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//命中缓存</span></span><br><span class="line">  <span class="keyword">if</span>(redisObj != null)&#123;</span><br><span class="line">    <span class="comment">//正常返回数据</span></span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(200)</span>.set<span class="constructor">Data(<span class="params">redisObj</span>)</span>.set<span class="constructor">Msg(<span class="string">"OK"</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  redisLock.lock(key);</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">//查询缓存；</span></span><br><span class="line">      redisObj = valueOperations.get(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//命中缓存</span></span><br><span class="line">      <span class="keyword">if</span>(redisObj != null)&#123;</span><br><span class="line">          <span class="comment">//正常返回数据</span></span><br><span class="line">          return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(200)</span>.set<span class="constructor">Data(<span class="params">redisObj</span>)</span>.set<span class="constructor">Msg(<span class="string">"OK"</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     T load = cacheLoadble.load<span class="literal">()</span>;<span class="comment">//查询数据库</span></span><br><span class="line">    <span class="keyword">if</span>(load != null)&#123;</span><br><span class="line">      valueOperations.set(key, load, expire, <span class="built_in">unit</span>);<span class="comment">//加入缓存</span></span><br><span class="line">      return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(200)</span>.set<span class="constructor">Data(<span class="params">redisObj</span>)</span>.set<span class="constructor">Msg(<span class="string">"OK"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;finally&#123;</span><br><span class="line">      <span class="comment">//解锁</span></span><br><span class="line">      redisLock.unlock(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">key</span>)</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"查询无果"</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存雪崩及解决方案"><a href="#缓存雪崩及解决方案" class="headerlink" title="缓存雪崩及解决方案"></a>缓存雪崩及解决方案</h2><p>缓存雪崩问题：</p><ol><li>redis服务器挂了</li><li>大部分数据失效</li></ol><p>比如有100W的商品数据，设置的过期时间统一是10天；则10天后大部分数据统一失效；而查询请求不断；这个时候也就容易导致数据库崩掉；即引发雪崩问题；</p><p>(redis缓存击穿指的是热点数据失效解决的是并发请求)</p><p>针对这种情况的处理方式：</p><p>[<strong>规避</strong>]<br>（1）redis搭建高可用集群（cluster）<br>（2）错开数据过期时间</p><p>如果已经出现了缓存雪崩问题；则处理方式为降级 熔断；</p><h2 id="数据一致性及解决方案"><a href="#数据一致性及解决方案" class="headerlink" title="数据一致性及解决方案"></a>数据一致性及解决方案</h2><p><strong>什么时候出现数据不一致的情况</strong></p><ul><li>更新数据的时候；<ul><li>先更新数据库，再更新缓存<ul><li>（步骤1）先更新数据库（步骤2）再更新缓存；<ul><li>如果此时更新缓存失败；则会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致</li></ul></li><li>1.线程A更新数据库；2.线程B更新数据库；4.线程A更新缓存；3.线程B更新缓存；<ul><li>更新数据库如果因为网络等原因，B却比A更早更新了缓存，这就导致了脏数据（不一致）</li><li>解决方案：先删除缓存；再修改数据库。如果数据库修改失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致；因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。</li></ul></li><li>解决方案一[<strong>延时双删</strong>]：1.线程A删除缓存 2.线程B查询缓存，发现为空 3.线程B查询数据库并加入缓存 4.线程A更新数据库 5.线程A删除缓存（第五步一定要执行成功）</li><li>解决方案二[<strong>串行化</strong>]</li></ul></li></ul></li></ul><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX4pgLmAu8VahKl7KcdIHB0TUz5G4e7vKThDgFA4qONmduoQbaGmQQkOcSL4ZRToJCp.Uf19bAH3AwkYd90x7O1U!/r" alt="数据一致性问题1"></p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX.XryE.7uV.ikOi43KtZHMMeFc5xE9CdpCZxb813hOndwi1w1ZBWEexHrxFZIBZfelNT79b7aY12qTQp7NauUZ8!/r" alt="数据一致性问题2"></p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX3mOzKCW7tUhJUWL8ztU7xPj*Pe*Joo30G7me5QGmt7Sxi5j5klGAArIsMW*y8bO.byfXwfDCTDh.6x5I.sLatg!/r" alt="数据一致性问题3"></p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX*S1qKXmK2eYWqUYxPcUsgsF6L*V72VsmLXrkJ.UnQ7ePKGiWhTZhWMp1b6T2ekmO6bUvjPP2Xe6sCMSxuyCrPc!/r" alt="数据一致性解决方案一"></p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX*S1qKXmK2eYWqUYxPcUsgsF6L*V72VsmLXrkJ.UnQ7ePKGiWhTZhWMp1b6T2ekmO6bUvjPP2Xe6sCMSxuyCrPc!/r" alt="数据一致性解决方案一"></p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXzQqwZMYfv*FkdsRt6pLKtRDNNQ8Pv2ce3feyq1.6u.ytk1wClBaFMU15A2dvCGK8aMDt0c6XmLkiGohBxyNLTo!/r" alt="数据一致性方案二串行化1"></p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX2CGSzajo.b8bZBcqLFBQeGmscwTpI*sRf3EyyWT3nGZ8bOZlQ82XlsrsHCkd*Z7RoJHLOsDtirE785Nk*g.jaA!/r" alt="数据一致性方案二串行化2"></p><p>第五步一定要执行成功，实现：<br>StockListener采用了延时队列；</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">SendMessageUtil sendMessageUtil;</span><br><span class="line"></span><br><span class="line">@<span class="constructor">RabbitListener(<span class="params">queue</span> = <span class="string">"stock_queue"</span>, <span class="params">containerFactory</span>=<span class="string">"simpleRabbitListenerContainerFactory"</span>)</span></span><br><span class="line">public void get<span class="constructor">StockMessage(Message <span class="params">message</span>, Channel <span class="params">channel</span>)</span> throws Exception&#123;</span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"接收到了消息"</span>+<span class="keyword">new</span> <span class="constructor">String(<span class="params">message</span>.<span class="params">getBody</span>()</span>,<span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">  Order order = <span class="module-access"><span class="module"><span class="identifier">JSON</span>.</span></span>parse<span class="constructor">Object(<span class="params">new</span> String(<span class="params">message</span>.<span class="params">getBody</span>()</span>,<span class="string">"UTF-8"</span>), <span class="module-access"><span class="module"><span class="identifier">Order</span>.</span></span><span class="keyword">class</span>);</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">//System.out.println(1/0);</span></span><br><span class="line">      redisTemplate.delete(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(Order.<span class="params">getId</span>()</span>));</span><br><span class="line">      channel.basic<span class="constructor">Ack(<span class="params">message</span>.<span class="params">getMessageProperties</span>()</span>.getDeliveryTag,<span class="literal">false</span>);</span><br><span class="line">  &#125;catch(Exception e)&#123;</span><br><span class="line">      <span class="built_in">int</span> count = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">order</span>.<span class="params">getName</span>()</span>);</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(order.get<span class="constructor">Name()</span>);</span><br><span class="line">      channel.basic<span class="constructor">Ack(<span class="params">message</span>.<span class="params">getMessageProperties</span>()</span>.get<span class="constructor">DeliveryTag()</span>, <span class="literal">false</span>);</span><br><span class="line">      <span class="comment">//重试5次；如果5次仍然不成功则记录到日志；到时候人为进行处理（人为干预）；</span></span><br><span class="line">      <span class="keyword">if</span>(count!=<span class="number">5</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        order.set<span class="constructor">Name(String.<span class="params">valueOf</span>(<span class="params">count</span>)</span>);</span><br><span class="line">        sendMessageUtil.place<span class="constructor">OrderMessage(<span class="params">order</span>)</span>;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      loggerFactory.error(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">order</span>.<span class="params">getId</span>)</span>);</span><br><span class="line">      e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis 版本6.0之后即为多线程；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看笔记：&lt;a href=&quot;https://www.bilibili.com/video/BV1gZ4y1s7Aw&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="面试" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="redis" scheme="https://fengshana.github.io/tags/redis/"/>
    
      <category term="缓存" scheme="https://fengshana.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ实战指南</title>
    <link href="https://fengshana.github.io/2020/05/12/RabbitMQ%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/RabbitMQ%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%9704/"/>
    <id>https://fengshana.github.io/2020/05/12/RabbitMQ%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/RabbitMQ%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%9704/</id>
    <published>2020-05-12T03:35:27.484Z</published>
    <updated>2020-05-12T10:23:14.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>《RabbitMQ实战指南》 - 朱忠华  </p><h2 id="第4章-RabbitMQ进阶"><a href="#第4章-RabbitMQ进阶" class="headerlink" title="第4章 RabbitMQ进阶"></a>第4章 RabbitMQ进阶</h2><p>前一章所讲述的是一些基础的概念及使用方法，比如 <font style="color:red;font-weight:bolder">创建交换器</font>、<font style="color:red;font-weight:bolder">队列</font>和<font style="color:red;font-weight:bolder">绑定关系</font> 等。  </p><p>但是其中有许多细节并未陈述，对使用过程中的一些“坑”也并未提及，一些高级用法也并未展现，所以本章的内容就是要弥补这些缺憾。  </p><p>本章以 <font style="color:red;font-weight:bolder">RabbitMQ</font> 基础使用知识为前提，阐述一些根据特色的细节及功能，为读者更进一步地掌握 <font style="color:red;font-weight:bolder">RabbitMQ</font> 提供基准。</p><h2 id="消息何去何从"><a href="#消息何去何从" class="headerlink" title="消息何去何从"></a>消息何去何从</h2><p>mandatory 和immediate 是channel.basicPublish 方法中的两个参数，他们都有 当消息传递过程中不可达目的地时将消息返回给生产者的功能。  </p><p>RabbitMQ 提供的 备份交换器（Alternate Exchange） 可以 将未能被交换器路由的消息（没有绑定队列或者没有匹配的绑定）存储起来， 而不用返回给客户端。  </p><p>对于初学者来说，特别容易将 mandatory 和immediate 这两个参数混淆，而对于备份交换器更是一筹莫展，本章对此一一展开探讨。  </p><blockquote><p>mandatory</p></blockquote><p>[<br>  adj. 强制的；托管的；命令的<br>  n. 受托者（等于 mandatary）<br>  复数 mandatories<br>  网络释义 强制的；强制性；命令的；义务的；<br>  mandatory 强制的；强制性；命令的；义务的；<br>  mandatory plan 指令性计划；强制性计划；指令性打算；指令性规划；<br>  mandatory offer 强制要约；强制性要约；强制性收购建议；强制性收购；<br>]</p><blockquote><p>immediate</p></blockquote><p>[<br>  adj. 立即的；直接的；最接近的；<br>  网络释义 立刻；立即的；即时；直接的<br>  immediate 立刻；立即的；即时；直接的<br>  immediate employer 直接雇主<br>  immediate mode 直接模式；立即模式；即时模式<br>]</p><h3 id="mandatory-参数"><a href="#mandatory-参数" class="headerlink" title="mandatory 参数"></a>mandatory 参数</h3><p>当 mandatory 参数 设为 true 时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么 RabbitMQ 会调用 Basic.Return 命令将消息返回给生产者。  </p><p>当 mandatory 参数 设置为 false 时，出现上述情形（交换器无法根据自身的类型和路由键找到一个符合条件的队列），则消息直接被丢弃。  </p><p>那么生产者如何获取到 没有被正确路由到合适队列的消息 呢？<br>这时候可以通过调用 channel.addReturnListener 来添加 ReturnListener 监听器实现。  </p><p>使用 mandatory 参数的关键代码清单如下所示：  </p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(</span><br><span class="line">  EXCHANGE_NAME,</span><br><span class="line">  <span class="string">""</span>,</span><br><span class="line">  <span class="keyword">true</span>,</span><br><span class="line">  MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">  <span class="string">"mandatory test"</span>.getBytes()</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  channel.addReturnListener(</span><br><span class="line">    <span class="keyword">new</span> ReturnListener()&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> handleReturn(</span><br><span class="line">        <span class="built_in">int</span> replyCode,</span><br><span class="line">        <span class="keyword">String</span> replyText,</span><br><span class="line">        <span class="keyword">String</span> exchange,</span><br><span class="line">        <span class="keyword">String</span> routingKey,</span><br><span class="line">        AMQP.BasicProperties basicProperties,</span><br><span class="line">        <span class="built_in">byte</span>[] body</span><br><span class="line">      ) <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="keyword">String</span> message = <span class="keyword">new</span> <span class="keyword">String</span>(body);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Basic.Return 返回的结果是："</span>+message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>上面代码中 生产者 没有成功地将消息路由到队列，此时 RabbitMQ 会通过 Basic.Return 返回 “mandatory test” 这条消息，之后生产者客户端通过 ReturnListener 监听到了这个时间，上面代码的最后输出应该是 “Basic.Return 返回的结果是：mandatory test”。  </p><p>从 AMQP 协议层面来说，其对应的流转过程如图：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">----------</span>|<span class="string">                              </span>|<span class="string">----------</span>|</span><br><span class="line">|<span class="string"> Producer </span>|<span class="string">                              </span>|<span class="string">  Broker  </span>|</span><br><span class="line">|<span class="string">----------</span>|<span class="string">                              </span>|<span class="string">----------</span>|</span><br><span class="line">     |<span class="string">                                          </span>|</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">     |<span class="string">  此处省略 Connection 和 Channel的开启     </span>|</span><br><span class="line">     |<span class="string">                                          </span>|</span><br><span class="line">     |<span class="string">  Basic.Publish--------------------------&gt;</span>|</span><br><span class="line">     |<span class="string">                                          </span>|<span class="string">&lt;-----没有路由到队列</span></span><br><span class="line"><span class="string">     </span>|<span class="string">&lt;-----------------------------Basic.Return</span>|</span><br><span class="line">     |<span class="string">                  (Basic.Return会携带消息) </span>|</span><br><span class="line">     |<span class="string">                                          </span>|</span><br><span class="line">     |<span class="string">    此处省略Connection和Channel的关闭      </span>|</span><br><span class="line">     |<span class="string">                                          </span>|</span><br><span class="line">     |<span class="string">                                          </span>|</span><br><span class="line">     |<span class="string">                                          </span>|</span><br><span class="line">     |<span class="string">                                          </span>|</span><br></pre></td></tr></table></figure><h3 id="immediate-参数"><a href="#immediate-参数" class="headerlink" title="immediate 参数"></a>immediate 参数</h3><p>当 immediate 参数设为 true时，如果交换器在消息</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h2&gt;&lt;p&gt;《RabbitMQ实战指南》 - 朱忠华  &lt;/p&gt;
&lt;h2 id=&quot;第4章-RabbitMQ进阶&quot;&gt;&lt;a href=&quot;#第4章-Rabbi
      
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="https://fengshana.github.io/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="https://fengshana.github.io/tags/RabbitMQ/"/>
    
      <category term="笔记" scheme="https://fengshana.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="RabbitMQ实战指南" scheme="https://fengshana.github.io/tags/RabbitMQ%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现</title>
    <link href="https://fengshana.github.io/2020/05/11/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B001/"/>
    <id>https://fengshana.github.io/2020/05/11/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B001/</id>
    <published>2020-05-11T12:26:03.085Z</published>
    <updated>2020-05-12T16:14:33.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>查阅了很多的如何学习Redis；发现很多人推荐了这本书《Redis设计与实现》（黄健宏著）  </p><p>于是，我想看了；<br>一口气吃不成一个胖子；我觉得多看书还挺好的；<br>对技术充满敬畏。突然有一种肃然起敬的感觉。不知道为什么。<br>我不想再这么浅显的过着，平庸乏味，单薄，好像仔细一想就能看透我这一生的轨迹。<br>我不想这么活着。我得有自己的信念，得有自己所坚持所热爱所为之奋斗一生的东西。<br>我不想，到一定年龄结婚生子，到一定年龄，成为了自己不想成为的人；  </p><p>redis github: <a href="https://github.com/antirez/redis" target="_blank" rel="noopener">https://github.com/antirez/redis</a>  </p><h2 id="The-Design-and-Implementation-of-Redis（Redis设计与实现）"><a href="#The-Design-and-Implementation-of-Redis（Redis设计与实现）" class="headerlink" title="The Design and Implementation of Redis（Redis设计与实现）"></a>The Design and Implementation of Redis（Redis设计与实现）</h2><p><strong>Redis设计与实现</strong><br>黄健宏 著  </p><p>The Design and Implementation of Redis.  </p><ul><li>由资深 Redis 技术专家撰写，深入了解 Redis 技术聂牧的必读之作。</li><li>从源码角度解析 Redis 的架构设计、实现原理和工作机制，为高效使用 Redis 提供原理性指导。  </li></ul><blockquote><p>design</p></blockquote><p>[<br>  n. 设计；构思；设计图样；装饰图案；打算<br>  v. 设计；构思；计划；制造；意欲<br>  n.(Design) (巴、印、俄)迪赛（人名）<br>  复数 designs；<br>  过去式 designed；<br>  过去分词 designed；<br>  现在分词 designing；<br>  第三人称单数 designs；<br>  网络释义 设计、外观设计、图案、工艺特色<br>  design 设计；外观设计；图案；工艺特色<br>  Fashion Design 时装设计；时尚设计；服装设计；服装设计专业<br>  urban design 城市设计；城区设计；都市设计；城市化规划<br>]</p><blockquote><p>implementation</p></blockquote><p>[<br>  n.[ 计] 实现；履行；安装启用<br>  网络释义 实现；实施；实现；执行<br>  implementation 实现；实施；实现；执行<br>  base implementation 基实现<br>  policy implementation 政策实施；政策执行；政策的实施；政策执行<br>]</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本书全面而完整的讲解了 Redis 的 内部机制 与 实现方式。  </p><p>对 Redis 的大多数单机功能以及所有多机功能的实现原理进行了介绍。  </p><p>展示了这些功能的 核心数据结构 以及 关键的算法思想 ， 图示丰富，描述清晰，并给出大量参考信息。  </p><p>通过阅读本书，读者可以快速、有效地了解 Redis 的 内部构造 以及 运作机制，更好、更高效地使用 Redis。  </p><p>本书主要分为四大部分。  </p><ol><li><strong>第一部分</strong>：“数据结构与对象”</li></ol><p>介绍了 Redis 中的各种 对象及其数据结构，并说明这些 数据结构 如何影响 对象的功能和性能。</p><ol start="2"><li><strong>第二部分</strong>：“单机数据库的实现”</li></ol><p>对 Redis 实现单机数据库的方法 进行了介绍，包括 数据库、RDB持久化、AOF持久化、事件等；</p><ol start="3"><li><strong>第三部分</strong>：”多机数据库的实现“</li></ol><p>对 Redis 的 Sentinel、复制、集群 三个多机功能进行了介绍。</p><ol start="4"><li><strong>第四部分</strong>：”独立功能的实现“</li></ol><p>对 Redis 中各个相对独立的功能模块进行了介绍，涉及 发布与订阅、事务、Lua脚本、排序、二进制位数组、慢查询日志、监视器等。  </p><p>本书作者专门维护了 <a href="http://www.redisbook.com" target="_blank" rel="noopener">www.redisbook.com</a> 网站，提供带有详细注释的 Redis源码，以及本书相关的更新内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;查阅了很多的如何学习Redis；发现很多人推荐了这本书《Redis设计与实现》（黄健宏著）  &lt;/p&gt;
&lt;p&gt;于是，我想看了；&lt;br&gt;一口气
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://fengshana.github.io/categories/Redis/"/>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Redis" scheme="https://fengshana.github.io/tags/Redis/"/>
    
      <category term="Redis设计与实现" scheme="https://fengshana.github.io/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java笔试面试-Spring核心</title>
    <link href="https://fengshana.github.io/2020/05/11/Java%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95-Spring%E6%A0%B8%E5%BF%83/"/>
    <id>https://fengshana.github.io/2020/05/11/Java%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95-Spring%E6%A0%B8%E5%BF%83/</id>
    <published>2020-05-11T01:56:02.931Z</published>
    <updated>2020-05-11T10:51:31.326Z</updated>
    
    <content type="html"><![CDATA[<p>笔记：<a href="https://blog.csdn.net/huanglei305/article/details/101195116?utm_source=app" target="_blank" rel="noopener">https://blog.csdn.net/huanglei305/article/details/101195116?utm_source=app</a></p><p><font style="color:red;font-weight:bolder;">Spring framework</font> 简称 <font style="color:red;font-weight:bolder;">Spring</font> , 是Java开发中最常用的框架，地位仅次于<font style="color:red;font-weight:bolder;">Java API</font> ;  </p><p>就连近几年比较流行的微服务框架 <font style="color:red;font-weight:bolder;">SpringBoot</font> ， 也是基于  <font style="color:red;font-weight:bolder;">Spring</font> 实现的， <font style="color:red;font-weight:bolder;">SpringBoot</font> 的诞生是为了让开发者更方便的使用 <font style="color:red;font-weight:bolder;">Spring</font> ， 因此 <font style="color:red;font-weight:bolder;">Spring</font> 在java体系中的地位可谓首屈一指。</p><h2 id="Spring-介绍"><a href="#Spring-介绍" class="headerlink" title="Spring 介绍"></a>Spring 介绍</h2><p><font style="color:red;font-weight:bolder;">Spring</font> 是一个 <font style="color:red;font-weight:bolder;">开源框架</font> ， 为了  <font style="color:red;font-weight:bolder;">解决企业应用程序开发复杂性</font>  而创建的， <font style="color:red;font-weight:bolder;">Spring</font> 的概念诞生于 2002年，于2003年正式发布第一个版本 Spring Framework 0.9。</p><p><strong>Spring 1.x</strong><br>此版本主要是为了  <font style="color:red;font-weight:bolder;">解决企业应用程序开发复杂性</font>  而创建的，当时 <font style="color:red;font-weight:bolder;">J2EE</font> 应用的经典架构是  <font style="color:red;font-weight:bolder;">分层架构</font>： <font style="color:red;font-weight:bolder;">表现层、业务层、持久层</font>，最流行的组合就是 <font style="color:red;font-weight:bolder;">SSH（Struts、Spring、Hibernate）</font>。</p><p><font style="color:red;font-weight:bolder;">Spring1.x</font> 仅支持 <font style="color:red;font-weight:bolder;">基于XML的配置</font> ， 确保用户 <font style="color:red;font-weight:bolder;">代码不依赖Spring</font>，它主要包含了以下功能模块： <font style="color:red;font-weight:bolder;">aop、 beans、ejb、jdbc、jndi、orm、transation、validation、web</font>等。</p><p><strong>Spring 2.x</strong><br><font style="color:red;font-weight:bolder;">Spring 2.x</font> 的改动并不是很大， 主要是在 <font style="color:red;font-weight:bolder;">Spring 1.x</font>的基础上增加了几个新模块，如 <font style="color:red;font-weight:bolder;">ehcache、jms、jmx、scripting、stereotype</font> 等。</p><p><strong>Spring 3.x</strong><br><font style="color:red;font-weight:bolder;">Spring 3.x</font> 开始不止支持 <font style="color:red;font-weight:bolder;">XML的配置</font> ， 还扩展了 <font style="color:red;font-weight:bolder;">基于Java类的配置</font>， 还增加了 <font style="color:red;font-weight:bolder;">Expression、Instructment、Tomcat、oxm</font>等组件， 同时将原来的 <font style="color:red;font-weight:bolder;">Web</font> 细分为：<font style="color:red;font-weight:bolder;">Portlet、Servlet</font>。</p><p><strong>Spring 4.x</strong><br><font style="color:red;font-weight:bolder;">Spring 4.x</font> 扩充了 <font style="color:red;font-weight:bolder;">Groovy、Messaging、WebMvc、Tiles2、WebSocket</font>等功能组件，同时 <font style="color:red;font-weight:bolder;">Spring</font> 还适配了 <font style="color:red;font-weight:bolder;">Java版本</font>，全面支持 <font style="color:red;font-weight:bolder;">Java 8.0、Lambda表达式</font>等。 随着 <font style="color:red;font-weight:bolder;">RESTful 架构风格</font>被越来越多的用户所采用， <font style="color:red;font-weight:bolder;">Spring 4.x</font> 也提供了<font style="color:red;font-weight:bolder;">ResultController 等注解</font> 新特性。  </p><p><strong>Spring 5.x</strong><br><font style="color:red;font-weight:bolder;">Spring 5.x</font> 紧跟 Java 相关技术的更新迭代，不断适配 <font style="color:red;font-weight:bolder;">Java 的新版本</font>，同时不断重构优化自身核心框架代码，支持 <font style="color:red;font-weight:bolder;">函数式、响应式编程模型</font> 等。  </p><h2 id="Spring-核心"><a href="#Spring-核心" class="headerlink" title="Spring 核心"></a>Spring 核心</h2><p><font style="color:red;font-weight:bolder;">Spring 核心</font>  包括以下三个方面：</p><ul><li><font style="color:red;font-weight:bolder;">控制反转（IOC，Inversion of Control）</font></li><li><font style="color:red;font-weight:bolder;">依赖注入（DI，Dependency Injection）</font></li><li><font style="color:red;font-weight:bolder;">面向切面编程（AOP，Aspect Oriented Programming）</font></li></ul><p><strong>控制反转（IOC）</strong><br><font style="color:red;font-weight:bolder;">控制反转（Inversion of Control, IOC）</font> ,顾名思义所谓的 <font style="color:red;font-weight:bolder;">控制反转</font> 就是 <font style="color:red;font-weight:bolder;">把创建对象的权利交给框架去控制， 而不需要人为的去创建</font>， 这样就实现了 <font style="color:red;font-weight:bolder;">可插拔式的接口编程</font> ， 有效的 <font style="color:red;font-weight:bolder;">降低代码的耦合度，降低了扩展和维护的成本</font>。<br>比如，去某地旅游不再用自己亲自为订购A酒店还是B酒店而发愁了，只需要把住店的这个需求告诉给某个 托管平台， 这个托管平台就会帮您订购一个既便宜又舒适的酒店，而这个帮你订购酒店的行为就可以称之为 <font style="color:red;font-weight:bolder;">控制反转</font>。</p><p><strong>依赖注入（DI）</strong><br><font style="color:red;font-weight:bolder;">依赖注入 （Dependency Injection，DI）</font>，是 <font style="color:red;font-weight:bolder;">组件之间依赖关系</font> 由 <font style="color:red;font-weight:bolder;">容器在运行期</font> 决定，即由 <font style="color:red;font-weight:bolder;">容器动态的将某个依赖关系注入到组件之中</font>。<br><font style="color:red;font-weight:bolder;">依赖注入</font> 的目的 并非为 软件系统带来更多功能，而是为了 <font style="color:red;font-weight:bolder;">提高组件重用的频率，并为系统搭建一个灵活、可扩展的平台</font>。<br>通过 <font style="color:red;font-weight:bolder;">依赖注入机制</font>，只需要通过简单的配置，而无需任何代码就可以指定目标需要的资源， 完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><p><strong>IOC和DI的关系</strong><br><font style="color:red;font-weight:bolder;">IOC</font> 是 <font style="color:red;font-weight:bolder;">Spring</font> 中一个极为重要的<font style="color:red;font-weight:bolder;">概念</font>， 而 <font style="color:red;font-weight:bolder;">DI </font>则是 <font style="color:red;font-weight:bolder;">实现IOC</font> 的 <font style="color:red;font-weight:bolder;">方法和手段</font>。  </p><p><strong>依赖注入的常见实现方式</strong></p><ul><li><font style="color:red;font-weight:bolder;">setter</font> 注入</li><li><font style="color:red;font-weight:bolder;">构造方法</font> 注入</li><li><font style="color:red;font-weight:bolder;">注解</font> 注入</li></ul><ol><li><strong>setter 注入</strong></li></ol><p>Java代码：  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">UserController</span>&#123;</span><br><span class="line">  <span class="comment">//注入 UserService 对象</span></span><br><span class="line">  <span class="keyword">private</span> UserService userService;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> setUserService(UserService userService)&#123;</span><br><span class="line">    <span class="keyword">this</span>.userService = userService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userController"</span> <span class="attr">class</span>=<span class="string">"com.learning.controller.UserController"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 依赖注入 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userService"</span> <span class="attr">ref</span>=<span class="string">"userService"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.learning.dao.impl.UserServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Bean标签的常用属性说明：</strong></p><ul><li><strong>id</strong>: 为实例化对象 起名称， 根据id值 可以得到配置的实例化对象，id属性的名称原则上可以任意命名，但是不能包含任何特殊符号；</li><li><strong>class</strong>: 创建对象所在类的全路径。</li><li><strong>name</strong>: 功能和id属性一样，但是现在一般不用；与id的区别在于：name属性值里可以包含特殊符号，但是id不可以；</li><li><strong>scope</strong>： 一般最常用的有两个值：<br><font style="color:red;font-weight:bolder;">Singleton（单例模式）</font>，整个应用程序，只创建bean这一个示例；<br><font style="color:red;font-weight:bolder;">Prototype（原型模式）</font>，每次注入都会创建一个新的bean实例，<font style="color:red;font-weight:bolder;">Spring默认的是单例模式</font>。</li></ul><ol start="2"><li><strong>构造方法注入</strong></li></ol><p>Java代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService;</span><br><span class="line">  <span class="keyword">public</span> UserController(UserService userService)&#123;</span><br><span class="line">    <span class="keyword">this</span>.userService = userService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userController"</span> <span class="attr">class</span>=<span class="string">"com.learning.controller.UserController"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 依赖注入 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"userService"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.learning.dao.impl.UserServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>注解注入：</strong></li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Controller</span></span><br><span class="line">public class UserController&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用注解自动注入</span></span><br><span class="line">  <span class="variable">@Autowired</span></span><br><span class="line">  private UserService userService;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建依赖对象</span></span><br><span class="line"><span class="variable">@Service</span></span><br><span class="line">public class UserService&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font style="color:red;font-weight:bolder;">创建依赖对象</font>的常见注解：<br><font style="color:red;font-weight:bolder;">@Component</font>、<br><font style="color:red;font-weight:bolder;">@Controller</font>、<br><font style="color:red;font-weight:bolder;">@Service</font>、<br><font style="color:red;font-weight:bolder;">@Repository</font></p><p>总结： 可以看出 <font style="color:red;font-weight:bolder;">注解的方式</font> 要比 <font style="color:red;font-weight:bolder;">传统的XML（setter和构造器注入）</font> 是实现注入更为方便，同时注解方式 也是官方力推的依赖注入最佳使用方式。</p><p><strong>面向切面编程（AOP，Aspect Oriented Programming）</strong><br><font style="color:red;font-weight:bolder;">面向切面编程（Aspect Oriented Programming，AOP）</font>；<br>它就好比 将系统按照功能分类，每一个类别就是一个“切面”，再针对不同的切面制定相应的规则，类似开发模式被称为<font style="color:red;font-weight:bolder;">面向切面编程</font>。</p><p><strong>AOP使用场景</strong></p><ul><li><font style="color:red;font-weight:bolder;">日志系统</font></li><li><font style="color:red;font-weight:bolder;">安全统一校验</font></li></ul><p><strong>AOP优点</strong></p><ul><li><font style="color:red;font-weight:bolder;">集中处理某一类问题，方便维护</font></li><li><font style="color:red;font-weight:bolder;">逻辑更加清晰</font></li><li><font style="color:red;font-weight:bolder;">降低模块间的耦合度</font></li></ul><p><strong>AOP相关概念</strong></p><ul><li><strong>Join point</strong>: <font style="color:red;font-weight:bolder;">连接点</font>，程序执行期间的某一个点，例如执行方法或处理异常时候的点，在Spring AOP中，连接点总是表示方法的执行。</li><li><strong>Advice</strong>: <font style="color:red;font-weight:bolder;">通知</font>，通知分为方法执行前通知、方法执行后通知、环绕通知等。许多AOP框架（包括Spring）都将通知建模为拦截器，在连接点周围维护一系列拦截器（形成拦截器链），对连接点的方法进行增强。</li><li><strong>PointCut</strong>：<font style="color:red;font-weight:bolder;">切点</font>，匹配连接点（Join point）的表达式，是AOP的核心，并且Spring默认使用AspectJ作为切入点表达式语言；</li><li><strong>Aspect</strong>：<font style="color:red;font-weight:bolder;">切面</font>，是一个跨越多个类的模块化的关注点，它是通知（Advice）和切点（Pointcut）合起来的抽象，它定义了一个切点（Pointcut）用来匹配连接点（Join point）,也就是需要对需要拦截的那些方法进行定义；</li><li><strong>Target object</strong>：<font style="color:red;font-weight:bolder;">目标对象</font>，对一个或者多个切面（Aspect）通知的对象，也就是需要被AOP进行拦截对方法进行增强（使用通知）的对象，也称为被通知的对象。由于在AOP里面使用运行时代理，因而目标对象一直是被代理的对象。</li><li><strong>AOP Proxy</strong>：<font style="color:red;font-weight:bolder;">AOP代理</font>，为了是实现切面（Aspect）功能使用AOP框架创建一个对象，在Spring框架里面一个AOP代理指的是JDK自身的动态代理或者是CGLIB实现的动态代理；</li><li><strong>Weaving</strong>：<font style="color:red;font-weight:bolder;">把切面加入到对象，并创建出代理对象的过程</font>；</li><li><strong>Advisor</strong>：一个Advisor相当于一个<font style="color:red;font-weight:bolder;">小型的切面</font>，不同的是它只有一个通知（Advice），Advisor在事务管理里面会经常遇到。</li></ul><p><strong>AOP代码实现</strong><br>AOP的示例就以开车为例；<br>开车的完成流程是这样的：<br>巡视车体以及周围情况—》发动—》开车—》熄火—》锁车。<br>当然，主要的目的是“开车”，但是在开车之前和开完车之后，要做一些其他的工作，这些“其他”的工作，可以理解为AOP编程。  </p><p>1）<strong>创建类和方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learning.aop;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">driver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"开车"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）<strong>创建AOP拦截</strong></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.learning.aop;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">After</span>;</span><br><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Aspect</span>;</span><br><span class="line">import org.aspectj.lang.<span class="keyword">annotation</span>.<span class="title">Before</span>;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CarAop</span>&#123;</span></span><br><span class="line">  @Before(<span class="string">"execution(* com.learning.aop.Person.driver())"</span>)</span><br><span class="line">  public void before()&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"巡视车体以及周围情况"</span>);</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"发动"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  @After(<span class="string">"execution(* com.learning.aop.Person.driver())"</span>)</span><br><span class="line">  public void before()&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"熄火"</span>);</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"锁车"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）<strong>XML配置注入扫描包路径</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.learning"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4）<strong>创建测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learning.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    Person landlord=context.getBean(<span class="string">"person"</span>,Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    landlord.driver();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试代码，执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">巡视车体以及周围情况</span><br><span class="line"></span><br><span class="line">发动</span><br><span class="line"></span><br><span class="line">开车</span><br><span class="line"></span><br><span class="line">熄火</span><br><span class="line"></span><br><span class="line">锁车</span><br></pre></td></tr></table></figure><p><strong>AspectJ 注解</strong> 说明：  </p><ul><li><strong>@Before</strong> <font style="color:red;font-weight:bolder;">前置通知</font>，在连接点方法前调用；</li><li><strong>@Around</strong> <font style="color:red;font-weight:bolder;">环绕通知</font>，它将覆盖原有方法，但是允许通过反射调用原有方法</li><li><strong>@After</strong> <font style="color:red;font-weight:bolder;">后置通知</font>，在连接点方法后调用；</li><li><strong>@AfterReturning</strong> <font style="color:red;font-weight:bolder;">返回通知</font>，在连接点方法执行并正常返回后调用，要求连接点方法在执行过程中没有发生任何异常。</li><li><strong>@AfterThrowing</strong> <font style="color:red;font-weight:bolder;">异常通知</font>，当连接点方法异常时调用；</li></ul><h2 id="笔试面试题"><a href="#笔试面试题" class="headerlink" title="笔试面试题"></a>笔试面试题</h2><ol><li><strong>@Value 注解的作用是什么？</strong></li></ol><p>答： 基于 <font style="color:red;font-weight:bolder;">@Value</font> 的注解可以 <font style="color:red;font-weight:bolder;">读取 properties 配置文件</font>，使用如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(<span class="string">"<span class="subst">#&#123;configProperties[<span class="string">'jdbc.username'</span>]&#125;</span>"</span>)</span><br><span class="line">private String userName;</span><br></pre></td></tr></table></figure><p>以上为读取configProperties下的jdbc.username 配置</p><ol start="2"><li><strong>Spring通知类型有哪些？</strong></li></ol><p>答：<br><font style="color:red;font-weight:bolder;">Spring 通知类型</font> 总共有5种：<br><font style="color:red;font-weight:bolder;">前置通知</font>、<br><font style="color:red;font-weight:bolder;">环绕通知</font>、<br><font style="color:red;font-weight:bolder;">后置通知</font>、<br><font style="color:red;font-weight:bolder;">异常通知</font>、<br><font style="color:red;font-weight:bolder;">最终通知</font>。</p><ul><li><strong>前置通知（Before Advice）</strong>：在目标方法执行之前执行的通知。在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li><li><strong>环绕通知（Around Advice）</strong>：在目标方法执行之前和之后都可以执行额外代码的通知，也可以选择是否继续执行连接点或者直接返回他们自己的返回值或抛出异常来结束执行。</li><li><strong>后置通知（After（finally）Advice）</strong>：目标方法执行之后（某连接点退出的时候）执行的通知（不论是正常返回还是异常退出）</li><li><strong>异常后通知（After throwing Advice）</strong>：在方法抛出异常退出时执行通知</li><li><strong>最终通知（After returning Advice）</strong>：在某连接点（join point）正常完成后执行的通知，例如，一个方法没有抛出任何异常，正常返回。</li></ul><ol start="3"><li><strong>怎么理解Spring中的IOC容器？</strong></li></ol><p>答： <font style="color:red;font-weight:bolder;">Spring IOC</font> 就是 <font style="color:red;font-weight:bolder;">把创建对象的权利交给框架去控制，而不需要人为的去创建</font>，这样就实现了 <font style="color:red;font-weight:bolder;">可插拔式的接口编程</font>，<font style="color:red;font-weight:bolder;">有效的降低代码的耦合度，降低了扩展和维护的成本</font>。</p><p>比如，去某地旅游不再用自己亲自为订购A酒店还是B酒店而发愁了，只需要把住店的需求告诉给某个托管平台，这个托管平台就会帮您订购一个既便宜又舒适的酒店，而这个帮你订购酒店的行为就可以称之为 控制反转。</p><ol start="4"><li><strong>怎么理解 Spring 中的依赖注入？</strong></li></ol><p>答：<font style="color:red;font-weight:bolder;">依赖注入</font> 是指 <font style="color:red;font-weight:bolder;">组件之间的依赖关系</font> 由  <font style="color:red;font-weight:bolder;">容器在运行期决定</font>，即由 <font style="color:red;font-weight:bolder;">容器动态的将某个依赖关系注入到组件之中</font>。依赖注入的目的并非为软件系统带来更多功能，而是 <font style="color:red;font-weight:bolder;">为了提升组件重用的频率， 并为系统搭建一个灵活、可扩展的平台</font>。 通过 <font style="color:red;font-weight:bolder;">依赖注入机制</font>，只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。  </p><ol start="5"><li><strong>IOC和DI有什么关系？</strong></li></ol><p>答：<font style="color:red;font-weight:bolder;">IOC(Inversion of Control)</font> 是 <font style="color:red;font-weight:bolder;">Spring</font> 中一个极为重要的 <font style="color:red;font-weight:bolder;">概念</font>，提供了<font style="color:red;font-weight:bolder;">对象管理</font> 的功能，从而省去了人为创建麻烦，而 <font style="color:red;font-weight:bolder;">DI(Dependency Injection)</font> 正是实现 <font style="color:red;font-weight:bolder;">IOC(Inversion of Control)</font> 的 <font style="color:red;font-weight:bolder;">方法和手段</font>。  </p><ol start="6"><li><strong>@Component和@Bean有什么区别？</strong></li></ol><p>答：<font style="color:red;font-weight:bolder;">@Component</font> 和 <font style="color:red;font-weight:bolder;">@Bean</font> 的 <font style="color:red;font-weight:bolder;">作用对象</font> 不同；</p><ul><li><font style="color:red;font-weight:bolder;">@Component</font>作用于<font style="color:red;font-weight:bolder;">类</font></li><li><font style="color:red;font-weight:bolder;">@Bean</font>直接作用于<font style="color:red;font-weight:bolder;">方法</font></li></ul><p><font style="color:red;font-weight:bolder;">@Component</font> 通常是通过 <font style="color:red;font-weight:bolder;">类路径扫描</font> 来自动 侦测和 装配 对象到Spring容器中；<br>比如<font style="color:red;font-weight:bolder;">@ComponentScan</font> 注解就是定义 扫描路径中的类 装配 到Spring的Bean容器中；</p><p><font style="color:red;font-weight:bolder;">@Bean</font> 注解是告诉Spring这是某个类的实例，当调用者需要用它的时候把它给调用者；<br>@Bean 注解比 @Component注解 <font style="color:red;font-weight:bolder;">自定义性</font> 更强，很多地方只能通过@Bean注解来注册Bean，比如当引用第三方库中的类需要 装配 到Spring容器时，则只能通过 @Bean 来实现，比如以下示例，只能通过@Bean注解来实现：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WireThirdLibClass</span></span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ThirdLibClass <span class="title">getThirdLibClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThirdLibClass();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>Spring中Bean的作用域有几种类型？</strong></li></ol><p>答：<font style="color:red;font-weight:bolder;">Spring中bean的作用域有四种类型</font>，如下列表：</p><ul><li><font style="color:red;font-weight:bolder;">单例（Singleton）</font>: 整个应用程序，只创建bean的一个实例；</li><li><font style="color:red;font-weight:bolder;">原型（Prototype）：</font> 每次注入都会创建一个新的bean实例；</li><li><font style="color:red;font-weight:bolder;">会话（Session）：</font> 每个会话创建一个bean实例，只在Web系统中有效；</li><li><font style="color:red;font-weight:bolder;">请求（Request）：</font> 每个请求创建一个bean实例，只在Web系统中有效；</li><li><font style="color:red;font-weight:bolder;">Spring默认的是单例模式。</font></li></ul><ol start="8"><li><strong>什么是Spring的内部Bean？</strong></li></ol><p>答：当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean，为了定义innerBean，在Spring的基于XML的配置元数据中，可以在&lt; property/&gt; 或者&lt; constructor-arg/&gt;元素内使用&lt; bean/&gt;元素，内部bean通常是匿名的，它们的Scope一般是prototype。  </p><ol start="9"><li><strong>Spring注入方式有哪些？</strong></li></ol><p>答：<font style="color:red;font-weight:bolder;">Spring的注入方式包含以下五种</font>：  </p><ul><li><font style="color:red;font-weight:bolder;">setter</font> 注入</li><li><font style="color:red;font-weight:bolder;">构造方法</font> 注入</li><li><font style="color:red;font-weight:bolder;">注解</font> 注入</li><li><font style="color:red;font-weight:bolder;">静态工厂</font> 注入</li><li><font style="color:red;font-weight:bolder;">实例工厂</font> 注入</li></ul><p>其中最常用的是前三种，官方推荐使用的是 <font style="color:red;font-weight:bolder;">注解</font> 注入，相对使用更简单，维护成本更低，更直观。  </p><ol start="10"><li><strong>在Spring中如何操作数据库？</strong></li></ol><p>答：在Spring中操作数据库，可以使用Spring提供的JDBC Template对象；<br>JDBC Template类提供了很多便利的方法；<br>比如把数据库数据转变成基本数据类型或对象；<br>执行自定义SQL语句；<br>提供了自定义的数据错误处理等；</p><p>jdbc template 使用示例如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增</span></span><br><span class="line">@GetMapping(<span class="string">"save"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">String</span> save()&#123;</span><br><span class="line">  <span class="built_in">String</span> sql=<span class="string">"INSERT INTO USER(USER_NAME,PASS_WORD) VALUES ('LAOWANG','ADMIN')"</span>;</span><br><span class="line">  int <span class="keyword">rows</span>=jdbcTemplate.update(sql);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"执行成功，影响"</span>+<span class="keyword">rows</span>+<span class="string">"行"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">@GetMapping(<span class="string">"del"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">String</span> del(int id)&#123;</span><br><span class="line">  int <span class="keyword">rows</span>=jdbcTemplate.update(<span class="string">"DELETE FROM USER WHERE ID=?"</span>,id);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"执行成功，影响"</span>+<span class="keyword">rows</span>+<span class="string">"行"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询</span></span><br><span class="line">@GetMapping(<span class="string">"getMapById"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">Map</span> getMapById(<span class="built_in">Integer</span> id)&#123;</span><br><span class="line">  <span class="built_in">String</span> sql=<span class="string">"SELECT * FROM USER WHERE ID=?"</span>;</span><br><span class="line">  <span class="built_in">Map</span> <span class="built_in">map</span>=jdbcTemplate.queryForMap(sql,id);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="11"><li><strong>Spring的 JdbcTemplate 对象和 JDBC 有什么区别？</strong></li></ol><p>答：<font style="color:red;font-weight:bolder;">Spring</font>的 <font style="color:red;font-weight:bolder;">JdbcTemplate</font>是对<font style="color:red;font-weight:bolder;">JDBC API的封装</font>，提供更多的功能和更便利的操作，比如<font style="color:red;font-weight:bolder;">JDBC Template </font>拥有：</p><ul><li><font style="color:red;font-weight:bolder;">JDBC Template</font>是<font style="color:red;font-weight:bolder;">线程安全</font>的；</li><li><font style="color:red;font-weight:bolder;">实例化</font>操作比较<font style="color:red;font-weight:bolder;">简单</font>，仅需要传递<font style="color:red;font-weight:bolder;">DataSource</font></li><li><font style="color:red;font-weight:bolder;">自动完成资源的创建和释放</font>工作；</li><li>创建一次JDBCTemplate，到处可用，<font style="color:red;font-weight:bolder;">避免重复开发</font>。</li></ul><ol start="12"><li><strong>Spring有几种实现事务的方式？</strong></li></ol><p>答：Spring实现事务的方式有两种方式：</p><ul><li><font style="color:red;font-weight:bolder;">编程式</font> 事务；</li><li><font style="color:red;font-weight:bolder;">声明式</font> 事务；</li></ul><p><font style="color:red;font-weight:bolder;">编程式</font> 事务：<br>使用<font style="color:red;font-weight:bolder;">TransactionTemplate</font>或<font style="color:red;font-weight:bolder;">Platform TransactionManager</font>实现，<br>示例代码如下：  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="comment">//Spring编程式事务，回调机制</span></span><br><span class="line">  transactionTemplate.execute(<span class="keyword">new</span> TransactionCallback&lt;Object&gt;)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        userMapper.insertSelective(user);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="comment">//异常，设置为回滚</span></span><br><span class="line">        status.setRollbackOnly();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有<font style="color:red;font-weight:bolder;">异常</font>，调用<font style="color:red;font-weight:bolder;">status.setRollbackOnly()</font>，<font style="color:red;font-weight:bolder;">回滚事务</font>；<br>否则<font style="color:red;font-weight:bolder;">正常</font>，执行<font style="color:red;font-weight:bolder;">doInTransaction()</font>方法，正常<font style="color:red;font-weight:bolder;">提交事务</font>。  </p><p>如果<font style="color:red;font-weight:bolder;">事务控制的方法不需要返回值</font>：<br>就可以使用<font style="color:red;font-weight:bolder;">TransactionCallbackWithoutResult(TransactionCallback接口的抽象实现类)</font><br>示例代码如下:  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="comment">//Spring编程式事务，回调机制</span></span><br><span class="line">  transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        userMapper.insertSelective(user);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="comment">//异常，设置为回滚</span></span><br><span class="line">        status.setRollbackOnly();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font style="color:red;font-weight:bolder;">声明式</font> 事务：<br>底层是建立在<font style="color:red;font-weight:bolder;">SpringAOP的基础</font>上；<br>在方法执行前后进行拦截；<br>并在目标方法开始执行前创建新事物或加入一个已存在事务；<br>最后在目标方法执行完毕后根据情况进行提交或者回滚事务；  </p><p><font style="color:red;font-weight:bolder;">声明式</font> 事务的优点:<br>不需要编程，<font style="color:red;font-weight:bolder;">减少了代码的耦合</font> ，<br>在配置文件中配置并在目标方法上添加 <font style="color:red;font-weight:bolder;">@Transactional 注解</font>来实现；</p><p>示例代码如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> save()&#123;</span><br><span class="line">  <span class="keyword">User</span> <span class="keyword">user</span>=<span class="built_in">new</span> <span class="keyword">User</span>("laowang");</span><br><span class="line">  userMapper.insertSelective(<span class="keyword">user</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    throw <span class="built_in">new</span> RuntimeException("异常");</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛出异常，事务回自动回滚；<br>如果方法正常执行，则会自动提交事务。</p><ol start="13"><li><strong>Spring中的AOP的底层实现原理是什么？</strong></li></ol><p>答：<font style="color:red;font-weight:bolder;">Spring AOP</font>的底层实现原理就是 <font style="color:red;font-weight:bolder;">动态代理</font>。</p><p><font style="color:red;font-weight:bolder;">Spring AOP的动态代理有两种实现方式</font>：<br>对于<font style="color:red;font-weight:bolder;">接口</font>使用的是<font style="color:red;font-weight:bolder;">JDK自带的动态代理</font>来实现的；<br>而对比<font style="color:red;font-weight:bolder;">非接口</font>使用的是<font style="color:red;font-weight:bolder;">CGLIB来实现</font>的；</p><ol start="14"><li><strong>Spring声明式事务无效可能的原因有哪些?</strong></li></ol><p>答：<font style="color:red;font-weight:bolder;">Spring声明式事务无效可能的原因</font>如下：</p><ul><li><font style="color:red;font-weight:bolder;">MySQL使用的是MyISAM存储引擎</font>，而<font style="color:red;font-weight:bolder;">MyISAM是不支持事务</font>的；</li><li><font style="color:red;font-weight:bolder;">@Transactional使用在非public方法上</font>，<font style="color:red;font-weight:bolder;">@Transactional注解只能支持public级别</font>，其他类型声明的事务不会生效；</li><li><font style="color:red;font-weight:bolder;">@Transactional 在同一个类中无事务方法 A() 内部调用 有事务方法B()，那么此时B() 事务不会生效</font>。</li></ul><ol start="15"><li><strong>Spring中的Bean是线程安全的吗？</strong></li></ol><p>答：<font style="color:red;font-weight:bolder;">Spring中的Bean默认是单例模式</font>;<br>Spring框架并没有对单例Bean进行多线程的封装处理;<br>因此<font style="color:red;font-weight:bolder;">默认的情况Bean并非是安全</font>的;<br>最简单保证Bean安全的举措就是<font style="color:red;font-weight:bolder;">设置Bean的作用域为Prototype（原型）模式</font>，这样每次请求都会新建一个Bean。</p><ol start="16"><li><strong>说一下Spring中Bean的生命周期？</strong></li></ol><p>答：<font style="color:red;font-weight:bolder;">Spring中Bean的生命周期</font>如下：</p><p>1）<font style="color:red;font-weight:bolder;">实例化Bean</font>：<br>对于BeanFactory容器，当客户想容器请求一个尚未初始化的Bean时，或初始化Bean的时候需要注入另一个尚未初始化的依赖时，<br>容器就会调用createBean进行实例化。<br>对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的Bean。</p><p>2）<font style="color:red;font-weight:bolder;">设置对象属性（依赖注入）</font>：<br>实例化后的对象被封装在BeanWrapper对象中，紧接着Spring根据BeanDefinition中的信息以及通过BeanWrapper提供的设置属性的接口完成依赖注入；</p><p>3）<font style="color:red;font-weight:bolder;">处理Aware接口</font>：<br>Spring会检测该对象是否实现了  xxxAware 接口，并将相关 xxxAware实例注入给Bean；</p><p>如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName（String BeanId）方法，此处传递的就是Spring配置文件中Bean的id值；</p><p>如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory（）方法，传递的是Spring工厂自身；</p><p>如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext（ApplicationContext）方法，传入Spring上下文；</p><p>4）<font style="color:red;font-weight:bolder;">BeanPostProcessor</font>：如果想对Bean进行一些自定义的处理，那么可以让Bean实现BeanPostProcessor接口，那将会调用 postProcessBeforeInitialization(Object obj，String s)方法；</p><p>5）<font style="color:red;font-weight:bolder;">InitialiingBean与init-method</font>：如果Bean在Spring配置文件中配置了init-method属性，则会自动调用其配置的初始化方法；</p><p>6）如果这个Bean实现了BeanPostProcessor接口，将会调用 postProcessAfterInitialization（Object obj，String s）方法；由于这个方法是在Bean初始化结束时调用的，因而可以被应用于内存或者缓存技术；</p><p>以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个Bean了。</p><p>7）<font style="color:red;font-weight:bolder;">DisposableBean</font>：当Bean不再需要时，会经过清理阶段；如果Bean实现了DisposableBean这个接口，会调用其实现的 destroy()方法；</p><p>8）<font style="color:red;font-weight:bolder;">destroy-mothod</font>：最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p><ol start="17"><li><strong>Spring 有哪些优点？</strong></li></ol><p>答：<font style="color:red;font-weight:bolder;">Spring 优点</font>如下：</p><ul><li><font style="color:red;font-weight:bolder;">开源</font>、<font style="color:red;font-weight:bolder;">免费</font>的热门框架，<font style="color:red;font-weight:bolder;">稳定性高</font>、<font style="color:red;font-weight:bolder;">解决问题成本低</font>；</li><li><font style="color:red;font-weight:bolder;">方便集成</font>各种优秀的框架；</li><li><font style="color:red;font-weight:bolder;">降低了代码耦合性</font>：通过Spring提供的<font style="color:red;font-weight:bolder;">IOC(Inversion of Control)</font>容器，可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过渡程序耦合；</li><li><font style="color:red;font-weight:bolder;">方便程序测试</font>：在Spring里，测试变得非常简单；例如：Spring对Junit的支持，可以通过注解方便的测试Spring程序；</li><li><font style="color:red;font-weight:bolder;">降低Java EE API 的使用难度</font>：Spring对很多难用的Java EE API（如JDBC、JavaMail、远程调用等）提供了一层封装，通过Spring的简易封装，让这些Java EE API的使用难度大为降低；</li></ul><ol start="18"><li><strong>Spring和Struts的区别？</strong></li></ol><p>答： <font style="color:red;font-weight:bolder;">Spring和Struts的区别</font>如下：</p><p><font style="color:red;font-weight:bolder;">Spring 特性</font>如下：</p><ul><li>具备<font style="color:red;font-weight:bolder;">IOC(Inversion of Control)/DI(Dependency Injection)、AOP(Aspect oriented Programming)</font>等通用能力，提高研发效率</li><li>除了支持Web层建设以外，还提供了了J2EE整体服务</li><li>方便与其他不同技术结合使用，如Hibernate、Mybatis等</li><li><font style="color:red;font-weight:bolder;">Spring拦截机制是方法级别</font></li></ul><p><font style="color:red;font-weight:bolder;">Struts特性</font>如下：</p><ul><li>是一个基于MVC模式的一个Web层的处理</li><li><font style="color:red;font-weight:bolder;">Struts拦截机制是类级别</font></li></ul><ol start="19"><li><strong>Spring、SpringBoot、SpringCloud的区别是什么？</strong></li></ol><p>答： <font style="color:red;font-weight:bolder;">Spring、SpringBoot、SpringCloud的区别</font>如下：</p><ul><li><font style="color:red;font-weight:bolder;">Spring Framework</font> 简称 Spring，是整个Spring生态的基础；</li><li><font style="color:red;font-weight:bolder;">Spring Boot</font>是一个快速开发框架；<br>让开发者可以迅速搭建一套基于Spring的应用程序；<br>并且将<font style="color:red;font-weight:bolder;">常用的Spring模块以及第三方模块</font>，如Mybatis、Hibernate等都做了很好的<font style="color:red;font-weight:bolder;">集成</font>，只需要简单的配置即可使用；<br><font style="color:red;font-weight:bolder;">不需要任何的XML配置文件</font>，真正做到了<font style="color:red;font-weight:bolder;">开箱即用</font>；<br>同时<font style="color:red;font-weight:bolder;">默认支持JSON格式的数据</font>；<br>使用Spring Boot进行<font style="color:red;font-weight:bolder;">前后端分离开发</font>也非常<font style="color:red;font-weight:bolder;">便捷</font>。</li><li><font style="color:red;font-weight:bolder;">Spring Cloud</font>是一套整合了<font style="color:red;font-weight:bolder;">分布式应用</font> 常用模块的框架；<br>使得开发者可以快速实现<font style="color:red;font-weight:bolder;">微服务应用</font>。<br>作为目前非常热门的技术，有关微服务的话题总是在各种场景下被大家讨论；<br>企业的招聘信息中也越来越多的出现对于微服务架构能力的要求。</li></ul><ol start="20"><li><strong>Spring中都是用了哪些设计模式？</strong></li></ol><p>答： <font style="color:red;font-weight:bolder;">Spring中使用的设计模式</font>如下：</p><ul><li><strong>工厂模式</strong>： 通过BeanFactory、ApplicationContext 来创建bean 都是属于工厂模式；</li><li><strong>单例、原型模式</strong>： 创建bean对象 设置作用域时，就可以声明Singleton（单例模式）、Prototype（原型模式）；</li><li><strong>观察者模式</strong>：Spring可以定义一下监听，如ApplicationListener 当某个动作触发时就会发出通知；</li><li><strong>责任链模式</strong>：AOP拦截器的执行；</li><li><strong>策略模式</strong>：在创建代理类时，如果代理的接口使用的是JDK自身的动态代理，如果不是，则接口使用的是CGLIB实现动态代理；</li></ul><ol start="22"><li><strong>Spring事务隔离级别有哪些？</strong></li></ol><p>答：<font style="color:red;font-weight:bolder;">Spring的事务隔离级别包含以下五种</font>：</p><ul><li><strong>ISOLATION_DEFAULT（isolation default）</strong>: 用底层数据库的设置隔离级别，数据库设置的是什么就用什么；</li><li><strong>ISOLATION_READ_UNCOMMITTED（isolation read uncommitted）</strong>:<font style="color:red;font-weight:bolder;">未提交读</font>，最低隔离级别、事务未提交前，就可以被其他事务读取（会出现幻读、脏读、不可重复读）；</li><li><strong>ISOLATION_READ_COMMITTED（isolation read committed）</strong>: <font style="color:red;font-weight:bolder;">提交读</font>，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL Server的默认级别；</li><li><strong>ISOLATION_REPEATABLE_READ( isolation repeatable read)</strong>: <font style="color:red;font-weight:bolder;">可重复度</font>，保证多次读取同一个数据时，其值都和事务开始时候的内容是一样的，禁止读取到别的事务未提交的数据（会造成幻读），MySQL的默认级别；</li><li><strong>ISOLATION_SERIALIZABLE（isolation serializable）</strong>:<font style="color:red;font-weight:bolder;">序列化</font>，代价最高最可靠的隔离级别，该隔离界别能防止脏读、不可重复读、幻读。</li></ul><p>默认值是 <strong>ISOLATION_DEFAULT</strong> 遵循数据库的事务隔离级别设置；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔记：&lt;a href=&quot;https://blog.csdn.net/huanglei305/article/details/101195116?utm_source=app&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.
      
    
    </summary>
    
    
      <category term="面试" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Spring" scheme="https://fengshana.github.io/tags/Spring/"/>
    
      <category term="面试" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>MicroservicesGuide-走近微服务</title>
    <link href="https://fengshana.github.io/2020/05/10/%E9%9D%A2%E8%AF%95/MicroservicesGuide-%E8%B5%B0%E8%BF%91%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://fengshana.github.io/2020/05/10/%E9%9D%A2%E8%AF%95/MicroservicesGuide-%E8%B5%B0%E8%BF%91%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-05-10T09:54:45.023Z</published>
    <updated>2020-05-17T18:44:36.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Nothing better than a buzy Saturday morning.</p></blockquote><p>为什么想要翻译这篇博客呢，因为也是看了b站上的一个学习springboot的一个视频，而且我今天面试的时候人家问了微服务是什么，然后由此可得我万分后悔没有当时通篇翻译这篇博客。<br>好了现在后悔也挽救不了我的愚不可及了。<br>观看笔记：<a href="https://www.bilibili.com/video/BV1Eg4y187XT" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Eg4y187XT</a><br>就是这个视频告诉了我：推荐看哦~<br>为了不后悔，以后每件事情，能做笔记就一定要压着自己做，不然会后悔的；  </p><h2 id="Microservices-Guide-微服务指南（翻译）"><a href="#Microservices-Guide-微服务指南（翻译）" class="headerlink" title="Microservices Guide 微服务指南（翻译）"></a>Microservices Guide 微服务指南（翻译）</h2><p>链接：<a href="https://www.martinfowler.com/microservices/" target="_blank" rel="noopener">https://www.martinfowler.com/microservices/</a>  </p><blockquote><p>A guide to material on martinfowler.com about microservices.<br><strong>Matin Fowler</strong><br>21 Aug 2019  </p></blockquote><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">martinfowler.com网站关于微服务的一个材料指南</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">--------------------------------------------------------</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">有道词典翻译：</span></span><br><span class="line"><span class="keyword">martinfowler.com </span>上关于微服务的材料指南。</span><br></pre></td></tr></table></figure><h3 id="Microservices-Guide"><a href="#Microservices-Guide" class="headerlink" title="Microservices Guide"></a>Microservices Guide</h3><h4 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h4><blockquote><p>In short , the microservice architectural style is an approach to developing a single application as a <strong>suite of small services</strong> , each <strong>running in its own process</strong>  and communicating with lightweight mechanisms , often an HTTP resource API .<br>These services are <strong>built around business capabilities</strong> and <strong>independently deployable</strong> by fully automated deployment machinery .<br>There is a bare minimum of centralized management of these services , which may be written in different programming languages and use different data storage technologies .<br>– <strong>James Lewis</strong> and <strong>Martin Fowler</strong>（2014）  </p></blockquote><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">简而言之，</span><br><span class="line">微服务架构风格 是一种近似于 将一个单体应用程序作为一个小型服务套件来进行开发的风格，</span><br><span class="line">每一个小型服务都运行在它自身的进程当中，</span><br><span class="line">并且通过轻量级机制进行相互间的交流，</span><br><span class="line">通常是以一种超文本传输协议资源应用编程接口的方式进行交互。</span><br><span class="line">这些服务都是围绕业务逻辑来进行构建的并且通过全自动化部署机制来进行独立部署。</span><br><span class="line">最低限度的集中式管理着这些服务（这些服务的集中管理非常少），</span><br><span class="line">通过这种方式，</span><br><span class="line">或许可以使用不同的程序语言进行编写以及使用不同的数据存储技术。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------</span><br><span class="line"></span><br><span class="line">有道词典翻译：</span><br><span class="line"></span><br><span class="line">简而言之，</span><br><span class="line">微服务体系结构风格是一种将单个应用程序作为一组小服务进行开发的方法，</span><br><span class="line">每个小服务都在自己的进程中运行，并与轻量级机制<span class="params">(通常是HTTP资源API)</span>进行通信。</span><br><span class="line">这些服务是围绕业务功能构建的，</span><br><span class="line">并且可以通过完全自动化的部署机制独立部署。</span><br><span class="line">这些服务的集中管理非常少，</span><br><span class="line">它们可以用不同的编程语言编写，</span><br><span class="line">并使用不同的数据存储技术。</span><br><span class="line">——詹姆斯·刘易斯和马丁·福勒<span class="params">(<span class="number">2014</span>)</span></span><br></pre></td></tr></table></figure><h3 id="Introduce-Martin-Fowler"><a href="#Introduce-Martin-Fowler" class="headerlink" title="Introduce - Martin Fowler"></a>Introduce - Martin Fowler</h3><p>了解微服务之前首先来看看<strong>Martin Fowler</strong>老爷子的自我介绍；<br>Fowler刚被我打成了Flower；  </p><p>简介链接：<a href="https://www.martinfowler.com" target="_blank" rel="noopener">https://www.martinfowler.com</a>  </p><h4 id="Contents-1"><a href="#Contents-1" class="headerlink" title="Contents"></a>Contents</h4><blockquote><p>Software development is a young profession , and we are still learning the techniques and building the tools to do it effectively .<br>I’ve been involved in this activity for over three decades and in the last two I’ve been writing on this website about patterns and practives that make it easier to build userful software .<br>The site began as a place to put my own writing , but I also use it to publish articles by my colleagues .  </p></blockquote><blockquote><p>In 2000 , I joined ThoughtWorkds , where my role is to learn about the techniques that we’ve learned to deliver software for our clients , and pass these techniques on to the wider software industry .<br>As this site has developed into a respected platform on software development , I’ve edited and published articles by me colleagues , both ThoughtWorkers and others , to help useful writing reach a wider audience .  </p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">软件发展是一个年轻的专业技术，</span><br><span class="line">并且我们是仍然在学习这门技术 和 构建一些工具去有效的完成它。</span><br><span class="line">我已经参与到这一项活动（工作）当中已经超过三十年了，</span><br><span class="line">并且在最近两年内，</span><br><span class="line">我在这个网站站点上已经编写了关于如何更容易的去构建有用的软件的一些思想模式以及练习方法；</span><br><span class="line">这个站点开始时作为来存放我自己的一个写作的一个地方，</span><br><span class="line">但是我也使用这个地方来进行发布一些通过我同事们写的文章；</span><br><span class="line"></span><br><span class="line">在<span class="number">2000</span>年，我加入到了ThoughtWorks，</span><br><span class="line">在这个地方我扮演的角色是去学习这一项技术，</span><br><span class="line">我们已经学习到去为我们的客户实现软件，</span><br><span class="line">以及通过这些技术在更广阔的软件产业当中；</span><br><span class="line">这个站点已经逐渐发展成为一个受人尊敬的平台在软件发展史当中，</span><br><span class="line">我已经写了很多以及发布了很多我同事写的文章，同时还有ThoughtWorkers的员工以及其他人；</span><br><span class="line">来帮助有用的写作，即逐渐成为一个有深度的受众；x</span><br><span class="line"></span><br><span class="line">------------------------------------------------</span><br><span class="line"></span><br><span class="line">有道词典翻译：</span><br><span class="line">软件开发是一个年轻的职业，</span><br><span class="line">我们仍然在学习技术和构建工具来有效地完成它。</span><br><span class="line">我已经参与这项活动超过<span class="number">30</span>年了，</span><br><span class="line">在过去的两年中，</span><br><span class="line">我一直在这个网站上撰写关于使构建有用软件变得更容易的模式和实践的文章。</span><br><span class="line">这个网站一开始是一个放置我自己的文章的地方，</span><br><span class="line">但我也用它来发表我同事的文章。</span><br><span class="line"><span class="number">2000</span>年，我加入了ThoughtWorks，</span><br><span class="line">在这里，我的职责是学习我们为客户交付软件的技术，</span><br><span class="line">并将这些技术传递给更广泛的软件行业。</span><br><span class="line">随着这个网站发展成为一个受人尊敬的软件开发平台，</span><br><span class="line">我已经编辑并发表了我的同事们的文章，</span><br><span class="line">包括ThoughtWorkers和其他人，</span><br><span class="line">以帮助更广泛的读者阅读有用的文章。</span><br></pre></td></tr></table></figure><h3 id="A-website-on-building-software-effectively"><a href="#A-website-on-building-software-effectively" class="headerlink" title="A website on building software effectively"></a>A website on building software effectively</h3><p>A website on building software effectively</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在一个网站上有效地构建软件 x</span><br><span class="line">（<span class="keyword">on</span> building software effectively作定语）</span><br><span class="line"></span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line"></span><br><span class="line">一个有效开发软件的网站</span><br></pre></td></tr></table></figure><h4 id="Contents-2"><a href="#Contents-2" class="headerlink" title="Contents"></a>Contents</h4><blockquote><p>If there’s a theme that runs through my work and writing on this site , it’s the interplay between the shift towards agile thinking and the technical patterns and practices that make agile software development practical .<br>While specifics of technology change rapidly in our profession , fundamental practices and patterns are more stable .<br>So writing about these allows me to have articles on this site that are several years old but still as relevant as when they were written .  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>As software becomes more critical to modern business , software needs t be able to react quickly to changes ,  allowing new features to be be conceived , developed and put into production rapidly .<br>The techniques of <font style="color:red;font-weight:bolder">agile software development</font> began in the 1990s and became steadily more popular in the last decade .<br>The focus on a flexible approach to planning , which allows software products to change direction as the user’s needs change and as product managers learn more about how to make their users effective .<br>While widely accepted now , agile approaches are not easy , requiring significant skills for a team , but more importantly a culture of open collaboration both within the team and with a team’s partners .  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>This need to respond fluently to changes hash an important impact upon the <font style="color:red;font-weight:bolder">architecture</font> of a software system.<br>The software needs to be built in such a way that it is able to adapt to unexpected changes in features .<br>One of the most important ways to do this is to write clear code , making it easy to understant what the program is supposed to do .<br>This code should be devided into modules which allow developers to understand only the parts of the system they need to make a change .<br>This production code should be supported with automated tests that can detect any errors made when making a change while providing examples of how internal structures are used .<br>Large and complex software efforts may find the <font style="color:red;font-weight:bolder">microservices</font> architectural style helps teams deploy software with less entangling dependencies .  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Creating software that has a good architecture isn’t something that can be done first time .<br>Like good prose , it needs regular revisions and programmers learn more about what the product needs to do and how best to design the product to achieve its goals .<br><font style="color:red;font-weight:bolder">Refactoring</font> is an essential technique to allow a program to be changed safety .<br>It consists of making small changes that don’t alter the observable behavior of the software .<br>Bt combining lots of small changes , developers can revise the software’s structure supporting significant modifications that weren’t planned when the system was first conceived .  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Software that runs only on a developer’s machine isn’t providing value to the customers of the software .<br>Traditionally releasing software has been a long and complicated process , one that hinders the need to evolve software quickly .<br><font style="color:red;font-weight:bolder">Continuous Delivery</font> uses automation and collaborative workflows to remove this bottleneck , allowing teams to release software as often as the customers demand .<br>For Continuous Delivery to be possible , we need to build in a solid foundation of <font style="color:red;font-weight:bolder">Testing</font> , with a range of automated tests that can give us confidence taht our changes haven’t introduced any bugs .<br>This leads us to integrate testing into programming , which can act to improve our architectural .  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Photostream"><a href="#Photostream" class="headerlink" title="Photostream"></a>Photostream</h3><h3 id="Data-Management"><a href="#Data-Management" class="headerlink" title="Data Management"></a>Data Management</h3><h4 id="Contents-3"><a href="#Contents-3" class="headerlink" title="Contents"></a>Contents</h4><blockquote><p>There are many kinds of softeare out there , the kind I’m primarily engaged is Enterprise Applications .<br>One of the enduring problems we need to tackle in this world is <font style="color:red;font-weight:bolder">data management</font> .<br>The aspectes of data management I’ve focused on here are how to migrate data stores as their applications respond to changing needs , coping with different contexts across a large enterprice , the role of NoSQL databases , and the broader issues of coping with data that is both Big and Messy .  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Domain-Specific-Languages"><a href="#Domain-Specific-Languages" class="headerlink" title="Domain-Specific Languages"></a>Domain-Specific Languages</h3><h3 id="Contents-4"><a href="#Contents-4" class="headerlink" title="Contents"></a>Contents</h3><blockquote><p>A common problem in complex software systems is how to capture complicated domain logic in a way that programmers can both easily manipulate and also easily communicate to domain experts .<br><font style="color:red;font-weight:bolder">Domain-Specific Languages</font>(DSLs) create a custom language for a particular problem , either with custom parsers or by conventions within a host language .  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Books"><a href="#Books" class="headerlink" title="Books"></a>Books</h3><h4 id="Contents-5"><a href="#Contents-5" class="headerlink" title="Contents"></a>Contents</h4><blockquote><p>I’ve written seven books on software development , including Refactoring , Patterns of Enterprise Application Architectural , and UML Distilled .<br>I’m also the editor of a signature series for Addison-Wesley that includes five jolt award winners .<br><font style="color:red;font-weight:bolder">My Books Page…</font>  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Conference-Talks"><a href="#Conference-Talks" class="headerlink" title="Conference Talks"></a>Conference Talks</h3><h4 id="Contents-6"><a href="#Contents-6" class="headerlink" title="Contents"></a>Contents</h4><blockquote><p>I’m often asked to give talks at conferences , from which I’ve inferred that I’m a pretty good speaker - which is ironic since I really hate giving talks .<br>You can form your own opinion of my talks by watching videos of some my conference talks .<br><font style="color:red;font-weight:bolder"> My Videos Page…</font>  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Board-Games"><a href="#Board-Games" class="headerlink" title="Board Games"></a>Board Games</h3><h4 id="Contents-7"><a href="#Contents-7" class="headerlink" title="Contents"></a>Contents</h4><blockquote><p>I’ve long been a fan of board games , I enjoy a game that fully occupies my mind , clearing out all the serious thoughts for a bit , while enjoying the company of good friends .<br>Modern board games saw dramatic improvement in the 1990’s with the rise of Eurogames , and I expect many people would be surprised if they haven’t tried any of this new generation .<br>I also appear regularly on <font style="color:red;font-weight:bolder">Heavy Cardboard</font> .<br><font style="color:red;font-weight:bolder">My Board Games page…</font>  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Nothing better than a buzy Saturday morning.&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
    
      <category term="面试" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="微服务" scheme="https://fengshana.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot知识点</title>
    <link href="https://fengshana.github.io/2020/05/10/%E9%9D%A2%E8%AF%95/SpringBoot/"/>
    <id>https://fengshana.github.io/2020/05/10/%E9%9D%A2%E8%AF%95/SpringBoot/</id>
    <published>2020-05-10T03:36:35.908Z</published>
    <updated>2020-05-11T10:51:31.324Z</updated>
    
    <content type="html"><![CDATA[<p>观看笔记：<a href="https://www.bilibili.com/video/BV1Eg4y187XT" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Eg4y187XT</a>  </p><h2 id="学习方法谈心"><a href="#学习方法谈心" class="headerlink" title="学习方法谈心"></a>学习方法谈心</h2><p>SpringBoot与SpringCloud这两个框架，说框架有点小，特别是SpringCloud整个的体系是非常庞大的；可以认为是一整套技术栈或者是说生态圈。</p><p>方法论；宏观意义上去了解；从问题的本源来进行剖析；有问题就去查官方文档；但是对于SpringCloud来说，官方文档就过于庞杂了；效果并不是特别的好。<br>一种好的学习方式：针对性的去学习。<br>像SpringCloud，每次去学习其当中的一个子项目的时候，则需要带着问题，带着心中的疑虑这样子去学习，就属于一种比较好的一种学习方式。  </p><p>在学习框架式，如何很好的切入进去，挖掘出来，形成自己的一整套技术体系：从宏观/方法论的层面上来讲：<br>前端框架更迭快。<br>如何保持自己的竞争力（持续的保持自己的竞争力）这是每一个开发人员都需要面临的问题。<br>职业追求奋斗目标；心中需要有一种紧迫感；对自己所从事的技术领域需要有一个很好的把握和理解。那么这个很好的把握和理解体现在什么地方呢？<br>首先对于使用的编程语言应当比较熟练的程度。第二，对于你所觉得重要的框架，一定要达到一种原理级别的理解和把控。这一点十分重要。<br>写了很多代码，也做了很多的项目，但是就是觉得自己的技术没有能得到提高，明显的长进，就感觉自己在原地踏步日复一日年复一年的工作而已。<br>反映出来了一个问题：在工作当中，工作技能对于自己的技能要求其实并没有那么高；对于中国大部分公司来说都不是纯技术公司；<br>纯技术公司指的是：其技术就是自己公司的一个成品；最典型的例子，比如说TiDBit（这是一个新型的国产数据库），类似于这些厂商它们的成品其实就是技术，它们的技术就是它们的成品。在这种情况下，其技术就是其核心竞争力核心生产力。<br>但是对于其他很多的互联网公司来说，却不是这样的情况，因为有其成品，有其自己的商业模式，而技术是为了实现这个成品，实现这个商业模式而必须要有的一种手段；换句话来说，在这样的互联网公司下，技术并不是其最为核心最为重要的一种生产力。但是技术又不可或缺，这是绝大互联网公司所面临的一个问题。<br>在工作当中，一方面很好的完成工作，另一方面能在日复一日的工作当中提高自己的水准，不断的提高自己；其实这是摆在每一个人面前很重要且离不开的话题。<br>在这样的情况下，作为一名软件从业者该如何去提升自己？<br>首先，一定要具备有的认识：在工作当中用技术去完成每一天自己工作当中的任务，这是本职工作需要自己去完成的；这毫无疑问；公司赋予自己薪水，而自己为了这份薪水去完成这些自己的本职工作，付诸自己的劳动力，把相应的工作去完成，这是自己应该去做的事情。<br>公司付给自己工资，而自己很好的完成这份本职工作；这样是远远不够的；而且会差距越来越大；<br>首先，现在的软件从业者越来越多；如何能够从这么多的软件从业者当中形成自己的核心竞争力从而脱颖而出呢？其实这是很考验一个人的内力以及一个人其认知水平和思维水准的这样一件事情。</p><p>掌握最为底层后者是一些核心的技能；最立竿见影的方式；<br>第二这也是能让自己以后在学习新的技术时能够越来越快；越来越扎实的一个必要的<br>保证；归根结底还是那句话；要掌握底层掌握原理性的东西；<br>日常做项目，换句话又叫做赶项目；因为项目有个截止日期。<br>在时间很紧迫的情况下，其实每天的工作就是在赶这个项目而已；每天也只是完成了这个功能而已。很多的时候其实自己并不能理解自己所写的每一行代码的原理是什么？为什么要这样子去写，其底层发生了什么的事情，产生了一种啥样的调用关系。光去做项目是远远不够的；<br>做项目是学习框架一种最为行之有效的一种手段；<br>那对于这种结论，但是对于这点还是远远不够，还会差很多。在做项目的过程中，关注点在于如何能够在短期内将项目做完做好；另外一个关注点，如何将项目当中使用到的框架理解的深入且扎实。这其实是在项目之外所需要思考的事情。<br>需要提高自己的认知；并不是做完项目了代表一切都完结了；</p><p>如何让自己的技术处于一种高位的一个这样的状态：掌握原理性的东西，必须要掌握底层的一些内容，这样才能够让自己立于不败之地。</p><p>面试的时候往往会问一些比较基础原理性的内容；这些内容可能用过，但是却投入很少的时间去思考他。所以就有了需要面试去花时间准备的缘故。</p><h2 id="Spring-Boot与Cloud整体介绍"><a href="#Spring-Boot与Cloud整体介绍" class="headerlink" title="Spring Boot与Cloud整体介绍"></a>Spring Boot与Cloud整体介绍</h2><h2 id="课程大纲深入解读与剖析"><a href="#课程大纲深入解读与剖析" class="headerlink" title="课程大纲深入解读与剖析"></a>课程大纲深入解读与剖析</h2><h2 id="微服务重要概念与权威解读"><a href="#微服务重要概念与权威解读" class="headerlink" title="微服务重要概念与权威解读"></a>微服务重要概念与权威解读</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;观看笔记：&lt;a href=&quot;https://www.bilibili.com/video/BV1Eg4y187XT&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/BV1Eg4y187XT&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="面试" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="SpringBoot" scheme="https://fengshana.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM虚拟机</title>
    <link href="https://fengshana.github.io/2020/05/09/%E9%9D%A2%E8%AF%95/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://fengshana.github.io/2020/05/09/%E9%9D%A2%E8%AF%95/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2020-05-09T14:44:24.559Z</published>
    <updated>2020-05-09T16:36:14.058Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>观看笔记</p></blockquote><p><a href="https://www.bilibili.com/video/BV1qE411Y7FQ?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1qE411Y7FQ?p=1</a>  </p><h2 id="学习方法论与高效学习方式演进"><a href="#学习方法论与高效学习方式演进" class="headerlink" title="学习方法论与高效学习方式演进"></a>学习方法论与高效学习方式演进</h2><p>JVM：Java virtual Machine  </p><ul><li>从人去学习</li><li>从事务去学习</li></ul><p>懂得很多道理，却依然过不好这一生。《后会无期》  </p><p>持久化：最终落到一个存储上面。有输入InputStream一定要有输出OutputStream；  </p><p>刻意联系。  </p><h2 id="JVM学习曲线与疑难点剖析"><a href="#JVM学习曲线与疑难点剖析" class="headerlink" title="JVM学习曲线与疑难点剖析"></a>JVM学习曲线与疑难点剖析</h2><p>应用框架：Spring、Spring Boot、Spring Cloud、Dubbo etc.  </p><p>JVM：枯燥，理论。  </p><p>基于java8；讲解；  </p><p>抱有敬畏的心态学习JVM。  </p><p>任重而道远；  </p><h2 id="深入理解JVM课程大纲分析与工具使用"><a href="#深入理解JVM课程大纲分析与工具使用" class="headerlink" title="深入理解JVM课程大纲分析与工具使用"></a>深入理解JVM课程大纲分析与工具使用</h2><h2 id="类加载器深入解析与阶段分析"><a href="#类加载器深入解析与阶段分析" class="headerlink" title="类加载器深入解析与阶段分析"></a>类加载器深入解析与阶段分析</h2><h2 id="类的加载连接与初始化过程详解"><a href="#类的加载连接与初始化过程详解" class="headerlink" title="类的加载连接与初始化过程详解"></a>类的加载连接与初始化过程详解</h2><h2 id="常量的本质含义与反编译及助记符详解"><a href="#常量的本质含义与反编译及助记符详解" class="headerlink" title="常量的本质含义与反编译及助记符详解"></a>常量的本质含义与反编译及助记符详解</h2><h2 id="编译器常量与运行期常量的区别以及数组创建本质分析"><a href="#编译器常量与运行期常量的区别以及数组创建本质分析" class="headerlink" title="编译器常量与运行期常量的区别以及数组创建本质分析"></a>编译器常量与运行期常量的区别以及数组创建本质分析</h2><h2 id="接口初始化规则与类加载器准备节点和初始化阶段的重要意义"><a href="#接口初始化规则与类加载器准备节点和初始化阶段的重要意义" class="headerlink" title="接口初始化规则与类加载器准备节点和初始化阶段的重要意义"></a>接口初始化规则与类加载器准备节点和初始化阶段的重要意义</h2><h2 id="类加载器深入解析以及重要特性剖析"><a href="#类加载器深入解析以及重要特性剖析" class="headerlink" title="类加载器深入解析以及重要特性剖析"></a>类加载器深入解析以及重要特性剖析</h2><h2 id="初始化对于类与接口的异同点深入解析"><a href="#初始化对于类与接口的异同点深入解析" class="headerlink" title="初始化对于类与接口的异同点深入解析"></a>初始化对于类与接口的异同点深入解析</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;观看笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1qE411Y7FQ?p=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://w
      
    
    </summary>
    
    
      <category term="面试" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="JVM虚拟机" scheme="https://fengshana.github.io/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Shopping for a TV</title>
    <link href="https://fengshana.github.io/2020/05/09/%E8%8B%B1%E8%AF%AD/lesson4/"/>
    <id>https://fengshana.github.io/2020/05/09/%E8%8B%B1%E8%AF%AD/lesson4/</id>
    <published>2020-05-09T12:35:35.381Z</published>
    <updated>2020-05-09T14:13:58.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Learn-amp-Talk-I"><a href="#Learn-amp-Talk-I" class="headerlink" title="Learn &amp; Talk I"></a>Learn &amp; Talk I</h2><h3 id="Chapter-1-Shopping"><a href="#Chapter-1-Shopping" class="headerlink" title="Chapter 1 Shopping"></a>Chapter 1 Shopping</h3><h4 id="Lesson-4-Shopping-for-a-TV"><a href="#Lesson-4-Shopping-for-a-TV" class="headerlink" title="Lesson 4 Shopping for a TV"></a>Lesson 4 Shopping for a TV</h4><blockquote><p>at the bottom of the following pages:T1=teaching instructions;T=teacher;S=student</p></blockquote><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ul><li><p>part <big>A</big>. Let’s Learn (12 mins)</p></li><li><p>part <big>B</big>. Let’s Talk (12 mins)</p></li><li><p>part <big>C</big>. Review (1 min)</p></li></ul><blockquote><p>Learning Objectives</p></blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">学习目标：</span><br><span class="line"><span class="number">4</span> <span class="built_in">words</span> <span class="keyword">about</span> <span class="string">"shopping for a TV"</span> | <span class="number">4</span>个和<span class="string">"买电视"</span>相关的单词</span><br><span class="line">Expressions <span class="keyword">for</span> <span class="string">"shopping for a TV"</span> | <span class="string">"买电视"</span>常用表达</span><br><span class="line">How <span class="keyword">to</span> talk <span class="keyword">about</span> topics related <span class="keyword">to</span> <span class="string">"shopping for a TV"</span> | 谈论和<span class="string">"买电视"</span>相关的话题</span><br></pre></td></tr></table></figure><h2 id="part-A-Let’s-Learn"><a href="#part-A-Let’s-Learn" class="headerlink" title="part A. Let’s Learn"></a>part A. Let’s Learn</h2><h3 id="Vocabulary-4-mins"><a href="#Vocabulary-4-mins" class="headerlink" title="Vocabulary (4 mins)"></a>Vocabulary (4 mins)</h3><table>  <tr>    <td style="font-weight:bolder;color:red;">warranty</td>    <td>a written promise from a company to repair or replace a product that develops a fault within a particular period of time</td>    <td>保修单，保修卡，保修服务</td>    <td>e.g. The TV has a 3-year <span style="font-weight:bolder;color:red;text-decoration:underline;">warranty</span>.</td>    <td></td>  </tr>   <tr>    <td style="font-weight:bolder;color:red;">best-seller</td>    <td>a new bool or other product that has sold a great number of copies.</td>    <td>热卖品，畅销品</td>    <td>e.g. As a writer, he wants to write a <span style="font-weight:bolder;color:red;text-decoration:underline;">best-seller</span>.</td>    <td></td>  </tr>     <tr>    <td style="font-weight:bolder;color:red;">offer</td>    <td>to provide or supply something.</td>    <td>提供</td>    <td>e.g. He <span style="font-weight:bolder;color:red;text-decoration:underline;">offered</span> me a glass of water.</td>    <td></td>  </tr>     <tr>    <td style="font-weight:bolder;color:red;">delivery</td>    <td>the act of taking goods,letters,parcels,etc. to people's houses or places of work</td>    <td>运送，递送</td>    <td>e.g. They offer free <span style="font-weight:bolder;color:red;text-decoration:underline;">delivery,</span> so it's a good deal.</td>    <td>deliver(v.) The letter was delivered yesterday,</td>  </tr></table><h3 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h3><h4 id="Role-play-the-dialog-with-your-teacher-twice-and-learn-the-highlighted-expressions-by-heart-和老师一起分角色朗读两遍一下对话。熟记标亮部分的短语和表达"><a href="#Role-play-the-dialog-with-your-teacher-twice-and-learn-the-highlighted-expressions-by-heart-和老师一起分角色朗读两遍一下对话。熟记标亮部分的短语和表达" class="headerlink" title="Role-play the dialog with your teacher twice,and learn the highlighted expressions by heart.和老师一起分角色朗读两遍一下对话。熟记标亮部分的短语和表达"></a>Role-play the dialog with your teacher twice,and learn the highlighted expressions by heart.和老师一起分角色朗读两遍一下对话。熟记标亮部分的短语和表达</h4><p>（John and Anne are shopping for a TV.）  </p><p><strong><em>Anne:</em></strong> How about this one?<br><strong><em>John:</em></strong> I like this brand ,and the price isn’t too high.<br>（They start to ask the salesperson for information.）<br><strong><em>John:</em></strong> <span style="background-color:yellow;font-weight:bolder;">How long is the warranty for this TV?</span><br><strong><em>Salesperson:</em></strong> It comes with a 2-year parts(零件)<span style="background-color:yellow;font-weight:bolder;">warranty</span>. It’s also the <span style="background-color:yellow;font-weight:bolder;">best-seller</span> now.<br><strong><em>Anne:</em></strong> <span style="background-color:yellow;font-weight:bolder;">Do you offer free delivery?</span><br><strong><em>Anne:</em></strong> Yes, we do.</p><h2 id="part-B-Let’s-Talk"><a href="#part-B-Let’s-Talk" class="headerlink" title="part B. Let’s Talk"></a>part B. Let’s Talk</h2><h3 id="Conversation"><a href="#Conversation" class="headerlink" title="Conversation"></a>Conversation</h3><h4 id="Suppose-you’re-shopping-for-appliances-Use-th-vocabulary-and-expressions-you’ve-learned-in-part-A-to-complete-the-following-conversation-假设你正在选购电器。运用在第一部分学到的词汇和表达将一下情境对话补充完整"><a href="#Suppose-you’re-shopping-for-appliances-Use-th-vocabulary-and-expressions-you’ve-learned-in-part-A-to-complete-the-following-conversation-假设你正在选购电器。运用在第一部分学到的词汇和表达将一下情境对话补充完整" class="headerlink" title="Suppose you’re shopping for appliances. Use th vocabulary and expressions you’ve learned in part A to complete the following conversation. 假设你正在选购电器。运用在第一部分学到的词汇和表达将一下情境对话补充完整"></a>Suppose you’re shopping for appliances. Use th vocabulary and expressions you’ve learned in part A to complete the following conversation. 假设你正在选购电器。运用在第一部分学到的词汇和表达将一下情境对话补充完整</h4><blockquote><p>Hints<br><strong><em>delivery</em></strong><br><strong><em>warranty</em></strong><br><strong><em>How long is the warranty for …?</em></strong><br><strong><em>best-seller</em></strong><br><strong><em>offer</em></strong></p></blockquote><p><strong><em>A:</em></strong> Excuse me. <span style="text-decoration:underline;">How along is warranty for</span> this air conditioner(空调) ?<br><strong><em>B:</em></strong> Three years. It’s the <span style="text-decoration:underline;">best-seller</span> now. We also <span style="text-decoration:underline;">offer</span> free <span style="text-decoration:underline;">delivery</span>.<br><strong><em>A:</em></strong> But there’s an air conditioner of this brand in the living room of my house,and it doesn’t work very well recently.<br><strong><em>B:</em></strong> We’ll <span style="text-decoration:underline;">offer</span> free repair(维修) if it’s still under <span style="text-decoration:underline;">warranty</span>.<br><strong><em>A:</em></strong> Fine.</p><h3 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h3><h4 id="Talk-with-your-teacher-about-the-following-question-Refer-to-the-hints-if-necessary-和老师一起讨论一下问题。可以参考方框中的提示"><a href="#Talk-with-your-teacher-about-the-following-question-Refer-to-the-hints-if-necessary-和老师一起讨论一下问题。可以参考方框中的提示" class="headerlink" title="Talk with your teacher about the following question. Refer to the hints if necessary.和老师一起讨论一下问题。可以参考方框中的提示"></a>Talk with your teacher about the following question. Refer to the hints if necessary.和老师一起讨论一下问题。可以参考方框中的提示</h4><ol><li>How often do you watch TV? When do you usually watch TV?</li></ol><blockquote><p>Hints:</p></blockquote><p><strong><em>every day / usually / from time to time(偶尔) / never …</em></strong><br><strong><em>in the evening(morning ,afternoon) / at the noon / on weekends …</em></strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I often watch TV <span class="keyword">is</span> irregularly scheduled.  </span><br><span class="line">recently, because I watch TV <span class="keyword">with</span> <span class="keyword">my</span> friends when <span class="keyword">my</span> friends <span class="keyword">after</span> their works,we will eat dinner <span class="keyword">and</span> watch TV <span class="keyword">at</span> <span class="keyword">the</span> evening.</span><br><span class="line">I usually watch TV <span class="keyword">at</span> <span class="keyword">the</span> evening <span class="keyword">with</span> <span class="keyword">my</span> friends.</span><br><span class="line">when i am alone,i don't want <span class="keyword">to</span> watch TV.</span><br><span class="line">maybe ,when only myself,i think <span class="keyword">that</span> watching TV don't bring <span class="keyword">me</span> <span class="keyword">some</span> original happy.</span><br><span class="line">i think <span class="keyword">that</span> watching TV <span class="keyword">is</span> seeing <span class="keyword">some</span> famous actors <span class="keyword">and</span> <span class="keyword">some</span> humorous actors acts happy shows.</span><br><span class="line">so i am <span class="keyword">not</span> <span class="keyword">every</span> <span class="built_in">day</span>  <span class="keyword">or</span> usually <span class="keyword">or</span> <span class="keyword">from</span> <span class="built_in">time</span> <span class="keyword">to</span> <span class="built_in">time</span> <span class="keyword">or</span> never ,no ,also ,i am <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">the</span> evening ,<span class="keyword">in</span> <span class="keyword">the</span> morning <span class="keyword">or</span> <span class="keyword">in</span> <span class="keyword">the</span> afternoon,<span class="keyword">or</span> <span class="keyword">on</span> weekends, <span class="keyword">and</span> so <span class="keyword">on</span>.</span><br><span class="line">long long ago ,when i was a child,</span><br><span class="line">i like watching TV.</span><br><span class="line">may be ,<span class="keyword">at</span> <span class="keyword">the</span> childhood,<span class="keyword">in</span> <span class="keyword">the</span> tv <span class="keyword">that</span>'s world, have many imagine <span class="keyword">and</span> interesting something <span class="keyword">or</span> someone fascinated <span class="keyword">my</span> eyes.</span><br></pre></td></tr></table></figure><ol start="2"><li>What kind of TV programs(节目) do you like ? Why?</li></ol><blockquote><p>Hints:</p></blockquote><p><strong><em>news -&gt; learn what’s happening around the world …</em></strong><br><strong><em>talk shows(访谈节目) -&gt; know more about the life of famous people …</em></strong><br><strong><em>variety shows (综艺节目) -&gt; funny,interesting ,relaxing(令人放松的)  …</em></strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i like variety shows, <span class="keyword">because </span><span class="keyword">it's </span>funny ,interesting <span class="keyword">and </span>relaxing.</span><br></pre></td></tr></table></figure><ol start="3"><li>What will you consider(考虑) when buying an appliance(电器)？</li></ol><blockquote><p>Hints:</p></blockquote><p><strong><em>brands (what brands?) / prices (how much?) / warranty(how long?) 、 delivery (free or not?) ….</em></strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i have <span class="keyword">not</span> enough money.</span><br><span class="line">due <span class="keyword">to</span> i have <span class="keyword">not</span> work.</span><br><span class="line">recently,i interviews four <span class="keyword">times</span>.</span><br><span class="line">when <span class="keyword">the</span> interviews process ending, i feel <span class="keyword">my</span> heart <span class="keyword">as</span> <span class="keyword">if</span> <span class="keyword">it</span> <span class="keyword">is</span> slowly sinking.</span><br><span class="line">even though,i look like a child, <span class="keyword">but</span> now,i am <span class="number">21</span> years old.</span><br><span class="line">i work <span class="keyword">from</span> programing. <span class="keyword">in</span> short programing <span class="keyword">is</span> <span class="keyword">it</span>.</span><br><span class="line">so ,<span class="keyword">in</span> <span class="keyword">the</span> short term ,i will <span class="keyword">not</span> consider buy <span class="keyword">some</span> expensive appliance.</span><br><span class="line">except <span class="keyword">for</span> example, a small oscillating fan ,because ,<span class="keyword">the</span> season <span class="keyword">is</span> summer,<span class="keyword">the</span> <span class="built_in">day</span> <span class="keyword">and</span> <span class="keyword">the</span> evening <span class="keyword">is</span> hot. when i have a small oscillating,i feel <span class="keyword">my</span> hand ,foot,hair,leg <span class="keyword">and</span> so <span class="keyword">on</span>,<span class="keyword">is</span> ,emm,<span class="keyword">as</span> <span class="keyword">if</span> a fish live <span class="keyword">the</span> water,especially,when <span class="keyword">after</span> bath shower <span class="keyword">and</span> wash <span class="keyword">my</span> clothes <span class="keyword">and</span> open <span class="keyword">my</span> small oscillating fan,<span class="keyword">the</span> oscillating fan bring <span class="keyword">me</span> <span class="keyword">is</span> this feeling.</span><br></pre></td></tr></table></figure><p>In this lesson,you’ve learned</p><ol start="4"><li>words about “buying appliances”</li></ol><blockquote><p>warranty<br>best-seller<br>offer<br>delivery</p></blockquote><ul><li>commonly used expressions for buying appliances</li></ul><blockquote><p>How long is the warranty for this TV?<br>Do you offer free delivery?</p></blockquote><ul><li>how to talk about TV and other appliances</li></ul><h2 id="Further-Study"><a href="#Further-Study" class="headerlink" title="Further Study"></a>Further Study</h2><h3 id="Listen-and-Learn"><a href="#Listen-and-Learn" class="headerlink" title="Listen and Learn"></a>Listen and Learn</h3><blockquote><p>range hood 抽油烟机<br>electric oven 电烤箱<br>dishwasher 洗碗机</p></blockquote><ul><li>The soybean milk machine(豆浆机)/ juicer(果汁机) has excellent features such as low cost, complete function,convenient to use and so on.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Learn-amp-Talk-I&quot;&gt;&lt;a href=&quot;#Learn-amp-Talk-I&quot; class=&quot;headerlink&quot; title=&quot;Learn &amp;amp; Talk I&quot;&gt;&lt;/a&gt;Learn &amp;amp; Talk I&lt;/h2&gt;&lt;h3 id=&quot;Chapt
      
    
    </summary>
    
    
      <category term="英语" scheme="https://fengshana.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="英语" scheme="https://fengshana.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized和ReentrantLock</title>
    <link href="https://fengshana.github.io/2020/05/06/%E9%9D%A2%E8%AF%95/Synchronized%E5%92%8CReentrantLock/"/>
    <id>https://fengshana.github.io/2020/05/06/%E9%9D%A2%E8%AF%95/Synchronized%E5%92%8CReentrantLock/</id>
    <published>2020-05-06T15:47:22.985Z</published>
    <updated>2020-05-06T17:25:51.822Z</updated>
    
    <content type="html"><![CDATA[<p>观看笔记: <a href="https://www.bilibili.com/video/BV1dE411r7iy?from=search&amp;seid=2860602863323633916" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1dE411r7iy?from=search&amp;seid=2860602863323633916</a>  </p><p>java当中的锁，比如说ReentrantLock，还有Synchronized关键字；  </p><p>重点：sync(synchronized关键字原理)  </p><p>java体系最难的技术点之一：sync；（涉及到JVM，C++源码等）  </p><ul><li>java的对象布局</li><li>sync底层工作的原理</li><li>sync优化原理</li><li>学习方法-学习的深度</li></ul><h2 id="java头的信息分析"><a href="#java头的信息分析" class="headerlink" title="java头的信息分析"></a>java头的信息分析</h2><p><font style="color:orange;font-weight:bold;">首先为什么要去研究java的对象头？</font>  </p><p><font style="color:orange;font-weight:bold;">这里截取一张Hotspot的源码当中的注释</font></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> 64 bits;</span><br><span class="line"><span class="string">//</span> <span class="params">--------</span></span><br><span class="line"><span class="string">//</span> unused: 25 hash<span class="function">:31</span> <span class="params">---</span>&gt;| unused<span class="function">:1</span>   age<span class="function">:4</span>   biased_lock<span class="function">:1</span> lock<span class="function">:2</span> <span class="params">(normal object)</span></span><br><span class="line"><span class="string">//JavaThread</span>*<span class="function">:54</span> epoch<span class="function">:2</span> unused<span class="function">:1</span> age<span class="function">:4</span> biased_lock<span class="function">:1</span> lock<span class="function">:2</span> <span class="params">(biased object)</span></span><br><span class="line"><span class="string">//</span> PromotedObject*<span class="function">:61</span> <span class="params">-----------------</span>&gt;| promo_bits<span class="function">:3</span> <span class="params">-----</span>&gt; <span class="params">(CMS promoted object)</span></span><br><span class="line"><span class="string">.//</span> size<span class="function">:64-------------------------------------------------</span>&gt;| <span class="params">(CMS free block)</span></span><br><span class="line"><span class="string">//</span></span><br></pre></td></tr></table></figure><p>这张图换成人可读的表格如下：  </p><table>    <tr>        <td colspan="3">Object Header(128 bits)</td>    </tr>    <tr>        <td>Mark Word(64 bits)</td>        <td>Klass Word(64 bits)</td>        <td></td>    </tr>        <tr>        <td>unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 </td>        <td>OOP to metadata object</td>        <td style="color:red;font-weight:bolder;">无锁</td>    </tr>    <tr>        <td>thread:54 |       epoch:2        | unused:1 | age:4 | biased_lock:1 | lock:2 </td>        <td>OOP to metadata object</td>        <td style="color:red;font-weight:bolder;">偏向锁</td>    </tr>      <tr>        <td>ptr_to_lock_record:62                                                    | lock:2 </td>        <td>OOP to metadata object</td>        <td style="color:red;font-weight:bolder;">轻量锁</td>    </tr>    <tr>        <td>ptr_to_heavyweight_monitor:62                                                    | lock:2 </td>        <td>OOP to metadata object</td>        <td style="color:red;font-weight:bolder;">重量锁</td>    </tr>    <tr>        <td>                                                    | lock:2 </td>        <td>OOP to metadata object</td>        <td style="color:red;font-weight:bolder;">gc</td>    </tr></table><p>意思是：<font style="color:orange;font-weight:bold;">java的对象头在对象的不同状态下会有不同的表现形式。</font>  </p><p>主要有三种状态：<br><font style="color:orange;font-weight:bold;">无锁状态、加锁状态、gc标记状态。</font>  </p><p>那么可以理解 <font style="color:orange;font-weight:bold;">java当中的取锁</font>  其实可以理解为是：<font style="color:orange;font-weight:bold;">给对象上锁，也就是改变对象头的状态。</font>  </p><p><font style="color:orange;font-weight:bold;">如果上锁成功则进入同步代码块。</font>  </p><p>但是java当中的锁有分为很多种，从上图可以看出大体分为：<font style="color:orange;font-weight:bold;">偏向锁、轻量锁、重量锁</font>三种锁状态。  </p><p><font style="color:orange;font-weight:bold;">这三种锁的效率完全不同。</font>  </p><p>关于效率的分析会在下文分析，只有合理的设计代码，才能合理的利用锁</p><p>那么这三种锁的原理是什么？所以，需要先研究这个 <font style="color:orange;font-weight:bold;">对象头</font>  </p><h2 id="java对象的布局以及对象头的布局"><a href="#java对象的布局以及对象头的布局" class="headerlink" title="java对象的布局以及对象头的布局"></a>java对象的布局以及对象头的布局</h2><ol><li><strong>JOL来分析java的对象布局</strong></li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        lockTest();<span class="comment">//问题：现在当前想要对该lockTest方法做同步处理</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设此时lockTest存在线程安全问题；如何用最简单的方式来进行处理lockTest方法的同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lockTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"xxxx"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理方式一：（加synchronized关键字）  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="title">com.lock;</span></span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line"></span><br><span class="line">    static L l=<span class="keyword">new</span> L();//为lock新建的专门的一个类；由于lockTest方法是静态的；该静态方法当中需要使用到该l 对象，所以将其置为static</span><br><span class="line"></span><br><span class="line">    static ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        lockTest();//问题：现在当前想要对该lockTest方法做同步处理</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //假设此时lockTest存在线程安全同步问题；如何处理</span><br><span class="line">    public static void lockTest()&#123;</span><br><span class="line">        //<span class="keyword">synchronized</span>()当中需要一个对象；可以传很多；</span><br><span class="line">        //比如说在非静态方法当中可以传this；</span><br><span class="line">        //如果是静态方法则可以传Test.class；也可以进行对对象加锁；</span><br><span class="line">        //更多的时候是建一个专门用来的lock类L,传入该类的对象l，给该l上锁；</span><br><span class="line">        //valatile不能实现同步；valatile只能用来保证访问时的可见性以及不乱去执行，与同步没有很大的关系；</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">        java 并发编程入门级别的问题：  </span><br><span class="line">        <span class="number">1</span>. java当中有哪些锁？</span><br><span class="line">        <span class="number">2</span>. <span class="keyword">synchronized</span>(l)&#123;System.<span class="keyword">out</span>.println(<span class="string">"xxxx"</span>);&#125; 当前该代码锁的是什么？锁的是代码块？还是锁l对象？</span><br><span class="line"></span><br><span class="line">        java当中的锁：比如说公平锁、非公平锁、读写锁、共享锁、互斥锁、自旋锁、偏向锁、轻量级锁、重量级锁....</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(l)&#123;System.<span class="keyword">out</span>.println(<span class="string">"xxxx"</span>);&#125; 这段代码本质上的语义是什么?<span class="keyword">synchronized</span>关键字锁住的是代码块还是l该对象？<span class="keyword">synchronized</span>此时锁的是该l 对象；</span><br><span class="line">        给该l 对象进行上锁；</span><br><span class="line">        该<span class="keyword">synchronized</span>是如何给该 l 对象进行上锁的？</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">        reentrantLock与<span class="keyword">synchronized</span>都是锁，但是这两把锁是有区别的；</span><br><span class="line">        <span class="keyword">synchronized</span>是java的内置锁；</span><br><span class="line">        而reentrantLock是JUC并发包下提供的锁；</span><br><span class="line">        这两个锁都能完成同样的功能：让锁之间的代码块进行同步执行，只有一个线程去访问；</span><br><span class="line">        当前问题在于：如果采用ReentrantLock调用lock()方法的时候，很容易理解为：就是给这个<span class="keyword">new</span>出来的reentrantLock对象去上锁；</span><br><span class="line">        那么从代码当中如何来理解呢？</span><br><span class="line">        因为在reentrantLock这个对象当中，有一个变量:</span><br><span class="line">        public void lock()&#123;</span><br><span class="line">            sync.lock();</span><br><span class="line">            /**</span><br><span class="line">            sync.lock();<span class="comment">--&gt;</span></span><br><span class="line">            <span class="keyword">abstract</span> static class Sync extends AbstractQueueSynchronizer&#123;</span><br><span class="line">                <span class="keyword">abstract</span> void lock();</span><br><span class="line">            &#125;<span class="comment">---&gt;</span></span><br><span class="line">            static final class FairSync extends Sync&#123;</span><br><span class="line">                final void lock()&#123;</span><br><span class="line">                    acquire(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">-----&gt;</span></span><br><span class="line">            public final void acquire(int arg)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!tryAcquire(arg)&amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE),arg))</span><br><span class="line">                selfInterrupt();</span><br><span class="line">            &#125;<span class="comment">----&gt;</span></span><br><span class="line">            //<span class="keyword">protected</span> boolean tryAcquire(int arg)&#123;</span><br><span class="line">            //    throw <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            //&#125;</span><br><span class="line">            <span class="keyword">protected</span> final boolean tryAcquire(int acquires)&#123;</span><br><span class="line">                final Thread current = Thread.currentThread();</span><br><span class="line">                int c = getState();</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                        //compareAndSetState CAS操作</span><br><span class="line">                        //即将getState()<span class="comment">---&gt;private volatile int state;当中的state变量，如果取值为0则改为1；</span></span><br><span class="line">                        compareAndSetState(<span class="number">0</span>,acquires))&#123;</span><br><span class="line">                            setExclusiveOwnerThread(current);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(current == getExclusiveOwnerThread())&#123;</span><br><span class="line">                    int nextc = c+ acquires;</span><br><span class="line">                    <span class="keyword">if</span>(nextc &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        throw <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                    setState(nextc);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            */</span><br><span class="line">        &#125;</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">        //整个reentrantLock代码reentrantLock.lock()该行代码的本质意义即为去改变reentrantLock对象当中的一个属性叫做state；将其改成<span class="number">1</span>；如果能够修改属性取值为<span class="number">1</span>成功说明上锁成功；如果没有修改属性取值为<span class="number">1</span>成功则上锁失败</span><br><span class="line">        //所以说给该对象reentrantLock加锁，那么该对象reentrantLock当中就需要有一个标识，标识存在的含义即是否加锁成功；</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"zzzzzz"</span>);</span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(l)&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"xxxx"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;观看笔记: &lt;a href=&quot;https://www.bilibili.com/video/BV1dE411r7iy?from=search&amp;amp;seid=2860602863323633916&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https
      
    
    </summary>
    
    
      <category term="面试" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="锁" scheme="https://fengshana.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>全面深入讲解MySQL数据库优化</title>
    <link href="https://fengshana.github.io/2020/04/24/%E9%9D%A2%E8%AF%95/%E5%85%A8%E9%9D%A2%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    <id>https://fengshana.github.io/2020/04/24/%E9%9D%A2%E8%AF%95/%E5%85%A8%E9%9D%A2%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</id>
    <published>2020-04-24T02:40:04.420Z</published>
    <updated>2020-05-06T10:18:48.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：<a href="https://www.bilibili.com/video/BV1fJ41127Rj?from=search&amp;seid=13531213796559959972" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1fJ41127Rj?from=search&amp;seid=13531213796559959972</a>  </p><p>本课程作为MySQL高级课程，主要讲解了：  </p><ul><li>MySQL中的视图/存储过程/触发器/索引等对象的使用</li><li>常见的SQL语句优化的技巧</li><li>应用优化</li><li>数据库优化</li><li>数据库日志</li></ul><p>等方面的知识，并通过综合案例，对课程中的知识进行一个整合应用。  </p><p>本课程旨在通过MySQl高级部分内容，可以在满足现有业务需求基础上，对MySQL底层的体系结构，及底层的优化有一个深入的理解，对系统的整体性能进行提升。  </p><h2 id="课程内容介绍"><a href="#课程内容介绍" class="headerlink" title="课程内容介绍"></a>课程内容介绍</h2><blockquote><p>Mysql高级-day01</p></blockquote><p>MySQL高级课程简介</p><ol><li>Linux系统安装MySQL</li><li>索引</li><li>视图</li><li>存储过程和函数</li><li>触发器</li></ol><h3 id="MySQL高级课程简介"><a href="#MySQL高级课程简介" class="headerlink" title="MySQL高级课程简介"></a>MySQL高级课程简介</h3><table>    <tr>      <th>序号</th>      <th>Day01</th>      <th>Day02</th>      <th>Day03</th>      <th>Day04</th>    </tr>    <tr>      <td>1</td>      <td>Linux系统安装MySQL</td>      <td>体系结构</td>      <td>应用优化</td>      <td>MySQL常用工具</td>    </tr>    <tr>      <td>2</td>      <td>索引</td>      <td>存储引擎</td>      <td>查询缓存优化</td>      <td>MySQL日志</td>    </tr>    <tr>      <td>3</td>      <td>视图</td>      <td>优化SQL步骤</td>      <td>内存管理及优化</td>      <td>MySQl主从复制</td>    </tr>    <tr>      <td>4</td>      <td>存储过程和函数</td>      <td>索引使用</td>      <td>MySQL锁问题</td>      <td>综合案例</td>    </tr>    <tr>      <td>5</td>      <td>触发器</td>      <td>SQL优化</td>      <td>常用SQL技巧</td>      <td></td>    </tr></table><h2 id="Linux上安装MySQL"><a href="#Linux上安装MySQL" class="headerlink" title="Linux上安装MySQL"></a>Linux上安装MySQL</h2><h3 id="下载Linux安装包"><a href="#下载Linux安装包" class="headerlink" title="下载Linux安装包"></a>下载Linux安装包</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/dev.mysql.com/downloads</span><span class="regexp">/mysql/</span><span class="number">5.7</span>.html<span class="comment">#downloads</span></span><br></pre></td></tr></table></figure><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><ol><li>卸载centos中预安装的mysql</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep -i mysql # 查询服务器当中mysql的安装包是否存在，存在则显示出存在安装包的名称</span><br><span class="line"></span><br><span class="line">rpm -e mysql-libs<span class="number">-5.1</span><span class="number">.71</span><span class="number">-1.e16</span>.x86_64 --nodeps # 对已存在的安装包(mysql-libs<span class="number">-5.1</span><span class="number">.71</span><span class="number">-1.e16</span>.x86_64)进行卸载</span><br></pre></td></tr></table></figure><ol start="2"><li>上传mysql的安装包</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alt + p -------&gt;put E:/tset/MySQL<span class="number">-5.6</span><span class="number">.22</span><span class="number">-1.e16</span>.i686.rpm-bundle.tar（MySQL安装包的目录）</span><br><span class="line"></span><br><span class="line"># 使用SecureCRT远程连接服务器工具，alt+p命令进入sftp模式；再执行put （MySQL安装包的目录）[ 上传 ]</span><br></pre></td></tr></table></figure><ol start="3"><li>解压mysql的安装包</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir mysql</span><br><span class="line"></span><br><span class="line">tar -xvf MySQL-<span class="number">5.6</span>.<span class="number">22</span>-<span class="number">1</span><span class="selector-class">.e16</span><span class="selector-class">.i686</span><span class="selector-class">.rpm-bundle</span><span class="selector-class">.tar</span> -c /root/mysql</span><br></pre></td></tr></table></figure><ol start="4"><li>安装依赖包</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装第三方的依赖库；yum -y 在线安装需连接网络</span><br><span class="line">yum -y install libaio.so<span class="number">.1</span> libgc_s.so<span class="number">.1</span> libstdc++.so<span class="number">.6</span> libncurses.so<span class="number">.5</span> --setopt=protected_multilib=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">yum update listdc++<span class="number">-4.4</span><span class="number">.7</span><span class="number">-4.e16</span>.x86_64 # 更新第三方类包</span><br></pre></td></tr></table></figure><ol start="5"><li>安装mysql-client</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rpm</span> <span class="selector-tag">-ivh</span> <span class="selector-tag">MySQL-client-5</span><span class="selector-class">.6</span><span class="selector-class">.22-1</span><span class="selector-class">.e16</span><span class="selector-class">.i686</span><span class="selector-class">.rpm</span></span><br></pre></td></tr></table></figure><ol start="6"><li>安装mysql-server</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rpm</span> <span class="selector-tag">-ivh</span> <span class="selector-tag">MySQL-server-5</span><span class="selector-class">.6</span><span class="selector-class">.22-1</span><span class="selector-class">.e16</span><span class="selector-class">.i686</span><span class="selector-class">.rpm</span></span><br></pre></td></tr></table></figure><blockquote><p>Linux</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ipconfig</span> <span class="comment"># 查看本机ip地址，内网地址</span></span><br></pre></td></tr></table></figure><h2 id="启动及登录MySQL"><a href="#启动及登录MySQL" class="headerlink" title="启动及登录MySQL"></a>启动及登录MySQL</h2><blockquote><p>启动mysql命令</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service mysql status # 查看mysql服务状态</span><br><span class="line">service mysql start # 启动mysql服务</span><br><span class="line">service mysql stop # 停止mysql服务</span><br></pre></td></tr></table></figure><blockquote><p>登录mysql</p></blockquote><p>mysql 安装完成之后，会自动生成一个随机密码，并且保存在一个密码文件中：/root/.mysql_secret；  </p><blockquote><p>查看随机密码</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/root/</span>.mysql_secret</span><br></pre></td></tr></table></figure><blockquote><p>登录命令</p></blockquote><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line"><span class="meta"># -u 指的是用户</span></span><br><span class="line"><span class="meta"># -p 指的是该用户所对应的密码</span></span><br></pre></td></tr></table></figure><blockquote><p>登录之后，修改密码命令</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">password</span> = <span class="keyword">password</span>(<span class="string">'itcast'</span>);</span><br><span class="line"><span class="comment"># itcast即明文密码</span></span><br></pre></td></tr></table></figure><blockquote><p>授权远程访问</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'itcast'</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><blockquote><p>防火墙</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service iptables status # 查看防火墙状态</span><br><span class="line">service iptables stop # 关闭防火墙</span><br></pre></td></tr></table></figure><h2 id="索引-概述"><a href="#索引-概述" class="headerlink" title="索引 - 概述"></a>索引 - 概述</h2><p>MySQL官方对索引的定义为：  </p><p>索引（index）是帮助MySQL高效获取数据的数据结构（有序）。<br>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。<br>如下面的示意图所示：  </p><p>左边是数据库，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也不是一定物理相邻的）。  </p><p>为了加快Col2的查找，可以维护右边所示的二叉查找树，每个结点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速后去到相应数据。  </p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上，索引是数据库中用来提供性能的最常用的工具。  </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mspaint</span> <span class="comment"># windows打开画板</span></span><br></pre></td></tr></table></figure><table>  <tr>    <td>物理地址</td>    <td>Col1</td>    <td>Col2</td>  </tr>  <tr>    <td>0x07</td>    <td>1</td>    <td>34</td>  </tr>  <tr>    <td>0x56</td>    <td>2</td>    <td>77</td>  </tr>  <tr>    <td>0x6A</td>    <td>3</td>    <td>5</td>  </tr>  <tr>    <td>0xF3</td>    <td>4</td>    <td>91</td>  </tr>  <tr>    <td>0x90</td>    <td>5</td>    <td>22</td>  </tr>  <tr>    <td>0x77</td>    <td>6</td>    <td>59</td>  </tr>  <tr>    <td>0xD1</td>    <td>7</td>    <td>3</td>  </tr></table><p>当前该为一张数据库表；在数据库表的左侧展示的是每一条记录的一个物理地址；右侧则是两列；一列字段Col1是序号；Col2字段数据可以认为就是主键数据；数据库表结构有了，接下来查询数据；  </p><p>（1）第一种情况：查询主键Col2为34的数据；因为这个时候只存在表，没有设置索引这些方便查询的数据结构；所以这个时候就会在表当中自上而下的进行遍历；这个时候就会去遍历到第一个，发现第一个的主键id，Col2的值就是34；此时即拿到数据；这样的话只需要查询一条记录；而且查询第一条记录就是，那么这样的话查询速度是很快的；这只是第一种情况；  </p><p>（2）第二种情况：查询主键Col2 id为91的记录行数据；那么还是需要自上而下从id为34的记录行数据开始遍历；那么第一条记录不是；第二条记录不是；第三条记录也不是；直到第四条记录的时候发现数据行id是91；那么这个时候也就是需要去遍历列表4次，查询4次才能够得到结果；  </p><p>（3）第三种情况：查询主键Col2 id为3的记录行数据；这个时候再来看，如果说遍历查询的元素id是3；那么这个时候依然是从上往下进行遍历，一直遍历到列表的最底部；才能将3查找出来；那么这个时候就相当于需要进行一个全表扫描的这样一个操作；对于当前该表当中只有6、7条数据；但是如果在实际开发当中数据量比较大；一张表当中存储了几百万上千万的记录；那么这个时候如果只有表中的记录，而没有索引的话；这个时候就会造成一种现象，在查找的时候从上往下进行整表扫描，所以这种查询效率是非常慢的；  </p><p>以上就是第一种情况，即没有建立索引的情况；查询效率很慢；  </p><p>下面分析有了索引之后，又是如何进行查找的；<br>此时有了表结构还需要对表结构当中的字段进行建立索引；索引就是一种数据结构；那么此时就可以使用数据结构来表示这种表当中的索引；这里使用一种数据结构二叉树；  </p><p>既然是二叉树；那么二叉树当中的第一个结点，也就是34；即根节点；34即作为当前该树状结构的根结点；<br>接下来第二行记录是77；对于二叉树来说，二叉树有一个特点；即当根结点已经存在的时候，再插入下一个结点；则需要将下一个结点的数值与根结点的数值进行比较大小；如果比根结点小则放在左边，称之为生成一个左子树；如果比根结点大则放在右边，称之为生成一个右子树，作为右子树存在；这个时候77是比34要大的，所以放在34的右边，即77为34根结点的一个子节点；<br>接下来第三行是5，需要对5也要进行插入到二叉树该数据结构当中，那么此时也是需要进行与34根结点进行比较的；此时5比34要小；那么则放在根结点34的左边，所以此时34根结点又有一个子节点5；<br>当5插入到二叉树结构当中之后，接着下一行记录91；则首先将91与34根结点进行比较大小；显然91比34要大，则处于根结点34的右边；当前使用的是二叉树的这种数据结构，也就意味着每一个结点最多都只能有2个分支；所以称之为二叉树；所以当此时34根结点已经有了两个分支之后，那么此时91比34大，但是34的右边已经有元素77了，所以这个时候91就需要去和77去进行比较；77与91进行比较，91显然要大，所以放在77的右侧，作为77的一个右子节点存在；<br>接下来是第5行记录数据集22；22比34小，显然要放在根结点的左侧；但是根结点的左侧已经有左子节点也就是5；那么此时22就去与5进行比较，显然22比5大；也就放在5的右边；称为5的右子结点；<br>最后还剩下最后两条记录，一个是59一个是3；快速过一下；59首先和34这个元素进行比较；显然59比34大需要放在34的右侧；然34已经有右子结点77了，那么这个时候59和77进行比较；显然77大于59，那么这个时候就将59放置在77的左侧，叶子结点91的左边，成为77的左子节点；同理最后一个元素，3也是同样的方式；3与34进行比较；显然3比34要小；然此时34是存在有左子节点5的；那么这个时候就将3与5进行比较；显然3比5要小；那么这个时候；就把3放在5的左侧；成为5的左子节点，叶子结点22的左侧；<br>此时到此为止二叉树已经构建完毕；二叉树构建完毕之后再来进行分析；构建了一棵二叉树之后就能够提高查询效率吗？<br>（我认为；在二叉树一定的深度下，二叉树依然会存在查询效率慢的情况；）<br>二叉树构建好了之后，再来进行搜索；如果按照刚才的查询情况；先进行搜索34这一数值；搜索二叉树；那么就需要到索引的结构二叉树的数据结构当中来进行搜索；在进行二叉树搜索的时候，是从根结点处开始进行查询匹配数值；即树状结构当中最顶层的这一节点即为根结点；最底层的结点，即3、22、59、91这四个结点称之为叶子结点；那么二叉树的搜索是从根节点开始进行搜索的；走根结点34；这个时候就已经将34查询到了，那么这个时候就可以直接进行返回即可；但是如果这一块当中查询的并不是34而是3；那么此时仍然先会去搜索根结点34，将要查询搜索的值3去与根节点34进行比较；发现3比根结点要小；所以此时就会去根结点的左侧，即左子树当中去进行查找3；二叉树当中根结点的左边的称之为左子树；右边则称之为右子树；那么在左子树当中通过3去跟根结点的左子节点5进行比较，那么此时5比3要大；所以紧接着，让3去跟结点5的左子节点3去进行比较；所以在这个时候就找到了3这个元素；<br>而找到了3之后，二叉树的这种数据结构是如何关联到表当中具体行数当中的具体数据的呢？<br>这个时候就需要看笔记当中提到的一句话：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</span><br></pre></td></tr></table></figure><p>那也就意味着，二叉树这种数据结构当中的每一个结点都是需要指向具体表当中具体行数的具体数据；<br>那么从刚才的查询规律当中从上而下进行查找3，则从根结点34到左子节点5，再从5到5的左子节点3查找到了3这一元素的指向/引用即可找到在具体某表当中的具体某一行的数据；那么这样的话就查找到了数据；  </p><table>  <tr>    <td>物理地址</td>    <td>Col1</td>    <td>Col2</td>  </tr>  <tr>    <td>0x07</td>    <td>1</td>    <td>34</td>  </tr>  <tr>    <td>0x56</td>    <td>2</td>    <td>77</td>  </tr>  <tr>    <td>0x6A</td>    <td>3</td>    <td>5</td>  </tr>  <tr>    <td>0xF3</td>    <td>4</td>    <td>91</td>  </tr>  <tr>    <td>0x90</td>    <td>5</td>    <td>22</td>  </tr>  <tr>    <td>0x77</td>    <td>6</td>    <td>59</td>  </tr>  <tr>    <td>0xD1</td>    <td>7</td>    <td>3</td>  </tr></table><blockquote><p>分析：没有建立索引的表与建立了索引的表当中，建立了索引之后性能的一个提升；</p></blockquote><ul><li><p>没有建立索引的表：在没有建立索引的情况下，如果是要进行查询数据元素3；那么则需要把整张表当中所有的数据都需要进行遍历一遍即全表扫描，直到找到3这个id数据；  </p></li><li><p>建立了索引的表：如果是在建立了索引的这种情况之下；那么同样还是查找元素3；只需要查找第一次34；第二次5；第三次3即可；三次即可；那么这样的话这个时候通过索引由二叉树这种数据结构实现的话就不再需要去遍历整张表的数据了；通过二叉树这种数据结构就可以快速的定位到3这个查询的数据元素；那么这就是索引；索引的目的即在于快速的来查找数据；  </p></li></ul><h2 id="索引-优势和劣势"><a href="#索引-优势和劣势" class="headerlink" title="索引 - 优势和劣势"></a>索引 - 优势和劣势</h2><blockquote><p>优势<br>1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本；<br>2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗；  </p></blockquote><blockquote><p>劣势<br>1）实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，索引列也是要占用空间的；（并不放在内存当中而是放在磁盘当中，索引占用磁盘空间）<br>2）虽然索引大大提高了查询效率，同时却也降低了更新表的速度，如对表进行INSERT、UPDATE、DELETE（都需要对索引进行维护，也就是相关实现该索引的数据结构当中存储的数据也要进行变动）。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会因为更新所带来的的键值变化后的索引信息。（所以索引的字段并不是越多越好也会影响到性能）  </p></blockquote><h2 id="索引-索引结构"><a href="#索引-索引结构" class="headerlink" title="索引 - 索引结构"></a>索引 - 索引结构</h2><p>索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。  </p><p>所以每种存储引擎的索引都不一定完全相同；也不是所有的存储引擎都支持所有的索引类型。  </p><p>MySQL目前提供了以下4中索引：  </p><ul><li>BTREE索引：最常见的索引类型，大部分索引都支持B树索引；</li><li>HASH索引：只有Memory引擎支持，使用场景简单（刚刚看了下我当前MySQL数据库现在InnoDB也支持HASH哦）；</li><li>R-tree索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍；</li><li>Full-text（全文索引）：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从MySQL5.6版本开始支持全文索引；  </li></ul><p>这个统计应该也有些时候了；不是一定正确的哦；需要结合当前不同版本的MySQL来说明；我还是贴一下吧；  </p><h3 id="MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持"><a href="#MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持" class="headerlink" title="MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持"></a>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</h3><table>  <tr>    <th>索引</th>    <th>InnoDB引擎</th>    <th>MyISAM引擎</th>    <th>Memory引擎</th>  </tr>  <tr>    <td>BTREE索引</td>    <td>支持</td>    <td>支持</td>    <td>支持</td>  </tr>  <tr>    <td>HASH索引</td>    <td>不支持</td>    <td>不支持</td>    <td>支持</td>  </tr>  <tr>    <td>R-tree索引</td>    <td>不支持</td>    <td>支持</td>    <td>不支持</td>  </tr>  <tr>    <td>Full-text索引</td>    <td>5.6版本之后支持</td>    <td>支持</td>    <td>不支持</td>  </tr></table><p>平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。<br>其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用B+tree树索引，统称为索引。  </p><h2 id="索引-索引结构-BTREE"><a href="#索引-索引结构-BTREE" class="headerlink" title="索引 - 索引结构 - BTREE"></a>索引 - 索引结构 - BTREE</h2><p>BTree又叫做多路平衡搜索树，一棵 m 叉的 BTree 特性如下：  </p><ul><li>树中每个结点最多包含 m 个孩子；</li><li>除根结点与叶子结点外，每个结点至少有[ cell ( m / 2 ) ]（cell向上取整）个孩子；</li><li>若根结点不是叶子结点，则至少有两个孩子；</li><li>所有的叶子结点都在同一层；</li><li>每个非叶子结点由 n 个 key 与 n + 1 个指针组成，其中[ cell ( m / 2 ) -1 ] &lt; = n &lt; =  m - 1</li></ul><p>（对于二叉树来说，树中的每个结点最多有2个分支）  </p><p>以5叉BTree为例（当前根结点下最多有5个分支，即每个结点下最多包含5个孩子），key的数量：公式推导[ cell ( m / 2 ) - 1 ] &lt; = n &lt; = m-1 ；所以 2 &lt; = n &lt; = 4。<br>当n&gt;4时，中间节点分裂到父节点，两边结点分裂。<br>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例；<br>1）插入前4个字母C N G A；  </p><table border="1">  <tr>    <td>A</td>    <td>C</td>    <td>G</td>    <td>N</td>  </tr></table><p>（按照26个字母排队顺序，字母A在C前，C排在G前，G排在N前的顺序进行排列）  </p><p>2）插入H ，n &gt; 4，中间元素G字母向上分裂到新的结点；  </p><table border="1">  <tr>    <td>A</td>    <td>C</td>    <td>G</td>    <td>H</td>    <td>N</td>  </tr></table><p>所以演变成中间元素G字母向上分裂到新的结点，即G分裂到父节点；</p><table border="1"><tr>     <td colspan="5" style="text-align:center">G</td>  </tr>  <tr>    <td>A</td>    <td>C</td>    <td></td>    <td>H</td>    <td>N</td>  </tr></table><br><table border="1">  <tr>     <td></td>    <td></td>      <td></td>     <td colspan="2" style="text-align:center;background-color:lightblue;color:black;">G</td>     <td></td>     <td></td>    <td></td>  </tr>  <tr>     <td></td>    <td></td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>     <td></td>    <td></td>  </tr>  <tr>    <td colspan="8"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C</td>    <td></td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span> N</td>  </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>新插入的H结点会在元素G之后，那么排序也就是 A C G H N 这个样子的一个排序；那么此时的中间的结点就是G元素了；那么按照规则，当n&gt;4时，中间节点分裂到父节点；此时的G元素结点就将会进行一次分裂；分裂至父节点（H插入至BTree则G分裂至父节点）；而此时两边结点进行一次分裂；也就是原本的中间元素中间节点G左边的A、C以及右边的（新插入的）H、N就将会被分裂成父节点G的两边结点；左边的A、C分裂至父节点G的左子节点；右边的H、N分裂至父节点G的右子结点；  </p><p>接下来继续进行插入操作；插入元素E；<br>插入的E首先进行跟根结点G进行比较前后顺序；比较完成之后，E应该是在根结点G的排位在前的；所以应该被放在根结点G的左侧；也就是结点A、C该侧，A、C、E这三个元素也是需要进行排出一个顺序来的，那么也就是A、C、E这样的一个顺序排列放置；插入的是左边；由于左边元素未构成5个，所以不做任何的（分裂）变化等；  </p><p>接下来再继续插入元素K；<br>在K插入元素的时候就需要拿G与K元素的前后排位顺序进行比较，K的排位顺序比G大，所以插入到根结点G的右侧，也就是H、N所在该侧；插入的是右边，即插入时也需要与H、N这两个元素相进行比较排位顺序，也就是K元素插入到H、N这两个元素的中间；那么此时右侧的元素未构成5个所以不作任何变化；  </p><p>接下来继续插入Q；<br>插入Q也是需要与根节点G相进行比较排位顺序的；得出Q是在G之后，那么就将Q放在G根节点的右侧，然后将Q进行与节点元素H、K、N相进行比较；得到排列顺序H、K、N、Q这样一个排列顺序，当然此时仍然不需要做出（分裂）变化；因为此时n并没有超过4；只有当n超过4的时候才会发生分裂的变化；分叉小于等于4的情况下并不做任何的分裂改变只进行结点元素间的大小排位；  </p><p>在此之前一直在说分裂；当前已经分裂过一次；也就是A、C、G、H、N的时候进行将G分裂至父节点；A、C结点与H、N结点进行两边结点的分裂；并且插入了三个新的元素E、K、Q；  </p><p>此时需要说明的是：  </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个非叶子结点由 n 个 <span class="type">key</span> 与 n + <span class="number">1</span> 个指针组成，其中[ cell( m / <span class="number">2</span>) <span class="number">-1</span> ] &lt; = n &lt; = m<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>n+1个指针值的就是每个结点下都有两个方块，这两个方块都是指针存储区域；<br>指针的含义：当进行插入一个元素的时候，比如说插入元素E；当插入E元素的时候会进行与根节点G进行一个前后顺序排位的一个对比；如果E比G要小；那么E元素就需要放在G的左侧，指向左侧；成为根结点当中的左子节点当中的一个；那么这个时候就由G结点的左指针指向左子节点的方向；通过左边的这个指针指向左边的这个数据块；小于G那么这个指针就指向的是小于G的这个数据块（也就是左侧的左子结点）；大于G那么指向的就是大于G的这个数据块（也就是右侧的右子结点）；  </p><p>即</p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="2" style="text-align:center;background-color:lightblue;color:black;">G</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>  </tr>  <tr>    <td colspan="11"></td>  </tr>  <tr>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C<span style="margin-left:5px;margin-right:5px;"></span> E</td>    <td></td>    <td></td>    <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> N <span style="margin-left:5px;margin-right:5px;"></span> Q</td>  </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>接下来继续插入M元素；M与G根结点相进行比较，应该是属于在G的后面的；所以应该排放在G的右侧；通过G的右指针指向右边的数据块；M插入进来之后，应该要介于K和N之间；也就是说此时G的右子结点当中的排列顺序为H、K、M、N、Q这样一个排列顺序；这个时候就需要将M插入到K和N之间；但是当M插入到K和N之间之后，此时右子结点当中的元素已经超过了4个，即5个了；超过4个元素那么此时就要发生分裂变化，M结点刚好是中间节点；即会要发生中间节点（新插入的元素）M结点元素最终需要向上分裂到G父节点当中去，以及同时左右两边的元素H、K以及H、Q需要分裂变化成两块；  </p><p>问题：明白没有？小朋友？<br>答：明白了！(ಥ_ಥ)  </p><p>经过分裂之后再来看其指针；那么根结点当中的三个指针分别指的是；第一个指针指的是小于根节点当中的G元素则指针指向左侧第一个数据元素块A、C、E；第二个指针，则因为根节点当中存在两个元素；所以中间这个第二个指针用于大于根节点当中的G元素而小于根节点当中的M元素则指向中间的H、K的这个数据块；最后根节点当中的第三个指针用于大于根节点当中M元素的指向第三个数据元素块即N、Q；  </p><p>问题：明白？小朋友？<br>答：明白了！o(ﾟДﾟ)っ！  </p><p>当前为插入M的数据结构；  </p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">G<span style="margin-left:5px;margin-right:5px;"></span> M</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="14"></td>  </tr>  <tr>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C<span style="margin-left:5px;margin-right:5px;"></span> E</td>    <td></td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    N <span style="margin-left:5px;margin-right:5px;"></span> Q</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>当前M插入完成之后，继续插入F、W、L、T这四个数据元素；<br>那么此时插入F、W、L、T这四个数据元素时是不需要进行分裂变化的；因为当这四个元素插入进来之后，各个数据块当中的key 结点都没有超过4；所以是不需要进行分裂变化处理的；  </p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">G<span style="margin-left:5px;margin-right:5px;"></span> M</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="18"></td>  </tr>  <tr>    <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C<span style="margin-left:5px;margin-right:5px;"></span> E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    N <span style="margin-left:5px;margin-right:5px;"></span> Q<span style="margin-left:5px;margin-right:5px;"></span> T<span style="margin-left:5px;margin-right:5px;"></span> W</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>上述F、W、L、T这四个元素插入完成之后，接着插入元素Z；<br>插入Z的时候，首先会进行与根节点的G和M相进行比较；Z元素比G、M都要大；所以就由根结点的第三个指针指向第三个数据块，也就是N、Q、T、W；走向第三个数据块时又会与第三个数据块当中的元素相进行比较得到其元素排列顺序N、Q、T、W、Z这样一个排列摆放位置；所以此时将Z插入第三个数据块当中的最后一个位置，当Z元素出现在W元素之后的时候，此时观察第三个数据库块当中的元素个数已经超过了4，即已经成为5个了，那么此时这5个元素当中中间元素需要进行向上分裂，分裂至父节点，然后其左右两边需要分裂成两个数据块；该第三个数据块当中的中间元素为T；T元素此时应当符合条件需要分裂至上一节点父节点当中去；以及T元素在分裂至父节点之前原来两边的结点需要进行分裂成两块也就是N、Q结点以及W、Z结点这两大块进行分裂开来称为单独的结点；</p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">G<span style="margin-left:5px;margin-right:5px;"></span> M<span style="margin-left:5px;margin-right:5px;"></span> T</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="20"></td>  </tr>  <tr>    <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C<span style="margin-left:5px;margin-right:5px;"></span> E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    N <span style="margin-left:5px;margin-right:5px;"></span> Q<span style="margin-left:5px;margin-right:5px;"></span>     </td>    <td></td><td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>当元素Z插入完成之后，接下来进行插入元素D；<br>元素D和根结点当中的G、M、T相比，显然是都小于这三者的；所以由根结点当中的第一个指针进行指向第一个数据块，也就是A、C、E、F这个数据块当中来；并且D元素需要进行与数据块元素当中的A、C、E、F这四个元素需要进行比较排序顺序大小；即通过排序顺序可得A、C、D、E、F；插入进来之后，此时该数据块当中的key元素大于4个了，即出现了5个；那么此时就需要将该数据块元素当中的那个中间元素（D作为该数据块当中的中间元素存在），也就是刚刚新插入的元素D进行向上分裂至父节点G、M、T当中去，且分裂至父节点的元素D也需要与G、M、T进行一个排序，排序得到D、G、M、T这样一个排列顺序；那么此时分裂至父节点的元素D的两边的元素同样也需要进行分裂成两个结点；即A、C与E、F进行分裂开来；<br>最终出现的数据结构：  </p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">D<span style="margin-left:5px;margin-right:5px;"></span> G<span style="margin-left:5px;margin-right:5px;"></span> M<span style="margin-left:5px;margin-right:5px;"></span> T</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="22"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C    </td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    N <span style="margin-left:5px;margin-right:5px;"></span> Q<span style="margin-left:5px;margin-right:5px;"></span>     </td>    <td></td><td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>当元素D插入完成之后，接着进行插入元素P、R、X、Y；<br>插入P、R、X、Y时并不需要进行相应的变化分裂；因为插入到数据块当中元素key并没有满足 &gt; 4 的这样一个条件；所以并不需要做出分裂；  </p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">D<span style="margin-left:5px;margin-right:5px;"></span> G<span style="margin-left:5px;margin-right:5px;"></span> M<span style="margin-left:5px;margin-right:5px;"></span> T</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="26"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C    </td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    N<span style="margin-left:5px;margin-right:5px;"></span> P<span style="margin-left:5px;margin-right:5px;"></span> Q<span style="margin-left:5px;margin-right:5px;"></span> R</td>    <td></td><td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> X<span style="margin-left:5px;margin-right:5px;"></span> Y<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>当插入元素P、R、X、Y这四个元素之后，接下来进行插入最后一个元素S；<br>S首先和根结点当中的是个元素D、G、M、T进行比较；显然介于M与T之间；即大于M而小于T这样一个范围；从而使得根结点的第四个指针指向第四个数据块，即N、P、Q、R这一个数据块当中；而当S插入到第四个数据块当中首先也是需要进行比较排序顺序大小的；有顺序可得；得到顺序为N、P、Q、R、S这样一个顺序排列；将S插入到该数据块当中来；此时第四个数据块当中的元素个数已经达到了5个，也就是超过了4个就需要进行分裂了；那么此时；该数据块当中的中间元素为Q；也就是Q元素需要进行向上分裂至父节点D、G、M、T该数据块当中去；以及Q元素两边的元素需要进行分裂，也就是N、P与R、S这两块分裂开来；<br>但是Q如果此时向上进行分裂，而此时父节点当中的元素对向上分裂来的Q元素进行排序得到D、G、M、Q、T；父节点插入元素Q；父节点当中的元素也达到了了5个；也需要进行分裂；其父节点当中的中间元素为M元素，则此时M元素继续向上进行分裂，则M更新称为该BTree的根节点；而M两边的元素，即D、G两元素与Q、T两元素则这两块进行分裂开来，D、G块称为根结点M的左子节点，Q、T块称为M根结点的右子结点；这就是所提到的五叉BTree结构的一个演变过程；</p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="2" style="text-align:center;background-color:lightblue;color:black;">M</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">D<span style="margin-left:5px;margin-right:5px;"></span>  G    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    Q <span style="margin-left:5px;margin-right:5px;"></span> T</td>         <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C    </td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    N<span style="margin-left:5px;margin-right:5px;"></span> P</td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">R<span style="margin-left:5px;margin-right:5px;"></span> S</td>    <td></td><td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> X<span style="margin-left:5px;margin-right:5px;"></span> Y<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>了解了五叉BTree数据结构的一个演变过程之后回过头来再看；一棵m叉的BTree特性；<br>如果是一个五叉的BTree；<br>则：  </p><ul><li>树中每个结点最多包含m个孩子；即树中每个结点最多包含5个孩子；不能多于5个，即不能多于m个；  </li></ul><blockquote><p>举例</p></blockquote><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">D<span style="margin-left:5px;margin-right:5px;"></span> G<span style="margin-left:5px;margin-right:5px;"></span> M<span style="margin-left:5px;margin-right:5px;"></span> T</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="26"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C    </td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    N<span style="margin-left:5px;margin-right:5px;"></span> P<span style="margin-left:5px;margin-right:5px;"></span> Q<span style="margin-left:5px;margin-right:5px;"></span> R</td>    <td></td><td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> X<span style="margin-left:5px;margin-right:5px;"></span> Y<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><ul><li>除根结点与叶子结点外，每个结点至少有 [ cell( m / 2 )]个孩子；即每个结点至少有5/2=3（向上取整）个孩子；M为根节点；AC块、EF块、HKL块、NP块、RS块、WXYZ块为叶子结点；所以仅剩DG块与QT块非叶子结点也非根节点；这两块分别有三个字节点，DG块的孩子即AC块、EF块、HKL块；QT块的孩子即NP块、RS块、WXYZ块；  </li></ul><blockquote><p>举例</p></blockquote><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="2" style="text-align:center;background-color:lightblue;color:black;">M</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">D<span style="margin-left:5px;margin-right:5px;"></span>  G    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    Q <span style="margin-left:5px;margin-right:5px;"></span> T</td>         <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C    </td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    N<span style="margin-left:5px;margin-right:5px;"></span> P</td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">R<span style="margin-left:5px;margin-right:5px;"></span> S</td>    <td></td><td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> X<span style="margin-left:5px;margin-right:5px;"></span> Y<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><ul><li>若根结点不是叶子结点，则至少有两个孩子；</li></ul><blockquote><p>举例</p></blockquote><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="2" style="text-align:center;background-color:lightblue;color:black;">M</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">D<span style="margin-left:5px;margin-right:5px;"></span>  G    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    Q <span style="margin-left:5px;margin-right:5px;"></span> T</td>         <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C    </td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    N<span style="margin-left:5px;margin-right:5px;"></span> P</td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">R<span style="margin-left:5px;margin-right:5px;"></span> S</td>    <td></td><td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> X<span style="margin-left:5px;margin-right:5px;"></span> Y<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><ul><li>所有的叶子结点都在同一层；</li></ul><blockquote><p>举例</p></blockquote><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="2" style="text-align:center;background-color:lightblue;color:black;">M</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">D<span style="margin-left:5px;margin-right:5px;"></span>  G    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    Q <span style="margin-left:5px;margin-right:5px;"></span> T</td>         <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C    </td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    N<span style="margin-left:5px;margin-right:5px;"></span> P</td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">R<span style="margin-left:5px;margin-right:5px;"></span> S</td>    <td></td><td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> X<span style="margin-left:5px;margin-right:5px;"></span> Y<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><ul><li>每个非叶子结点由n个key与n+1个指针组成；其中[ cell( m / 2)-1] &lt; = n &lt; = m - 1；即</li></ul><p>key即指的每一个结点当中的元素；指针即用来指向数据块</p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">G<span style="margin-left:5px;margin-right:5px;"></span> M</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="18"></td>  </tr>  <tr>    <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C<span style="margin-left:5px;margin-right:5px;"></span> E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    N <span style="margin-left:5px;margin-right:5px;"></span> Q<span style="margin-left:5px;margin-right:5px;"></span> T<span style="margin-left:5px;margin-right:5px;"></span> W</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>到此已经提到了两种数据结构，一种是二叉树；一种是BTree；这两个数据结构可以拿过来相互比较一下优劣；  </p><p>BTree数据结构相对于二叉树相比；存在有多个分支；而二叉树一个结点仅仅只存在有两个结点；那么对于相同数据量来说，二叉树的数据层次，也就是二叉树的深度要更高一些；一旦层次更深也就意味着查找数据的时候；磁盘的IO的次数也就更多；从而导致查询的效率也就比较低；<br>到此，该BTree树就已经构建完成了，BTREE树和二叉树相比，查询数据的效率更高，因为对于相同的数据量来说，BTREE的层次结构相比二叉树小，因此搜索速度更快；  </p><h2 id="索引-索引结构-B-TREE"><a href="#索引-索引结构-B-TREE" class="headerlink" title="索引 - 索引结构 - B+TREE"></a>索引 - 索引结构 - B+TREE</h2><p>B+Tree为BTree的变种，B+Tree与BTree的区别为：<br>1） n叉B+Tree最多含有n个key，而BTree最多含有n-1个key；<br>2） B+Tree的叶子结点保存所有的key信息，依照key大小顺序排列；<br>3） 所有的非叶子结点都可以看做是key的索引部分；  </p><p>没有子节点的结点称之为叶子结点；叶子结点当中包含了所有key的信息；叶子结点当中的key才是完整的包含了所有的key的信息；包含了所有的数据信息；根结点当中以及非叶子结点当中的key起到的是一个索引的作用；索引就是为了查找到叶子结点当中的key；而且对于B+树来说所有的数据都是存储在叶子结点上面了；非叶子结点是不存在数据信息的；B树当中的所有数据是跟结点挂钩的；B+树当中所有的key存储在叶子结点所有的数据也都存储在叶子结点上了；<br>这也是B+树与B树的一个区别；  </p><p>B+Tree相对于BTree的一个优势：<br>由于B+Tree只有叶子结点保存key信息，查询任何key都要从root走到叶子（非叶子结点上的key都是起到一个索引的作用并没有数据，叶子结点上的key才关联着相关的数据信息），所以B+Tree的查询效率更加稳定；  </p><h2 id="索引-索引结构-MySQL中的B-Tree"><a href="#索引-索引结构-MySQL中的B-Tree" class="headerlink" title="索引 - 索引结构 - MySQL中的B+Tree"></a>索引 - 索引结构 - MySQL中的B+Tree</h2><p>MySQL索引数据结构对经典的B+Tree进行了优化。<br>在原B+Tree的基础上，增加一个指向相邻叶子结点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能；<br>问题：为什么要增加这样一个指针？<br>答：方便进行查询；  </p><blockquote><p>增加该指针的原因在于：方便进行范围搜索；  </p></blockquote><p>举例：如果想要进行搜索id为9~15的数据；由于有该指针相连所以从9一直查询链表下一结点到15即可；<br>所以该链表指针的作用主要是用来提高区间访问的性能；  </p><h2 id="索引-索引分类"><a href="#索引-索引分类" class="headerlink" title="索引 - 索引分类"></a>索引 - 索引分类</h2><p>1） 单值索引：即一个索引值包含单个列，一个表可以有多个单列索引(一个索引当中只包含一个列；比如现在需要对某一张表当中建立索引；该表当中有多个字段name、gender、age、help_category_id等字段，但是只针对name该字段该列进行建立索引；help_category_id也可以建立个索引；则当前存在两个索引，但是每个索引只对应了相对应的一列；这个叫做单列索引或者是单值索引；一个表当中可以包含有多个单列索引)<br>2） 唯一索引：索引列的值必须唯一，但允许有空值；（当前表当中某一个字段或者是某一列当中其值都是唯一的；也就是说如果存在有列当中的值都是唯一的；那么必要情况下就可以针对该列建立一个唯一索引，在唯一索引的该列当中允许包括有多个NULL值；）<br>3） 复合索引：即一个索引包含多个列（比如：经常在查询当中需要对name字段以及parent_category_id或者是说age字段进行联合查询，那么此时可以将name字段以及age字段组合起来建立一个复合索引，即一个索引当中包含了两个列或者说多个列；那么这种索引称之为复合索引）；  </p><h2 id="索引-索引语法"><a href="#索引-索引语法" class="headerlink" title="索引 - 索引语法"></a>索引 - 索引语法</h2><p>索引在创建表的时候，可以同时创建，也可以随时增加新的索引；<br>准备环境：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> demo_01 <span class="keyword">default</span> charset=utf8mb4;</span><br><span class="line"></span><br><span class="line">use demo_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">'city'</span>(</span><br><span class="line">    <span class="string">'city_id'</span> <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT;</span><br><span class="line">    <span class="string">'city_name'</span> <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="string">'country_id'</span> <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (<span class="string">'city_id'</span>)</span><br><span class="line">)ENGINE=InnoDB <span class="keyword">DEFAULT</span> CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">'country'</span>(</span><br><span class="line">    <span class="string">'country_id'</span> <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT;</span><br><span class="line">    <span class="string">'country_name'</span> <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (<span class="string">'country_id'</span>)</span><br><span class="line">)ENGINE=InnoDB <span class="keyword">DEFAULT</span> CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'city'</span>(<span class="string">'city_id'</span>,<span class="string">'city_name'</span>,<span class="string">'country_id'</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'西安'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'city'</span>(<span class="string">'city_id'</span>,<span class="string">'city_name'</span>,<span class="string">'country_id'</span>) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'NewYork'</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'city'</span>(<span class="string">'city_id'</span>,<span class="string">'city_name'</span>,<span class="string">'country_id'</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'北京'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'city'</span>(<span class="string">'city_id'</span>,<span class="string">'city_name'</span>,<span class="string">'country_id'</span>) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'上海'</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'country'</span>(<span class="string">'country_id'</span>,<span class="string">'country_name'</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'China'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'country'</span>(<span class="string">'country_id'</span>,<span class="string">'country_name'</span>) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'America'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'country'</span>(<span class="string">'country_id'</span>,<span class="string">'country_name'</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Japan'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'country'</span>(<span class="string">'country_id'</span>,<span class="string">'country_name'</span>) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'UK'</span>);</span><br></pre></td></tr></table></figure><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>语法：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">UNIQUE</span> | <span class="keyword">FULL</span> <span class="built_in">TEXT</span> |SPATIAL] <span class="keyword">INDEX</span> index_name</span><br><span class="line">[ <span class="keyword">using</span> index_type ]</span><br><span class="line"><span class="keyword">ON</span> tb1_name(index_col_name, .... )</span><br><span class="line"></span><br><span class="line">index_col_name : column_name[ ( <span class="keyword">length</span> ) ] [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ]</span><br></pre></td></tr></table></figure><p>索引的类型：UNIQUE唯一索引、FULLTEXT全文索引、SPATIAL；索引类型可选；可以不进行指定；<br>index_name：索引的名称；<br>using index_type：索引所使用的哪一个类型；如果不指定；则使用，默认的索引类型即B+树索引类型；<br>ON tb1_name(index_col_name, ….)：进行指定对哪一张表的哪几个字段创建索引；  </p><p>在MySQL当中，如果当前该字段是主键的话；则默认该字段默认有一个索引叫做主键索引；  </p><p>所以此时在city表当中对city_id字段的索引不必再进行创建；可以在city_name字段上创建索引；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_city_name <span class="keyword">on</span> city(city_name);<span class="comment">#此时在city_name字段上创建的该索引为普通索引；</span></span><br></pre></td></tr></table></figure><p>示例：为city表中的city_name 字段创建索引：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_city_name <span class="keyword">on</span> city(city_name);</span><br></pre></td></tr></table></figure><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><p>语法：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> <span class="built_in">table_name</span>; #<span class="built_in">table_name</span>，索引所建立在该字段，该字段所处的表的名称</span><br></pre></td></tr></table></figure><p>示例：查看city表中的索引信息：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> city\G; <span class="comment">#\G格式化</span></span><br></pre></td></tr></table></figure><p>在MySQL当中会默认对主键city_id字段创建一个索引就称作是主键索引key_name：primary；<br>而刚刚对city_name创建的索引则为key_name：idx_city_name；<br>主键索引primary以及刚刚没有指定索引类型的idx_city_name的索引类型都是BTREE类型；即B+Tree索引，BTree索引；</p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>语法：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> tb1_name;</span><br><span class="line"><span class="comment"># index_name索引的名称</span></span><br><span class="line"><span class="comment"># 该index_name索引所具体在的表的名称</span></span><br></pre></td></tr></table></figure><p>示例：想要删除city表上的索引[ idx_city_name ]，可以操作如下：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> idx_city_name <span class="keyword">on</span> city;</span><br></pre></td></tr></table></figure><p>删除之后可以通过以下命令来进行查看删除的索引是否仍然存在；</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> <span class="built_in">table_name</span>\G;</span><br></pre></td></tr></table></figure><h3 id="ALTER指令"><a href="#ALTER指令" class="headerlink" title="ALTER指令"></a>ALTER指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alter 修改</span></span><br><span class="line"><span class="comment"># 该语句添加一个主键，这意味着索引值必须唯一，且不能为NULL；</span></span><br><span class="line">1. <span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> primary <span class="keyword">key</span>(column_list);</span><br><span class="line"></span><br><span class="line"><span class="comment"># unique 唯一的</span></span><br><span class="line"><span class="comment"># 这条语句创建索引的值必须是唯一的（除了NULL意外，NULL可能会出现多次）</span></span><br><span class="line"><span class="comment"># Non_unique:0 #Non不，unique唯一；0：否定；双重否定等于肯定；即唯一</span></span><br><span class="line"><span class="comment"># 当创建普通索引时其Non_unique:1；即不唯一；  </span></span><br><span class="line">2. <span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> <span class="keyword">unique</span> index_name(column_list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加普通索引，索引值可以出现多次</span></span><br><span class="line">3. <span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> <span class="keyword">index</span> index_name(column_list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 该语句指定了索引为FULLTEXT，用于全文索引</span></span><br><span class="line">4. <span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> fulltext index_name(column_list);</span><br></pre></td></tr></table></figure><p>示例：添加唯一索引  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> city <span class="keyword">add</span>  <span class="keyword">unique</span>  idx_city_name(city_name);</span><br></pre></td></tr></table></figure><h2 id="索引-索引设计原则"><a href="#索引-索引设计原则" class="headerlink" title="索引 - 索引设计原则"></a>索引 - 索引设计原则</h2><p>索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引；  </p><ul><li>对查询频次较高，且数据量比较大的表建立索引；</li><li>索引字段的选择，最佳候选列应当从where子句的条件中提取（即查询条件当中的字段），如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。</li><li>使用唯一索引，区分度越高，使用索引的效率越高；</li><li>索引可以有效的提升查询数据的效率，但是索引数量不是多多益善；索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价（维护索引的数据结构），降低DML操作的效率，增加响应操作的时间消耗；另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但是无疑提高了选择的代价；</li><li>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，乡音的可以有效地提升MySQL访问索引的I/O效率。</li><li>利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升性能；  </li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建复合索引：</span><br><span class="line"></span><br><span class="line">CREATE <span class="built_in">INDEX</span> idx_name_email_status ON tb_seller(<span class="keyword">NAME</span>,email,<span class="keyword">STATUS</span>);</span><br><span class="line"></span><br><span class="line">就相当于</span><br><span class="line">      对<span class="keyword">name</span> 创建了索引；</span><br><span class="line">      对<span class="keyword">name</span> , email 创建了索引；</span><br><span class="line">      对<span class="keyword">name</span> , email , <span class="keyword">status</span> 创建了索引；</span><br><span class="line">只需要创建这么一个索引，在查询<span class="keyword">name</span>单个字段的时候就将会走索引；在查询<span class="keyword">name</span>，email这两个字段的时候也会走索引；在查询<span class="keyword">name</span>,email,<span class="keyword">status</span>这三个字段的时候也会走索引；  </span><br><span class="line">最左索引：最左指的是复合索引当中的第一个字段，只要查询的时候包含第一个字段，那么这个时候就会走索引；</span><br></pre></td></tr></table></figure><h2 id="视图-创建及修改视图"><a href="#视图-创建及修改视图" class="headerlink" title="视图 - 创建及修改视图"></a>视图 - 创建及修改视图</h2><p>视图（View）是一种虚拟存在的表。<br>视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。<br>通俗的讲，视图就是一条SELECT语句执行后返回的结果集。<br>所以在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。  </p><p>视图相对于普通表的又是主要包括以下几项：  </p><ul><li>简单：使用视图的用户完全不需要关心后面对应表的结构、关联条件和筛选条件，对用户来说已经是过滤好的符合条件的结果集。  </li><li>安全：使用视图的用户只能访问他们被允许查询的结果喜，对表的权限管理并不能先知道某个行某个列，但是通过视图就可以简单的实现；</li><li>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响；</li></ul><h3 id="创建或者修改视图"><a href="#创建或者修改视图" class="headerlink" title="创建或者修改视图"></a>创建或者修改视图</h3><blockquote><p>创建视图的语法为</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">OR</span> <span class="keyword">REPLACE</span>] [ ALGORITHM = &#123; UNDEFINED | <span class="keyword">MERGE</span> | TEMPTABLE &#125; ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">VIEW</span> view_name [ (column_list) ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line"></span><br><span class="line">[ <span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> | <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> <span class="keyword">OPTION</span> ]</span><br></pre></td></tr></table></figure><blockquote><p>修改视图的语法</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> [ ALGORITHM = &#123; UNDEFINED | <span class="keyword">MERGE</span> | TEMPTABLE &#125; ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">VIEW</span> view_name [ (column_list) ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line"></span><br><span class="line">[ WITE [ <span class="keyword">CASCADED</span> | <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> <span class="keyword">OPTION</span> ]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选项：</span><br><span class="line">    <span class="keyword">WITH</span> [ <span class="keyword">CASCADED</span> | <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> <span class="keyword">OPTION</span> 决定了是否允许更新数据使记录不在满足视图的条件；</span><br><span class="line">    <span class="keyword">LOCAL</span> 只要满足本视图的条件就可以更新</span><br><span class="line">    <span class="keyword">CASCADED</span> 必须满足所有针对该视图的所有视图的条件才可以更新（默认值）</span><br><span class="line"></span><br><span class="line">    <span class="keyword">CREATE</span> [ <span class="keyword">OR</span> <span class="keyword">REPLACE</span>] 创建或者是替换</span><br><span class="line">    <span class="keyword">AS</span> select_statement select_statement即<span class="keyword">select</span>语句</span><br></pre></td></tr></table></figure><p>示例：在视图当中展示国家以及其相关城市的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>; <span class="comment"># 显示在该数据库下所有的表</span></span><br><span class="line">desc table_name; <span class="comment"># 显示该table_name当中的表结构</span></span><br><span class="line">desc city;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> city c,country t <span class="keyword">where</span> c.country_id=t.country_id;</span><br><span class="line"><span class="keyword">select</span> c.*,t.country_name <span class="keyword">from</span> city c,country t <span class="keyword">where</span> c.country_id=t.country_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_city_country <span class="keyword">as</span> <span class="keyword">select</span> c.*,t.country_name <span class="keyword">from</span> city c,country t <span class="keyword">where</span> c.country_id=t.country_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> view_city_country;<span class="comment"># 查询视图与表操作一致</span></span><br><span class="line"><span class="keyword">update</span> view_city_country <span class="keyword">set</span> city_name=<span class="string">'西安市'</span> <span class="keyword">where</span> city_id=<span class="number">1</span>;<span class="comment">#修改视图与表操作一致</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> city; <span class="comment"># 这个时候基础表当中的数据也会被更新掉；也就是说此时的视图修改操作是会影响到基础表当中的数据；  </span></span><br><span class="line">虽然视图能够做到更新，但是并不建议去更新数据；因为视图就是用来简化查询操作的，不建议更新视图；</span><br></pre></td></tr></table></figure><h2 id="视图-查看及删除视图"><a href="#视图-查看及删除视图" class="headerlink" title="视图 - 查看及删除视图"></a>视图 - 查看及删除视图</h2><h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><p>从MySQL5.1版本开始，使用SHOW TABLES命令的时候不仅会显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的SHOW VIEWS命令。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;<span class="comment"># 显示表以及视图的名称</span></span><br></pre></td></tr></table></figure><p>同样，在使用SHOW TABLE STATUS命令的时候，不但可以显示表的信息，同时也可以显示视图的信息；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span>; <span class="comment"># 显示表以及视图的信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'city_country_view'</span>\G; <span class="comment"># 示例查看视图city_country_view</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> view_city_country; <span class="comment"># 查看创建视图时所使用的的SQL语句是什么</span></span><br></pre></td></tr></table></figure><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>语法：  </p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">DROP</span> <span class="meta">VIEW</span> [ <span class="meta">IF</span> EXISTS ] view_name [, view_name ] ... [ <span class="meta">RESTRICT</span> | <span class="meta">CASCADE</span> ]</span><br></pre></td></tr></table></figure><p>示例，删除视图city_country_view:  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> city_country_view;# or <span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="keyword">if</span> <span class="keyword">exists</span> city_country_view;</span><br></pre></td></tr></table></figure><h2 id="存储过程-概述"><a href="#存储过程-概述" class="headerlink" title="存储过程 - 概述"></a>存储过程 - 概述</h2><p>存储过程和函数是实现经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率时有好处的。<br>存储过程和函数的区别在于函数必须有返回值，而存储过程没有；<br>函数：是一个有返回值的过程；<br>存储过程：是一个没有返回值的函数；</p><h2 id="存储过程-创建调用查询删除语法"><a href="#存储过程-创建调用查询删除语法" class="headerlink" title="存储过程 - 创建调用查询删除语法"></a>存储过程 - 创建调用查询删除语法</h2><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="function"><span class="keyword">PROCEDURE</span> <span class="title">procedure_name</span> <span class="params">( [proc_parameter[,.....]])</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    -- <span class="title">SQL</span>语句</span></span><br><span class="line"><span class="function"><span class="title">end</span>;</span></span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">select</span> '<span class="title">Hello</span> <span class="title">MySQL</span>';</span></span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h4 id="知识小贴士"><a href="#知识小贴士" class="headerlink" title="知识小贴士"></a>知识小贴士</h4><p>DELEMITER<br>    该关键字用来声明SQL语句的分隔符，告诉MySQL解释器，改短命令是否已经结束了，mysql是否可以执行了，默认情况下，delimiter是分号;<br>    在命令行客户端中，如果一行命令以分号结束，那么回车后，mysql将会执行该命令；</p><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> procedure_name();</span><br></pre></td></tr></table></figure><h3 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 查询db_name 数据库中的所有的存储过程</span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> mysql.proc <span class="keyword">where</span> db=<span class="string">'db_name'</span>;</span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> mysql.proc <span class="keyword">where</span> db=<span class="string">'demo_01'</span>$ #示例</span><br><span class="line"></span><br><span class="line">-- 查询存储过程的状态信息</span><br><span class="line">show <span class="function"><span class="keyword">procedure</span> <span class="title">status</span>;</span></span><br><span class="line">show <span class="function"><span class="keyword">procedure</span> <span class="title">status</span>$ # 示例</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-- 查询某个存储过程的定义</span></span><br><span class="line"><span class="function"><span class="title">show</span> <span class="title">create</span> <span class="title">procedure</span> <span class="title">test</span>.<span class="title">pro_test1</span> \<span class="title">G</span>;</span></span><br><span class="line">show <span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test</span>\<span class="title">G</span>$ #示例</span></span><br></pre></td></tr></table></figure><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DROP <span class="function"><span class="keyword">PROCEDURE</span> [ <span class="title">IF</span> <span class="title">EXISTS</span> ] <span class="title">sp_name</span>;</span></span><br><span class="line"></span><br><span class="line">drop <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test1</span>$ # 示例</span></span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-变量"><a href="#存储过程-语法-变量" class="headerlink" title="存储过程 - 语法 - 变量"></a>存储过程 - 语法 - 变量</h2><p>存储过程是可以编程的，意味着可以使用变量，表达式，控制结构，来完成比较复杂的功能。(使得SQL具有过程化语言的处理能力)  </p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>DECLARE</li></ul><p>通过DECLARE可以定义一个局部变量，该变量的作用返回只能在BEGIN…END块中。  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE var_name[ <span class="built_in">..</span>. ]<span class="built_in"> type </span>[DEFAULT value]</span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">declare</span> <span class="title">num</span> <span class="title">int</span> <span class="title">default</span> 5;</span></span><br><span class="line">    <span class="keyword">select</span> num+ <span class="number">10</span>;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">declare</span> <span class="title">num</span> <span class="title">int</span> <span class="title">default</span> 10;</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'num的值为'</span>,num);</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">call pro_test1()$</span><br><span class="line">call pro_test2()$</span><br><span class="line"></span><br><span class="line">delimiter $</span><br></pre></td></tr></table></figure><ul><li>SET</li></ul><p>直接赋值使用SET，可以赋常量或者赋表达式，具体语法如下：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">SET</span> var_name = expr [ , <span class="attribute">var_name</span>=expr ] <span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="function"><span class="keyword">PROCEDURE</span> <span class="title">pro_test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">BEGIN</span></span></span><br><span class="line"><span class="function">    <span class="title">DECLARE</span> <span class="title">NAME</span> <span class="title">VARCHAR</span><span class="params">(20)</span>;</span></span><br><span class="line">    <span class="keyword">SET</span> NAME = <span class="string">'MYSQL'</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> NAME ;</span><br><span class="line"><span class="keyword">END</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="function"><span class="keyword">PROCEDURE</span> <span class="title">pro_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">declare</span> <span class="title">num</span> <span class="title">int</span> <span class="title">default</span> 0;</span></span><br><span class="line">    <span class="keyword">set</span> num = num +<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">select</span> num;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">call pro_test3()$</span><br><span class="line">call pro_demo()$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>也可以通过 select….into 方式进行赋值操作；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> pro_test5()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> countnum <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> countnum <span class="keyword">from</span> city;</span><br><span class="line">    <span class="keyword">select</span> countnum;</span><br><span class="line"><span class="keyword">END</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> PPROCEDURE pro_demo()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">num</span> <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> <span class="keyword">num</span> <span class="keyword">from</span> city;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'city表中的记录数为'</span>,<span class="keyword">num</span>);</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> pro_test5()$</span><br><span class="line"><span class="keyword">call</span> pro_demo()$</span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-if判断"><a href="#存储过程-语法-if判断" class="headerlink" title="存储过程 - 语法 - if判断"></a>存储过程 - 语法 - if判断</h2><h3 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h3><p>语法结构：  </p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> search_condition then statement_list</span><br><span class="line">      [ <span class="keyword">elseif</span> search_condition then statement_list ] ...</span><br><span class="line">      [ <span class="keyword">else</span> statementlist ]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br></pre></td></tr></table></figure><p>需求：  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">根据定义的身高变量，判定当前身高的所属的身材类型</span><br><span class="line"></span><br><span class="line"><span class="number">180</span>及以上----------》身材高挑</span><br><span class="line"><span class="number">170</span> ~ <span class="number">180</span>----------》标准身材</span><br><span class="line"><span class="number">170</span>一下------------》一般身材</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">delimiter &amp;</span><br><span class="line">create procedure pro_test4()</span><br><span class="line">begin</span><br><span class="line">    declare height int<span class="built_in"> default </span>175;</span><br><span class="line">    declare description varchar(50)<span class="built_in"> default </span><span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> hegith &gt;= 180 then</span><br><span class="line">      <span class="builtin-name">set</span> <span class="attribute">description</span>=<span class="string">'身材高挑'</span>;</span><br><span class="line">    elseif height &gt;=170 <span class="keyword">and</span> height &lt; 180 then</span><br><span class="line">      <span class="builtin-name">set</span> <span class="attribute">description</span>=<span class="string">'标准身材'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="builtin-name">set</span> <span class="attribute">description</span>=<span class="string">'一般身材'</span>;</span><br><span class="line">    end <span class="keyword">if</span>;</span><br><span class="line">    select concat(<span class="string">'身高'</span>,height,<span class="string">'对应的身材类型为'</span>,description);</span><br><span class="line">end$</span><br><span class="line"></span><br><span class="line">call pro_test()$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-输入参数"><a href="#存储过程-语法-输入参数" class="headerlink" title="存储过程 - 语法 - 输入参数"></a>存储过程 - 语法 - 输入参数</h2><p><strong>传递参数</strong></p><p>语法格式：  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">procedure_name</span><span class="params">([ <span class="keyword">in</span> / <span class="keyword">out</span> / inout ]参数名称 参数类型)</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># <span class="title">IN</span> 该参数可以作为输入，也就是需要调用方传入值，默认</span></span><br><span class="line"><span class="function"># <span class="title">OUT</span> 该参数作为输出，也就是该参数可以作为返回值</span></span><br><span class="line"><span class="function"># <span class="title">INOUT</span> 既可以作为输入参数，也可以作为输出参数</span></span><br></pre></td></tr></table></figure><p><strong>IN - 输入</strong></p><p>需求：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据定义的身高变量，判定当前身高的所属的身材类型</span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">create procedure pro_test5(<span class="keyword">in</span> height int)</span><br><span class="line">begin</span><br><span class="line">    declare description varchar(50)<span class="built_in"> default </span><span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> hegith &gt;= 180 then</span><br><span class="line">      <span class="builtin-name">set</span> <span class="attribute">description</span>=<span class="string">'身材高挑'</span>;</span><br><span class="line">    elseif height &gt;=170 <span class="keyword">and</span> height &lt; 180 then</span><br><span class="line">      <span class="builtin-name">set</span> <span class="attribute">description</span>=<span class="string">'标准身材'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="builtin-name">set</span> <span class="attribute">description</span>=<span class="string">'一般身材'</span>;</span><br><span class="line">    end <span class="keyword">if</span>;</span><br><span class="line">    select concat(<span class="string">'身高'</span>,height,<span class="string">'对应的身材类型为'</span>,description);</span><br><span class="line">end$</span><br><span class="line"></span><br><span class="line">call pro_test5(198)$</span><br><span class="line">call pro_test5(178)$</span><br><span class="line">call pro_test5(158)$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-输出参数"><a href="#存储过程-语法-输出参数" class="headerlink" title="存储过程 - 语法 - 输出参数"></a>存储过程 - 语法 - 输出参数</h2><p>需求：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据传入的身高变量，获取当前身高的所属的身材类型</span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test5</span><span class="params">(<span class="keyword">in</span> height int ,<span class="keyword">out</span> description varchar(10)</span>)</span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">height</span> &gt;=180 <span class="title">then</span></span></span><br><span class="line"><span class="function">        <span class="title">set</span> <span class="title">description</span>='身材高挑';</span></span><br><span class="line">    elseif height &gt;= <span class="number">170</span> <span class="keyword">and</span> height &lt; <span class="number">180</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> description=<span class="string">'身材标准'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">set</span> description=<span class="string">'一般身材'</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">call pro_test5(<span class="number">188</span>,@description)$</span><br><span class="line"># @description 代表用户的变量；用户的会话变量</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @description$ # 查询用户会话变量取值</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p><strong>小知识</strong><br>@description：这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程它都是有作用的，这个类似于全局变量一样。<br>@@global.sort_buffer_size:这种在变量前加上“@@”，叫做系统变量；  </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">set</span> <span class="variable">@name</span>=<span class="string">'itcast'</span>$</span><br><span class="line"></span><br><span class="line"><span class="literal">select</span> <span class="variable">@name</span>$</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-case结构"><a href="#存储过程-语法-case结构" class="headerlink" title="存储过程 - 语法 - case结构"></a>存储过程 - 语法 - case结构</h2><p>语法结构：  </p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">方式一：  </span><br><span class="line"><span class="keyword">CASE</span> case_value <span class="meta"># case_value 条件</span></span><br><span class="line">    <span class="keyword">WHEN</span> when_value <span class="keyword">THEN</span> statement_list <span class="meta"># statement_list SQL语句</span></span><br><span class="line">    [ <span class="keyword">WHEN</span> when_value <span class="keyword">THEN</span> statement_list ] ...</span><br><span class="line">    [ <span class="keyword">ELSE</span> statement_list ]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方拾二：  </span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> search_condition <span class="keyword">THEN</span> statement_list <span class="meta"># search_condition 条件表达式；如果该表达式为真只执行THEN后的statement_list SQL语句</span></span><br><span class="line">    [ <span class="keyword">WHEN</span> search_condition <span class="keyword">THEN</span> statement_list ] ...</span><br><span class="line">    [ <span class="keyword">ELSE</span> statement_list ]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure><p>需求：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个月份，然后计算出所在的季度</span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test7</span><span class="params">( mon int)</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">declare</span> <span class="title">result</span> <span class="title">varchar</span><span class="params">(10)</span>;</span></span><br><span class="line">    <span class="keyword">case</span></span><br><span class="line">      when mou&gt;=<span class="number">1</span> <span class="keyword">and</span> mon &lt;=<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span>=<span class="string">'第一季度'</span>;</span><br><span class="line">      when mou&gt;=<span class="number">4</span> <span class="keyword">and</span> mon &lt;=<span class="number">6</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span>=<span class="string">'第二季度'</span>;</span><br><span class="line">      when mou&gt;=<span class="number">7</span> <span class="keyword">and</span> mon &lt;=<span class="number">9</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span>=<span class="string">'第三季度'</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span>=<span class="string">'第四季度'</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'传递的月份为'</span>,mon,<span class="string">'， 计算出的结果为：'</span>,<span class="keyword">result</span>) <span class="keyword">as</span> content;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">call pro_test7(<span class="number">7</span>)$</span><br><span class="line">call pro_test7(<span class="number">2</span>)$</span><br><span class="line">call pro_test7(<span class="number">11</span>)$</span><br><span class="line">call pro_test7(<span class="number">9</span>)$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-while循环"><a href="#存储过程-语法-while循环" class="headerlink" title="存储过程 - 语法 - while循环"></a>存储过程 - 语法 - while循环</h2><p>语法结构：  </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> search_condition <span class="keyword">do</span> <span class="comment"># search_condition 条件成立执行循环；条件不成立则跳出循环</span></span><br><span class="line">    statement_list</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br></pre></td></tr></table></figure><p>需求：  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算从<span class="number">1</span>加到n的值</span><br></pre></td></tr></table></figure><p>示例:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test8(n <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">start</span> <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    while <span class="keyword">start</span> &lt;= n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">set</span> total=total+<span class="keyword">start</span>;</span><br><span class="line">        <span class="keyword">start</span>=<span class="keyword">start</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> pro_test8(<span class="number">3</span>)$</span><br><span class="line"><span class="keyword">call</span> pro_test8(<span class="number">6</span>)$</span><br><span class="line"><span class="keyword">call</span> pro_test8(<span class="number">100</span>)$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-repeat循环"><a href="#存储过程-语法-repeat循环" class="headerlink" title="存储过程 - 语法 - repeat循环"></a>存储过程 - 语法 - repeat循环</h2><p>有条件的循环控制语句，当满足条件的时候退出循环。<br>while是满足条件才执行，repeat是满足条件就退出循环。  </p><p>语法结构：  </p><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REPEAT</span></span><br><span class="line">    statement_list</span><br><span class="line"></span><br><span class="line">    <span class="keyword">UNTIL</span> search_condition</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br></pre></td></tr></table></figure><p>需求：  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算从<span class="number">1</span>加到n的值</span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test9</span><span class="params">(n int)</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">declare</span> <span class="title">total</span> <span class="title">int</span> <span class="title">default</span> 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">set</span> total=total+n;</span><br><span class="line">        <span class="keyword">set</span> n=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">until</span> n=<span class="number">0</span> # 此处不加分号；加分号报错；满足当前条件则跳出循环</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">call pro_test10(<span class="number">50</span>)$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-loop循环"><a href="#存储过程-语法-loop循环" class="headerlink" title="存储过程 - 语法 - loop循环"></a>存储过程 - 语法 - loop循环</h2><h3 id="loop语句"><a href="#loop语句" class="headerlink" title="loop语句"></a>loop语句</h3><p>LOOP实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用LEAVE语句实现，具体语法如下：  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ begin_label: ] <span class="keyword">LOOP</span></span><br><span class="line">    statement_list</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span> [ end_label ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果不在 statement_list 中增加退出循环的语句，那么LOOP语句可以用来实现简单的死循环</p><h3 id="leave语句"><a href="#leave语句" class="headerlink" title="leave语句"></a>leave语句</h3><p>用来从标注的流程构造中退出，通常和BEGIN….END或者循环一起使用。<br>下面是一个使用LOOP和LEAVE的简单例子，退出循环；</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="function"><span class="keyword">PROCEDURE</span> <span class="title">pro_test10</span><span class="params">(n int)</span></span></span><br><span class="line"><span class="function"><span class="title">BEGIN</span></span></span><br><span class="line"><span class="function">    <span class="title">declare</span> <span class="title">total</span> <span class="title">int</span> <span class="title">default</span> 0;</span></span><br><span class="line"></span><br><span class="line">    ins:<span class="keyword">LOOP</span></span><br><span class="line">        <span class="keyword">IF</span> n &lt;= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">          leave ins;</span><br><span class="line">        <span class="keyword">ELSE</span></span><br><span class="line">          <span class="keyword">SET</span> total=total+n;</span><br><span class="line">          <span class="keyword">SET</span> n=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">LOOP</span> ins;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">END</span>$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test10</span><span class="params">(n int)</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">declare</span> <span class="title">total</span> <span class="title">int</span> <span class="title">default</span> 0;</span></span><br><span class="line"></span><br><span class="line">    c:<span class="keyword">loop</span></span><br><span class="line">        <span class="keyword">set</span> total=total+n;</span><br><span class="line">        <span class="keyword">set</span> n=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            leave c; # 满足条件跳出循环</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span> c;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">call pro_test10(<span class="number">100</span>)$</span><br><span class="line">call pro_test10(<span class="number">99</span>)$</span><br><span class="line">call pro_test10(<span class="number">3</span>)$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-游标介绍"><a href="#存储过程-语法-游标介绍" class="headerlink" title="存储过程 - 语法 - 游标介绍"></a>存储过程 - 语法 - 游标介绍</h2><p>游标是用来存储查询结果集的数据类型，唉存储过程和函数中可以使用光标对结果集进行循环的处理。<br>光标的使用包括光标的声明、OPEN、FETCH和CLOSE。  </p><h2 id="存储过程-语法-游标基本操作"><a href="#存储过程-语法-游标基本操作" class="headerlink" title="存储过程 - 语法 - 游标基本操作"></a>存储过程 - 语法 - 游标基本操作</h2><p>其语法分别如下：  </p><p>声明光标：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">for</span> select_statement;</span><br></pre></td></tr></table></figure><p>OPEN光标：  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN cursor_name<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>FETCH光标：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH cursor_name INTO var_name [ , var_name ] <span class="string">...</span> <span class="comment"># 每抓取一次，即获取结果集当中每一行数据；调用一次指针往下指向一次；调用一次指针往下指向一次；当指针指到最后没有数据的那一行时，即此时就应该退出游标了；</span></span><br></pre></td></tr></table></figure><p>CLOSE光标：  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE cursor_name<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>示例：<br>初始化脚本:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'姓名'</span>,</span><br><span class="line">  age <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">comment</span> <span class="string">'年龄'</span>,</span><br><span class="line">  salary <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">comment</span> <span class="string">'薪水'</span>,</span><br><span class="line">  primary <span class="keyword">key</span>(<span class="string">'id'</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(<span class="keyword">id</span>,<span class="keyword">name</span>,age,salary) <span class="keyword">values</span> (<span class="literal">null</span>,<span class="string">'金毛狮王'</span>,<span class="number">55</span>,<span class="number">3800</span>),(<span class="literal">null</span>,<span class="string">'白眉鹰王'</span>,<span class="number">60</span>,<span class="number">4400</span>),(<span class="literal">null</span>,<span class="string">'青翼蝠王'</span>,<span class="number">38</span>,<span class="number">2800</span>),(<span class="literal">null</span>,<span class="string">'素衫龙王'</span>,<span class="number">42</span>,<span class="number">1800</span>);</span><br></pre></td></tr></table></figure><p>需求：  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询emp表中数据，并逐行获取进行显示</span></span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delimiter</span> $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test11()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> e_id <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">declare</span> e_name <span class="type">varchar</span>(<span class="number">50</span>);</span><br><span class="line">    decalre e_age <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">declare</span> e_salary <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">declare</span> emp_result <span class="keyword">cursor</span> fro <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> emp_result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fetch</span> emp_result <span class="keyword">into</span> e_id,e_naem,e_age,e_salary;</span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">'id为：'</span> , e_id,<span class="string">', 名字为: '</span> , e_name , <span class="string">', 年龄为：'</span> , e_age , <span class="string">', 薪资为：'</span> , e_salary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fetch</span> emp_result <span class="keyword">into</span> e_id,e_naem,e_age,e_salary;</span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">'id为：'</span> , e_id,<span class="string">', 名字为: '</span> , e_name , <span class="string">', 年龄为：'</span> , e_age , <span class="string">', 薪资为：'</span> , e_salary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fetch</span> emp_result <span class="keyword">into</span> e_id,e_naem,e_age,e_salary;</span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">'id为：'</span> , e_id,<span class="string">', 名字为: '</span> , e_name , <span class="string">', 年龄为：'</span> , e_age , <span class="string">', 薪资为：'</span> , e_salary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fetch</span> emp_result <span class="keyword">into</span> e_id,e_naem,e_age,e_salary;</span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">'id为：'</span> , e_id,<span class="string">', 名字为: '</span> , e_name , <span class="string">', 年龄为：'</span> , e_age , <span class="string">', 薪资为：'</span> , e_salary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fetch</span> emp_result <span class="keyword">into</span> e_id,e_naem,e_age,e_salary;</span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">'id为：'</span> , e_id,<span class="string">', 名字为: '</span> , e_name , <span class="string">', 年龄为：'</span> , e_age , <span class="string">', 薪资为：'</span> , e_salary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">close</span> emp_result;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"># emp表当中只有四条数据，如果<span class="keyword">fetch</span>的次数大于表当中的数据，那么<span class="keyword">fetch</span>表中总行数依然可以打印出来，一旦<span class="keyword">fetch</span>大于表中的总行数则进行报错；</span><br><span class="line"></span><br><span class="line"># 通过<span class="keyword">fetch</span>一行一行进行抓取记录编写的效率十分低；</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> pro_test11();</span><br><span class="line"><span class="keyword">delimiter</span> ;</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-循环获取游标"><a href="#存储过程-语法-循环获取游标" class="headerlink" title="存储过程 - 语法 - 循环获取游标"></a>存储过程 - 语法 - 循环获取游标</h2><blockquote><p>循环当中，游标的fetch退出判断</p></blockquote><p>1） count(*) into num;  num –<br>2） mysql存在机制，变量，通过改变该变量取值状态及退出fetch  </p><p>示例：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delimiter</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test12()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> e_id <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line">    decalre e_name <span class="type">varchar</span>(<span class="number">50</span>);</span><br><span class="line">    decalre e_age <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line">    decalre e_salary <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">declare</span> has_data <span class="type">int</span> <span class="keyword">default</span> <span class="number">1</span>;#当has_data为<span class="number">1</span>时表示还有数据；当has_data为<span class="number">0</span>时表示没有数据</span><br><span class="line"></span><br><span class="line">    <span class="keyword">declare</span> emp_result <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="keyword">EXIT</span> <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">NOT</span> <span class="built_in">FOUND</span> <span class="keyword">set</span> has_data=<span class="number">0</span>;#退出当前游标指向程序并设置has_data为<span class="number">0</span>；此为mysql提供的一种机制；同时该句话需要声明在声明游标的下方；当游标进行<span class="keyword">fetch</span>获取不到数据的时候，此时会进行触发；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> emp_reuslt;</span><br><span class="line"></span><br><span class="line">    repeat</span><br><span class="line">        <span class="keyword">fetch</span> emp_result <span class="keyword">into</span> e_id,e_name,e_age,e_salary;</span><br><span class="line">        <span class="keyword">select</span> concat(<span class="string">'id为：'</span> , e_id,<span class="string">', 名字为: '</span> , e_name , <span class="string">', 年龄为：'</span> , e_age , <span class="string">', 薪资为：'</span> , e_salary);</span><br><span class="line">        <span class="keyword">until</span> has_data=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span> repeat;</span><br><span class="line">    <span class="keyword">close</span> emp_result;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> pro_test12()$</span><br><span class="line"></span><br><span class="line"><span class="keyword">delimiter</span> ;</span><br></pre></td></tr></table></figure><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><p>语法结构：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION function_name([ param<span class="built_in"> type </span><span class="built_in">..</span>. ])</span><br><span class="line">RETURNS type</span><br><span class="line">BEGIN</span><br><span class="line">    <span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>案例：<br>定义一个存储过程，请求满足条件的总记录数：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delimiter</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> count_city(countryId <span class="type">int</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="type">int</span> # 此处不需要分号</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> cnum <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> count(*) <span class="keyword">into</span> cnum <span class="keyword">from</span> city <span class="keyword">where</span> country_id = countryId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnum;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">delimiter</span> ;</span><br><span class="line"></span><br><span class="line"># 存储过程虽然没有返回值；但是依然可以返回结果；因为其参数列表当中有<span class="keyword">in</span>、<span class="keyword">out</span>（返回值）、<span class="keyword">inout</span>；存储函数能做的事情；存储过程也可以做；</span><br></pre></td></tr></table></figure><blockquote><p>调用存储函数命令</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> count_city(<span class="number">1</span>)$</span><br><span class="line"><span class="keyword">select</span> count_city(<span class="number">2</span>)$</span><br></pre></td></tr></table></figure><blockquote><p>删除存储函数命令</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop <span class="keyword">function</span> <span class="title">count_city$</span></span><br></pre></td></tr></table></figure><h2 id="触发器-介绍"><a href="#触发器-介绍" class="headerlink" title="触发器 - 介绍"></a>触发器 - 介绍</h2><p>触发器是与表有关的数据库对象，指的是在insert、update、delete之前或者之后，触发并执行触发器中定义的SQL语句集合，触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作；  </p><p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。<br>现在触发器还只支持行级触发，不支持语句级触发。  </p><table>  <tr>    <th>触发器类型</th>    <th>NEW和OLD的使用</th>  </tr>  <tr>    <td>INSERT型触发器</td>    <td>NEW表示将要或者已经新增的数据</td>  </tr>  <tr>    <td>UPDATE型触发器</td>    <td>OLD表示修改之前的数据，NEW表示将要或者已经修改后的数据</td>  </tr>  <tr>    <td>DELETE型触发器</td>    <td>OLD表示将要或者已经删除的数据</td>  </tr></table><h2 id="触发器-创建及应用"><a href="#触发器-创建及应用" class="headerlink" title="触发器 - 创建及应用"></a>触发器 - 创建及应用</h2><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>语法结构：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">before</span>/<span class="keyword">after</span> <span class="keyword">insert</span>/<span class="keyword">update</span>/<span class="keyword">delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># before 在...之前/after 在...之后</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">on</span> tb1_name</span><br><span class="line"></span><br><span class="line">[ <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> ] <span class="comment">-- 当前操作的是一个行级触发器;oracle数据库当中既有行级触发器也有语句级的触发器；而mysql数据库当中只支持行级触发器现还不支持语句级触发器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  trigger_stmt;<span class="comment">--触发的内容</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>需求：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过触发器记录 emp表的数据变更日志，包含新增、修改、删除；</span><br></pre></td></tr></table></figure><p>示例：  </p><p>首先创建一张日志表:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp_logs(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    operation <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'操作类型，insert/update/delete'</span>,</span><br><span class="line">    operate_time datatime <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'操作时间'</span>,</span><br><span class="line">    operate_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'操作表的id'</span>,</span><br><span class="line">    operate_params <span class="built_in">varchar</span>(<span class="number">500</span>) <span class="keyword">comment</span> <span class="string">'操作参数'</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="string">'id'</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>$</span><br></pre></td></tr></table></figure><p>创建insert性触发器，完成插入数据时的日志记录；  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELIMITER</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">trigger</span> emp_logs_insert_trigger</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> emp</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(</span><br><span class="line">      <span class="keyword">null</span>,<span class="string">'insert'</span>,now(),<span class="built_in">new</span>.id,concat( <span class="string">'插入后 ( id：'</span>, <span class="built_in">new</span>.id , <span class="string">', name: '</span> , <span class="built_in">new</span>.name , <span class="string">' ,  age: '</span> ,  <span class="built_in">new</span>.age , <span class="string">' , salary: '</span> , <span class="built_in">new</span>.salary , <span class="string">')'</span>)</span><br><span class="line">    );</span><br><span class="line">    # 此处的<span class="built_in">new</span>.id即新插入emp表中数据的记录的id，即emp当中的id字段；</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,<span class="type">name</span>,age,salary) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">'光明左使'</span>,<span class="number">30</span>,<span class="number">3500</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp$</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_logs$</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,<span class="type">name</span>,age,salary) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">'光明右使'</span>,<span class="number">35</span>,<span class="number">3800</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">trigger</span> emp_logs_update_trigger</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">on</span> emp</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(</span><br><span class="line">      <span class="keyword">null</span>,<span class="string">'update'</span>,now(),<span class="built_in">new</span>.id,</span><br><span class="line">      concat( </span><br><span class="line">        <span class="string">'修改前 ( id：'</span>, <span class="built_in">old</span>.id ,</span><br><span class="line">        <span class="string">',name: '</span> , <span class="built_in">old</span>.name ,</span><br><span class="line">        <span class="string">',age: '</span> ,  <span class="built_in">old</span>.age ,</span><br><span class="line">        <span class="string">',salary: '</span> , <span class="built_in">old</span>.salary ,</span><br><span class="line">        <span class="string">') 修改后( id：'</span>, <span class="built_in">new</span>.id ,</span><br><span class="line">        <span class="string">',name: '</span> , <span class="built_in">new</span>.name ,</span><br><span class="line">        <span class="string">',age: '</span> ,  <span class="built_in">new</span>.age ,</span><br><span class="line">        <span class="string">',salary: '</span> , <span class="built_in">new</span>.salary ,</span><br><span class="line">        <span class="string">')'</span>  </span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    # 此处的<span class="built_in">new</span>.id即新插入emp表中数据的记录的id，即emp当中的id字段；</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> age=<span class="number">39</span> <span class="keyword">where</span> id=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp$</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_logs$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">trigger</span> emp_logs_delete_trigger</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> emp</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(</span><br><span class="line">      <span class="keyword">null</span>,<span class="string">'delete'</span>,now(),<span class="built_in">old</span>.id,</span><br><span class="line">      concat(</span><br><span class="line">        <span class="string">'删除前( id：'</span>, <span class="built_in">old</span>.id ,</span><br><span class="line">        <span class="string">',name: '</span> , <span class="built_in">old</span>.name ,</span><br><span class="line">        <span class="string">',age: '</span> ,  <span class="built_in">old</span>.age ,</span><br><span class="line">        <span class="string">',salary: '</span> , <span class="built_in">old</span>.salary ,</span><br><span class="line">        <span class="string">')'</span>  </span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp$</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_logs$</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp$</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_logs$</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELIMITER</span> ;</span><br></pre></td></tr></table></figure><h2 id="触发器-查看及删除"><a href="#触发器-查看及删除" class="headerlink" title="触发器 - 查看及删除"></a>触发器 - 查看及删除</h2><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><p>语法结构：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> [ <span class="built_in">schema_name</span>.] trigger_name</span><br></pre></td></tr></table></figure><p>如果没有指定schema_name，默认为当前数据库。</p><h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h3><p>可以通过执行SHOW TRIGGERS 命令查看触发器的状态、语法等信息。<br>语法结构：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br><span class="line"></span><br><span class="line"># Event 触发器监听的事件 <span class="keyword">INSERT</span>/<span class="keyword">UPDATE</span>/<span class="keyword">DELETE</span></span><br><span class="line"># <span class="keyword">Table</span> 对于哪一张表监听的触发器</span><br><span class="line"># <span class="keyword">Timing</span> 触发器是前置触发<span class="keyword">BEFORE</span>还是后置触发<span class="keyword">AFTER</span></span><br><span class="line"># <span class="keyword">Statement</span> 触发器定义</span><br></pre></td></tr></table></figure><h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><blockquote><p>Mysql高级-day02</p></blockquote><p>1） MySql的体系结构概览（MySQL内部原理，内部执行流程有一个认识）<br>2） 存储引擎（InnoDB以及MyISAM）<br>3） 优化SQL步骤（从哪些方面以及参考指标）<br>4） 索引的使用（在SQL优化中如何使用）<br>5） SQL优化  </p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="MySQL的体系结构概览"><a href="#MySQL的体系结构概览" class="headerlink" title="MySQL的体系结构概览"></a>MySQL的体系结构概览</h3><p>MySQL的体系结构图和在进行Web开发的三层架构是相类似的；  </p><p>Web开发时的三层架构：<br>（1）前端发起请求先到达controller；<br>（2）controller调service；service调用dao;<br>（3）dao再去访问数据库；  </p><p>mysql的体系结构当中，首先最上面的部分Connectors实际上代表的就相当于是客户端；<br>在客户端连接当中Natice C API，JDBC，ODBC,.NET，PHP,Perl，Python，Ruby，Cobol这些个；<br>JDBC就很熟悉了；在Java程序当中可以通过JDBC来进行操作mysql；<br>所以最上面部分即mysql连接的客户端通过JDBC来进行操作；<br>然后紧接着中层即MySQL Server；  </p><p>MySQL Server当中最上面一层即Connection Pool连接池；在连接池当中有很多的组件模块Authentication、Thread Reuse、Connection Limits、Check Memory、Caches；<br>也就是客户端发起一个连接；<br>这个连接就会到MySQL Server的这个Connection Pool连接池当中来进行获取一个连接来执行对应的请求；<br>当然，在MySQL Server的Connection Pool进行获取连接的时候还需要进行认证、连接最大数、缓存等相关操作；<br>此为MySQL Server的第一层连接层；<br>连接层主要负责的就是客户端发起一个请求，<br>MySQL Server接收到这个请求之后，开启一段线程进行与客户端请求相关的操作；<br>这是连接层；  </p><p>MySQL Server当中的第二层即Management Services &amp; Utillties、SQL Interface、Parser、Optimizer、Caches &amp; Buffers 这一部分；<br>MySQL Server第二层当中有很多的组件；<br>其中第一个（第一个模块）即MySQL的管理服务以及一些工具；管理层Management Services当中可以进行数据的备份与恢复以及集群安全以及系统配置相关的内容（Backup &amp; Recovery，Security，Replication，Cluster，Administrator，Configuration，Migration &amp; Metadata）<br>第二层的第二个模块：SQL Interface即SQL的一个接口，在此当中可以去进行执行或者是去封装DML、DDL语句以及存储过程、存储函数、视图、触发器等等相关数据库对象（DML、DDL、Stored Procedures，Views ，Triggers ，etc.）</p><p>第二层的第三个模块即：Parser，Parser就是一个解析器，这个解析器解析的是客户端发起的一个请求，客户端发起的这个请求就是SQL语句，SQL语句需要经过这个解析器Parser的解析，解析之后并且在这一块进行相关的过滤（Query Translation,Object Privilege）  </p><p>解析完成之后，在MySQL的内部还需要几个过程；<br>第二层的第四个模块：Optimizer，这个过程实际上称作优化器；即在解析完成了前端请求过来的SQL语句并进行相关的过滤之后，MySQL内部还须要通过其内部的一个优化器，对前端请求来的SQL语句解析并过滤后进行一个优化处理；MySQL内部会按照其内部自己的一个优化体系来进行优化（Access Paths，Statistics）  </p><p>当优化完成之后，接下来还需要进行缓存的一个操作：<br>第二程的第五个模块：Caches &amp; Buffers，即查询在缓存当中有没有要查询的数据；如果存在有对应的树据信息，那么这个时候可能就直接返回给前端客户端了；（Global and Engine ，Specific Caches &amp; Buffers）  </p><p>所以第二层当中的这五个模块就是MySQL的服务层操作；即将前端请求的SQL语句进行封装起来并且进行解析以及相关过滤，以及对其进行优化，最终还需要操作MySQL当中的缓存区的信息；  </p><p>MySQL Server的第三层：Pluggable Storage Engines(Memory，Index &amp; Storage Management)，此处实际指的是存储引擎；<br>Pluggable插件式的存储引擎；<br>以下是MySQL当中的存储引擎:<br>（MyISAM、InnoDB、NDB、Archive、Federated、Memory、Merge、Partner、Community、Custom ….）<br>MySQL版本5.5之后默认的存储引擎即为InnoDB；<br>引擎：发动机；<br>存储引擎是什么？（与飞机上的引擎比较类似，比如客机则有客机的引擎，客机即运送乘客、旅客；但是还有对应的货机，那么货机即对应的即运输货物的；还有直升机等等；不同的飞机有不同的飞机引擎；不同的飞机引擎在相对应的机型当中都发挥着不同的作用；在操作的时候需要考虑到，用户是什么，然后去考虑更适合哪一种引擎，对应的发动机；同样对于mysql的存储引擎是一个道理；存储引擎则需要根据存储的数据不同或者是需求不同而选择不同的存储引擎来进行存储不同的数据；）<br>MySQL Server的第三层为存储引擎层；  </p><p>MySQL Server的第四层即存储层：File system（NTFS，ufs，ext2/3，NFS，SAN，NAS）<br>Files &amp; Logs（Redo，Undo，Data，Index，Binary，Error，Query and Slow）<br>在操作MySQL数据库中表当中的数据的时候，不管是插入还是查询或者修改删除等操作；实际上最终都是操作的File system即文件系统；最终操作的都是文件系统当中的文件；而这个文件系统即就处于磁盘当中；所以最下面一层就文件系统；最重要操作的也就是文件系统；除了在表结构当中的数据，还有对应的索引信息、二进制错误、查询、慢查询日志等；  </p><p>此为MySQL体系结构当中的四层；  </p><p>第一层连接层；负责接收客户端的发送的请求；然后MySQL Server开启一段线程进行相关的认证授权之后再来进行请求的处理；<br>第二层服务层：服务层在主要起到备份恢复、SQL封装、解析过滤、SQL语句优化、缓存查询等相关操作；<br>第三层存储引擎层，选择合适的存储引擎对相关数据进行相关的处理；<br>第四层文件系统：当第三层的数据进行相关的处理完成之后，则需要将数据最终写入文件系统当中，即实际的物理磁盘当中；</p><p>整个MySQL由以下组成：  </p><ul><li>Connection Pool：连接池组件</li><li>Management Service &amp; Utillties: 管理服务和工具组件</li><li>SQL Interface: SQL接口组件</li><li>Parser: 查询分析器组件</li><li>Optimizer: 优化器组件</li><li>Caches &amp; Buffers: 缓冲池组件</li><li>Pluggable Storage Engines: 存储引擎</li><li>File System: 文件系统</li></ul><ol><li>连接层<br>最上层是一些客户和连接服务，包含本地socket通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。<br>主要完成一些类似于连接处理、授权认证、以及相关的安全方案。<br>在该层上引入了线程池的概念，未通过认证安全接入的客户端提供线程。<br>同样在该层上可以实现基于SSL的安全连接，服务器也会为安全接入的每个客户端验证它所具有的的操作权限；  </li><li>服务层<br>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。<br>所有跨存储引擎的功能也在这一层实现，如过程、函数等。<br>在该层，服务器会解析查询并创建相应的内部解析树，并对其完成响应的优化如确定表的查询顺序，是否利用索引等，最后生成响应的执行操作。<br>如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。  </li><li>引擎层<br>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。<br>不同的存储引擎具有不同的功能，这样可以根据自己的需要，来选取合适的存储引擎；  </li><li>存储层<br>数据存储层，主要是将数据存储在文件系统之上，并完成与存储引擎的交互；  </li></ol><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。<br>主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。<br>这种架构可以根据业务的需求和实际需要选择合适的存储引擎；  </p><h2 id="存储引擎-概述"><a href="#存储引擎-概述" class="headerlink" title="存储引擎 - 概述"></a>存储引擎 - 概述</h2><p>和大多数的数据库不同，MySQL中有一个存储引擎的概念，针对不同的存储需求可以选择最优的存储引擎；<br>存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式。<br>存储引擎是基于表的，而不是基于库的。<br>索引存储引擎也可被称为表类型。<br>Oracle、SQLServer等数据库只有一种存储引擎。<br>MySQL提供了插件式的存储引擎架构。<br>索引MySQl存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。<br>MySQL5.0支持的存储引擎包含：InnoDB、MyISAM、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供食物安全表，其他存储引擎是非事务安全表；<br>可以通过指定 show engines，来进行查询当前数据库支持的存储引擎；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br></pre></td></tr></table></figure><p>创建新表时，如果不指定存储引擎，那么系统就会使用默认的存储引擎。<br>MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为InnoDB；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p <span class="comment">#连接mysql</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br><span class="line"><span class="comment"># Engine 存储引擎的名字</span></span><br><span class="line"><span class="comment"># Support 是否支持该存储引擎，YES/NO/DEFAULT，DEFAULT默认，默认支持的存储引擎InnoDB</span></span><br><span class="line"><span class="comment"># comment 注释</span></span><br></pre></td></tr></table></figure><blockquote><p>Comment注释</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyISAM : MyISAM <span class="keyword">storage</span> engines</span><br><span class="line">MRG_MYISAM : COLLECTION <span class="keyword">OF</span> IDENTICAL MyISAM <span class="keyword">tables</span></span><br><span class="line">MEMORY : Hash based,stored <span class="keyword">in</span> memory,useful <span class="keyword">for</span> <span class="keyword">temporary</span> <span class="keyword">tables</span></span><br><span class="line">BLACKHOLE : /dev/<span class="keyword">null</span> <span class="keyword">storage</span> engine (anything you wirte <span class="keyword">to</span> it disappears)</span><br><span class="line">CSV : CSV <span class="keyword">storage</span> engine</span><br><span class="line">PERFIRMANCE_SCHEMA : Performance <span class="keyword">Schema</span></span><br><span class="line">ARCHIVE : Archive <span class="keyword">storage</span> engine</span><br><span class="line">FEDERATED ： Federated MySQL <span class="keyword">storage</span> engine</span><br><span class="line">InnoDB ： Support <span class="keyword">transaction</span>,<span class="keyword">row</span>-<span class="keyword">level</span> locking, <span class="keyword">and</span> <span class="keyword">foreign</span> keys # 支持事务，支持行级锁并且支持外键</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看数据库当中的词汇？</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%storage_engine%'</span>;</span><br><span class="line"></span><br><span class="line">default_storage_engine InnoDB</span><br><span class="line">default_tmp_storage_engine InnoDB</span><br><span class="line">storage_engine InnoDB</span><br></pre></td></tr></table></figure><h2 id="存储引擎-特性"><a href="#存储引擎-特性" class="headerlink" title="存储引擎 - 特性"></a>存储引擎 - 特性</h2><p>下面重点介绍几种常用的存储引擎，并对比各个存储引擎之间的区别，如下表所示：  </p><table>    <tr>      <th>特点</th>      <th style="background-color:lightblue;color:red;font-weight:bolder;">InnoDB</th>      <th style="background-color:lightblue;color:red;font-weight:bolder;">MyISAM</th>      <th>MEMORY</th>      <th>MERGE</th>      <th>NDB</th>    </tr>    <tr>      <td>存储限制</td>      <td>64TB</td>      <td>有</td>      <td>有</td>      <td>没有</td>      <td>有</td>    </tr>    <tr>      <td style="background-color:lightblue;color:red;font-weight:bolder;">事务安全</td>      <td>支持</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td style="background-color:lightblue;color:red;font-weight:bolder;">锁机制</td>      <td style="background-color:lightgreen;color:red;font-weight:bolder;">行锁（适合高并发）</td>      <td style="background-color:lightgreen;color:red;font-weight:bolder;">表锁</td>      <td>表锁</td>      <td>表锁</td>      <td>行锁</td>    </tr>    <tr>      <td>B树索引</td>      <td>支持</td>      <td>支持</td>      <td>支持</td>      <td>支持</td>      <td>支持</td>    </tr>    <tr>      <td>哈希索引</td>      <td>（当前我看到的是支持的）</td>      <td></td>      <td>支持</td>      <td></td>      <td></td>    </tr>    <tr>      <td>全文索引</td>      <td>支持（5.6版本之后）</td>      <td>支持</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>集群索引</td>      <td>支持</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>数据索引</td>      <td>支持</td>      <td></td>      <td>支持</td>      <td></td>      <td>支持</td>    </tr>     <tr>      <td>索引缓存</td>      <td>支持</td>      <td>支持</td>      <td>支持</td>      <td>支持</td>      <td>支持</td>    </tr> <tr>      <td>数据可压缩</td>      <td></td>      <td>支持</td>      <td></td>      <td></td>      <td></td>    </tr> <tr>      <td>空间使用</td>      <td>高</td>      <td>低</td>      <td>N/A</td>      <td>低</td>      <td>低</td>    </tr> <tr>      <td>内存使用</td>      <td>高</td>      <td>低</td>      <td>中等</td>      <td>低</td>      <td>高</td>    </tr>     <tr>      <td>批量插入速度</td>      <td>低</td>      <td>高</td>      <td>高</td>      <td>高</td>      <td>高</td>    </tr>     <tr>      <td style="background-color:lightblue;color:red;font-weight:bolder;">支持外键</td>      <td style="background-color:lightgreen;color:red;font-weight:bolder;">支持</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr></table><p>下面将重点介绍最常使用的两种存储引擎：InnoDB、MyISAM，另外两种MEMORY、MERGE，了解即可；  </p><h2 id="存储引擎-InnoDB特性"><a href="#存储引擎-InnoDB特性" class="headerlink" title="存储引擎 - InnoDB特性"></a>存储引擎 - InnoDB特性</h2><p>InnoDB存储引擎是MySQL的默认存储引擎。<br>InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。<br>但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引；  </p><p>InnoDB存储引擎不同于其他存储引擎的特点：  </p><p><strong>事务控制</strong></p><p>MySQL 当中事务默认自动提交；  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create database demo_02<span class="built_in"> default </span><span class="attribute">charset</span>=utf8mb4;  </span><br><span class="line">use demo_01;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table goods_innodb(</span><br><span class="line">  id int(11) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  name varchar(20) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  primary key(id)</span><br><span class="line">)<span class="attribute">ENGINE</span>=innodb<span class="built_in"> default </span><span class="attribute">charset</span>=utf8;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods_innodb(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'Meta20'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;<span class="comment"># 如不提交，则其他客户端无法查看得到插入的数据；</span></span><br><span class="line"><span class="comment"># MySQL默认的隔离级别为可重复读</span></span><br></pre></td></tr></table></figure><p><strong>外键约束</strong></p><p>MySQL支持外键的存储引擎只有InnoDB，在创建外键的时候，要求父表必须有对应的索引，子表在创建索引的时候，也会自动的创建对应的索引；<br>下面两张表中，<br>1） country_innodb是父表，country_id为主键索引；<br>2） city_innodb是子表，country_id字段为外键，对应于country_innodb表中的主键country_id；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> country_innodb(</span><br><span class="line">  country_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  counry_name <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span> ,</span><br><span class="line">  primary <span class="keyword">key</span> (country_id)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> city_innodb(</span><br><span class="line">  city_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  city_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  country_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  primary <span class="keyword">key</span> (city_id),</span><br><span class="line">  <span class="keyword">key</span> idx_fk_country_id(country_id),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">'fk_city_contry'</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(country_id) <span class="keyword">REFERENCES</span> country_innodb(country_id) <span class="keyword">ON</span> DFLETE RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ON DELETE RESTRICT 在删除主表数据时，如果有关联记录则不删除</span></span><br><span class="line"><span class="comment"># ON UPDATE CASCADE 更新主表时，如果子表有关联记录，则更新子表记录  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> country_innodb <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'China'</span>),(<span class="literal">null</span>,<span class="string">'America'</span>),(<span class="literal">null</span>,<span class="string">'Japan'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> city_innodb <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'Xian'</span>,<span class="number">1</span>),(<span class="literal">null</span>,<span class="string">'NewYork'</span>,<span class="number">2</span>),(<span class="literal">null</span>,<span class="string">'BeiJing'</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在创建索引时，可以指定在删除、更新父表时，对子表进行的相应操作，包括RESTRICT、CASCADE、SET NULL和NO ACTION。<br>RESTRICT和NO ACTION相同，是指限制在子表有关联记录的情况下，父表不能更新；<br>CASCADE表示父表在更新或者删除时，更新或者删除子表对应的记录；<br>SET NULL则表示父表在更新或者删除的时候，子表对应字段被SET NULL。<br>针对上面创建的两个表，子表在外键指定是ON DELETE RESTRICT ON UPDATE CASCADE方式的，那么在主表删除记录的时候，如果子表有对应记录，则不允许删除。主表在更新记录的时候，如果子表有对应记录，则子表也会对应更新；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> country_innodb;<span class="comment">#主表</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> city_innodb;<span class="comment">#子表；子表当中的外键country_id指向主表country_innodb当中的主键country_id</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> country_innodb <span class="keyword">where</span> country_id=<span class="number">2</span>;</span><br><span class="line"><span class="comment">#此处由于外键关联，所以导致删除报错，无法更新；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> country_innodb <span class="keyword">set</span> country_id=<span class="number">100</span> <span class="keyword">where</span> country_id=<span class="number">1</span>;</span><br><span class="line"><span class="comment">#此时子表当中关联有1；那么说则刚才的子表当中对应country_id也为1 的记录将会进行相应的更新；  </span></span><br><span class="line">查看主表以及子表：  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> country_innodb;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> city_innodb;</span><br></pre></td></tr></table></figure><p><strong>存储方式</strong></p><p>存储方式实际上指的是InnoDB这个存储引擎对应的表在数据库当中以数据文件的存储方式；<br>InnoDB存储表和索引有以下两种方式：  </p><ol><li>使用共享表空间存储，这种方式创建的表的表结构保存在.frm文件中，数据和索引保存在 innodb_data_home_dir和innodb_data_file_path定义的表空间中，可以是多个文件；  </li><li>使用多表空间存储，这种方式存储的表的表结构仍然存在.frm文件中，但是每个表的数据和索引单独保存在.ibd中；</li></ol><h2 id="存储引擎-MyISAM特性"><a href="#存储引擎-MyISAM特性" class="headerlink" title="存储引擎 - MyISAM特性"></a>存储引擎 - MyISAM特性</h2><p>MyISAM不支持事务，也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表，有以下两个比较重要的特点：  </p><p><strong>不支持事务</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> goods_myisam(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">engine</span>=myisam <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods_myisam <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'电脑3'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><p>通过测试可以发现，在MyISAM存储引擎中，是没有事务控制的；  </p><p><strong>文件存储方式</strong></p><p>每个MyISAM在磁盘上存储成3个文件，其文件名都和表明相同，但拓展名称分别是：</p><ul><li>.frm (存储表定义)</li><li>.MYD (MYData，存储数据)</li><li>.MYI (MYIndex，存储索引)</li></ul><h2 id="存储引擎-Memory与Merge特性"><a href="#存储引擎-Memory与Merge特性" class="headerlink" title="存储引擎 - Memory与Merge特性"></a>存储引擎 - Memory与Merge特性</h2><p>Memory（内存）存储引擎将表的数据放在内存中。<br>每个MEMORY表实际对应一个磁盘文件，格式是.frm，改文件中只存储表的数据结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表达效率。<br>MEMORY类型的表访问非常的快，因为他的数据是存放在内存中的，并且默认使用HASH索引，但是服务一旦关闭，表中的数据就会丢失；  </p><p>MERGE（合并）存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的；  </p><p>对于MERGE类型表的插入操作是通过INSERT_METHOD子句定义插入的表，可以有三个不同的值，使用FIRST或者LAST值使得插入操作被相应的作用在第一或者是最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作；  </p><p>可以对MERGE表进行DROP操作，但是这个操作知识删除MERGE表的定义，对内部的表是没有任何影响的；  </p><p>MERGE存储引擎与view视图有些类似；  </p><p>下面是一个创建和使用MERGE表的示例：<br>1）创建三个测试表 payment_2006、payment_2007、payment_all，其中payment_all是前两个表的MERGE表；</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">create table order_1990(</span><br><span class="line">  order_id int,</span><br><span class="line">  order_money double(10,2),</span><br><span class="line">  order_address varchar(50),</span><br><span class="line">  primary key (order_id)</span><br><span class="line">)<span class="attribute">engine</span>=myisam<span class="built_in"> default </span><span class="attribute">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line">create table order_1991(</span><br><span class="line">  order_id int,</span><br><span class="line">  order_money double(10,2),</span><br><span class="line">  order_address varchar(50),</span><br><span class="line">  primary key (order_id)</span><br><span class="line">)<span class="attribute">engine</span>=myisam<span class="built_in"> default </span><span class="attribute">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line">create table order_all(</span><br><span class="line">  order_id int,</span><br><span class="line">  order_money double(10,2),</span><br><span class="line">  order_address varchar(50),</span><br><span class="line">  primary key (order_id)</span><br><span class="line">)<span class="attribute">engine</span>=merge  </span><br><span class="line">union = ( order_1990, order_1991 )  </span><br><span class="line"><span class="attribute">INSERT_METHOD</span>=LAST  </span><br><span class="line">default <span class="attribute">charset</span>=utf8;</span><br></pre></td></tr></table></figure><p>2） 分别向两张表中插入记录  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1990 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">100.0</span>,<span class="string">'上海'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1990 <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">100.0</span>,<span class="string">'北京'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1991 <span class="keyword">values</span>(<span class="number">10</span>,<span class="number">100.0</span>,<span class="string">'北京'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1991 <span class="keyword">values</span>(<span class="number">11</span>,<span class="number">100.0</span>,<span class="string">'上海'</span>);</span><br></pre></td></tr></table></figure><p>3） 查询三张表当中的数据：<br>order_1990表中的数据：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> order_1990;</span><br></pre></td></tr></table></figure><p>order_1991表中的数据：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> order_1991;</span><br></pre></td></tr></table></figure><p>order_all表中的数据：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> order_all;</span><br></pre></td></tr></table></figure><h2 id="存储引擎-选择原则"><a href="#存储引擎-选择原则" class="headerlink" title="存储引擎 - 选择原则"></a>存储引擎 - 选择原则</h2><p>在选择存储引擎时，应该选择根据应用系统的特点选择合适的存储引擎。<br>对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合；<br>以下是几种常用的存储引擎的使用环境：  </p><ul><li>InnoDB<ul><li>是MySQL的默认存储引擎，用于事务处理应用程序，支持外键。</li><li>如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。  </li><li>InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定，还可以确保事务的完整提交和回滚，对于类似于计费系统或者是财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择；  </li></ul></li><li>MyISAM<ul><li>如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的；  </li></ul></li><li>MEMORY<ul><li>将所有的数据保存在内存当中RAM，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。</li><li>MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。  </li><li>MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。  </li></ul></li><li>MERGE<ul><li>用于将一些列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。</li><li>MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率，这对于存储诸如数据仓库等VLDB环境十分合适。  </li></ul></li></ul><p>有一个点：就是有没有类似emm，MERGE然后内部基层的表的存储引擎是InnoDB这种的；如果是这种的话；不是有那个什么分库分表什么的？（我不太了解分库分表，乱说的）  </p><h2 id="优化SQL步骤-SQL执行频率"><a href="#优化SQL步骤-SQL执行频率" class="headerlink" title="优化SQL步骤 - SQL执行频率"></a>优化SQL步骤 - SQL执行频率</h2><p>在应用的开发过程中，由于初期数据量小，开发人员写SQL语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据的急剧增长，很多SQL语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的SQL语句就成为整个系统性能的瓶颈，因此必须要对它们进行优化，本章将详细介绍MySQL中优化SQL语句的方法。  </p><p>当面对一个有SQL性能问题的数据库时，应该从何处入手来进行系统的分析，使得能够尽快定位问题SQL并尽快解决问题。  </p><h3 id="查看SQL执行频率"><a href="#查看SQL执行频率" class="headerlink" title="查看SQL执行频率"></a>查看SQL执行频率</h3><p>MySQL客户端连接成功后，通过 show [ session | global ] status 命令可以提供服务器状态信息。<br>show [ session | global ]status 可以根据需要加上参数 “session”或者“global”来显示session级（当前连接）的统计结果和global级（自数据库上次启动至今）的统计结果。<br>如果不写，默认使用参数是“session”。  </p><p>下面的命令显示了当前session中所有统计参数的值：</p><blockquote><p>针对数据库</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Com_______'</span>; <span class="comment"># _ 占位字符，匹配的模糊字符 查询级别为session会话级别</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Com_______'</span>; <span class="comment"># _ 匹配的模糊字符 查询级别为global全局级别</span></span><br><span class="line"></span><br><span class="line">Com_binlog</span><br><span class="line">Com_commit</span><br><span class="line">Com_delete <span class="comment">#删除的次数</span></span><br><span class="line">Com_insert <span class="comment">#插入的次数</span></span><br><span class="line">Com_repair</span><br><span class="line">Com_select <span class="comment">#查询的次数</span></span><br><span class="line">Com_revoke</span><br><span class="line">Com_signal</span><br><span class="line">Com_update <span class="comment">#修改的次数</span></span><br><span class="line">Com_xa_end</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时查询的为当前连接session的信息，并非为整个数据库全局的统计参数</span></span><br><span class="line"><span class="comment">#如果需要查询全局则：show global status like 'Com_______';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过知道当前数据库当中是以查询为主还是增删改为主；为SQL优化提供借鉴性指标</span></span><br></pre></td></tr></table></figure><p>Com_xxx表示每个xxx语句执行的次数，通常比较关心的是以下几个统计参数</p><table>  <tr>    <th>参数</th>    <th>含义</th>  </tr>  <tr>    <td>Com_select</td>    <td>执行select操作的次数，一次查询只累加1</td>  </tr>  <tr>    <td>Com_insert</td>    <td>执行INSERT操作的次数，对于批量插入的INSERT操作，只累加一次</td>  </tr>  <tr>    <td>Com_update</td>    <td>执行UPDATE操作的次数</td>  </tr>  <tr>    <td>Com_delete</td>    <td>执行DELETE操作的次数</td>  </tr>  <tr>    <td>Innodb_rows_read</td>    <td>select查询返回的行数</td>  </tr>  <tr>    <td>Innodb_rows_inserted</td>    <td>执行INSERT操作插入的行数</td>  </tr>  <tr>    <td>Innodb_rows_updated</td>    <td>执行UPDATE操作更新的行数</td>  </tr>  <tr>    <td>Innodb_rows_deleted</td>    <td>执行DELETE操作删除的行数</td>  </tr>  <tr>    <td>Connections</td>    <td>视图连接MySQL服务器的次数</td>  </tr>  <tr>    <td>Uptime</td>    <td>服务器工作时间</td>  </tr>  <tr>    <td>Slow_queries</td>    <td>慢查询的次数</td>  </tr></table><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Com_*** : 这些参数对于所有存储引擎的表操作都会进行累计</span><br><span class="line">Innodb_** : 这几个参数只是针对<span class="type">Innodb</span>存储引擎的，累加的算法也略有不同。</span><br></pre></td></tr></table></figure><blockquote><p>针对InnoDB存储引擎</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">针对于InnoDB：  </span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Innodb_rows_%'</span>;<span class="comment"># 此时查询出来的为InnoDB的各个操作所影响的行，数量</span></span><br><span class="line"></span><br><span class="line">Innodb_rows_deleted 2 <span class="comment"># 该存储引擎中删去的行数</span></span><br><span class="line">Innodb_rows_inserted 49<span class="comment"># 该存储引擎中插入的行数</span></span><br><span class="line">Innodb_rows_read 380<span class="comment"># 该存储引擎中读取的行数</span></span><br><span class="line">Innodb_rows_updated 15<span class="comment"># 更新的行数</span></span><br><span class="line"></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="keyword">use</span> demo_01l</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> goods_innodb; <span class="comment"># Innodb_rows_read此时会增加，查询出来的结果集有n条记录，则Innodb_rows_read增加n</span></span><br><span class="line"></span><br><span class="line">Innodb_rows_deleted 2 <span class="comment"># 该存储引擎中删去的行数</span></span><br><span class="line">Innodb_rows_inserted 49<span class="comment"># 该存储引擎中插入的行数</span></span><br><span class="line">Innodb_rows_read 382<span class="comment"># 该存储引擎中读取的行数</span></span><br><span class="line">Innodb_rows_updated 15<span class="comment"># 更新的行数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> goods_innodb <span class="keyword">set</span> <span class="keyword">name</span> =<span class="string">'Meta30'</span>; <span class="comment"># Innodb_rows_update此时会增加；修改影响n条记录，则Innodb_rows_update增加n;</span></span><br><span class="line"></span><br><span class="line">Innodb_rows_deleted 2 <span class="comment"># 该存储引擎中删去的行数</span></span><br><span class="line">Innodb_rows_inserted 49<span class="comment"># 该存储引擎中插入的行数</span></span><br><span class="line">Innodb_rows_read 382<span class="comment"># 该存储引擎中读取的行数</span></span><br><span class="line">Innodb_rows_updated 17<span class="comment"># 更新的行数</span></span><br></pre></td></tr></table></figure><h2 id="优化SQL步骤-定位低效SQL"><a href="#优化SQL步骤-定位低效SQL" class="headerlink" title="优化SQL步骤 - 定位低效SQL"></a>优化SQL步骤 - 定位低效SQL</h2><p>可以通过以下两种方式定位执行效率较低的SQL语句。  </p><ul><li>慢查询日志：通过慢查询日志定位那些执行效率较低的SQL语句，用–log-slow-queries[ =file_name ]选项启动时，mysqld写一个包含所有执行时间超过long_query_time秒的SQL语句的日志文件。</li><li>show processlist：慢查询日志在查询结束以后才记录，所以在应该用反映执行效率出现问题的时候查询慢日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看SQL的执行情况，同时对一些锁表操作进行优化。(实时)  </li></ul><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">show processlist;</span><br><span class="line"></span><br><span class="line"><span class="meta">#（1）id列：用户登录mysql时，系统分配的“connection_id”，可以使用函数connection_id()查看；</span></span><br><span class="line"><span class="meta">#（2）user列：显示当前用户，如果不是root，这个命令就只显示用户权限范围的sql语句；</span></span><br><span class="line"><span class="meta">#（3）host列：显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户；</span></span><br><span class="line"><span class="meta">#（4）db列：显示这个进程目前连接的是哪个数据库；</span></span><br><span class="line"><span class="meta">#（5）command列：显示当前连接的执行命令，一般取值为休眠（sleep）、查询（query）、连接（connect）等；</span></span><br><span class="line"><span class="meta">#（6）time列，显示这个状态持续的时间，单位是秒；</span></span><br><span class="line"><span class="meta">#（7）state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table， sorting result， sending data等状态才可以完成。  </span></span><br><span class="line"><span class="meta">#（8）info列，显示这个sql语句，是判断问题语句的一个重要依据。</span></span><br></pre></td></tr></table></figure><h2 id="优化SQL步骤-explain指令介绍"><a href="#优化SQL步骤-explain指令介绍" class="headerlink" title="优化SQL步骤 - explain指令介绍"></a>优化SQL步骤 - explain指令介绍</h2><p>通过以上步骤查询到效率低的SQL语句后，可以通过EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括SELECT语句执行过程中表如何连接和连接的顺序。  </p><p>查询SQL语句的执行计划：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_item</td>    <td>const</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>4</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr></table><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="built_in">title</span>=<span class="string">'阿尔卡特（OT-979）冰川白 联通3G手机3'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_item</td>    <td>ALL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>9816098</td>    <td>Using where</td>  </tr></table><table>  <tr>    <th>字段</th>    <th>含义</th>  </tr>  <tr>    <td>id</td>    <td>select查询的序列号，是一组数字，表示的是查询中select子句或者是操作表的顺序。（与表结构执行的顺序有关系）</td>  </tr>  <tr>    <td>select_type</td>    <td>表示SELECT的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者是子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个SELECT）等</td>  </tr>  <tr>    <td>table</td>    <td>输出结果集的表（当前输出的数据与哪一张表有关）</td>  </tr>  <tr>    <td>type</td>    <td>表示表的连接类型，性能由好到差的连接类型为（system---->const---->eq_ref------>ref------->ref_or_null------>index_merge------>index_subquery------->range------>index------>all）</td>  </tr>  <tr>    <td>possible_keys</td>    <td>表示查询时，可能使用的索引。</td>  </tr>  <tr>    <td>key</td>    <td>表示实际使用的索引</td>  </tr>  <tr>    <td>key_len</td>    <td>索引字段的长度</td>  </tr>  <tr>    <td>ref</td>    <td>引用</td>  </tr>  <tr>    <td>rows</td>    <td>扫描行的数量</td>  </tr>  <tr>    <td>extra</td>    <td>执行情况的说明和描述，额外的内容，前面几个字段当中没有表述清楚的，在这个字段当中表述出来</td>  </tr></table><blockquote><p>explain 用来查看SQL语句的执行计划。</p></blockquote><h2 id="优化SQL步骤-explain之id"><a href="#优化SQL步骤-explain之id" class="headerlink" title="优化SQL步骤 - explain之id"></a>优化SQL步骤 - explain之id</h2><p><strong>环境准备</strong></p><p>用户表、角色表、用户角色表（多对多关系）  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">'t_role'</span>(</span><br><span class="line">  <span class="string">'id'</span> varchar(32) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'role_name'</span> varchar(255)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'role_code'</span> varchar(255)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'description'</span> varchar(255)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">'id'</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">'union_role_name'</span> (<span class="string">'role_name'</span>)</span><br><span class="line">)<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE <span class="string">'t_user'</span>(</span><br><span class="line">  <span class="string">'id'</span> varchar(32) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'username'</span> varchar(45)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'name'</span> varchar(45)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'password'</span> varchar(96)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">'id'</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">'union_user_username'</span> (<span class="string">'user_name'</span>)</span><br><span class="line">)<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE <span class="string">'user_role'</span>(</span><br><span class="line">  <span class="string">'id'</span> int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> autoincrement,</span><br><span class="line">  <span class="string">'user_id'</span> varchar(32)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'role_id'</span> varchar(32)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">'id'</span>),</span><br><span class="line">  KEY <span class="string">'fk_ur_user_id'</span>(<span class="string">'user_id'</span>),</span><br><span class="line">  KEY <span class="string">'fk_ur_role_id'</span>(<span class="string">'role_id'</span>),</span><br><span class="line">  CONSTRAINT <span class="string">'fk_ur_role_id'</span> FOREIGN KEY (<span class="string">'role_id'</span>) REFERENCES <span class="string">'t_role'</span> (<span class="string">'id'</span>) ON DELETE <span class="literal">NO</span> ACTION ON UPDATE <span class="literal">NO</span> ACTION,</span><br><span class="line">  CONSTRAINT <span class="string">'fk_ur_user_id'</span> FOREIGN KEY (<span class="string">'user_id'</span>) REFERENCES <span class="string">'t_user'</span> (<span class="string">'id'</span>) ON DELETE <span class="literal">NO</span> ACTION ON UPDATE <span class="literal">NO</span> ACTION</span><br><span class="line">)<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入用戶数据</span></span><br><span class="line">insert into <span class="string">'t_user'</span>(<span class="string">'id'</span>,<span class="string">'username'</span>,<span class="string">'password'</span>,<span class="string">'name'</span>) values(<span class="string">'1'</span>,<span class="string">'老王'</span>,<span class="string">'xxxxxyyyyyyy'</span>,<span class="string">'超级管理员'</span>);</span><br><span class="line">insert into <span class="string">'t_user'</span>(<span class="string">'id'</span>,<span class="string">'username'</span>,<span class="string">'password'</span>,<span class="string">'name'</span>) values(<span class="string">'2'</span>,<span class="string">'老李'</span>,<span class="string">'xxxxxyyyyyyyzzzzz'</span>,<span class="string">'系统管理员'</span>);</span><br><span class="line">insert into <span class="string">'t_user'</span>(<span class="string">'id'</span>,<span class="string">'username'</span>,<span class="string">'password'</span>,<span class="string">'name'</span>) values(<span class="string">'3'</span>,<span class="string">'老头子'</span>,<span class="string">'xxxxxyyyytyyyzzzzz'</span>,<span class="string">'学生1'</span>);</span><br><span class="line">insert into <span class="string">'t_user'</span>(<span class="string">'id'</span>,<span class="string">'username'</span>,<span class="string">'password'</span>,<span class="string">'name'</span>) values(<span class="string">'4'</span>,<span class="string">'老婆子'</span>,<span class="string">'xxxxxyywyyyyyzzzzz'</span>,<span class="string">'学生2'</span>);</span><br><span class="line">insert into <span class="string">'t_user'</span>(<span class="string">'id'</span>,<span class="string">'username'</span>,<span class="string">'password'</span>,<span class="string">'name'</span>) values(<span class="string">'5'</span>,<span class="string">'super'</span>,<span class="string">'xxxxxyyfyyyyyzzzzz'</span>,<span class="string">'学生3'</span>);</span><br><span class="line">insert into <span class="string">'t_user'</span>(<span class="string">'id'</span>,<span class="string">'username'</span>,<span class="string">'password'</span>,<span class="string">'name'</span>) values(<span class="string">'6'</span>,<span class="string">'admin'</span>,<span class="string">'xxxxxyyyyyyyzzzzze'</span>,<span class="string">'学生4'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入角色数据</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"><span class="comment"># 插入用户角色数据</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><p><strong>explain当中的id字段</strong></p><p>id字段是select查询的序号(并不是自增，控制表结构的执行顺序)，是一组数字，表示是的是处查询中执行select子句或者是操作表的顺序，id情况有三种：<br>（1）<strong>id相同表示加载表的顺序是从上到下</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_role r,t_user u,user_role ur <span class="keyword">where</span> r.id=ur.role_id <span class="keyword">and</span> u.id=ur.user_id;<span class="comment"># 多表联查</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>r</td>    <td>PRIMARY</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>5</td>    <td>NULL</td>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>ur</td>    <td>ref</td>    <td>fk_ur_user_id,fk_ur_role_id</td>    <td>fk_ur_role_id</td>    <td>99</td>    <td>db03.r.id</td>    <td>1</td>    <td>Using where</td>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>u</td>    <td>eq_ref</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>98</td>    <td>db.ur.user_id</td>    <td>1</td>    <td>NULL</td>  </tr></table><p>（2）<strong>id不同id值越大，优先级越高，越先被执行</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_role <span class="keyword">WHERE</span> <span class="keyword">id</span>=</span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> role_id <span class="keyword">FROM</span> user_role <span class="keyword">WHERE</span> user_id=</span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> username=<span class="string">'stu1'</span></span><br><span class="line">  )</span><br><span class="line">)<span class="comment"># 嵌套子查询</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>t_role</td>    <td>const</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>98</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>2</td>    <td>SUBQUERY</td>    <td>user_role</td>    <td>ref</td>    <td>fk_ur_user_id</td>    <td>fk_ur_user_id</td>    <td>99</td>    <td>const</td>    <td>1</td>    <td>Using where</td>  </tr>  <tr>    <td>3</td>    <td>SUBQUERY</td>    <td>t_user</td>    <td>const</td>    <td>unique_user_username</td>    <td>unique_user_username</td>    <td>137</td>    <td>const</td>    <td>1</td>    <td>Using index</td>  </tr></table><p>（3）<strong>id有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_role r,</span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_role ur <span class="keyword">WHERE</span> ur.<span class="string">'user_id'</span>=<span class="string">'2'</span></span><br><span class="line">) a  </span><br><span class="line"><span class="keyword">WHERE</span> r.id=a.role_id;  </span><br><span class="line"><span class="comment">#三表查询又连接了一个子查询</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>< derived2></td>    <td>ALL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>2</td>    <td>Using where</td>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>r</td>    <td>eq_ref</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>98</td>    <td>a.role_id</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>2</td>    <td>DERIVED</td>    <td>ur</td>    <td>ref</td>    <td>fk_ur_user_id</td>    <td>fk_ur_user_id</td>    <td>99</td>    <td>const</td>    <td>1</td>    <td>Using index condition</td>  </tr></table><h2 id="优化SQL步骤-explain之select-type"><a href="#优化SQL步骤-explain之select-type" class="headerlink" title="优化SQL步骤 - explain之select_type"></a>优化SQL步骤 - explain之select_type</h2><p><strong>explain之select_type</strong><br>表示SELECT的类型，常见的取值，如下表所示（从上往下，效率越来越低）：  </p><table>  <tr>    <th>select_type</th>    <th>含义</th>  </tr>  <tr>    <td>SIMPLE</td>    <td>简单的select查询，查询中不包含子查询或者UNION。</td>  </tr>  <tr>    <td>PRIMARY</td>    <td>查询中若包含任何复杂的子查询，最外层查询标记为该标识。</td>  </tr>  <tr>    <td>SUBQUERY</td>    <td>在SELECT或者WHERE列表中包含了子查询。</td>  </tr>  <tr>    <td>DERIVED</td>    <td>在FROM列表中包含的子查询，被标记为DERIVED（衍生）MYSQL或递归执行这些子查询，把结果放在临时表中。</td>  </tr>  <tr>    <td>UNION</td>    <td>若第二个SELECT出现在UNION之后，则标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将标记为：DERIVED</td>  </tr>  <tr>    <td>UNION RESULT</td>    <td>从UNION表获取结果的SELECT</td>  </tr></table><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item;</span><br><span class="line"># SIMPLE  </span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=(<span class="keyword">select</span> id <span class="keyword">from</span> user_role <span class="keyword">where</span> role_id=<span class="string">'9'</span>);  </span><br><span class="line"># <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id： <span class="keyword">PRIMARY</span> ；  </span><br><span class="line">#(<span class="keyword">select</span> id <span class="keyword">from</span> user_role <span class="keyword">where</span> role_id=<span class="string">'9'</span>)：SUBQUERY  </span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> a.* <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="string">'1'</span>,<span class="string">'2'</span>)) a;</span><br><span class="line"># <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="string">'1'</span>,<span class="string">'2'</span>): <span class="keyword">DERIVED</span>；存储至衍生的临时表</span><br><span class="line"># <span class="keyword">select</span> a.* <span class="keyword">from</span> ： <span class="keyword">PRIMARY</span>  derived2指的是<span class="keyword">derived</span>指的是衍生的表a，<span class="number">2</span>则指的是id，执行操作表顺序字段；</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=<span class="string">'1'</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=<span class="string">'2'</span>;</span><br><span class="line">#<span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=<span class="string">'1'</span>: <span class="keyword">PRIMARY</span></span><br><span class="line">#<span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=<span class="string">'2'</span> ： <span class="keyword">UNION</span></span><br><span class="line"># <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=<span class="string">'1'</span>的结果  &amp;&amp;  <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=<span class="string">'2'</span>的结果联合起来： <span class="keyword">UNION</span> RESULT</span><br></pre></td></tr></table></figure><h2 id="优化SQL步骤-explain之table-、type"><a href="#优化SQL步骤-explain之table-、type" class="headerlink" title="优化SQL步骤 - explain之table 、type"></a>优化SQL步骤 - explain之table 、type</h2><p><strong>explain之table</strong><br>展示这一行的数据是关于哪一张表的；  </p><p><strong>explain之type</strong><br>type显示的是访问类型，是较为重要的一个指标，可取值为：  </p><table>  <tr>    <th>type</th>    <th>含义</th>  </tr>  <tr>    <td>NULL</td>    <td>MySQL不访问任何表，索引，直接返回结果</td>  </tr>  <tr>    <td>system</td>    <td>表只有一行记录（等同于系统表），这是const类型的特例，一般不会出现</td>  </tr>  <tr>    <td>const</td>    <td>表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，索引很快。如将主键置于where列表中，MySQL就能将该查询转换成一个常量。(根据主键或者唯一索引进行查询)</td>  </tr>  <tr>    <td>eq_ref</td>    <td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描</td>  </tr>  <tr>    <td>ref</td>    <td>非唯一性索引扫描，返回皮诶某个单独值的所有行。本质上也是野种索引访问，返回所有匹配某个单独值的所有行（多个）</td>  </tr>  <tr>    <td>range</td>    <td>只检索给定返回的行，使用一个索引来选择行。where之后出现between，<，>，in等操作</，></td>  </tr>  <tr>    <td>index</td>    <td>index与ALL的区别为index类型只是遍历了索引树，通常比ALL快，ALL是遍历数据文件。</td>  </tr>  <tr>    <td>all</td>    <td>将遍历全表以找到匹配的行</td>  </tr></table><p><strong>type为NULL</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> now(); # 查询当前时间(查询效率非常高) ： <span class="keyword">type</span>-&gt;<span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>No tables used</td>  </tr></table><p><strong>type为system</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=<span class="string">'1'</span>) a;： <span class="keyword">type</span>-&gt;<span class="keyword">system</span></span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>< derived2></td>    <td>system</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>2</td>    <td>DERIVED</td>    <td>t_user</td>    <td>const</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>98</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr></table><p><strong>type为const</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">'1'</span>;<span class="comment"># 根据主键查询返回一条记录：type-&gt;const</span></span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>t_user</td>    <td>const</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>98</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr></table><p><strong>type为const</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> username=<span class="string">'stu1'</span>;<span class="comment">#根据唯一索引查询返回一条记录：type-&gt;const</span></span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>t_user</td>    <td>const</td>    <td>unique_user_username</td>    <td>unique_user_username</td>    <td>137</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr></table><p><strong>type为eq_ref</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user;//id有1、2、3、4、5、6</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_role;//id有10、5、7、8、9</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user u ,t_role r <span class="keyword">where</span> u.id=r.id;<span class="comment">#业务逻辑层面不符合，只是数据库硬性查询（强行关联）出一个type为eq_ref的示例而已</span></span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>r</td>    <td>ALL</td>    <td>PRIMARY</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>5</td>    <td>NULL</td>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>u</td>    <td>eq_ref</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>98</td>    <td>demo_02.r.id</td>    <td>1</td>    <td>NULL</td>  </tr></table><p><strong>type为ref</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> t_user;<span class="comment">#查询t_user表当中的索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_user_name <span class="keyword">on</span> t_user(<span class="string">'name'</span>);</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'a'</span>;<span class="comment">#根据非唯一性索引进行查询，返回的记录只有一条</span></span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>t_user</td>    <td>ref</td>    <td>idx_user_name</td>    <td>idx_user_name</td>    <td>137</td>    <td>const</td>    <td>1</td>    <td>Using index condition</td>  </tr></table><p><strong>type为range(范围查询)</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.（between <span class="keyword">and</span>）、（&gt;、&lt;、&gt;=、&lt;=）<span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><p><strong>type为index(指的即索引)</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user;//查询所有数据，进行全表扫描，即到数据文件当中进行读取；<span class="keyword">type</span>为<span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id <span class="keyword">from</span> t_user;//此时<span class="keyword">type</span>为<span class="keyword">index</span>；因为id为主键，主键则走主键索引；</span><br></pre></td></tr></table></figure><p>结果值从最好到最坏依次是：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NULL</span> &gt;<span class="built_in"> system </span>&gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; all</span><br></pre></td></tr></table></figure><h2 id="优化SQL步骤-explain之key-rows-extra"><a href="#优化SQL步骤-explain之key-rows-extra" class="headerlink" title="优化SQL步骤 - explain之key rows extra"></a>优化SQL步骤 - explain之key rows extra</h2><p><strong>explain之key</strong>  </p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">possible_keys:</span>显示可能应用在这张表的索引，一个或者多个；</span><br><span class="line"><span class="symbol">key:</span>实际使用的索引，如果为NULL，则没有使用索引；</span><br><span class="line">key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好（越短执行效率越高）；</span><br></pre></td></tr></table></figure><p><strong>explain之rows</strong>  </p><p>扫描行的数量。  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="type">name</span> =<span class="string">'a'</span>;#<span class="type">name</span>建了索引，所以查询<span class="keyword">rows</span>为<span class="number">1</span>行</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">password</span>=<span class="string">'aaa'</span>;# <span class="keyword">password</span>没有建立索引，整表扫描；<span class="keyword">rows</span>即<span class="keyword">SQL</span>语句查询时所查询的行数；</span><br></pre></td></tr></table></figure><p><strong>explain之extra</strong>  </p><p>其他的额外的执行计划信息，在该列展示。<br>（using_filesort以及using_temporary非常耗性能；需要优化using_filesort以及using_temporary；保持using_index）</p><table>  <tr>    <th>extra</th>    <th>含义</th>  </tr>  <tr>    <td>using_filesort</td>    <td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，称为“文件排序”</td>  </tr>  <tr>    <td>using_temporary</td>    <td>使用了临时表保存中间结果，MySQL对查询结果排序时使用临时表。常见于order by 和group by</td>  </tr>  <tr>    <td>using_index</td>    <td>表示相应的select操作使用了覆盖索引，避免访问表的数据行，效率不错。</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>;<span class="comment">#按照id进行排序</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">password</span>;<span class="comment">#根据文件进行排序；即需要扫描文件当中的内容，然后再去进行排序；效率非常低；这个时候如果需要进行优化的话，可以在password字段上与name一样建立索引；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>; <span class="comment">#此时依然是using_filesort根据文件排序</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> t_user <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>;<span class="comment">#此时则使用的是using_index根据索引排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;<span class="comment">#此时extra为null，原因是根据name字段建立了索引</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">password</span>;<span class="comment">#此时password字段没有建立索引；extra为using temporary；using filesort效率低；</span></span><br></pre></td></tr></table></figure><h2 id="优化SQL步骤-show-profile"><a href="#优化SQL步骤-show-profile" class="headerlink" title="优化SQL步骤 - show profile"></a>优化SQL步骤 - show profile</h2><p>MySQL从5.0.37版本开始增加了对 show profiles 和show profile语句的支持。  </p><p>show profiles能够在做SQL优化时帮助了解事件都耗费到哪里去了；  </p><p>通过 have_profiling 参数，能够看到当前MySQL是否支持profile；  </p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">select</span> <span class="comment">@@</span>have_profiling;<span class="meta">#系统变量；YES/NO</span></span><br></pre></td></tr></table></figure><p>默认 profiling 是关闭的，可以通过set语句在Session级别开启profiling：  </p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="symbol">@profiling</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span> <span class="attribute">profiling</span>=1;# 开启profiling开关；0:未开启；1：开启</span><br></pre></td></tr></table></figure><p>通过profile，能够更清楚的了解SQL执行的过程；<br>首先，可以执行一系列的操作，如下图所示：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> db01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> title=<span class="string">'abc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;<span class="comment">#查看之前每一个操作的耗时情况 query_id(当前查询的id)、duration（执行的耗时时间）、query（查询的sql）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use db01;其实底层即select database();</span></span><br></pre></td></tr></table></figure><p>执行完上述命令之后，再执行show profiles指令，来查看SQL语句执行的耗时：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;<span class="comment"># query_id、duration、query</span></span><br></pre></td></tr></table></figure><p>通过 show profile for query query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间；  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show<span class="built_in"> profile </span><span class="keyword">for</span> query 6;#6即通过show profiles查询出来的query_id;  status、duration</span><br></pre></td></tr></table></figure><table>  <tr>    <th>status（经历的每一个阶段）</th>    <th>duration（每一个阶段的耗时情况）</th>  </tr>  <tr>    <td>starting（开启）</td>    <td>0.000046</td>  </tr>  <tr>    <td>checking permissions（校验权限）</td>    <td>...</td>  </tr>  <tr>    <td>opening tables（打开表）</td>    <td>...</td>  </tr>    <tr>    <td>init（初始化）</td>    <td>...</td>  </tr>    <tr>    <td>system lock（系统锁）</td>    <td>...</td>  </tr>    <tr>    <td>optimizing（优化器）</td>    <td>...</td>  </tr>    <tr>    <td>statistics（统计）</td>    <td>...</td>  </tr>    <tr>    <td>perparing（准备）</td>    <td>...</td>  </tr>    <tr>    <td>executing（执行）</td>    <td>...</td>  </tr>    <tr>    <td>sending data（发送数据）</td>    <td>...</td>  </tr>    <tr>    <td>end（结束）</td>    <td>...</td>  </tr>    <tr>    <td>query end（查询结束）</td>    <td>...</td>  </tr>    <tr>    <td>closing tabls（关闭表）</td>    <td>...</td>  </tr>    <tr>    <td>freeing itmes（释放其他项）</td>    <td>...</td>  </tr>    <tr>    <td>cleaning up（清除）</td>    <td>...</td>  </tr></table><p>（select count(*) from tb_item；该sql语句的时间都耗费在sending data上了；）  </p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">TIP:  </span></span><br><span class="line"><span class="code">    Sending data 状态表示MySQL线程开始访问数据行并把结果放回给客户端，而不仅仅是返回给客户端。  </span></span><br><span class="line"><span class="code">    由于Sending data 状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整个查询中耗时最长的状态。</span></span><br></pre></td></tr></table></figure><p>在获取到最耗时时间的线程状态后，MySQL支持进一步选择all、cpu、block io、context switch、page faults 等明细类型等查看MySQL在使用什么资源上耗费了过高的时间。<br>例如，选择查看CPU的耗费时间：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select<span class="built_in"> profile </span>cpu <span class="keyword">for</span> query 6;# status、duration、CPU_user、CPU_System查询到的是id为6的该条sql语句在各个阶段当中cpu的耗费情况；</span><br><span class="line"></span><br><span class="line">select<span class="built_in"> profile </span>all <span class="keyword">for</span> query 6;# status、duration、CPU_user、CPU_system、context_voluntary、context_involuntary、block_ops_in、block_ops_out、<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><blockquote><p>通过show profile可以分析SQL语句各个阶段的耗时情况</p></blockquote><h2 id="优化SQL步骤-trace工具"><a href="#优化SQL步骤-trace工具" class="headerlink" title="优化SQL步骤 - trace工具"></a>优化SQL步骤 - trace工具</h2><p>mysql的服务端server有一个步骤就是optimizer，优化sql部分；按照mysql当中具体对应的规则对SQL进行优化处理；trace即分析优化器</p><p><strong>trace分析优化器执行计划</strong><br>MySQL5.6提供了对SQL的跟踪 trace，通过trace文件能够进一步了解为什么优化器选择A计划，而不是B计划。  </p><p>打开trace，设置格式为JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">SET</span> optimizer_trace =<span class="string">'enabled=on'</span>, <span class="attribute">end_markers_in_json</span>=on;# optimizer_trace =<span class="string">'enabled=on'</span>进行开启；<span class="attribute">end_markers_in_json</span>=on 设置格式为JSON</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">optimizer_trace_max_mem_size</span>=1000000;# 日志文件占用内存大小</span><br></pre></td></tr></table></figure><p>执行SQL语句：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>最后，检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> infomation_schema.optimizer_trace\G;# infomation_schema系统库；optimizer_trace系统库当中的日志表</span><br><span class="line"></span><br><span class="line"># QUERY 查询的SQL语句；<span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> id&lt;<span class="number">4</span>;</span><br><span class="line"># TRACE 跟踪信息；在跟踪信息当中最终<span class="keyword">select</span> * 当中的* 最终解析为tb_item表当中的每一个具体的字段</span><br></pre></td></tr></table></figure><h2 id="索引的使用-验证索引提升查询效率"><a href="#索引的使用-验证索引提升查询效率" class="headerlink" title="索引的使用 - 验证索引提升查询效率"></a>索引的使用 - 验证索引提升查询效率</h2><p><strong>索引的使用</strong><br>索引时候数据库优化最常用也是最重要的手段之一，通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题；  </p><p><strong>验证索引提升查询效率</strong><br>在准备的表结构tb_item中，一共存储了300万条记录；  </p><p><strong>A.</strong> 根据ID查询  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_items;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1888</span>;<span class="comment">#id字段具有主键索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1999</span>\G;</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据title进行精确查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> title=<span class="string">'阿尔卡特'</span>;<span class="comment">#查询速度慢，因为title字段没有索引，查询效率低，创建主键即自动生成主键索引；</span></span><br><span class="line"><span class="comment">#查看SQL语句的执行计划：  </span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> title=<span class="string">'阿尔卡特'</span>\G;</span><br></pre></td></tr></table></figure><p>处理方案，针对title字段，创建索引：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_item_title <span class="keyword">on</span> tb_item(<span class="built_in">title</span>);</span><br></pre></td></tr></table></figure><p>索引创建完成之后，再次查询：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> title=<span class="string">'阿尔卡特'</span>\G;</span><br><span class="line"><span class="comment"># 创建索引的过程中，mysql在做什么？表tb_item中有300万条记录，那么在创建索引的时候就会对这300万条记录重建索引；所以此时即数据库底层在重建索引；创建完索引之后再进行查询效率则变快；索引是优化查询最有效的方式之一；</span></span><br></pre></td></tr></table></figure><p>查询速度很快，接近0s，主要的原因是因为id为主键，有索引；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1999</span>\G;</span><br></pre></td></tr></table></figure><p><strong>准备环境</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'tb_seller'</span>(</span><br><span class="line">  <span class="string">'sellerid'</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="string">'name'</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="string">'nickname'</span> <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  <span class="string">'password'</span> <span class="built_in">varchar</span>(<span class="number">60</span>),</span><br><span class="line">  <span class="string">'status'</span> <span class="built_in">varchar</span>(<span class="number">1</span>),</span><br><span class="line">  <span class="string">'address'</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="string">'createtime'</span> datetime,</span><br><span class="line">  primary <span class="keyword">key</span>(<span class="string">'sellerid'</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">#插入记录 导入基本数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_seller <span class="keyword">values</span> ......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建联合索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_name_sta_addr <span class="keyword">on</span> tb_seller(<span class="keyword">name</span>,<span class="keyword">status</span>,address);</span><br></pre></td></tr></table></figure><p>创建了索引并不是一定会提高效率；创建了索引并且需要合理运用索引才能够提高查询效率；  </p><h2 id="索引的使用-全值匹配"><a href="#索引的使用-全值匹配" class="headerlink" title="索引的使用 - 全值匹配"></a>索引的使用 - 全值匹配</h2><p><strong>避免索引失效</strong>  </p><p>(1) 全值匹配，对索引中所有列都指定具体值。<br>该情况下，索引生效，执行效率提高。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span>\G;</span><br></pre></td></tr></table></figure><h2 id="索引的使用-最左前缀法则"><a href="#索引的使用-最左前缀法则" class="headerlink" title="索引的使用 - 最左前缀法则"></a>索引的使用 - 最左前缀法则</h2><p><strong>避免索引失效</strong>  </p><p>(2)最左前缀法则<br>tb_seller创建了一个复合索引即name、status、address这三个字段；<br>如果索引了多列，要遵守最左前缀法则。<br>指的是查询从索引的最左前列开始，并且不跳过索引中的列。<br>匹配最左前缀法则，走索引：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'小米科技'</span>;<span class="comment"># key:idx_name_sta_addr； key_len：403</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="string">'1'</span>;<span class="comment"># key:idx_name_sta_addr； key_len：410</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span>;<span class="comment"># key:idx_name_sta_addr； key_len：813</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">status</span>=<span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span>;<span class="comment"># key:NULL key_len：NULL 此时则不再走索引；因为不再符合最左前缀法则，没有以最左边的列开始；  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">status</span>=<span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span> <span class="keyword">and</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;<span class="comment"># key:idx_name_sta_addr； key_len：813 此时是走索引的；与where列表当中字段的先后顺序无关；会检查where条件列表中包不包含最左列；而是与复合索引当中的是否存在有复合索引当中的最左字段；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span> ;<span class="comment">#跳过索引列不走索引; key:idx_sellter_name_sta_addr；key_len: 403；此时索引的长度是403；也就是这是执行 explain select * from tb_seller where name ='小米科技'; 时所走的索引；即后面的 and address='北京市' 并未走索引；</span></span><br></pre></td></tr></table></figure><blockquote><p>违反最左前缀法则，索引失效；<br>需要包含复合索引当中的最左列，并且不能跳过复合索引当中的某一列进行查询否则复合索引失效；</p></blockquote><h2 id="索引的使用-索引失效情况（范围查询、字段运算）"><a href="#索引的使用-索引失效情况（范围查询、字段运算）" class="headerlink" title="索引的使用 - 索引失效情况（范围查询、字段运算）"></a>索引的使用 - 索引失效情况（范围查询、字段运算）</h2><p><strong>避免索引失效</strong>  </p><p>（3）范围查询右边的列，不能使用索引；<br>根据前面的两个字段name、status查询是走索引的，但是最后一个条件address没有用到索引。  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">explain select * <span class="keyword">from</span> tb_seller where <span class="attribute">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="attribute">status</span>=<span class="string">'1'</span> <span class="keyword">and</span> <span class="attribute">address</span>=<span class="string">'北京市'</span>;# key:idx_name_sta_addr； key_len：813；此时三个字段name、status、address三个字段都走了索引；  </span><br><span class="line"></span><br><span class="line">explain select * <span class="keyword">from</span> tb_seller where name =<span class="string">'小米科技'</span> <span class="keyword">and</span> status &gt;<span class="string">'1'</span> <span class="keyword">and</span><span class="built_in"> address </span>=<span class="string">'北京市'</span>;# key:idx_name_sta_addr； key_len：410;此时走的索引是name和status字段的索引；而范围查询status&gt;<span class="string">'1'</span>之后的address并没有走索引；  </span><br><span class="line"><span class="comment"># 范围查询之后的索引字段将失效</span></span><br></pre></td></tr></table></figure><p>（4）不要在索引列上进行运算操作，索引将失效；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller  <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;<span class="comment">#此时走索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">3</span>,<span class="number">2</span>)=<span class="string">'科技'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">3</span>,<span class="number">2</span>)=<span class="string">'科技'</span>;<span class="comment">#此时key为null以及key_len为null；而type为ALL则说明了进行了全表扫描；没有走索引</span></span><br></pre></td></tr></table></figure><p>（5）字符串不加单引号，会造成索引失效；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="string">'0'</span>;<span class="comment"># 此时key:idx_name_sta_addr；key_len：410；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="number">0</span>;<span class="comment"># 此时key：idx_name_sta_addr；key_len：403；索引长度为403；则说明走的索引为name字段的索引；而status字段的索引并没有走；造成了status=0 该索引字段的失效；当status字段取值没有加单引号时，mysql底层检测到status字段为varchar类型所以会对其没有加单引号的取值进行隐式类型转换；隐式类型转换了之后该status索引字段就失效了；因为底层对该字段进行了运算操作；</span></span><br></pre></td></tr></table></figure><h2 id="索引的使用-覆盖索引"><a href="#索引的使用-覆盖索引" class="headerlink" title="索引的使用 - 覆盖索引"></a>索引的使用 - 覆盖索引</h2><p><strong>避免索引失效</strong>  </p><p>（6）尽量使用覆盖索引，避免使用 select *  </p><p>尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * ；  </p><p>如果查询列，超出索引列，也会降低性能；  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="type">name</span> =<span class="string">'小米科技'</span>;# extra为<span class="keyword">using</span> <span class="keyword">index</span> condition指的是：在查询的时候确实用到了<span class="type">name</span>这个字段的索引；但是用到了<span class="type">name</span>这个字段的索引信息之后，在返回数据的时候还需要进行索引回调查询；  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="type">name</span> , status ,address <span class="keyword">where</span> <span class="type">name</span>=<span class="string">'小米科技'</span>; # 此时extra为<span class="keyword">using</span> <span class="keyword">where</span> ;<span class="keyword">using</span> <span class="keyword">index</span>；此时表示的是：可以通过索引进行查询；但是此时并不需要进行回调查询了；原因就在于查询的字段在索引结构当中已经被记录了；所以并不需要去进行回调查询；  </span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="type">name</span> , status  <span class="keyword">where</span> <span class="type">name</span>=<span class="string">'小米科技'</span>;#同上</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="type">name</span> ,  address <span class="keyword">where</span> <span class="type">name</span>=<span class="string">'小米科技'</span>;#同上</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="type">name</span> ,  address ,<span class="keyword">password</span> <span class="keyword">where</span> <span class="type">name</span>=<span class="string">'小米科技'</span>;#复合索引当中并未包括<span class="keyword">password</span>字段则此时<span class="type">name</span>索引字段以及address索引字段当中并没有包括<span class="keyword">password</span>字段的信息，则此时需要去回调查询<span class="keyword">password</span>字段的信息；即extra为<span class="keyword">using</span> index_condition</span><br></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">TIP:  </span></span><br><span class="line">索引回调查询指的是：  </span><br><span class="line"><span class="code">    using index : 使用覆盖索引的时候就会出现</span></span><br><span class="line"><span class="code">    using where : 在查找使用索引的情况下，需要回表去查询所需的数据</span></span><br><span class="line"><span class="code">    using index condition ：查找使用了索引，但是需要回表查询数据（从索引当中拿到了数据，然后再到表结构当中去拿到该数据对应的一整行数据，因为该name索引字段并没有记录所有的数据，只是记录了那么字段的数据；所以需要回表查询数据；即用了索引还需要回调查询）</span></span><br><span class="line"><span class="code">    using index ; using where : 查找使用了索引，但是需要的数据都在索引列中能找到，索引不需要回表查询数据</span></span><br></pre></td></tr></table></figure><p>（7） in走索引，not in 索引失效</p><h2 id="索引的使用-or索引失效情况"><a href="#索引的使用-or索引失效情况" class="headerlink" title="索引的使用 - or索引失效情况"></a>索引的使用 - or索引失效情况</h2><p><strong>避免索引失效</strong><br>（7）用or分隔开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到；  </p><p>示例：name字段是索引列，而createtime不是索引列，中间是or进行连接是不走索引的；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> createtime=<span class="string">'2088-01-01 12:00:00'</span>\G;<span class="comment">#key:idx_name_sta_addr； key_len: 403;此时走索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">or</span> createtime=<span class="string">'2088-01-01 12:00:00'</span>\G;<span class="comment">#key:idx_name_sta_addr； key_len: NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> nickname=<span class="string">'小米官方旗舰店'</span>;<span class="comment">#此时走索引；key_len:403;走的是name字段的索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">or</span> nickname=<span class="string">'小米官方旗舰店'</span>;<span class="comment">#换成or之后，nickname字段非索引字段；所以此时将全表扫描；不会走索引；key_len:NULL；以及type为ALL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or之后的字段如果没有索引的话；那么整个where列表当中即便有索引字段也将都失效，不再走索引；</span></span><br></pre></td></tr></table></figure><h2 id="索引的使用-like模糊匹配"><a href="#索引的使用-like模糊匹配" class="headerlink" title="索引的使用 - like模糊匹配"></a>索引的使用 - like模糊匹配</h2><p><strong>避免索引失效</strong>  </p><p>（8）以%开头的Like模糊查询，索引失效。  </p><p>如果仅仅是尾部模糊查询，索引不会失效。<br>如果是头部模糊查询匹配，则索引失效。  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">like</span> <span class="string">'小米科技'</span>;#key: idx_name_sta_addr； key_len: <span class="number">403</span>; 此时走索引；索引走的是<span class="type">name</span>字段</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">like</span> <span class="string">'%小米科技'</span>;#key: <span class="keyword">NULL</span>； key_len: <span class="keyword">NULL</span>; 此时不走索引；且<span class="keyword">type</span>为<span class="keyword">ALL</span>；全表扫描</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">like</span> <span class="string">'%小米科技%'</span>;#key: <span class="keyword">NULL</span>； key_len: <span class="keyword">NULL</span>; 此时不走索引；且<span class="keyword">type</span>为<span class="keyword">ALL</span>；全表扫描</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">like</span> <span class="string">'科技%'</span>;#key: idx_name_sta_addr； key_len: <span class="number">403</span>; 此时走索引；索引走的是<span class="type">name</span>字段</span><br></pre></td></tr></table></figure><p>类似 “%科技%” 这种情况在业务逻辑处理当中还是比较多的；但是这样效率将十分低下；所以针对这种情况的处理方式为：<br>覆盖索引：覆盖索引指的是，尽量不要使用select * 这种方式进行查询；而是使用复合索引当中的那些索引列，即索引字段；即复合索引为idx_name_sta_addr，当中包含的索引字段为name、status、address；所以select 查询列名称的时候尽量查询的列名称为复合索引当中的索引列，或者是其他索引的字段（例如唯一索引的索引字段、主键索引的索引字段等）；<br>即通过覆盖索引就可以解决 “%科技%” like模糊查询效率低下的情况（条件是select 查询的字段都需要是索引字段，如果出现了查询非索引字段则将不再走索引）；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> sellerid <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%科技%'</span>;<span class="comment"># 则此时是走索引的；key:idx_seller_name_sta_addr；key_len：813；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> sellerid,<span class="keyword">name</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%科技%'</span>;<span class="comment"># 则此时是走索引的；key:idx_seller_name_sta_addr；key_len：813；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> sellerid,<span class="keyword">name</span>,<span class="keyword">status</span>,address <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%科技%'</span>;<span class="comment"># 则此时是走索引的；key:idx_seller_name_sta_addr；key_len：813；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> sellerid,<span class="keyword">name</span>,<span class="keyword">status</span>,address,<span class="keyword">password</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%科技%'</span>;<span class="comment"># 则此时是不走索引的，由于password字段并不是索引字段，所以将造成不会走索引的局面；key:NULL；key_len：NULL；</span></span><br></pre></td></tr></table></figure><h2 id="索引的使用-全表扫描更快"><a href="#索引的使用-全表扫描更快" class="headerlink" title="索引的使用 - 全表扫描更快"></a>索引的使用 - 全表扫描更快</h2><p><strong>避免索引失效</strong>  </p><p>（9）如果MySQL评估使用索引比全表更慢，则不使用索引；  </p><p>如果发现走全表扫描比走索引要快，这个时候mysql就会走全表扫描；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address=<span class="string">'北京市'</span>;<span class="comment">#此时key:NULL 以及key_len: NULL；由于address是复合索引当中的索引字段但是又不满足最左前缀法则；所以不走索引；  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_address <span class="keyword">on</span> tb_seller(address);<span class="comment">#在tb_seller表中的address字段上建立索引；单列索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address=<span class="string">'北京市'</span>;<span class="comment"># 但是此时仍然没有走索引；possible_key出现有idx_seller_address；但是key为NULL；以及key_len为NULL；type为ALL；即走的还是全表扫描</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address=<span class="string">'西安市'</span>;<span class="comment">#此时是走索引的，key为idx_address；key_len为403;索引走的是address字段；extra为using index condition</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#同样一条SQL语句，只是传入的参数不同；也就导致了是否走索引的不同；一个是全表扫描没有走索引；而另外一个是走了索引idx_seller_address；  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#原因就在于：这个与数据库当中的数据是存在一定的关系的；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller; <span class="comment">#该表当中一共有12条记录；这12条记录当中出现有address为“北京市”的记录行数就有11条记录；只有一条是1条是“西安市”；  </span></span><br><span class="line"><span class="comment">#如果数据量大，且精确查询的内容又在表中占比大；此时就极有可能走的是全表扫描而非走索引了；速度更快</span></span><br></pre></td></tr></table></figure><h2 id="索引的使用-NULL值的判定"><a href="#索引的使用-NULL值的判定" class="headerlink" title="索引的使用 - NULL值的判定"></a>索引的使用 - NULL值的判定</h2><p><strong>避免索引失效</strong>  </p><p>（10） is NULL，is  NOT NULL  <span style="color:red;"><strong>有时</strong></span> 索引失效；  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> tb_seller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">null</span>;# 此时是走索引的；key：idx_seller_address ;key_len：<span class="number">403</span> 走的索引字段为address</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;# 此时是没有走索引的；key：<span class="keyword">null</span> ;key_len:<span class="keyword">null</span>;<span class="keyword">type</span>:<span class="keyword">all</span> 走的是全表扫描</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;</span><br><span class="line">#当前该表当中每一条记录都address字段记录取值都是 <span class="keyword">not</span> <span class="keyword">null</span>; 当前<span class="keyword">explain</span> <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">null</span>时走了索引，即address <span class="keyword">is</span> <span class="keyword">null</span>这样的记录在表当中占比较少此时则走索引；而<span class="keyword">explain</span> <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>时没有走索引；而此时 address <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>则在表当中占比较多；所以就不会去走索引而是全表扫描；这个与前面所说的全表扫描更快是一个道理；全表扫描与走索引的这两种方式哪一种更快就选择哪一种方式；也就是说mysql底层会去自动的判断如果走全表扫描更快就走全表扫描；如果走索引更快就走索引的这种方式；  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">is</span> <span class="keyword">null</span>;#此时走索引；key:idx_name_sta_addr；key_len：<span class="number">403</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>; # 此时不走索引；key:<span class="keyword">null</span>； key_len：<span class="keyword">null</span>; <span class="keyword">type</span>：<span class="keyword">ALL</span> 走的是全表扫描</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">is</span> <span class="keyword">null</span>;# 此时不走索引；key：<span class="keyword">null</span>；key_len: <span class="keyword">null</span> ; <span class="keyword">type</span>:<span class="keyword">all</span> 走的是全表扫描</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>; # 此时走了索引；key:idx_name; key_len:<span class="number">138</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t_user <span class="keyword">set</span> <span class="type">name</span> =<span class="keyword">null</span> <span class="keyword">where</span> id &lt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user;#则此时除了id为<span class="number">1</span>的记录其余的记录的<span class="type">name</span>字段就变成了<span class="keyword">null</span>；所以如果此时查询t_user表当中<span class="type">name</span>字段为<span class="keyword">is</span> <span class="keyword">null</span>则走全表扫描；而查询<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>则走索引；</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> t_user;#此时在t_user表当中<span class="type">name</span>字段是存在索引的；</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">is</span> <span class="keyword">null</span>;# key:<span class="keyword">null</span> ; key_len:<span class="keyword">null</span>;<span class="keyword">type</span>:<span class="keyword">all</span> 走的是全表扫描（原因就在于此时在表当中记录<span class="type">name</span>字段为<span class="keyword">null</span>占比大于<span class="type">name</span>字段<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>；所以全表扫描与走索引的方式这两者相比较之下，全表扫描更快；）</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;#此时是走索引的；key:idx_user_name;key_len:<span class="number">138</span>;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 也就是说<span class="keyword">is</span> <span class="keyword">null</span>与<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>；有时是会走索引的有时又不会走索引；这要分情况而定；这个根据数据库当中的数据量来决定的；如果查询的字段在数据量当中的<span class="keyword">null</span>值占比较多,那么这个时候<span class="keyword">is</span> <span class="keyword">null</span>将会走全表扫描而<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>则走索引；如果查询的字段在数据量当中绝大部分都是存在有值的也就是说<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>占据较多；则此时<span class="keyword">is</span> <span class="keyword">null</span>就会走索引；而<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>则走全表扫描；</span><br></pre></td></tr></table></figure><h2 id="索引的使用-in和not-in"><a href="#索引的使用-in和not-in" class="headerlink" title="索引的使用 - in和not in"></a>索引的使用 - in和not in</h2><p><strong>避免索引失效</strong>  </p><p>（11）in 走索引； not in 索引失效；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> sellerid <span class="keyword">in</span> (<span class="string">'oppo'</span>,<span class="string">'xiaomi'</span>,<span class="string">'sina'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> sellerid <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'oppo'</span>,<span class="string">'xiaomi'</span>,<span class="string">'sina'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> sellerid <span class="keyword">in</span> (<span class="string">'oppo'</span>,<span class="string">'xiaomi'</span>,<span class="string">'sina'</span>);<span class="comment">#此时使用了索引；key:PRIMARY；key_len:402;  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> sellerid <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'oppo'</span>,<span class="string">'xiaomi'</span>,<span class="string">'sina'</span>);<span class="comment">#此时未走索引；索引失效；key:NULL；key_len:NULL；type:ALL 全表扫描</span></span><br></pre></td></tr></table></figure><h2 id="索引的使用-单列索引与复合索引选择"><a href="#索引的使用-单列索引与复合索引选择" class="headerlink" title="索引的使用 - 单列索引与复合索引选择"></a>索引的使用 - 单列索引与复合索引选择</h2><p><strong>避免索引失效</strong>  </p><p>（12）单列索引和复合索引  </p><p>尽量使用复合索引，而少量使用单列索引；  </p><p>创建复合索引：  </p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create <span class="built_in">index</span> idx_name_sta_address on tb_seller(<span class="keyword">name</span>,<span class="keyword">status</span>,address);</span><br><span class="line"></span><br><span class="line">就相当于创建了三个索引：  </span><br><span class="line">* <span class="keyword">name</span></span><br><span class="line">* <span class="keyword">name</span> + <span class="keyword">status</span></span><br><span class="line">* <span class="keyword">name</span> + <span class="keyword">status</span> + address</span><br></pre></td></tr></table></figure><p>创建单列索引：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_name <span class="keyword">on</span> tb_seller(<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_status <span class="keyword">on</span> tb_seller(<span class="keyword">status</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br></pre></td></tr></table></figure><p>当对name、status、address字段进行搜索的时候，数据库只会选择一个索引；所以此时在这种情况下单列索引并不占优势；  </p><p>数据库会选择一个最优的索引来使用，并不会使用全部索引；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> tb_seller;<span class="comment">#查看tb_seller表当中的索引</span></span><br><span class="line"><span class="comment"># PRIMARY 主键索引</span></span><br><span class="line"><span class="comment"># idx_name_sta_address name</span></span><br><span class="line"><span class="comment"># idx_name_sta_address status</span></span><br><span class="line"><span class="comment"># idx_name_sta_address address</span></span><br><span class="line"><span class="comment"># idx_seller_address address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除单列索引</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> <span class="keyword">from</span> idx_seller_address <span class="keyword">on</span> tb_seller;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看tb_seller表的索引</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> tb_seller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span>  <span class="keyword">status</span>=<span class="string">'0'</span> <span class="keyword">and</span> address=<span class="string">'西安市'</span>;<span class="comment">#此时使用复合索引；key:idx_name_sta_addr；key_len：813</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除复合索引</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> idx_name_sta_address <span class="keyword">on</span> tb_seller;</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建单列索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_name <span class="keyword">on</span> tb_seller(<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_status <span class="keyword">on</span> tb_seller(<span class="keyword">status</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看单列索引</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> tb_seller;</span><br><span class="line"><span class="comment">#PRIMARY 主键索引</span></span><br><span class="line"><span class="comment"># idx_seller_name 单列索引name字段</span></span><br><span class="line"><span class="comment"># idx_seller_status 单列索引status字段</span></span><br><span class="line"><span class="comment"># idx_seller_address 单列索引address字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="string">'0'</span> <span class="keyword">and</span> address=<span class="string">'西安市'</span>;<span class="comment">#此时走索引但是；key:idx_seller_name; key_len:403;只走了name字段的索引；而status字段以及address字段的索引未走；相当于白创建了status以及address字段的索引了；</span></span><br><span class="line"><span class="comment">#即此时possible_key：idx_seller_name、idx_seller_status、idx_seller_address；这三个索引可能都会用到；但是实际上只用到了idx_seller_name索引；即name字段的索引；</span></span><br><span class="line"><span class="comment">#为什么选择了name字段来作为该SQL的索引；原因在于：数据库会选择一个最优的索引来使用；并不会使用全部索引；也就意味着name该字段的索引在这三个索引当中最优；</span></span><br><span class="line"><span class="comment">#为什么name该字段的索引idx_seller_name最优，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;<span class="comment"># 因为在此表当中，name查询的精确值为“小米科技”辨识度最高，记录行为1；而status字段取值为0的记录行超过1；address字段取值为“西安市”记录行也只有1；也应该是遵循了从左到右的一个判断；所以此时idx_seller_name索引最优；从而走了idx_seller_name索引；  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">status</span>=<span class="string">'0'</span> <span class="keyword">and</span> address=<span class="string">'西安市'</span>;<span class="comment">#此时没有name字段；而address在数据表当中辨识度最高；即记录行为1；所以此时走的索引自然即为idx_seller_address；</span></span><br><span class="line"><span class="comment">#key:idx_seller_address;key_len:403;possible_key:idx_seller_status,idx_seller_address;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">status</span>=<span class="string">'0'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span>;<span class="comment"># 如果此时address取精确值为“北京市”；而在数据库当中address取值为“北京市”的记录行辨识度并不高；也就是取值为“北京市”的address字段其记录行有很多超过1，即总共12条记录，有11条记录当中的address都是“北京市”，从而其辨识度并不高；</span></span><br><span class="line"><span class="comment">#而此时status字段相比较之下，取值为0的记录行数，总行数12行，而status取值为0的记录行数为3行，那么此时较之address的辨识度自然是要高一些；所以将走status字段的索引，即idx_seller_status索引；</span></span><br><span class="line"><span class="comment"># possible_key:idx_seller_status,idx_seller_address；key:idx_seller_status;key_len:7；</span></span><br></pre></td></tr></table></figure><p>也就是说：数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部的索引；  </p><h2 id="索引的使用-查看索引使用情况"><a href="#索引的使用-查看索引使用情况" class="headerlink" title="索引的使用 - 查看索引使用情况"></a>索引的使用 - 查看索引使用情况</h2><p><strong>查看索引使用情况</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Handler_read%'</span>;<span class="comment">#查看的是当前会话中索引的使用情况</span></span><br><span class="line"><span class="comment">#Variable_name  Value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Handler_read%'</span>;<span class="comment">#查看的是全局中索引的使用情况</span></span><br></pre></td></tr></table></figure><table border="1">  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Handler_read_first</td>    <td>0</td>  </tr>  <tr>    <td>Handler_read_key</td>    <td>2</td>  </tr>  <tr>    <td>Handler_read_last</td>    <td>0</td>  </tr>    <tr>    <td>Handler_read_next</td>    <td>0</td>  </tr>    <tr>    <td>Handler_read_prev</td>    <td>0</td>  </tr>    <tr>    <td>Handler_read_rnd</td>    <td>0</td>  </tr>    <tr>    <td>Handler_read_rnd_next</td>    <td>22</td>  </tr></table><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Handler_read_first</span>: 索引中第一条被读的次数。如果较高，表示服务器正在自行大量全索引扫描（这个值越低越好）；</span><br><span class="line"></span><br><span class="line"><span class="attribute">Handler_read_key</span>: 如果索引正在工作，这个值代表一个行被索引值读取的次数；如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）；</span><br><span class="line"></span><br><span class="line"><span class="attribute">Handler_read_next</span>: 按照键顺序读下一行的请求数。如果用范围约束或者如果执行索引扫描来查询索引列，该值增加；  </span><br><span class="line"></span><br><span class="line"><span class="attribute">Handler_read_prev</span>: 按照键顺序读前一行的请求数，该读方法主要用于优化ORDER BY.....DESC；</span><br><span class="line"></span><br><span class="line"><span class="attribute">Handler_read_rnd</span>: 根据固定位置读一行的请求数。如果正执行大量查询并需要对结果进行排序该值较高。可能使用了大量需要MySQL扫描整个表的查询或者连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救；  </span><br><span class="line"></span><br><span class="line"><span class="attribute">Handler_read_rnd_next</span>: 在数据文件中读下一行的请求数。如果正进行大量的表扫描，该值要求较高。通常说明表索引不正确或者是写入的查询没有利用索引；</span><br></pre></td></tr></table></figure><h2 id="SQL优化-大批量插入数据"><a href="#SQL优化-大批量插入数据" class="headerlink" title="SQL优化 - 大批量插入数据"></a>SQL优化 - 大批量插入数据</h2><p><strong>大批量插入数据</strong>  </p><p>环境准备：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">'tb_user_1'</span>(</span><br><span class="line">  <span class="string">'id'</span> int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">'username'</span> varchar(45) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'password'</span> varchar(96) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'name'</span> varchar(45) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'birthday'</span> datetime<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'sex'</span> char(1)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'email'</span> varchar(45)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'phone'</span> varchar(45)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'qq'</span> varchar(32)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'status'</span>  varchar(32)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span> comment <span class="string">'用户状态'</span>,</span><br><span class="line">  <span class="string">'create_time'</span>  datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'update_time'</span> datetime<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY(<span class="string">'id'</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">'unique_user_username'</span>(<span class="string">'username'</span>)</span><br><span class="line">)<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE <span class="string">'tb_user_2'</span>(</span><br><span class="line">  <span class="string">'id'</span> int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">'username'</span> varchar(45) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'password'</span> varchar(96) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'name'</span> varchar(45) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'birthday'</span> datetime<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'sex'</span> char(1)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'email'</span> varchar(45)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'phone'</span> varchar(45)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'qq'</span> varchar(32)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'status'</span>  varchar(32)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span> comment <span class="string">'用户状态'</span>,</span><br><span class="line">  <span class="string">'create_time'</span>  datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'update_time'</span> datetime<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY(<span class="string">'id'</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">'unique_user_username'</span>(<span class="string">'username'</span>)</span><br><span class="line">)<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>当使用load命令导入数据的时候，适当的设置可以提高导入的效率。  </p><p>引擎使用的是Innodb，Innodb底层使用的索引是B+树索引；而B+树索引当中的数据有顺序的；  </p><p>对于Innodb类型的表，有以下集中方式可以提高导入的效率：  </p><p>（1）<strong>主键顺序插入</strong>  </p><p>因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。  </p><p>如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。  </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">脚本文件介绍：  </span><br><span class="line">  <span class="function"><span class="title">sql1</span>.<span class="built_in">log</span> -----&gt;</span> 主键有序</span><br><span class="line">  <span class="function"><span class="title">sql2</span>.<span class="built_in">log</span> -----&gt;</span> 主键无序</span><br></pre></td></tr></table></figure><p>插入ID顺序排列数据：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> <span class="keyword">infile</span> <span class="string">'/root/sql1.log'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">'tb_user_1'</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment"># 耗费时长：20.58 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_user_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> <span class="keyword">infile</span> <span class="string">'/root/sql2.log'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">'tb_user_2'</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">#耗费时长：1min 59.29 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_user_2;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sql1.log当中数据有序进行排列；sql2.log当中数据无序进行排列；</span></span><br><span class="line"><span class="comment">#而sql1.log当中的数据将插入到tb_user_1表；sql2.log当中的数据将插入到tb_user_2表当中；</span></span><br><span class="line"><span class="comment">#sql1.log与sql2.log当中数据量完全一致；只数据排列分布顺序不一致；</span></span><br><span class="line"></span><br><span class="line">head sql1.log <span class="comment">#linux 查看sql1.log前一部分的数据内容，id主键数据有序</span></span><br><span class="line">head sql2.log <span class="comment">#linux 查看sql2.log前一部分的数据内容，主键数据无序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> <span class="keyword">infile</span> <span class="string">'/root/sql1.log'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">'tb_user_1'</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment"># load data 加载数据  </span></span><br><span class="line"><span class="comment">#local infile 从本地文件系统当中加载数据；</span></span><br><span class="line"><span class="comment">#'/root/sql1.log' 数据文件在linux当中的位置</span></span><br><span class="line"><span class="comment"># into table 'tb_user_1' 加载数据到具体表tb_user_1当中</span></span><br><span class="line"><span class="comment"># fields terminated by ',' 每一个域之间使用逗号,进行分隔</span></span><br><span class="line"><span class="comment"># lines terminated by '\n' 每一行之间使用\n进行分隔,也就是换行</span></span><br><span class="line"><span class="comment"># 回车之后，在导入数据的过程当中，还需要去进行维护索引，维护唯一索引；unique；</span></span><br><span class="line"><span class="comment"># sql1.log导入到tb_user_1表当中耗费时间为19.37 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_user_1;<span class="comment"># 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> <span class="keyword">infile</span> <span class="string">'/root/sql2.log'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">'tb_user_2'</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">#回车之后，耗费的时间为 1min 51.42 second；和sql1.log导入tb_user_1时差距很大；  </span></span><br><span class="line"><span class="comment">#所以这样就验证了大批量导入数据时，有序数据导入表当中时耗费的时间小于无序数据导入表当中的时间；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_user_2;<span class="comment"># 1000000</span></span><br></pre></td></tr></table></figure><p>（2）<strong>关闭唯一性校验</strong>  </p><p>在导入数据前执行 SET UNIQUE_CHECKS=0, 关闭唯一性校验，在导入结束后执行 SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在tb_user_1表结构当中存在username字段的唯一性索引；如果存在唯一性索引则在插入数据的时候是需要对唯一性字段数据的取值进行校验的；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> infiles <span class="string">'/root/sql1.log'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">'tb_user_1'</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">#耗费时长为 19.39 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>（3）<strong>手动提交事务</strong>  </p><p>如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1；打开自动提交，也可以提高导入的效率。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> infiles <span class="string">'/root/sql1.log'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">'tb_user_1'</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">#耗费时长为 19.58 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_user_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="SQL优化-insert优化"><a href="#SQL优化-insert优化" class="headerlink" title="SQL优化 - insert优化"></a>SQL优化 - insert优化</h2><p><strong>优化insert语句</strong>  </p><p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。  </p><ul><li><p>如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。<br>使得效率比分开执行的单个insert语句块。<br>示例，原始方式为：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'cat'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Jerry'</span>);</span><br></pre></td></tr></table></figure><p>优化后的方案为：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'tom'</span>),(<span class="number">2</span>,<span class="string">'cat'</span>),(<span class="number">3</span>,<span class="string">'Jerry'</span>);</span><br></pre></td></tr></table></figure></li><li><p>在事务中进行数据插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'cat'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Jerry'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li><p>数据有序插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'Tim'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'cat'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'Rose'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Jerry'</span>);</span><br></pre></td></tr></table></figure><p>优化后：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'Tim'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'cat'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'Rose'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'Jerry'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="SQL优化-orderby优化"><a href="#SQL优化-orderby优化" class="headerlink" title="SQL优化 - orderby优化"></a>SQL优化 - orderby优化</h2><p><strong>优化 order by 语句</strong>  </p><p><strong>环境准备</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">'emp'</span>(</span><br><span class="line">  <span class="string">'id'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">'name'</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'age'</span> <span class="built_in">int</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'salary'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="string">'id'</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> DEAFULT <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">#基础数据插入</span></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_emp_age_salary <span class="keyword">on</span> emp(age,salary);<span class="comment">#建立age、salary字段的复合索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">#PRIMARY 主键索引</span></span><br><span class="line"><span class="comment">#idx_emp_age_salary age 复合索引</span></span><br><span class="line"><span class="comment">#idx_emp_age_salary salary 复合索引</span></span><br></pre></td></tr></table></figure><p><strong>两种排序方式</strong>  </p><p>（1）<strong>第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫做 FileSort排序</strong>。  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age;#key:<span class="keyword">NULL</span>；key_len:<span class="keyword">NULL</span>；Extra：<span class="keyword">Using</span> filesort;<span class="keyword">type</span>:<span class="keyword">ALL</span> 没有走索引，全表扫描（升序）</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age,salary;#key:<span class="keyword">NULL</span>；key_len:<span class="keyword">NULL</span>；Extra：<span class="keyword">Using</span> filesort;<span class="keyword">type</span>:<span class="keyword">ALL</span> 没有走索引，全表扫描（升序）</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;#key:<span class="keyword">NULL</span>；key_len:<span class="keyword">NULL</span>；Extra：<span class="keyword">Using</span> filesort;<span class="keyword">type</span>:<span class="keyword">ALL</span> 没有走索引，全表扫描（降序）</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>,salary <span class="keyword">desc</span>;#key:<span class="keyword">NULL</span>；key_len:<span class="keyword">NULL</span>；Extra：<span class="keyword">Using</span> filesort;<span class="keyword">type</span>:<span class="keyword">ALL</span> 没有走索引，全表扫描（降序）</span><br><span class="line"></span><br><span class="line">#通过file sort 文件系统进行排序，效率较低</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;#<span class="keyword">type</span>：<span class="keyword">ALL</span>，key：<span class="keyword">NULL</span>；key_len:<span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;#<span class="keyword">type</span>：<span class="keyword">ALL</span>，key：<span class="keyword">NULL</span>；key_len:<span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><p>（2）<strong>第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</strong>。  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;#走索引；key：idx_age_salary；key_len:<span class="number">9</span>；Extra：<span class="keyword">Using</span> <span class="keyword">index</span> 走索引</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id,age <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;#走索引；key：idx_age_salary；key_len:<span class="number">9</span>；Extra：<span class="keyword">Using</span> <span class="keyword">index</span> 走索引</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id,age,salary <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;#走索引；key：idx_age_salary；key_len:<span class="number">9</span>；Extra：<span class="keyword">Using</span> <span class="keyword">index</span> 走索引</span><br><span class="line">#覆盖索引的用法；查询<span class="keyword">select</span> 的字段都是覆盖索引则这个时候使用的即为<span class="keyword">using</span> <span class="keyword">index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id,age,salary,<span class="type">name</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;#走索引；key：<span class="keyword">NULL</span>；key_len:<span class="keyword">NULL</span>；<span class="keyword">type</span>:<span class="keyword">ALL</span>；Extra：<span class="keyword">Using</span> filesort 全表扫描；由于查询的字段当中包含了非索引字段；即并未覆盖索引；所以走全表扫描的方式；id、age、salary这三个字段都有索引；而<span class="type">name</span>字段没有索引；</span><br></pre></td></tr></table></figure><p><strong>多字段排序</strong>  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id ,age,salary <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age,salary;#key:idx_age_salary;key_len:<span class="number">9</span>;Extra:<span class="keyword">Using</span> <span class="keyword">index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id ,age,salary <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>,salary <span class="keyword">asc</span>;#key:idx_age_salary;key_len:<span class="number">9</span>;Extra:<span class="keyword">Using</span> <span class="keyword">index</span>(<span class="keyword">order</span> <span class="keyword">by</span> 如不标明<span class="keyword">desc</span>或者<span class="keyword">asc</span>;默认为<span class="keyword">asc</span>升序排序)</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id,age,salary <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>,salary <span class="keyword">desc</span>;#key:idx_age_salary;key_len:<span class="number">9</span>;Extra:<span class="keyword">Using</span> <span class="keyword">index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id,age,salary <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>,salary <span class="keyword">desc</span>;#key:idx_age_salary;key_len:<span class="number">9</span>;Extra:<span class="keyword">Using</span> <span class="keyword">index</span>;<span class="keyword">Using</span> filesort此时就会出现Filesort</span><br><span class="line"></span><br><span class="line"># 即在使用<span class="keyword">order</span> <span class="keyword">by</span>进行多字段排序的时候，如果想要效率较高；那么此时最好这些多字段统一排序方式；要么都是升序要么都是降序；如果出现一升一降那么就会出现Filesort；文件系统排序造成效率低；</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id,age,salary <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">asc</span>,age <span class="keyword">asc</span>;#key:idx_age_salary;key_len:<span class="number">9</span>;Extra:<span class="keyword">Using</span> <span class="keyword">index</span>;<span class="keyword">Using</span> filesort；此时将age <span class="keyword">asc</span>进行了调后处理；也出现了Filesort</span><br><span class="line">#原因在于：</span><br><span class="line">#按照多字段进行排序，要么统一进行升序<span class="keyword">asc</span>要么统一进行降序排序；</span><br><span class="line">#如果按照多字段进行排序，那么排序的顺序需要和复合索引当中的字段顺序要保持一致；</span><br><span class="line">#复合索引为idx_emp_age_salary（age，salary）复合索引当中age字段的索引顺序先于salary字段的顺序；</span><br><span class="line">#而此时<span class="keyword">SQL</span>当中<span class="keyword">order</span> <span class="keyword">by</span>语句多字段排序salary字段先于age字段；所以此时Extra当中就出现了<span class="keyword">using</span> <span class="keyword">index</span>；也出现了<span class="keyword">using</span> filesort;</span><br></pre></td></tr></table></figure><p>了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。  </p><p>where条件和Order by 使用相同的索引并且Order by 的顺序和索引顺序相同，并且Order by的字段都是升序，或者都是降序。  </p><p>否则肯定需要额外的操作，这样就会出现FileSort排序；  </p><h3 id="Filesort的优化"><a href="#Filesort的优化" class="headerlink" title="Filesort的优化"></a>Filesort的优化</h3><p>尽可能避免Filesort的出现，但是无法完全避免Filesort的出现；  </p><p>通过创建合适的索引，能够减少Filesort的出现。  </p><p>但是在某些情况下，条件限制不能让Filesort小时，那就需要加快Filesort的排序操作，对于Filesort，MySQL有两种排序算法：  </p><p>（1）两次扫描算法：MySQL4.1之前，使用该方式排序。<br>    首先，根据条件取出排序字段和行指针信息，然后在排序区 sort buffer中排序；<br>    如果sort buffer不够，则在临时表 temporary table中存储排序结果。<br>    完成排序之后，再根据航指针回表读取记录，该操作可能会导致大量随机I/O操作。  </p><p>（2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区sort buffer中排序后直接输出结果集。<br>    排序时内存开销较大，但是排序效率比两次扫描算法要高；  </p><p>MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query 语句取出的字段总大小，来判定合适哪一种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种；  </p><p>可以适当提高 sort_buffer_size和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'max_length_for_sort_data'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>max_length_for_sort_data</td>    <td>1024</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'sort_buffer_size'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>sort_buffer_size</td>    <td>262144</td>  </tr></table><h2 id="SQL优化-group-by优化"><a href="#SQL优化-group-by优化" class="headerlink" title="SQL优化 - group by优化"></a>SQL优化 - group by优化</h2><p>由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY相比，GROUP BY主要只是多了排序字后的分组操作。  </p><p>当然如果在分组的时候还是用了其他的一些聚合函数，那么还需要一些聚合函数的计算。  </p><p>所以，在GROUP BY的实现过程中，与ORDER BY一样也可以利用到索引。  </p><p>如果查询包含GROUP BY，但是用户想要避免排序结果的消耗，则可以执行order by null 禁止排序。  </p><p>如下：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> idx_emp_age_salary <span class="keyword">on</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> age,count(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age;#key:<span class="keyword">NULL</span>,key_len:<span class="keyword">NULL</span>;<span class="keyword">type</span>:<span class="keyword">ALL</span>;Extra:<span class="keyword">Using</span> <span class="keyword">temporary</span>;<span class="keyword">Using</span> filesort; 由此可以看出<span class="keyword">GROUP</span> <span class="keyword">BY</span> 底层进行了排序操作；<span class="keyword">Using</span> filesort</span><br><span class="line"><span class="meta">#Using temporary与Using Filesort都是比较耗时的操作；</span></span><br></pre></td></tr></table></figure><p>优化后：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> age,count(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span>;#key:<span class="keyword">null</span>;key_len:<span class="keyword">null</span>;<span class="keyword">type</span>:<span class="keyword">All</span>;Extra:<span class="keyword">Using</span> <span class="keyword">temporary</span>;此时就没有<span class="keyword">Using</span> filesort了</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出，第一个SQL语句需要进行“Filesort”，而第二个SQL语句由于order by null不需要进行“Filesort”，而上文提过FileSort往往非常耗费时间。  </p><p> 创建索引：  </p> <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_emp_age_salary  <span class="keyword">on</span> emp(age,salary);</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> age,<span class="built_in">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">order</span> <span class="keyword">by</span> <span class="literal">null</span>;#key:idx_emp_age_salary;key_len:9;extra:using <span class="keyword">index</span> 此时走索引；</span><br><span class="line">#<span class="keyword">group</span> <span class="keyword">by</span>语句也是可以通过索引来提高效率的；</span><br></pre></td></tr></table></figure><h2 id="SQL优化-子查询优化"><a href="#SQL优化-子查询优化" class="headerlink" title="SQL优化 - 子查询优化"></a>SQL优化 - 子查询优化</h2><p><strong>优化嵌套查询</strong>  </p><p>MySQL4.1 版本之后，开始支持SQL的子查询。  </p><p>这个技术可以使用select语句来创建一个单列的查询结果，然后吧这个结果来作为过滤条件用在另一个查询当中。  </p><p>使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。  </p><p>但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。(使用多表连接查询来替换子查询)  </p><p>示例，查找有角色的所有用户信息：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;<span class="comment"># t_user 用户表 , t_role 角色表 , user_role 用户角色中间表 ；</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> ( <span class="keyword">select</span> user_id <span class="keyword">from</span> user_role);</span><br></pre></td></tr></table></figure><p>执行计划为：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> user_id <span class="keyword">from</span> user_role);</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>t_user</td>    <td>ALL</td>    <td>PRIMARY</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>6</td>    <td>Using where</td>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>< subquery2></td>    <td>eq_ref</td>    <td>< auto_key></td>    <td>< auto_key></td>    <td>99</td>    <td>demo_02.t_user.id</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>2</td>    <td>MATERIALIZED</td>    <td>user_role</td>    <td>index</td>    <td>fk_ur_user_id</td>    <td>fk_ur_user_id</td>    <td>99</td>    <td>NULL</td>    <td>6</td>    <td>Using index</td>  </tr></table><p>优化后：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user u,user_role ur <span class="keyword">where</span> u.id=ur.user_id;<span class="comment">#多表联查替代子查询</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>u</td>    <td>ALL</td>    <td>PRIMARY</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>6</td>    <td>NULL</td>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>ur</td>    <td>ref(ref的效率比index效率高)</td>    <td>fk_ur_user_id</td>    <td>fk_ur_user_id</td>    <td>99</td>    <td>demo_02.u.id</td>    <td>1</td>    <td>NULL</td>  </tr></table><h2 id="SQL优化-or优化"><a href="#SQL优化-or优化" class="headerlink" title="SQL优化 - or优化"></a>SQL优化 - or优化</h2><p><strong>对于包含 OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引，而且不能使用到复合索引；如果没有索引，则应该考虑增加索引</strong>。  </p><p>获取emp表中的所有的索引；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">show</span> index <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line">explain <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="built_in">where</span> id=<span class="number">1</span> <span class="built_in">or</span> name='Tom;#id为主键，即存在主键索引；而name字段没有设置索引；所以此时用<span class="built_in">or</span>来连接两个条件时，当中包含有一个非索引字段；所以不会走索引,索引失效，采用的是全表扫描；<span class="built_in">key</span>:NULL;key_len:NULL;<span class="built_in">type</span>:ALL;extra:Using <span class="built_in">where</span>；<span class="built_in">or</span>关键字如果想要走索引则<span class="built_in">or</span>连接的条件列字段需要是索引列；从而能够走索引否则全表扫描不走索引；</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="built_in">where</span> age=<span class="number">20</span> <span class="built_in">or</span> salary=<span class="number">3500</span>;#<span class="built_in">key</span>:NULL,key_len:NULL;<span class="built_in">type</span>;All;extra:Using <span class="built_in">where</span>;此时未走索引；age与salary为复合索引当中的索引列；而<span class="built_in">or</span>关键字所连接的条件列当中字段的索引不能为复合索引列；可以为主键索引列、唯一索引列、单列索引等；就是不能为复合索引列其他皆可；</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="built_in">where</span> id=<span class="number">1</span> <span class="built_in">or</span> age=<span class="number">30</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>t_user</td>    <td>ALL</td>    <td>PRIMARY</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>6</td>    <td>Using where</td>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>emp</td>    <td>index_merge</td>    <td>PRIMARY,idx_emp_age_salary</td>    <td>PRIMARY,idx_emp_age_salary</td>    <td>4,4</td>    <td>NULL</td>    <td>2</td>    <td>Using sort_union(idx_emp_age_salary,PRIMARY);Using where</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">or</span> <span class="keyword">id</span>=<span class="number">10</span> \G;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>emp</td>    <td>range</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>4</td>    <td>NULL</td>    <td>2</td>    <td>Using where</td>  </tr></table><p>建议使用 union 替换 or；  </p><p>优化：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">10</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>emp</td>    <td>const(const效率远高于range)</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>4</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>2</td>    <td>UNION</td>    <td>emp</td>    <td>const</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>4</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>NULL</td>    <td>UNION RESULT</td>    <td>< union1,2></td>    <td>ALL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>Using temporary</td>  </tr></table><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">explain select * from emp where id=<span class="number">1</span> or age=<span class="number">20</span>;</span><br><span class="line"><span class="meta">#id 1</span></span><br><span class="line"><span class="meta">#select_type SIMPLE</span></span><br><span class="line"><span class="meta">#table emp</span></span><br><span class="line"><span class="meta">#possible_key PRIMARY,idx_emp_age_salary</span></span><br><span class="line"><span class="meta">#key idx_emp_age_salary,PRIMARY</span></span><br><span class="line"><span class="meta">#key_len 4,4</span></span><br><span class="line"><span class="meta">#ref NULL</span></span><br><span class="line"><span class="meta">#rows 2</span></span><br><span class="line"><span class="meta">#extra Using sort_union(idx_emp_age_salary,PRIMARY)</span></span><br><span class="line"><span class="meta">#type index_merge</span></span><br></pre></td></tr></table></figure><p>优化：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> age=<span class="number">20</span>;</span><br><span class="line"><span class="comment">#union即为一个求并集的一个操作；</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>emp</td>    <td>const(const效率远高于range)</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>4</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>2</td>    <td>UNION</td>    <td>emp</td>    <td>ref(ref比index_merge效率高)</td>    <td>idx_emp_age_salary</td>    <td>idx_emp_age_salary</td>    <td>4</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>NULL</td>    <td>UNION RESULT</td>    <td>< union1,2></td>    <td>ALL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>Using temporary</td>  </tr></table><p>建议通过union替换or；<br>来比较下重要指标，发现主要差别是type和ref这两项；<br>type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="keyword">ref</span> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; uniqe_subquery &gt; index_subquery &gt; range &gt; <span class="keyword">index</span> &gt; <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><p>UNION语句的type值为ref，OR语句的type值为range，可以看到这是一个很明显的差距  </p><p>UNION语句的ref值为const，OR语句的type值为NULL，const表示是常量值引用，非常快  </p><p>这两项的差距就说明了UNION要优于OR；</p><h2 id="SQL优化-limit优化"><a href="#SQL优化-limit优化" class="headerlink" title="SQL优化 - limit优化"></a>SQL优化 - limit优化</h2><h3 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h3><p>一般分页查询时，通过创建覆盖索引能够比较好的提高性能。  </p><p>一个常见又非常头疼的问题就是 limit 2000000,10;   此时需要MySQL排序前2000010记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大。  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">limit</span> <span class="number">2000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_item</td>    <td>ALL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>9816098</td>    <td>NULL</td>  </tr></table><h3 id="优化思路一"><a href="#优化思路一" class="headerlink" title="优化思路一"></a>优化思路一</h3><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slect count(*) from tb_item;#3000000</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">limit</span> <span class="number">10</span>,<span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">limit</span> <span class="number">20</span>,<span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">limit</span> <span class="number">2000000</span>,<span class="number">10</span>;#查询效率低 此时为全表扫描没有使用得到索引；</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item t, (<span class="keyword">select</span> id <span class="keyword">from</span> tb_item <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">limit</span> <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">where</span> t.id=a.id;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>< derived2></td>    <td>ALL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>2000010</td>    <td>NULL</td>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>t</td>    <td>eq_ref</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>4</td>    <td>a.id</td>    <td>1</td>    <td>NULL</td>  </tr>    <tr>    <td>2</td>    <td>DERIVED</td>    <td>tb_item</td>    <td>index</td>    <td>NULL</td>    <td>PRIMARY</td>    <td>4</td>    <td>NULL</td>    <td>2903274</td>    <td>Using index</td>  </tr></table><h3 id="优化思路二"><a href="#优化思路二" class="headerlink" title="优化思路二"></a>优化思路二</h3><p>该方案适用于<strong>主键自增的表(且主键自增的列不能够出现断层)</strong>，可以把limit 查询转换成某个位置的查询；  </p><p><strong>断层</strong>：即指的是当在查询数据时，id主键自增列当中可能会有出现修改或者删除的操作，那么这个时候数据就不一定准确了；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">1000000</span> <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_item</td>    <td>range</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>4</td>    <td>NULL</td>    <td>4908049</td>    <td>Using where</td>  </tr></table><h2 id="SQL优化-索引提示"><a href="#SQL优化-索引提示" class="headerlink" title="SQL优化 - 索引提示"></a>SQL优化 - 索引提示</h2><p><strong>使用SQL提示</strong>  </p><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。  </p><h3 id="USE-INDEX"><a href="#USE-INDEX" class="headerlink" title="USE INDEX"></a>USE INDEX</h3><p>在查询语句中 表名称的后面 ，添加 use index 来提供希望MySQL去<strong>参考</strong>的索引列表，就可以让MySQL不再考虑其他可用的索引。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> tb_seller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_name <span class="keyword">on</span> tb_seller(<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_status <span class="keyword">on</span> tb_seller(<span class="keyword">status</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_name_sta_addr <span class="keyword">on</span> tb_seller(<span class="keyword">name</span>,<span class="keyword">status</span>,address);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_seller</td>    <td>ref</td>    <td>idx_seller_name_sta_address,idx_seller_name</td>    <td>idx_seller_name(数据库选择使用idx_seller_name索引)</td>    <td>403</td>    <td>const</td>    <td>1</td>    <td>Using index condition</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">use</span> <span class="keyword">index</span>(idx_seller_name_sta_address) <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'小米科技'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_seller</td>    <td>ref</td>    <td>idx_seller_name_sta_address</td>    <td>idx_seller_name_sta_address</td>    <td>403</td>    <td>const</td>    <td>1</td>    <td>Using index condition</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">use</span> <span class="keyword">index</span>(idx_seller_name) <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'小米科技'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_seller</td>    <td>ref</td>    <td>idx_seller_name</td>    <td>idx_seller_name</td>    <td>403</td>    <td>const</td>    <td>1</td>    <td>Using index condition</td>  </tr></table><h3 id="IGNORE-INDEX"><a href="#IGNORE-INDEX" class="headerlink" title="IGNORE INDEX"></a>IGNORE INDEX</h3><p>如果用户只是单纯的想让MySQL<strong>忽略</strong>一个或者多个索引，则可以使用 ignore index 作为 hint；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">ignore</span> <span class="keyword">index</span>(idx_seller_name) <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'小米科技'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_seller</td>    <td>ref</td>    <td>idx_seller_name_sta_address</td>    <td>idx_seller_name_sta_address</td>    <td>403</td>    <td>const</td>    <td>1</td>    <td>Using index condition</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">ignore</span> <span class="keyword">index</span>(idx_seller_name_sta_address) <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_seller</td>    <td>ref</td>    <td>idx_seller_name</td>    <td>idx_seller_name</td>    <td>403</td>    <td>const</td>    <td>1</td>    <td>Using index condition</td>  </tr></table><h3 id="FORCE-INDEX"><a href="#FORCE-INDEX" class="headerlink" title="FORCE INDEX"></a>FORCE INDEX</h3><p>为了<strong>强制</strong>MySQL使用一个特定的索引，可在查询中使用 force index 来作为 hint;</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address=<span class="string">'北京市'</span>;#实际没有使用到索引；<span class="keyword">type</span>:<span class="keyword">all</span>;key:<span class="keyword">null</span>;key_len:<span class="keyword">null</span>;extra:<span class="keyword">using</span> <span class="keyword">where</span>使用的是全表扫描；原因在于address为北京市时在表当中占比较多所以由mysql底层判断决定不走索引即全表扫描会快于走索引；所以此处没有使用得到索引；</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller use <span class="keyword">index</span>(idx_seller_address) <span class="keyword">where</span> address=<span class="string">'北京市'</span>;#此时则走索引</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_seller</td>    <td>ALL</td>    <td>idx_seller_address</td>    <td>idx_seller_address</td>    <td>NULL</td>    <td>NULL</td>    <td>12</td>    <td>Using where</td>  </tr></table><h2 id="今日内容2"><a href="#今日内容2" class="headerlink" title="今日内容2"></a>今日内容2</h2><ul><li>应用优化</li><li>MySQL中查询缓存优化</li><li>MySQL内存管理以及优化</li><li>MySQL并发参数调整</li><li>MySQL锁问题</li><li>常用SQL技巧</li></ul><h2 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h2><p>前面章节，介绍了很多数据库的优化措施，但是在实际生产环境中，由于数据库本身的性能局限，就必须对前台的应用进行一些优化，来降低数据库的访问压力。  </p><h3 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h3><p>对于访问数据库来说，建立连接的代价是比较昂贵的，因为频繁的创建关闭连接，是比较耗费资源的，有必要建立数据库连接池，以提高访问的性能。  </p><h3 id="减少对MySQL的访问"><a href="#减少对MySQL的访问" class="headerlink" title="减少对MySQL的访问"></a>减少对MySQL的访问</h3><h4 id="减少对数据进行重复检索"><a href="#减少对数据进行重复检索" class="headerlink" title="减少对数据进行重复检索"></a>减少对数据进行重复检索</h4><p>在编写应用代码时，需要能够理解对数据库的访问逻辑。  </p><p>能够一次连接就获取得到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求。  </p><p>比如，需要获取书籍的id和name字段，则查询如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure><p>之后，在业务逻辑中有需要获取得到书籍状态信息，则查询如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> ,<span class="keyword">status</span> <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure><p>这样，就需要向数据库提交两次请求，数据库就要做两次查询操作。<br>其实完全可以用一条SQL语句得到想要的结果。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> ,<span class="keyword">status</span> <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure><h4 id="增加cache层"><a href="#增加cache层" class="headerlink" title="增加cache层"></a>增加cache层</h4><p>在应用中，可以在应用中增加 缓存 层 来达到减轻数据库负担的目的。  </p><p>缓存层有很多种，也有很多事先方式，只要达到降低数据库的负担又能满足应用需求就可以。  </p><p>因此可以部分数据从数据库中抽取出来放到应用端以文本方式存储，或者使用框架（Mybatis，Hibernate）提供的一级缓存、二级缓存，或者使用redis数据库来缓存数据。  </p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡是应用中使用非常普遍的一种优化方式。  </p><p>负载均衡的机制就是利用某种均衡算法，将固定的负载量分不到不同的服务器上，一次来降低单台服务器的负载，达到优化的效果。  </p><h4 id="利用MySQL复制分流查询"><a href="#利用MySQL复制分流查询" class="headerlink" title="利用MySQL复制分流查询"></a>利用MySQL复制分流查询</h4><p>通过MySQL的主从复制，实现读写分离，使得增删改操作走主节点，查询操作走从结点，从而可以降低单台服务器的读写压力。  </p><h4 id="采用分布式数据库架构"><a href="#采用分布式数据库架构" class="headerlink" title="采用分布式数据库架构"></a>采用分布式数据库架构</h4><p>分布式数据库架构适合大数据量、负载高的情况，它由良好的拓展性和高可用性。<br>通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率。  </p><h2 id="查询缓存-概述及流程"><a href="#查询缓存-概述及流程" class="headerlink" title="查询缓存 - 概述及流程"></a>查询缓存 - 概述及流程</h2><h3 id="Mysql中查询缓存优化-概述"><a href="#Mysql中查询缓存优化-概述" class="headerlink" title="Mysql中查询缓存优化-概述"></a>Mysql中查询缓存优化-概述</h3><p>开启mysql的查询缓存，当执行完全相同的SQL语句的时候，服务器就会直接从缓存中读取结果；当数据被修改，之前的缓存就会失效，修改比较频繁的表不适合做查询缓存。  </p><h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><ol><li>客户端发送一条查询SQL给服务器</li><li>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段。</li><li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；</li><li>将结果缓存并返回给客户端；</li></ol><h2 id="查询缓存-配置参数"><a href="#查询缓存-配置参数" class="headerlink" title="查询缓存 - 配置参数"></a>查询缓存 - 配置参数</h2><h3 id="查询缓存配置"><a href="#查询缓存配置" class="headerlink" title="查询缓存配置"></a>查询缓存配置</h3><ol><li>查看当前的MySQL数据库是否支持查询缓存：  </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p  </span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'have_query_cache'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>have_query_cache</td>    <td>YES</td>  </tr></table><ol start="2"><li>查看当前MySQL是否开启了查询缓存：  </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'query_cache_type'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>query_cache_type</td>    <td>OFF(关闭)</td>  </tr></table><ol start="3"><li>查看查询缓存的占用大小（建议按照1024倍数进行增大）：  </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'query_cache_size'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>query_cache_size</td>    <td>1048576（单位为字节，占用内存空间约为：1048576/1024/1024约为 1M的内存空间）</td>  </tr></table><ol start="4"><li>查看查询缓存的状态变量</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr>    <td>Qcache_hits</td>    <td>13</td>  </tr>  <tr>    <td>Qcache_inserts</td>    <td>6</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>16</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>4</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> demo_02;<span class="comment">#切换数据库也算是一次查询mysql底层当中</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗费时间2.76 second</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗费时间2.53 second</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks（可用的内存块的个数）</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory（可用的内存空间）</td>    <td>1038344</td>  </tr>  <tr>    <td>Qcache_hits（查询缓存的命中次数）</td>    <td>13</td>  </tr>  <tr>    <td>Qcache_inserts（添加到缓存当中的次数）</td>    <td>6</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes（如果内存空间不足，将内存中数据移出缓存空间次数）</td>    <td>0</td>  </tr>  <tr>    <td style="color:red;font-weight:bolder;">Qcache_not_cached(当前查询没有进行缓存次数)</td>    <td style="color:red;font-weight:bolder;">19</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>4</td>  </tr></table><table>  <tr>    <th>参数</th>    <th>含义</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>查询缓存中的可用内存块数</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>查询缓存的可用内存量</td>  </tr><tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>查询缓存命中数</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts</td>    <td>添加到查询缓存的查询数</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>由于内存不足而从查询缓存中删除的查询数</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached</td>    <td>非缓存查询的数量（由于query_cache_type设置而无法缓存或者未缓存）</td>  </tr>  <tr>    <td>Qcache_queries_in_cache</td>    <td>查询缓存中注册的查询数</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>查询缓存中的块总数</td>  </tr></table><h2 id="查询缓存-开启查询缓存"><a href="#查询缓存-开启查询缓存" class="headerlink" title="查询缓存 - 开启查询缓存"></a>查询缓存 - 开启查询缓存</h2><p>MySQL的查询缓存默认是关闭的，需要手动配置参数 query_cache_type，来开启查询缓存。  </p><p>query_cache_type 该参数的可取值有三个：  </p><table>  <tr>    <th>值</th>    <th>定义</th>  </tr>  <tr>    <td>OFF 或 0</td>    <td>查询缓存功能关闭</td>  </tr>    <tr>    <td>ON 或 1</td>    <td>查询缓存功能打开，SELECT的结果符合缓存条件即会缓存；否则不予缓存；显式指定SQL_NO_CACHE，则不予缓存</td>  </tr>    <tr>    <td> DEMAND 或 2</td>    <td>查询缓存功能按需进行，<span style="color:red;font-weight:bolder;">显式指定 SQL_CACHE 的SELECT语句才会缓存</span>；其他均不予缓存</td>  </tr></table><p>在 /usr/my.cnf配置中，增加以下配置：  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在开启mysql的查询缓存</span></span><br><span class="line"><span class="attr">query_cache_type</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>配置完毕之后，重启服务即可生效；  </p><p>然后就可以在命令行执行SQL语句进行验证，执行一条比较耗时的SQL语句，然后再执行多次，查看后面几次的执行时间；  </p><p>获取通过查看查询缓存的缓存命中数，来判定是否走了查询缓存。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/my.cnf</span><br><span class="line">query_cache_type:1</span><br><span class="line"></span><br><span class="line">service mysql restart<span class="comment">#重启mysql</span></span><br><span class="line"></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> demo_02;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 2.58 second</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 0.00 second</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 0.00 second</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 0.00 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="string">'Qcache'</span>%;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>4</td>  </tr>  <tr>    <td>Qcache_inserts</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr>    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>2</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>4</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 0.00 second</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_inserts</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr>    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>2</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>4</td>  </tr></table><h2 id="查询缓存-SELECT选项"><a href="#查询缓存-SELECT选项" class="headerlink" title="查询缓存 - SELECT选项"></a>查询缓存 - SELECT选项</h2><p>可以在SELECT语句中指定两个与查询缓存相关的选项：  </p><ul><li>SQL_CACHE：如果查询结果是可缓存的，并且query_cache_type 系统变量的值为ON或者DEMAND，则缓存查询结果；  </li><li>SQL_NO_CACHE: 服务器不使用查询缓存，它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。  </li></ul><p>例子：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_CACHE id, name <span class="keyword">FROM</span> customer;</span><br><span class="line">SELECT SQL_NO_CACHE id,name <span class="keyword">FROM</span> customer;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item  <span class="keyword">limit</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span>  <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>5</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr>    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>2</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>8</td>  </tr></table><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_NO_CACHE <span class="built_in">title</span>, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> id=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>6</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts（添加到缓存的数量）</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>2</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>8</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_NO_CACHE title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>6</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts（添加到缓存的数量）</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>8</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_NO_CACHE title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> SQL_NO_CACHE title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1035936</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>6</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts（添加到缓存的数量）</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>8</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_CACHE</span> title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_CACHE</span> title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>7</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts（添加到缓存的数量）</td>    <td>4</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>4</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>10</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_CACHE</span> title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_CACHE</span> title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>9</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts（添加到缓存的数量）</td>    <td>4</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>4</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>10</td>  </tr></table><h2 id="查询缓存-失效场景"><a href="#查询缓存-失效场景" class="headerlink" title="查询缓存 - 失效场景"></a>查询缓存 - 失效场景</h2><table>  <tr>    <th>值</th>    <th>定义</th>  </tr>  <tr>    <td>OFF 或 0</td>    <td>查询缓存功能关闭</td>  </tr>    <tr>    <td>ON 或 1</td>    <td>查询缓存功能打开，<span style="color:red;font-weight:bolder;">SELECT的结果符合缓存条件即会缓存</span>；否则不予缓存；显式指定SQL_NO_CACHE，则不予缓存</td>  </tr>    <tr>    <td> DEMAND 或 2</td>    <td>查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其他均不予缓存</td>  </tr></table><p>开启mysql的查询缓存，当执行<strong>完全相同的SQL语句</strong>的时候，服务器就会直接从缓存中读取结果；当数据被修改，之前的缓存就会失效，修改比较频繁的表不适合做查询缓存。</p><ol><li>SQL语句不一致的情况，要想命中查询缓存，查询的SQL语句必须一致。  </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#SQL1：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#3000000 耗时0.00 second</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#SQL2：</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#3000000 耗时2.79 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1033888</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>11</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr>    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>12</td>  </tr></table><ol start="2"><li>当查询语句中有一些不确定的时候，则不会缓存。如：now()、current_date()、curdate()、curtime()、rand()、uuid()、user()、database()；  </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>(); <span class="comment"># 耗时 0.01 second</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>(); <span class="comment"># 耗时 0.01 second；时间是发生了变化的；即不会走缓存</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1033888</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>11</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>7</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>12</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#SQL1：</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> updatetime &lt; <span class="keyword">now</span>() <span class="keyword">limit</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#SQL2：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">#SQL3：</span></span><br><span class="line"><span class="keyword">select</span> databse();</span><br></pre></td></tr></table></figure><ol start="3"><li>不适用任何表查询语句。  </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1033888</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>11</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>8</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>12</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'A'</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>查询mysql、information_schema 或者 performance_schema 数据库中的表时，不会走查询缓存。  </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"><span class="comment">#information_schema</span></span><br><span class="line"><span class="comment">#mysql</span></span><br><span class="line"><span class="comment">#performance_schema</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.engines;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1033888</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>11</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>9</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>12</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.engines;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1033888</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>11</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>10</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>12</td>  </tr></table><ol start="5"><li><p>在存储的函数，触发器或者时间的主体内执行的查询；</p></li><li><p>如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。这包括使用<strong>MERGE</strong>映射到已更改表的查询。一个表可以被许多类型的语句，如被改变INSERT、UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE 或者 DROP DATABASE。  </p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 0.00 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> tb_item <span class="keyword">set</span> title=<span class="string">'test1'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 2.67 second；该SQL失效；但是失效的同时又去进行了缓存；当前查询时并未缓存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 0.00 second；此时再去查询；即查询的缓存区内的内容</span></span><br></pre></td></tr></table></figure><h2 id="内存优化-优化原则"><a href="#内存优化-优化原则" class="headerlink" title="内存优化 - 优化原则"></a>内存优化 - 优化原则</h2><h3 id="内存优化原则"><a href="#内存优化原则" class="headerlink" title="内存优化原则"></a>内存优化原则</h3><ol><li>将尽量多的内存分配给MySQL做缓存(提高mysql的访问效率)，但要给操作系统和其他程序预留足够内存；</li><li>MyISAM存储引擎的数据文件读取依赖于操作系统自身的I/O缓存，因此，如果有MyISAM表，就要预留更多的内存给操作系统做I/O缓存。</li><li>排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。</li></ol><h2 id="内存优化-MyISAM内存优化"><a href="#内存优化-MyISAM内存优化" class="headerlink" title="内存优化 - MyISAM内存优化"></a>内存优化 - MyISAM内存优化</h2><p>MyISAM的缓存机制：  </p><p>MyISAM存储引擎使用key_buffer缓存索引块（没有缓存数据块），加速MyISAM索引的读写速度，对于MyISAM表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的I/O缓存。  </p><p><strong>key_buffer_size</strong>  </p><p>key_buffer_size决定MyISAM索引块缓存区的大小，直接影响到MyISAM表的存取效率。  </p><p>可以在mysql参数文件中设置key_buffer_size的值，对于一般MyISAM数据库，建议至少将1/4可用内存分配给key_buffer_size。  </p><p>在/usr/my.cnf 中做如下配置：  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key_buffer_size</span>=<span class="number">512</span>M</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'key_buffer_size'</span>;<span class="comment">#mysql 命令行</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>key_buffer_size</td>    <td>8388608(单位为字节；默认大小)</td>  </tr></table><p><strong>read_buffer_size</strong>  </p><p>如果需要经常顺序扫描MyISAM表，可以通过增大read_buffer_size的值来改善性能。  </p><p>但是需要注意的是read_buffer_size是每个session独占的，如果默认值设置太大，就会造成内存浪费。  </p><p><strong>read_rnd_buffer_size</strong>  </p><p>对于需要做排序的MyISAM表的查询，如带有 order by 子句的SQL，适当增加read_rnd_buffer_size的值，可以改善此类的SQL性能。  </p><p>但是需要注意的是read_rnd_buffer_size 是每个session独占的，如果默认值设置太大，就会造成内存浪费。  </p><h2 id="内存优化-InnoDB内存优化"><a href="#内存优化-InnoDB内存优化" class="headerlink" title="内存优化 - InnoDB内存优化"></a>内存优化 - InnoDB内存优化</h2><p>innodb的缓存机制：<br>InnoDB用一块内存区做IO缓存池，该缓存池不仅用来缓存InnoDB的索引块，而且也用来缓存InnoDB的数据块。  </p><p><strong>innodb_buffer_pool_size</strong>  </p><p>该变量决定了innodb存储引擎表数据和索引数据的最大缓存区大小。<br>在保证操作系统以及其他程序有足够内存可用的情况下，innodb_buffer_pool_size的值越大，缓存命中率越高，访问innodb表的需要的磁盘I/O就越少，性能也就越高。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_buffer_pool_size'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>innodb_buffer_pool_size</td>    <td>134217728(单位为字节；默认大小128M；134217728/1024-->131072（换算成B），134217728/1024/1024-->128（换算成M）；)</td>  </tr></table><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/<span class="keyword">my</span>.cnf</span><br><span class="line"><span class="comment"># innodb_buffer_pool_size=512M #修改内容</span></span><br></pre></td></tr></table></figure><p><strong>innodb_log_buffer_size</strong>  </p><p>决定了innodb重做日志缓存的大小，对于避免产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/my.cnf</span><br><span class="line"><span class="comment"># innodb_log_buffer_size=10M #修改内容</span></span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><h2 id="并发参数调整"><a href="#并发参数调整" class="headerlink" title="并发参数调整"></a>并发参数调整</h2><h3 id="mysql并发参数调整"><a href="#mysql并发参数调整" class="headerlink" title="mysql并发参数调整"></a>mysql并发参数调整</h3><p>从实现上来说，MySQL Server是多线程结构，包括后台线程和客户服务线程。  </p><p>多线程可以有效利用服务器资源，提高数据库的并发性能。  </p><p>在mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_size；  </p><h4 id="max-connections（最大连接数）"><a href="#max-connections（最大连接数）" class="headerlink" title="max_connections（最大连接数）"></a>max_connections（最大连接数）</h4><p>采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是151。  </p><p>如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已经达到允许最大值而失败，这时可以考虑增大max_connections的值。  </p><p>MySQL最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。  </p><p>在Linux平台下，性能好的服务器，支持500-1000个连接都不是难事，需要根据服务器性能进行评估设定。  </p><h4 id="back-log"><a href="#back-log" class="headerlink" title="back_log"></a>back_log</h4><p>back_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。  </p><p>如果mysql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。  </p><p>5.6.6版本之前默认值为50，之后的版本默认为50+（max_connections/5），但最大不超过900。  </p><p>如果需要数据库在较短的时间内处理大量连接请求，可以考虑适当增大back_log的值。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'back_log'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>back_log</td>    <td>80(默认个数)</td>  </tr></table><h4 id="table-open-cache"><a href="#table-open-cache" class="headerlink" title="table_open_cache"></a>table_open_cache</h4><p>该参数用来控制所有SQL语句执行线程可打开表缓存的数量，而在执行SQL语句时，每一个SQL执行线程至少要打开一个表缓存，该参数的值应该根据设置的最大连接数max_connections 以及每个连接执行关联查询中涉及的白鸥的最大数量来决定。  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_connections x N<span class="comment">;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'table_open_cache'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>table_open_cache</td>    <td>2000(默认大小)</td>  </tr></table><h4 id="thread-cache-size（线程缓存大小）"><a href="#thread-cache-size（线程缓存大小）" class="headerlink" title="thread_cache_size（线程缓存大小）"></a>thread_cache_size（线程缓存大小）</h4><p>为了加快连接数据库的速度，MySQL会缓存一定数量的客户服务线程（线程池）以备重用，通过参数 thread_cache_size 可控制MySQL缓存客户服务线程的数量（线程池的大小）。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'thread_cache_size'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>thread_cache_size</td>    <td>9(默认大小9个线程)</td>  </tr></table><h4 id="innodb-lock-wait-timeout（innodb行锁的等待时间）"><a href="#innodb-lock-wait-timeout（innodb行锁的等待时间）" class="headerlink" title="innodb_lock_wait_timeout（innodb行锁的等待时间）"></a>innodb_lock_wait_timeout（innodb行锁的等待时间）</h4><p>该参数是用来设置InnoDB事务等待行锁的时间，默认值时候50ms。  </p><p>可以根据需要进行动态设置。  </p><p>对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起；  </p><p>对于后台运行的批量处理程序来说，可以将行锁的等待时间调大，以避免发生大的回滚操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_lock_wait_timeout'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>innodb_lock_wait_timeout</td>    <td>50</td>  </tr></table><h2 id="锁-锁的概述及分类"><a href="#锁-锁的概述及分类" class="headerlink" title="锁 - 锁的概述及分类"></a>锁 - 锁的概述及分类</h2><h3 id="锁概述"><a href="#锁概述" class="headerlink" title="锁概述"></a>锁概述</h3><p>锁是计算机协调多个进程 或者 线程 并发访问某一资源的机制（避免争抢）。  </p><p>在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。  </p><p>如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。  </p><p>从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。  </p><h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><p>从对数据操作的粒度分为：  </p><ol><li>表锁：操作时，会锁定整个表</li><li>行锁：操作时，会锁定当前操作行</li></ol><p>从对数据操作的类型分：  </p><ol><li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响</li><li>写锁（排它锁）：当前操作没有完成之前，他会阻断其他写锁和读锁</li></ol><h2 id="锁-MySQL对锁的支持"><a href="#锁-MySQL对锁的支持" class="headerlink" title="锁 - MySQL对锁的支持"></a>锁 - MySQL对锁的支持</h2><p>相对其他数据库而言，MySQL的锁机制比较简单。  </p><p>其最显著的特点是不同的存储引擎支持不同的锁机制。  </p><p>下标罗列出了各个存储引擎对锁的支持情况。  </p><table>  <tr>    <th>存储引擎</th>    <th>表级锁</th>    <th>行级锁</th>    <th>页面锁</th>  </tr>  <tr>    <td>MyISAM</td>    <td>支持</td>    <td>不支持</td>    <td>不支持</td>  </tr>    <tr>    <td>InnoDB</td>    <td>支持</td>    <td>支持</td>    <td>不支持</td>  </tr>    <tr>    <td>MEMORY</td>    <td>支持</td>    <td>不支持</td>    <td>不支持</td>  </tr>    <tr>    <td>BDB</td>    <td>支持</td>    <td>不支持</td>    <td>支持</td>  </tr></table><p>MySQL这三种锁的特性可大致归纳如下：  </p><table>  <tr>    <th>锁类型</th>    <th>特定</th>  </tr>  <tr>    <td>表级锁</td>    <td>偏向MyISAM存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</td>  </tr>    <tr>    <td>行级锁</td>    <td>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</td>  </tr>    <tr>    <td>页面锁</td>    <td>开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。</td>  </tr></table><p>从上述特点可见，很难笼统的说哪种锁更好，只能就具体应用的特点来说哪种锁更合适。  </p><p>仅从锁的角度来说：<br>  表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；<br>  而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统；  </p><h2 id="锁-MyISAM表锁-读锁"><a href="#锁-MyISAM表锁-读锁" class="headerlink" title="锁 - MyISAM表锁 - 读锁"></a>锁 - MyISAM表锁 - 读锁</h2><p>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</p><p>MyISAM存储引擎支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。  </p><h3 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h3><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等），会自动给涉及的表加写锁，这个过程并不需要用户干预。  </p><p>因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。  </p><p>显示加表锁语法：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加读锁：  </span></span><br><span class="line"><span class="keyword">lock</span> <span class="keyword">table</span> table_name <span class="keyword">read</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#加写锁：  </span></span><br><span class="line"><span class="keyword">lock</span> <span class="keyword">table</span> table_name write;</span><br></pre></td></tr></table></figure><h3 id="读锁案例"><a href="#读锁案例" class="headerlink" title="读锁案例"></a>读锁案例</h3><p>准备环境  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">create database demo_03<span class="built_in"> default </span><span class="attribute">charset</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line">use demo_03;</span><br><span class="line"></span><br><span class="line">CREATE TABLE <span class="string">'tb_book'</span>(</span><br><span class="line">  <span class="string">'id'</span> INT(11) AUTO_INCREMENT,</span><br><span class="line">  <span class="string">'name'</span> VARCHAR(50)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'publish_name'</span> DATE<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'status'</span> CHAR(1)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">'id'</span>)</span><br><span class="line">)<span class="attribute">ENGINE</span>=myisam<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入tb_book 基础数据</span></span><br><span class="line"></span><br><span class="line">CREATE TABLE <span class="string">'tb_user'</span>(</span><br><span class="line">  <span class="string">'id'</span> INT(11) AUTO_INCREMENT,</span><br><span class="line">  <span class="string">'name'</span> VARCHAR(50)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY(<span class="string">'id'</span>)</span><br><span class="line">)<span class="attribute">ENGINE</span>=myisam<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入tb_user 基础数据</span></span><br><span class="line"></span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">lock table tb_book read;</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> tb_books;</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> tb_user;# Table <span class="string">'tb_user'</span> was <span class="keyword">not</span> locked with LOCK TABLES 锁定tb_book表途中无法去操作其他表；除非当前tb_book表锁释放；</span><br><span class="line"></span><br><span class="line">update tb_book <span class="builtin-name">set</span> name =<span class="string">'solr'</span> where <span class="attribute">id</span>=2;#当前对tb_book表进行的锁是读锁，而不是写锁；所以当前无法进行更新；Table <span class="string">'tb_book'</span> was locked with a READ lock <span class="keyword">and</span> can<span class="string">'t be updated.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">unlock tables;#只有当当前的tb_book表当中的读锁进行解锁，其他客户端连接mysql的该表时才能够进行写锁；否则将一直等待当前该tb_book的读锁释放；</span></span><br></pre></td></tr></table></figure><p>如果对MyISAM表进行操作了读锁，其不会阻塞其他线程的读操作，但是会阻塞其他线程的写操作。  </p><h2 id="锁-MyISAM表锁-写锁"><a href="#锁-MyISAM表锁-写锁" class="headerlink" title="锁 - MyISAM表锁 - 写锁"></a>锁 - MyISAM表锁 - 写锁</h2><p>写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当前客户端</span></span><br><span class="line"><span class="keyword">lock</span> <span class="keyword">table</span> tb_book write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> tb_book <span class="keyword">set</span> <span class="keyword">name</span> =<span class="string">'solr'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_book(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'es'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#其他客户端</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_book;<span class="comment">#其他客户端将一直处于等待状态，除非当前客户端的写锁释放（即当前客户端的业务操作完成），否则其他客户端一直处于等待状态。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当前客户端</span></span><br><span class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#其他客户端</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_book;<span class="comment">#当 当前客户端释放锁之后，该其他客户端即立刻能查询到数据。</span></span><br></pre></td></tr></table></figure><h2 id="锁-MyISAM表锁-小结"><a href="#锁-MyISAM表锁-小结" class="headerlink" title="锁 - MyISAM表锁 - 小结"></a>锁 - MyISAM表锁 - 小结</h2><p>锁模式的互相兼容性如表所示：  </p><table>  <tr>    <th>当前锁模式/请求锁模式</th>    <th>None（理解为当前客户端获取得到的锁）</th>    <th>读锁（其他客户端对于读操作是否可行）</th>    <th>写锁（其他客户端对于写操作是否可行）</th>  </tr>  <tr>    <th>读锁</th>    <td>是（当前客户端获取得到的读锁）</td>    <td>是（其他客户端可以进行读操作）</td>    <td>否（其他客户端无法进行写操作）</td>  </tr>    <tr>    <th>写锁</th>    <td>是（当前客户端获取得到的写锁）</td>    <td>否（其他客户端无法进行读操作）</td>    <td>否（其他客户端无法进行写操作）</td>  </tr></table><p>由上表可见：  </p><ol><li>对MyISAM表的读操作，不会阻塞其他用户对同一张表的读请求，但是会阻塞对同一张表的写请求。</li><li>对MyISAM表的写操作，则会阻塞其他用户对同一张表的读和写操作。</li></ol><p>简而言之，就是读锁会阻塞写，但是不会阻塞读；而写锁，则既会阻塞读，又会阻塞写。  </p><p>此外，MyISAM的读写锁调度是写操作优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。<br>因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p><h2 id="锁-MyISAM表锁-查看锁争用情况"><a href="#锁-MyISAM表锁-查看锁争用情况" class="headerlink" title="锁 - MyISAM表锁 - 查看锁争用情况"></a>锁 - MyISAM表锁 - 查看锁争用情况</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><p>Database: 数据库  </p><p>Table: 数据表  </p><p>In_use: 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。  </p><p>Name_locked: 表名称是否被锁定。名称锁定用于取消表或者对表进行重命名等操作。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">table</span> tb_book write;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;<span class="comment">#database: demo_03; table: tb_book ; In_use(正在使用):1；Name_locked:0</span></span><br><span class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Table_locks%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Table_lockes_immediate</td>    <td>70</td>  </tr>    <tr>    <td>Table_locks_waited</td>    <td>0</td>  </tr></table><p>Table_locks_immediate: 指的是能够立即获得表级锁的次数，每次立即获取锁，值加1；  </p><p>Table_locks_waited: 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。</p><h2 id="锁-InnoDB行锁-介绍及背景知识"><a href="#锁-InnoDB行锁-介绍及背景知识" class="headerlink" title="锁 - InnoDB行锁 - 介绍及背景知识"></a>锁 - InnoDB行锁 - 介绍及背景知识</h2><h3 id="行锁介绍"><a href="#行锁介绍" class="headerlink" title="行锁介绍"></a>行锁介绍</h3><p>InnoDB默认支持行锁，也支持表锁；  </p><p>行锁特点：偏向InnoDB存储迎请，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>（由于锁定粒度最小，所以发生锁冲突的概率最低，二者存在关联）  </p><p>InnoDB与MyISAM的最大不同有两点：一是支持事务；二是采用了行级锁；<br>(事务和行级锁之间存在关联，支持事务的原因即在于InnoDB采用的是行级锁)</p><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p><strong>事务及其ACID属性</strong>  </p><p>事务是由一组SQL语句组成的逻辑处理单元。<br>事务具有以下4个特性，简称为事务ACID属性。  </p><table>  <tr>    <th>ACID属性</th>    <th>含义</th>  </tr>  <tr>    <td>原子性（Atomic）</td>    <td>事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败</td>  </tr>  <tr>    <td>一致性（Consistent）</td>    <td>在事务开始和完成时，数据都必须保持一致状态</td>  </tr>  <tr>    <td>隔离性（Isolation）</td>    <td>数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境下运行</td>  </tr>  <tr>    <td>持久性（Durable）</td>    <td>事务完成之后，对于数据的修改是永久的</td>  </tr></table><p><strong>并发事务处理带来的问题</strong>  </p><table>  <tr>    <th>问题</th>    <th>含义</th>  </tr>  <tr>    <td>丢失更新（Lost Update）</td>    <td>当两个或者多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖</td>  </tr>  <tr>    <td>脏读（Dirty Reads）</td>    <td>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据（一个事务读取到了另外一个事务还未提交的数据）</td>  </tr>  <tr>    <td>不可重复度（Non_repeatable Reads）</td>    <td>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前独处的数据不一致</td>  </tr>  <tr>    <td>幻读（Phantom Reads）</td>    <td>一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。</td>  </tr></table><p><strong>事务隔离级别</strong>  </p><p>为了解决上述提到的事务并发问题，数据库提供一定的事务隔离机制来解决这个问题。  </p><p>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大(性能越低)，因为事务隔离实质上就是使用事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。  </p><p>数据库的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable ，这四个界别可以逐个解决脏写、脏读、不可重复度、幻读这几类问题。  </p><table>  <tr>    <th>隔离级别</th>    <th>丢失更新</th>    <th>脏读</th>    <th>不可重复读</th>    <th>幻读</th>  </tr>  <tr>    <td>Read uncommitted</td>    <td>x</td>    <td>√</td>    <td>√</td>    <td>√</td>  </tr>    <tr>    <td>Read committed</td>    <td>x</td>    <td>x</td>    <td>√</td>    <td>√</td>  </tr>   <tr>    <td>Repeatable read(默认)</td>    <td>x</td>    <td>x</td>    <td>x</td>    <td>√</td>  </tr>    <tr>    <td>Serializable</td>    <td>x</td>    <td>x</td>    <td>x</td>    <td>x</td>  </tr></table><p>备注： √ 代表可能出现， x 代表不会出现。  </p><p>MySQL的数据库的默认隔离级别是 Repeatable read，查看方式：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'tx_isolation'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>tx_isolation</td>    <td>REPEATABLE-READ</td>  </tr></table><h2 id="锁-InnoDB行锁-类型"><a href="#锁-InnoDB行锁-类型" class="headerlink" title="锁 - InnoDB行锁 - 类型"></a>锁 - InnoDB行锁 - 类型</h2><h3 id="InnoDB的行锁模式"><a href="#InnoDB的行锁模式" class="headerlink" title="InnoDB的行锁模式"></a>InnoDB的行锁模式</h3><p>InnoDB实现了以下两种类型的行锁：  </p><ul><li><p>共享锁（S）： 又称为读锁，简称S锁，共享锁就是多个事务对于统一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。  </p></li><li><p>排它锁（X）：又称为写锁，简称X锁，排它锁就是不能与其他锁并存。如果一个事务湖区了一个数据行的排它锁，其他事务就不能再获取该行的其他锁，包括共享锁和排它锁，但是获取排它锁的事务可以对数据进行读取和修改。  </p></li></ul><p>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排它锁（X）；<br>对于普通SELECT语句，InnoDB不会加任何锁；  </p><p>可以通过以下语句显式给记录集加共享锁或者排它锁：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#共享锁（S）</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ...... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#排它锁（X）</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ....... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure><h3 id="案例准备工作"><a href="#案例准备工作" class="headerlink" title="案例准备工作"></a>案例准备工作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_innodb_lock(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>),</span><br><span class="line">  sex <span class="built_in">varchar</span>(<span class="number">1</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">#插入基础数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建单列索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_test_innodb_lock_id <span class="keyword">on</span> test_innodb_lock(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_test_innodb_lock_name <span class="keyword">on</span> test_innodb_lock(<span class="keyword">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><h3 id="行锁基本演示"><a href="#行锁基本演示" class="headerlink" title="行锁基本演示"></a>行锁基本演示</h3><table>  <tr>    <th>Session-1</th>    <th>Session-2</th>  </tr>  <tr>    <td>关闭自动提交功能（set autocommit=0;）</td>    <td>关闭自动提交功能（set autocommit=0;）</td>  </tr>  <tr>    <td>可以正常的查询出全部的数据（select * from test_innodb_lock;）</td>    <td>可以正常的查询出全部的数据（select * from test_innodb_lock;）</td>  </tr>  <tr>    <td>查询id为3的数据；（select * from test_innodb_lock where id=3;）</td>    <td>查询id为3的数据；（select * from test_innodb_lock where id=3;）</td>  </tr>   <tr>    <td>更新id为3的数据，但是不提交（update test_innodb_lock set name='AI' where id=3;）</td>    <td>更新id为3的数据，在Session-1的更新提交完成之前一直处于等待状态；（update test_innodb_lock set name='AII' where id=3;）</td>  </tr><tr>    <td>通过commit，提交事务（commit;）</td>    <td>接触阻塞，更新正常进行（update test_innodb_lock set name='AII' where id=3;）</td>  </tr>  <tr>    <td colspan="2">以上，操作的都是同一行的数据，接下来，演示不同行的数据；</td>  </tr>  <tr>    <td>更新id为3的数据，正常的获取到行锁，执行更新；(update test_innodb_lock set name='a1' where id =3;)</td>    <td>由于与Session-1操作不是同一行，获取当前行锁，执行更新；（update test_innodb_lock set name ="C1" where id=5;）</td>  </tr></table><h2 id="锁-InnoDB行锁-行锁升级为表锁"><a href="#锁-InnoDB行锁-行锁升级为表锁" class="headerlink" title="锁 - InnoDB行锁 - 行锁升级为表锁"></a>锁 - InnoDB行锁 - 行锁升级为表锁</h2><p>如果不通过索引条件检索数据，那么innodb将对表中的所有记录加锁，实际效果跟表锁一样。  </p><p>查看当前表的索引：show index from test_innodb_lock;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> test_innodb_lock\G;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Session-1</th>    <th>Session-2</th>  </tr>  <tr>    <td>关闭事务的自动提交（set autocommit=0;）</td>    <td>关闭事务的自动提交（set autocommit=0;）</td>  </tr>  <tr>    <td>执行更新语句（update test_innodb_lock set sex='2' where <span style="color:red;font-weight:bolder;">name=400</span>; ）</td>    <td>执行更新语句，但是出于阻塞状态（update test_innodb_lock set sex='2' where id=9;）</td>  </tr>   <tr>    <td>提交事务（commit;）</td>    <td>解除阻塞，执行更新成功（update test_innodb_lock set sex='2' where id=9;）</td>  </tr>  <tr>    <td></td>    <td>执行提交操作（commit;）</td>  </tr></table><p>由于执行更新时，name字段本来为varchar类型，但是Session-1当中name作为数字类型来使用，所以存在类型转换，索引失效，最终行锁变为表锁；  </p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> test_innodb_lock;<span class="meta">#查看表结构</span></span><br></pre></td></tr></table></figure><p>索引失效：name字段本来的类型为varcahr类型；如果是varchar类型但是在使用的时候，没有给其name字段的取值加上单引号，那么这个时候索引就将失效；索引失效，行锁升级为表锁；</p><h2 id="锁-InnoDB行锁-间隙锁危害"><a href="#锁-InnoDB行锁-间隙锁危害" class="headerlink" title="锁 - InnoDB行锁 - 间隙锁危害"></a>锁 - InnoDB行锁 - 间隙锁危害</h2><p>当用范围条件，而不是使用相等条件检索数据，并请求共享或者排它锁的时候，InnoDB会给符合条件的已有数据进行加锁；<br>对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁）；  </p><p>ID &lt; 10 ：  </p><ul><li>1,2,3,4,5,6,7,8,9</li><li>1,2,3,4,6,9(此时当中的5 和 7、8 则称之为间隙)</li></ul><p>示例：  </p><table>  <tr>    <th>Session-1</th>    <th>Session-2</th>  </tr>  <tr>    <td>关闭事务自动提交（set autocommit=0;）</td>    <td>关闭事务自动提交（set autocommit=0;）</td>  </tr>  <tr>    <td>根据id范围更新数据（update test_innodb_lock set name='332423' where id < 4 ;）</td>    <td>插入id为2的记录，处于阻塞状态（insert into test_innodb_lock values(2,'1001','1'); ）</td>  </tr>    <tr>    <td>提交事务（commit;）</td>    <td>解除阻塞，执行插入操作（insert into test_innodb_lock values(2,'1001','1'); ）</td>  </tr>   <tr>    <td></td>    <td>提交事务（commit;）</td>  </tr></table><h2 id="锁-InnoDB行锁-争用情况查看"><a href="#锁-InnoDB行锁-争用情况查看" class="headerlink" title="锁 - InnoDB行锁 - 争用情况查看"></a>锁 - InnoDB行锁 - 争用情况查看</h2><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">show status like <span class="string">'innodb_row_lock%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#Innodb_row_lock_current_waits: 当前正在等待锁定的数量；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#Innodb_row_lock_time： 从系统启动到现在锁定总时间长度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#Innodb_row_lock_time_avg: 每次等待所花平均时长</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#Innodb_row_lock_time_max: 从系统启动到现在等待最长的一次所花时间</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#Innodb_row_lock_waits： 系统启动后到现在总共等待的次数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#当等待的次数很高，而且每次等待的时长也不小的时候，就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</span></span><br></pre></td></tr></table></figure><h2 id="锁-InnoDB行锁-总结"><a href="#锁-InnoDB行锁-总结" class="headerlink" title="锁 - InnoDB行锁 - 总结"></a>锁 - InnoDB行锁 - 总结</h2><p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面姚媛媛优于MyISAM的表锁的。  </p><p>当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。  </p><p>但是，InnoDB的行级锁同样也有其脆弱的一面，但使用不当的时候，可能会让InnoDB的整体性能不仅不能比MyISAM高，甚至可能会更差。  </p><p>优化建议：  </p><ul><li>尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少索引条件，以及索引范围，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可能使用低级别事务隔离（前提：但是需要业务层面满足需求）</li></ul><h2 id="SQL技巧-SQL执行顺序及正则表达式"><a href="#SQL技巧-SQL执行顺序及正则表达式" class="headerlink" title="SQL技巧 - SQL执行顺序及正则表达式"></a>SQL技巧 - SQL执行顺序及正则表达式</h2><h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><p>编写顺序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">  &lt;<span class="keyword">select</span> <span class="keyword">list</span>&gt;</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  &lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">  &lt;right_table&gt; <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">  &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">  &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">  &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span></span><br><span class="line">  &lt;limit_params&gt;</span><br></pre></td></tr></table></figure><p>执行顺序  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;left_table&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line"></span><br><span class="line">&lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> &lt;<span class="keyword">select</span> list&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_params&gt;</span><br></pre></td></tr></table></figure><h3 id="正则表达式使用"><a href="#正则表达式使用" class="headerlink" title="正则表达式使用"></a>正则表达式使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_book;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式 regexp</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_book <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'^j'</span>;<span class="comment">#查询name字段取值以 “j” 字符开头的记录行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_book <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'S$'</span>;<span class="comment">#查询name字段取值以 “S” 字符结尾的记录行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_book <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'[uvw]'</span>;<span class="comment">#查询name字段取值包含 “u”、“v”、“w” 字符的记录行</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>符号</th>    <th>含义</th>  </tr>  <tr>    <td>^</td>    <td>在字符串开始处进行匹配</td>  </tr>    <tr>    <td>$</td>    <td>在字符串末尾处进行匹配</td>  </tr>    <tr>    <td>.</td>    <td>匹配任意单个字符，包括换行符</td>  </tr>  <tr>    <td>[...]</td>    <td>匹配出括号内的任意字符</td>  </tr>  <tr>    <td>[^...]</td>    <td>匹配不出括号内的任意字符</td>  </tr>  <tr>    <td>a*</td>    <td>匹配零个或者多个a（包括空串）</td>  </tr>  <tr>    <td>a+</td>    <td>匹配一个或者多个a（不包括空串）</td>  </tr>  <tr>    <td>a?</td>    <td>匹配零个或者一个a</td>  </tr>    <tr>    <td>a1|a2</td>    <td>匹配a1或者a2</td>  </tr>    <tr>    <td>a(m)</td>    <td>匹配m个a</td>  </tr>      <tr>    <td>a(m,)</td>    <td>至少匹配m个a</td>  </tr>      <tr>    <td>a(m,n)</td>    <td>匹配m个a 到n个a</td>  </tr>      <tr>    <td>a(,n)</td>    <td>匹配0到n个a</td>  </tr>      <tr>    <td>(...)</td>    <td>将模式元素组成单一元素</td>  </tr></table><h2 id="SQL技巧-数字函数与字符串函数"><a href="#SQL技巧-数字函数与字符串函数" class="headerlink" title="SQL技巧 - 数字函数与字符串函数"></a>SQL技巧 - 数字函数与字符串函数</h2><h3 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h3><table>  <tr>    <th>函数名称</th>    <th>作用</th>  </tr>  <tr>    <td>ABS</td>    <td>求绝对值</td>  </tr>    <tr>    <td>SQRT</td>    <td>求二次方根</td>  </tr>    <tr>    <td>MOD</td>    <td>求余数</td>  </tr>    <tr>    <td>CEIL和CEILING</td>    <td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td>  </tr>  <tr>    <td>FLOOR</td>    <td>向下取整，返回值转化为一个BIGINT</td>  </tr>  <tr>    <td>RAND</td>    <td>生成一个0-1之间的随机数，传入整数参数是，用来产生重复序列</td>  </tr>  <tr>    <td>ROUND</td>    <td>对所传入参数进行四舍五入</td>  </tr>    <tr>    <td>SIGN</td>    <td>返回参数的符号</td>  </tr>    <tr>    <td>POW和POWER</td>    <td>两个函数的功能相同，都是所传参数的次方的结果值</td>  </tr>  <tr>    <td>SIN</td>    <td>求正弦值</td>  </tr>  <tr>    <td>COS</td>    <td>求余弦值</td>  </tr>  <tr>    <td>ACOS</td>    <td>求反余弦值，与函数COS互为反函数</td>  </tr>    <tr>    <td>TAN</td>    <td>求正切值</td>  </tr>  <tr>    <td>ATAN</td>    <td>求反正切值，与函数TAN互为反函数</td>  </tr>  <tr>    <td>COT</td>    <td>求余切值</td>  </tr></table><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table>  <tr>    <th>函数名称</th>    <th>作用</th>  </tr>  <tr>    <td>LENGTH</td>    <td>计算字符串长度函数，返回字符串的字节长度</td>  </tr>    <tr>    <td>CONCAT</td>    <td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使用一个或者多个</td>  </tr>    <tr>    <td>INSERT</td>    <td>替换字符串函数</td>  </tr>    <tr>    <td>LOWER</td>    <td>将字符串中的字母转换为小写</td>  </tr>    <tr>    <td>UPPER</td>    <td>将字符串中的字母转换为大写</td>  </tr>    <tr>    <td>LEFT</td>    <td>从左侧截取字符串，返回字符串左边的若干个字符</td>  </tr>    <tr>    <td>RIGTH</td>    <td>从右侧截取字符串，返回字符串右边的若干个字符</td>  </tr>    <tr>    <td>TRIM</td>    <td>删除字符串左右两侧的空格</td>  </tr>    <tr>    <td>REPLACE</td>    <td>字符串替换函数，返回替换后的新字符串</td>  </tr>    <tr>    <td>SUBSTRING</td>    <td>截取字符串，返回从指定位置开始的指定长度的字符串</td>  </tr>    <tr>    <td>REVERSE</td>    <td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td>  </tr></table><h2 id="SQL技巧-日期函数与聚合函数"><a href="#SQL技巧-日期函数与聚合函数" class="headerlink" title="SQL技巧 - 日期函数与聚合函数"></a>SQL技巧 - 日期函数与聚合函数</h2><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table>  <tr>    <th>函数名称</th>    <th>作用</th>  </tr>  <tr>    <td>CURDATE和CURRENT_DATE</td>    <td>两个函数作用相同，返回当前系统的日期值</td>  </tr>  <tr>    <td>CURTIME和CURRENT_TIME</td>    <td>两个函数作用相同，返回当前系统的时间值</td>  </tr>  <tr>    <td>NOW和SYSDATE</td>    <td>两个函数作用相同，返回当前系统的日期和时间值</td>  </tr>  <tr>    <td>MONTH</td>    <td>获取指定日期中的月份</td>  </tr>  <tr>    <td>MONTHNAME</td>    <td>获取指定日期中的月份英文名称</td>  </tr>  <tr>    <td>DAYNAE</td>    <td>获取指定日期对应的星期几的英文名称</td>  </tr>  <tr>    <td>DAYOFWEEK</td>    <td>获取指定日期对应的一周的索引位置值</td>  </tr>  <tr>    <td>WEEK</td>    <td>获取指定日期是一年中的第几周，返回值的范围是否为0~52或者1~53</td>  </tr>  <tr>    <td>DAYOFYEAR</td>    <td>获取指定日期是一年中的第几天，返回值范围是1~366</td>  </tr>  <tr>    <td>DAYOFMONTH</td>    <td>获取指定日期是一个月中的第几天，返回值是1~31</td>  </tr>  <tr>    <td>YEAR</td>    <td>获取年份，返回值范围是1970~2069</td>  </tr>  <tr>    <td>TIME_TO_SEC</td>    <td>将时间参数转换为秒数</td>  </tr>  <tr>    <td>SEC_TO_TIME</td>    <td>将秒数转换为时间，与TIME_TO_SEC互为反函数</td>  </tr>  <tr>    <td>DATE_ADD和ADDDATE</td>    <td>两个函数功能相同，都是向日期添加指定的时间间隔</td>  </tr>  <tr>    <td>DATE_SUB和SUBDATE</td>    <td>两个函数功能相同，都是向日期减去指定的时间间隔</td>  </tr>  <tr>    <td>ADDTIME</td>    <td>时间加法运算，在原始时间上添加指定的时间</td>  </tr>  <tr>    <td>SUBTIME</td>    <td>时间减法运算，在原始时间上减去指定时间</td>  </tr>  <tr>    <td>DATEDIFF</td>    <td>获取两个日期之间间隔，返回参数1减去参数2的值</td>  </tr>  <tr>    <td>DATE_FORMAT</td>    <td>格式化指定的日期，根据参数返回指定格式的值</td>  </tr>  <tr>    <td>WEEKDAY</td>    <td>获取指定日期在一周内的对应的工作日索引</td>  </tr></table><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><table>  <tr>    <th>函数名称</th>    <th>作用</th>  </tr>  <tr>    <td>MAX</td>    <td>查询指定列的最大值</td>  </tr>  <tr>    <td>MIN</td>    <td>查询指定列的最小值</td>  </tr>  <tr>    <td>COUNT</td>    <td>统计查询结果的行数</td>  </tr>  <tr>    <td>SUM</td>    <td>求和，返回指定列的总和</td>  </tr>  <tr>    <td>AVG</td>    <td>求平均值，返回指定列数据的平均值</td>  </tr></table><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><h2 id="常用工具-mysql"><a href="#常用工具-mysql" class="headerlink" title="常用工具 - mysql"></a>常用工具 - mysql</h2><h2 id="常用工具-mysqladmin"><a href="#常用工具-mysqladmin" class="headerlink" title="常用工具 - mysqladmin"></a>常用工具 - mysqladmin</h2><h2 id="常用工具-mysqlbinlog与mysqldump"><a href="#常用工具-mysqlbinlog与mysqldump" class="headerlink" title="常用工具 - mysqlbinlog与mysqldump"></a>常用工具 - mysqlbinlog与mysqldump</h2><h2 id="常用工具-mysqlimport与source"><a href="#常用工具-mysqlimport与source" class="headerlink" title="常用工具 - mysqlimport与source"></a>常用工具 - mysqlimport与source</h2><h2 id="常用工具-mysqlshow"><a href="#常用工具-mysqlshow" class="headerlink" title="常用工具 - mysqlshow"></a>常用工具 - mysqlshow</h2><h2 id="日志-错误日志"><a href="#日志-错误日志" class="headerlink" title="日志 - 错误日志"></a>日志 - 错误日志</h2><h2 id="日志-二进制日志（statement）"><a href="#日志-二进制日志（statement）" class="headerlink" title="日志 - 二进制日志（statement）"></a>日志 - 二进制日志（statement）</h2><h2 id="日志-二进制日志（row及日志删除）"><a href="#日志-二进制日志（row及日志删除）" class="headerlink" title="日志 - 二进制日志（row及日志删除）"></a>日志 - 二进制日志（row及日志删除）</h2><h2 id="日志-查询日志"><a href="#日志-查询日志" class="headerlink" title="日志 - 查询日志"></a>日志 - 查询日志</h2><h2 id="日志-慢查询日志"><a href="#日志-慢查询日志" class="headerlink" title="日志 - 慢查询日志"></a>日志 - 慢查询日志</h2><h2 id="复制-原理"><a href="#复制-原理" class="headerlink" title="复制 - 原理"></a>复制 - 原理</h2><h2 id="案例-需求及环境准备"><a href="#案例-需求及环境准备" class="headerlink" title="案例 - 需求及环境准备"></a>案例 - 需求及环境准备</h2><h2 id="案例-基本工程导入"><a href="#案例-基本工程导入" class="headerlink" title="案例 - 基本工程导入"></a>案例 - 基本工程导入</h2><h2 id="案例-AOP记录日志"><a href="#案例-AOP记录日志" class="headerlink" title="案例 - AOP记录日志"></a>案例 - AOP记录日志</h2><h2 id="案例-日志查询后端-mapper接口"><a href="#案例-日志查询后端-mapper接口" class="headerlink" title="案例 - 日志查询后端 - mapper接口"></a>案例 - 日志查询后端 - mapper接口</h2><h2 id="案例-日志查询后端-Service-amp-Controller"><a href="#案例-日志查询后端-Service-amp-Controller" class="headerlink" title="案例 - 日志查询后端 - Service&amp;Controller"></a>案例 - 日志查询后端 - Service&amp;Controller</h2><h2 id="案例-日志查询-前端"><a href="#案例-日志查询-前端" class="headerlink" title="案例 - 日志查询 - 前端"></a>案例 - 日志查询 - 前端</h2><h2 id="案例-系统性能优化分析"><a href="#案例-系统性能优化分析" class="headerlink" title="案例 - 系统性能优化分析"></a>案例 - 系统性能优化分析</h2><h2 id="案例-系统性能优化-分页优化"><a href="#案例-系统性能优化-分页优化" class="headerlink" title="案例 - 系统性能优化 - 分页优化"></a>案例 - 系统性能优化 - 分页优化</h2><h2 id="案例-系统性能优化-索引优化"><a href="#案例-系统性能优化-索引优化" class="headerlink" title="案例 - 系统性能优化 - 索引优化"></a>案例 - 系统性能优化 - 索引优化</h2><h2 id="案例-系统性能优化-读写分离概述"><a href="#案例-系统性能优化-读写分离概述" class="headerlink" title="案例 - 系统性能优化 - 读写分离概述"></a>案例 - 系统性能优化 - 读写分离概述</h2><h2 id="案例-系统性能优化-数据源配置"><a href="#案例-系统性能优化-数据源配置" class="headerlink" title="案例 - 系统性能优化 - 数据源配置"></a>案例 - 系统性能优化 - 数据源配置</h2><h2 id="案例-系统性能优化-AOP切换数据源"><a href="#案例-系统性能优化-AOP切换数据源" class="headerlink" title="案例 - 系统性能优化 - AOP切换数据源"></a>案例 - 系统性能优化 - AOP切换数据源</h2><h2 id="案例-系统性能优化-AOP切换数据源-测试"><a href="#案例-系统性能优化-AOP切换数据源-测试" class="headerlink" title="案例 - 系统性能优化 - AOP切换数据源 - 测试"></a>案例 - 系统性能优化 - AOP切换数据源 - 测试</h2><h2 id="案例-系统性能优化-AOP切换数据源-原理解析"><a href="#案例-系统性能优化-AOP切换数据源-原理解析" class="headerlink" title="案例 - 系统性能优化 - AOP切换数据源 - 原理解析"></a>案例 - 系统性能优化 - AOP切换数据源 - 原理解析</h2><h2 id="案例-系统性能优化-应用优化"><a href="#案例-系统性能优化-应用优化" class="headerlink" title="案例 - 系统性能优化 - 应用优化"></a>案例 - 系统性能优化 - 应用优化</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看笔记：&lt;a href=&quot;https://www.bilibili.com/video/BV1fJ41127Rj?from=search&amp;
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="MySQL" scheme="https://fengshana.github.io/tags/MySQL/"/>
    
      <category term="数据库优化" scheme="https://fengshana.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>微信支付</title>
    <link href="https://fengshana.github.io/2020/04/23/%E9%9D%A2%E8%AF%95/%E3%80%90%E5%8A%A8%E5%8A%9B%E8%8A%82%E7%82%B9%E3%80%91%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/"/>
    <id>https://fengshana.github.io/2020/04/23/%E9%9D%A2%E8%AF%95/%E3%80%90%E5%8A%A8%E5%8A%9B%E8%8A%82%E7%82%B9%E3%80%91%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/</id>
    <published>2020-04-22T22:54:44.581Z</published>
    <updated>2020-05-13T13:47:07.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p>重点是复习一下微信支付流程。  </p><p>昨天面试官问我，比如说支付验签、在支付过程中前端用户进行输入购买商品的支付金额这个时候被抓包了怎么办、接口加密、在已经是支付跳转这些时候，支付金额通过抓包被篡改怎么办等支付方面的问题。  </p><h2 id="微信特性"><a href="#微信特性" class="headerlink" title="微信特性"></a>微信特性</h2><ul><li>微信授权</li><li>微信支付</li><li>微信退款</li></ul><p>难点：需要吃透微信的官方文档；一定要按照文档的要求去做；而不是自己YY；  </p><h3 id="第一个关键点"><a href="#第一个关键点" class="headerlink" title="第一个关键点"></a>第一个关键点</h3><p><strong>获取OpenId的方式</strong>：  </p><ul><li><strong>手工方式</strong>（使用手工方式的原因目的在于仔细去看微信的官方文档）</li><li>利用<strong>第三方SDK</strong>（相较于手工方式，高级的方式）</li></ul><p>在实际开发当中使用推荐第三方SDK进行开发微信支付模块。  </p><p>第一步是要完成网页授权，只有通过授权才能够获取得到OpenId，而有了OpenId，才能够继续做下一系列的操作；所以获取OpenId是第一个关键点；  </p><p>强调：一定要单独、仔细、完整的看一遍，甚至看几遍都是可以的；</p><h3 id="微信网页授权"><a href="#微信网页授权" class="headerlink" title="微信网页授权"></a>微信网页授权</h3><p>注意一定要以微信官方文档为准，跟其思路进行。  </p><ul><li>官方文档<br>- <a href="http://mp.weixin.qq.com/wiki" target="_blank" rel="noopener">http://mp.weixin.qq.com/wiki</a><br>- <a href="https://pay.weixin.qq.com/wiki/doc/api/index.html" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/index.html</a></li><li>调试<br>- <a href="https://natapp.cn/" target="_blank" rel="noopener">https://natapp.cn/</a></li><li>第三方SDK<br>- <a href="https://github.com/Wechat-Group/weixin-java-tools" target="_blank" rel="noopener">https://github.com/Wechat-Group/weixin-java-tools</a></li></ul><p>微信官方文档当中，分有普通商户以及服务商版本；</p><p>简单介绍普通商户版本以及服务商版本(<a href="https://pay.weixin.qq.com/wiki/doc/api/index.html)：" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/index.html)：</a>  </p><p>普通商户即普通商家；个人身份是不能够申请微信支付的；必须有着企业的资质才能够进行申请；个人开发者如果想要进行开发调试的话可以向朋友借账号等方式；  </p><p>服务商版可以理解为微信的代理商；接入代理商则往往可能是微信方进行提供了技术以及一些更低费率等等；其实普通商户版本以及服务商版本差别并不太大；  </p><p>现在还多了一个银行服务商，我猜大概也就是银行资质的与微信进行合作；  </p><p>要介绍的是普通商户版本当中的公众号开发支付，即也就是选择JSAPI支付方式（用户通过微信扫码、关注公众号等方式进入商家H5页面，并在微信内调用JSSDK完成支付）；跳转至（<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_1）；" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_1）；</a>  </p><p>再次强调：仔细查阅官方API文档；其实不管任何支付也都是这样；比如说PayPal（想哭）；难点在于需要去完完整整的理清楚；  </p><p>往往很多时候的不成功不是由于自身开发不好，而是由于官方文档上并没有去仔细阅读；  </p><p>场景介绍、开发步骤、案例介绍….等等都需要仔细查阅，而不是只看一个这种；  </p><p>业务流程：<br> 微信客户端发起支付（展示、生成二维码等不太重要）<br> （重要的是）第四步，请求支付订单然后生成商户订单，再调用统一下单API（第五步）；<br>调用之后返回一个预付单信息；<br>注意是预付单信息；预付单信息返回之后；<br>需要去进行生成JSAPI页面；<br>即在另外一个页面上调用预支付的一些参数；并且签名然后发起支付；<br>发起支付之后，就会有一个异步通知商户支付结果（第十步，很重要）；<br>第一步下单返回的是一个预付单信息；并不是直接下单成功；<br>一般来说不仅仅是微信支付；支付宝也好，最终支付成功之后，会有一个异步的通知；支付完成之后，需要将相关的订单修改成已支付状态（成功/失败）；<br>根据异步通知来的；<br>也可以使用订单查询的API；进行查询订单支付结果；<br>如能接收到异步通知其实就可以进行修改支付结果了；</p><ul><li>文档说明<ul><li>阅读对象</li><li>版本说明</li></ul></li><li>术语<ul><li>支付模式</li><li>名词解释</li></ul></li><li>支付账户<ul><li>支付账户</li></ul></li><li>接口规则<ul><li>协议规则</li><li>参数规定</li><li>安全规范</li><li>获取OpenId</li></ul></li><li>JSAP支付<ul><li>场景介绍</li><li>案例介绍</li><li>开发步骤</li><li>业务流程</li><li>获取微信版本号</li><li>微信内H5调起支付</li><li>收货地址共享</li><li>支付常见问题</li></ul></li><li>API列表<ul><li>统一下单</li><li>查询订单</li><li>关闭订单</li><li>申请退款</li><li>查询退款</li><li>下载交易账单</li><li>下载资金账单</li><li>支付结果通知</li><li>退款结果通知</li><li>拉取订单评价数据</li></ul></li><li>最佳实践<ul><li>支付回调和查单实现指引</li><li>支付验收指引</li><li>网络排查指引</li><li>最佳安全实践</li><li>跨域冗灾方案</li><li>回调通知注意事项</li></ul></li><li>运营规范<ul><li>运营规范</li></ul></li><li>SDK与DEMO下载</li><li>联系我们</li></ul><h2 id="文档说明"><a href="#文档说明" class="headerlink" title="文档说明"></a>文档说明</h2><h3 id="阅读对象"><a href="#阅读对象" class="headerlink" title="阅读对象"></a>阅读对象</h3><p>链接：<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=1_1" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=1_1</a>  </p><p>本文阅读对象：商户系统（在线购物平台、人工收银系统、自动化智能收银系统或者其他）集成微信支付涉及的技术架构师、研发工程师、测试工程师、系统运维工程师等；</p><h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h3><p>链接：<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=1_2" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=1_2</a></p><ul><li>2019.05.06<ul><li>企业付款到银行卡接口，北京银行 银行编码从1032修改为4836；</li></ul></li><li>2019.03.12<ul><li>财付通10位海关注册编码变更为：4403169D3W（原编码440316T004不再使用）</li></ul></li><li>2019.03.06<ul><li>支付结果通知回调频率调整为15s / 15s / 30s / 3m / 10m / 20m / 30m / 30m / 30m / 30m / 60m / 3h / 3h / 3h / 6h / 6h / - 总计24h4m</li></ul></li><li>2019.01.10<ul><li>企业付款接口增加接口频率说明</li></ul></li><li>2019.01.03<ul><li>除合单支付外，字段spbill_create_ip（终端IP）支持IPV6和IPV4两种格式</li></ul></li><li>2019.12.24<ul><li>境内申请退款接口，退款原因下发条件更新</li><li>不超过1元的部分退款，将不会下发退款原因</li></ul></li><li>2018.12.12<ul><li>报关接口新增返回参数</li><li>verify_department-验核机构</li><li>verify_department_trade_id-验核机构交易流水号</li></ul></li><li>2018.12.10<ul><li>企业付款接口新增错误码；</li><li>NO_AUTH</li><li>企业付款备注（desc）参数中的敏感词会被转成字符*</li></ul></li><li>2018.12.09<ul><li>新增支付凭证处开放电子发票入口功能</li><li>统一下单、付款码支付、委托代扣接口新增电子发票开票入口开放参数</li></ul></li><li>2018.12.01<ul><li>企业付款接口新增错误码：<ul><li>PAY_CHANNEL_NOT_ALLOWED</li><li>RECV_ACCOUNT_NOT_ALLOWED</li><li>SENDNUM_LIMIT</li></ul></li></ul></li><li>2018.11.30<ul><li>企业付款接口规则变更：<ul><li>付款到零钱-商户号单日出款总额，由100万降低至10万</li><li>付款到零钱-商户号单人单日付款额度，由2万降低至5000</li><li>付款到银行卡-商户号单日出款总额，由100万降低至10万</li><li>付款到银行卡-商户号单人单日付款额度，由5万降低至2万</li><li>付款到零钱-新增两个商户资金安全相关的错误码</li><li>付款到银行卡-新增三个商户资金安全相关的错误码</li></ul></li></ul></li><li>2018.11.27<ul><li>付款码支付规则变更<ul><li>1000元以下免密支付次数从“每日5次”变更为“每日10次”</li></ul></li></ul></li><li>2018.11.12<ul><li>支付产品名字变更<ul><li>公众号支付-变更为-JSAPI支付</li><li>扫码支付-变更为-Native支付</li><li>刷卡支付-变更为-付款码支付</li></ul></li></ul></li><li>2018.07.06<ul><li>SDK&amp;DEMO更新</li></ul></li><li>2018.05.06<ul><li>报关API新增支付人信息校验结果返回</li></ul></li><li>2018.03.07<ul><li>新增H5支付API</li></ul></li><li>2018.02.15<ul><li>新增小程序支付API</li></ul></li><li>2017.10.15<ul><li>新增资金账单下载API</li></ul></li><li>2017.07.15<ul><li>新增退款结果通知API</li></ul></li><li>2017.07.13<ul><li>添加“场景信息 scene_info”字段</li><li>添加状态机图</li></ul></li><li>2017.06.07<ul><li>申请退款与查询退款接口删除参数：op_user_id</li><li>代金券接口删除参数：coupon_type、locked_num、used_num</li></ul></li><li>2017.03.20<ul><li>退款接口参数refund_id字段长度变更—原“28”位变更为“32”位</li><li>退款接口参数out_refund_no字段长度变更—原“28”位变更为“64”位</li></ul></li><li>2017.03.15<ul><li>更新单品优惠功能</li><li>更新银行类型列表</li></ul></li><li>2017.02.21<ul><li>下载对账单接口-新增充值退款对账单下载（bill_type=RECHARGE_REFUND）</li></ul></li><li>2016.10.11<ul><li>查询退款接口-退款状态-删除“NOTSURE”状态</li></ul></li><li>2016.09.09<ul><li>退款接口增加字段（可选）—-支持可用余额退款</li><li>增加退款错误码”余额不足“</li></ul></li><li>2016.08.24<ul><li>文档左侧导航栏增加“错误码”栏</li></ul></li><li>2015.07.29<ul><li>受理机构更名为：服务商</li><li>受理机构子商户更名为：特约商户</li></ul></li><li>2014.12.12<ul><li>更新付款码支付java版本Demo</li><li>企业红包更名为“代金券\立减优惠”</li><li>邮件中不附带证书，按照指引去商户系统下载</li></ul></li><li>2014.12.11<ul><li>发布新建版本，本文档适用于V3版本商户号接入微信支付，旧版本账号没有MCHID，需要登录商户系统升级（详细请参考升级指引）。</li></ul></li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="支付模式"><a href="#支付模式" class="headerlink" title="支付模式"></a>支付模式</h3><blockquote><p>支付产品  </p></blockquote><ol><li>付款码支付<br>付款码支付是用户展示微信钱包内的“刷卡条码/二维码”给商户系统扫描后直接完成支付的模式。主要应用线下面对面收银的场景。</li><li>Native支付<br>Native支付是商户系统按照微信支付协议生成支付二维码，用户再用微信“扫一扫”完成支付的模式。该模式适用于PC网站支付、实体店单品或者订单支付、媒体广告支付等场景。</li><li>JSAP支付<br>JSAP支付是用户在微信中打开商户的H5页面，商户在H5页面通过调用微信支付提供的JSAP接口调起微信支付模块完成支付。<br>应用场景：</li></ol><ul><li>用户在微信公众账号进入商家公众号，打开某个主页面，完成支付</li><li>用户的好友在朋友圈、聊天窗口等分项商家页面链接，用户点击链接打开商家页面，完成支付</li><li>将商户页面转换成二维码，用户扫描二维码后再微信浏览器中打开页面后完成支付</li></ul><ol start="4"><li>APP支付<br>APP支付又称移动端支付，是商户通过在移动端应用APP中集成开放SDK调起微信支付模块完成支付的模式。  </li><li>H5支付<br>H5支付主要是在手机、ipad等移动设备中通过浏览器唤起微信支付的支付产品。</li><li>小程序支付<br>小程序支付是专门被定义使用在小程序中的支付产品。目前在小程序中能且只能使用小程序支付的方式来唤起微信支付。</li></ol><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ol><li>微信公众平台</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记录&quot;&gt;&lt;a href=&quot;#记录&quot; class=&quot;headerlink&quot; title=&quot;记录&quot;&gt;&lt;/a&gt;记录&lt;/h2&gt;&lt;p&gt;重点是复习一下微信支付流程。  &lt;/p&gt;
&lt;p&gt;昨天面试官问我，比如说支付验签、在支付过程中前端用户进行输入购买商品的支付金额这个时候被抓包
      
    
    </summary>
    
    
      <category term="支付" scheme="https://fengshana.github.io/categories/%E6%94%AF%E4%BB%98/"/>
    
    
      <category term="支付" scheme="https://fengshana.github.io/tags/%E6%94%AF%E4%BB%98/"/>
    
      <category term="微信" scheme="https://fengshana.github.io/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>想一想自己为什么要去面试？</title>
    <link href="https://fengshana.github.io/2020/04/20/%E4%BB%8A%E5%B9%B4%E8%A6%81%E4%B9%B0%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    <id>https://fengshana.github.io/2020/04/20/%E4%BB%8A%E5%B9%B4%E8%A6%81%E4%B9%B0%E7%9A%84%E4%B8%9C%E8%A5%BF/</id>
    <published>2020-04-20T02:34:46.720Z</published>
    <updated>2020-05-05T10:08:07.143Z</updated>
    
    <content type="html"><![CDATA[<p>想想今年为什么自己想去面试？<br>气死我了；  </p><ol><li>我今年得换个手机了；</li><li>得交房租了；</li><li>日常开销；</li><li>我想买台相机；</li><li>我还想买把吉他；</li><li>我今年还想买台电脑；</li><li>想去一次漫展，等疫情好了的时候，跟朋友一起；</li><li>想去西塘，参加汉服文化节；等疫情好了的时候，跟朋友一起；</li><li>扩充一下自己的兴趣爱好；</li><li>我就不信了，我好歹也被人喊过老师，我还面试不上一份10k的java开发工程师了？</li><li>每次面试就那么几个问题，我花一个星期还搞不定？</li><li>我学东西的能力有这么差？</li><li>好歹自己的脑子里面也不全是水啊？</li><li>自信一点，很难吗？有点底气行吗？别人这么信任你？怎么跟个扶不起的刘阿斗似的？</li><li>再不去认认真真的面试，等会儿你妹都高考完了我跟你讲；</li><li>再不认真面试，我看你怎么交代吧？？？！！！；老是犹犹豫豫有什么好的，都讲了几百回了，要你果决一点，果断一点，你不听；</li><li>好了，不说了，好好面试，好好加油；</li><li>每次不想看视频的时候，就看看这里，自己怎么写的，自己怎么去做；我倒是看你浑浑噩噩要躲到什么时候去；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想想今年为什么自己想去面试？&lt;br&gt;气死我了；  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我今年得换个手机了；&lt;/li&gt;
&lt;li&gt;得交房租了；&lt;/li&gt;
&lt;li&gt;日常开销；&lt;/li&gt;
&lt;li&gt;我想买台相机；&lt;/li&gt;
&lt;li&gt;我还想买把吉他；&lt;/li&gt;
&lt;li&gt;我今年还想买台电脑；&lt;/
      
    
    </summary>
    
    
      <category term="about" scheme="https://fengshana.github.io/categories/about/"/>
    
    
      <category term="心态" scheme="https://fengshana.github.io/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Git工作流学习笔记</title>
    <link href="https://fengshana.github.io/2020/04/20/%E9%9D%A2%E8%AF%95/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://fengshana.github.io/2020/04/20/%E9%9D%A2%E8%AF%95/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-04-20T02:21:22.445Z</published>
    <updated>2020-04-24T01:36:46.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git工作流指南-分布式版本控制系统"><a href="#Git工作流指南-分布式版本控制系统" class="headerlink" title="Git工作流指南 分布式版本控制系统"></a>Git工作流指南 分布式版本控制系统</h2><p>观看笔记：<a href="https://www.bilibili.com/video/BV1dW411U7ER?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1dW411U7ER?p=1</a><br>老师笔记： <a href="http://www.funtl.com/zh/git/" target="_blank" rel="noopener">http://www.funtl.com/zh/git/</a>  </p><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><ul><li>什么是版本控制系统</li><li>什么是Git</li><li>如何安装Git</li></ul><h3 id="什么是版本控制系统"><a href="#什么是版本控制系统" class="headerlink" title="什么是版本控制系统"></a>什么是版本控制系统</h3><h4 id="为什么需要版本控制"><a href="#为什么需要版本控制" class="headerlink" title="为什么需要版本控制"></a>为什么需要版本控制</h4><p>在软件开发过程中，每天都会产生新的代码，代码合并的过程中可能会出现如下问题：  </p><ul><li>代码被覆盖或丢失；</li><li>代码写的不理想，希望还原之前的版本；</li><li>希望知道与之前版本的差别；</li><li>是谁修改了代码以及为什么修改；</li><li>发版时希望分成不同的版本（测试版本、发行版本等）；</li></ul><p>因此，希望有一种机制，能够帮助我们：  </p><ul><li>可以随时回滚到之前的版本；</li><li>协同开发时，不会覆盖别人的代码；</li><li>留下修改记录，以便随时查看；</li><li>发版时可以方便的管理不同的版本；</li></ul><h4 id="什么是版本控制系统-1"><a href="#什么是版本控制系统-1" class="headerlink" title="什么是版本控制系统"></a>什么是版本控制系统</h4><p>一个标准的版本控制系统 Version Control System（VCS），通常需要有以下功能：  </p><ul><li>能够创建Repository（仓库），用来保存代码；</li><li>协同开发时，方便将代码分发给团队成员；</li><li>记录每次修改代码的内容、时间、原因等信息；</li><li>能够创建Branch（分支），可以根据不同的场景进行开发；</li><li>能够创建Tag（标签），建立项目里程碑；</li></ul><h4 id="版本控制系统的发展史"><a href="#版本控制系统的发展史" class="headerlink" title="版本控制系统的发展史"></a>版本控制系统的发展史</h4><p>版本控制系统发展至今有几种不同的模式：  </p><h5 id="Local-VCS"><a href="#Local-VCS" class="headerlink" title="Local VCS"></a>Local VCS</h5><p>本地使用 复制/粘贴 的方式进行管理，缺点是无法协同开发</p><h5 id="Gentralized-VCS（Lock，悲观锁）"><a href="#Gentralized-VCS（Lock，悲观锁）" class="headerlink" title="Gentralized VCS（Lock，悲观锁）"></a>Gentralized VCS（Lock，悲观锁）</h5><p>中央集中式版本控制系统团队共用仓库，当某人需要编辑文件时，进行锁定，以免其他人同时编辑时造成冲突，但不是很方便，其他人需要排队才能编辑文件，如果有人编辑了很久或是忘记解锁会造成其他人长时间等待的情况；  </p><p>如何理解悲观锁：总有刁民想害朕。<br>我要是面试这么答，会怎么样？  </p><h5 id="Gentralized-VCS（Merge，乐观锁）"><a href="#Gentralized-VCS（Merge，乐观锁）" class="headerlink" title="Gentralized VCS（Merge，乐观锁）"></a>Gentralized VCS（Merge，乐观锁）</h5><p>中央集中式版本控制系统团队共用仓库，不采用悲观锁方式来避免冲突，而是时候发现如果别人也修改相同文件（冲突），再进行手动修改解决。  </p><p>有很多VCS属于这种类型，如：CVS、Subversion、Perforce等；  </p><p>中央集中式版本控制系统的共同问题是，做任何操作都需要和服务器同步，如果服务器宕机则会造成无法继续工作的窘迫；  </p><p>如何理解乐观锁：天网恢恢疏而不漏。<br>我想给自己两锤子；  </p><h5 id="Distributed-VCS"><a href="#Distributed-VCS" class="headerlink" title="Distributed VCS"></a>Distributed VCS</h5><p>分布式版本控制系统，本地也拥有完整的代码仓库，就不会出现上述集中式管理的问题，即使没有网络，依然可以commit和看log，也无需担心服务器同步问题；  </p><p>如：Git、Mercurial、Bazaar等就属于分布式版本控制系统。缺点是功能比较复杂，上手需要一定的学习时间；  </p><p>（分布式版本控制系统都有一个本地化的这样一个概念；区块链系统也能称之为一个分布式系统）  </p><h2 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h2><p>Git工作流：代码管理的工作流程、方式  </p><ul><li>Git工作流简介</li><li>集中式工作流</li><li>功能分支工作流</li><li>GitFlow工作流</li><li>Forking工作流</li><li>Pull Requests</li></ul><h3 id="Git工作流简介"><a href="#Git工作流简介" class="headerlink" title="Git工作流简介"></a>Git工作流简介</h3><p>工作流有各式各样的用法，但也正因此使得在实际工作中如何上手使用增加了难度。  </p><p>这篇指南通过总览公司团队中最常用的集中Git工作流让大家可以上手使用；  </p><p>在阅读的过程中请记住，本文中的集中工作流是作为方案指导而不是条例规定，在展示了各种工作流可能的用法后，可以从不同的工作流中挑选或揉合出一个满足自己需求的工作流；  </p><h4 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXyIW2ezMoDhUXO*s5pTGue2N753CPNKcE42sPIP6l3d0rpu2DZjcGmC.Kga3cDUruqQwuWnPoetw.KevCfGSm5U!/r" alt="集中式工作流"></p><p>如果开发团队成员已经很熟Subversion，集中式工作流让你无需去适应一个全新流程就可以体验Git带来的收益。  </p><p>这个工作流也可以作为向更Git风格工作流迁移的友好过渡。  </p><p>（个人、三五个人的小团队）  </p><h4 id="功能分支工作流"><a href="#功能分支工作流" class="headerlink" title="功能分支工作流"></a>功能分支工作流</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX.QLkS1nyIjv6HHWnbV4dX7srariw7MEQpLi1gOAxL3ou18PqhQZr1mrBrEaIbVs5JuQWzjNbAd8lfxuJK8OGPM!/r" alt="功能分支工作流"></p><p>功能分支工作流以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发。  </p><p>这样可以在把新功能继承到正式项目前，用Pull  Requests的方式讨论变更；  </p><p>（达到约12个人的团队）  </p><h4 id="Git-Flow工作流"><a href="#Git-Flow工作流" class="headerlink" title="Git Flow工作流"></a>Git Flow工作流</h4><p>Git Flow工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更顺畅。  </p><p>严格的分支模型也为大型项目提供了一些非常必要的结构。  </p><p>（整个公司，这么一个团队的规模）  </p><h4 id="Forking工作流"><a href="#Forking工作流" class="headerlink" title="Forking工作流"></a>Forking工作流</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7NQkdqkFQWuuELLHKCcql5ABKaPDZFUejww*HH9qtsi8qr7IlATkqBkQ9PV1LJ9rT6faqWzcfgS3pJZnzLSzVg!/r" alt="Forking工作流"></p><p>Forking工作流是分布式工作流，充分利用了Git在分支和克隆上的优势。  </p><p>可以安全可靠地管理大团队的开发者（developer），并能接受不信任贡献者（contributor）的提交。  </p><p>（跨国合作。跨国团队的使用，一般用于Forking工作流）  </p><h4 id="Pull-Requests"><a href="#Pull-Requests" class="headerlink" title="Pull Requests"></a>Pull Requests</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXzYbgZ.02.6Smac50apszMyWGwg89uQEVJSVU01e69u2Dts1al5lueZ4HgBrr.WyV.0GtO*ZTdT3LpQtilbX2Vk!/r" alt="Pull Requests"></p><p>功能分支工作流、GitFlow工作流、Forking工作流都会穿插一个Pull Requests的一个东西。  </p><p>Pull Requests通常称为请求合并（Merge Pull Requests）；  </p><p>Pull Requests让开发者更方便地进行协作的功能，提供了友好的Web界面可以在提议的修改合并到正式项目之前对修改进行讨论。  </p><p>（相当于一个评论系统）；</p><h3 id="集中式工作流-1"><a href="#集中式工作流-1" class="headerlink" title="集中式工作流"></a>集中式工作流</h3><p>转到分布式版本控制系统看起来像个令人生畏的任务，但不改变已用的工作流你也可以用上Git带来的收益。  </p><p>团队可以用和Subversion完全不变的方式来开发项目。  </p><p>但使用Git加强开发的工作流，Git比SVN有几个优势。  </p><p>（1）首先，每个开发者可以有属于自己的整个工程的本地拷贝。隔离的环境让各个开发者的工作和项目的其他部分（修改）独立开来——-即自由地提交到自己的本地仓库，先完全忽略上游的开发，直到方便的时候再把修改反馈上去。  </p><p>（2）其次，Git提供了强壮的分支和合并模型。不像SVN，Git的分支设计成可以作为一种用来在仓库之间集成代码和分享修改的【失败安全】的机制。  </p><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX58rubGqwbukXS4rvP.hcw8vVDFpcMEKyanOzFC60vYY7EfnKsFaNa8DYFcGkpbCkTOCu8b0QXObUxn8ABvZn4U!/r" alt="工作方式"></p><p>像Subversion一样，集中式工作流以中央仓库作为项目所有修改的单点实体。  </p><p>相比SVN缺省的开发分支trunk，Git叫做master，所有修改提交到这个分支上。  </p><p>该工作流只用到master这一个分支。  </p><p>开发者开始先克隆中央仓库。  </p><p>在自己的项目拷贝中，像SVN一样的编辑文件和提交修改；  </p><p>但修改是存在本地的，和中央仓库完全隔离的；  </p><p>开发者可以把和上游的同步延后到一个方便时间点；  </p><p>要发布修改到正式项目中，开发者要把本地master分支的修改【推（push）】到中央仓库中。  </p><p>这相当于svn  commit操作，但push操作会把所有还不在中央仓库的本地提交都推上去。  </p><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7NAq94egRJ5nBPO8Co87th*P0cTdtAGYXp43mklxBxvhd73.i5d8Lm58WdsFYNrarV7XZaiqfrmkd3gUFAFW0o!/r" alt="解决冲突"></p><p>中央仓库代表了正式项目，所以提交历史应该被尊重且是稳定不变的。  </p><p>如果开发者本地的提交历史和中央仓库有分歧，Git会拒绝push提交否则会覆盖已经在中央库的正式提交。  </p><p>在开发者提交自己功能修改到中央库前，需要先fetch在中央库的新增提交，rebase自己提交到中央库提交历史之上。  </p><p>这样做的意思是在说，【我要把自己的修改加到别人已经完成的修改上。】最终的结果是一个完美的线性历史，就像以前的SVN的工作流中一样；  </p><p>如果本地修改和上游提交有冲突，Git会暂停rebase过程，给你手动解决冲突的机会。  </p><p>Git解决合并冲突，用和生成提交一样的git  status和git add命令，很一致方便。  </p><p>还有一点，如果解决冲突时遇到麻烦，Git可以很简单中止整个rebase操作，重来一次（或者让别人来帮助解决）。  </p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>一起逐步分解来看看一个常见的小团队如何用这个工作流来协作的。  </p><p>有两个开发者小明和小红，看他们是如何开发自己的功能并提交到中央仓库上的。  </p><h5 id="有人先初始化好中央仓库"><a href="#有人先初始化好中央仓库" class="headerlink" title="有人先初始化好中央仓库"></a>有人先初始化好中央仓库</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX9UbT3uXKi44e*o.QOIDNJOk403REJAlPsZkIyST70GEweXbAbks3cFR7TqiVMFHAtTg9MXSvYT6HSyIH1eLii4!/r" alt="有人先初始化好中央仓库"></p><p>第一步，有人在服务器上创建好中央仓库。  </p><p>如果是新项目，可以初始化一个空仓库；否则要导入已有的Git或SVN仓库。  </p><p>中央仓库应该是个裸仓库（bare repository），即没有工作目录（working directory）的仓库。  </p><h5 id="所有人克隆中央仓库"><a href="#所有人克隆中央仓库" class="headerlink" title="所有人克隆中央仓库"></a>所有人克隆中央仓库</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX8lXRlkamDF*h*SxpL42PuUsH4aIULseTwL66K.p5pWkVzGz*Bh8Nih.I7qaVf43t7zoP8GGUp44vHNS*NRccIY!/r" alt="所有人克隆中央仓库"></p><p>下一步，各个开发者创建整个项目的本地拷贝。  </p><p>通过git clone命令完成。  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span>  <span class="title">https</span>://github.com/path/to/repo.git</span><br></pre></td></tr></table></figure><p>基于后续会持续和克隆的仓库做交互的假设，克隆仓库时Git会自动添加远程别名origin指回【父】仓库。  </p><p>github即git的中央仓库；版本控制系统有一个版本仓库。  </p><p>github上public即开源，公开的意思，代码开源。  </p><p>如果是私有private则需要进行CreditCard 信用卡支付相应的金额；收费；  </p><h5 id="小明开发功能"><a href="#小明开发功能" class="headerlink" title="小明开发功能"></a>小明开发功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX3cSXX6681Ge8WeUymk3FFjspNtDVB3t7XeHuVufMD05ZhJzX9OyWJDCYAlloD65QJLNRkDaLpYfFLKjESAA0SM!/r" alt="小明开发功能"></p><p>在小明的本地仓库中，他使用标准的Git过程开发功能：编辑、暂存（Stage）和提交。  </p><p>如果你不熟悉暂存区（Stageing Area），这里说明一下：暂存区的用来准备一个提交，但可以不用把工作目录中所有的修改内容都包含进来。  </p><p>这样可以创建一个高度聚焦的提交，尽管本地修改很多内容。  </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status <span class="comment"># 查看本地仓库的修改状态</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> <span class="comment"># 暂存文件</span></span></span><br><span class="line">git commit <span class="comment"># 提交文件</span></span><br></pre></td></tr></table></figure><p>请记住，因为这些命令生成的是本地提交，小明可以按自己需求反复操作多次，而不用担心中央仓库有了什么操作。  </p><p>对需要多个更简单更原子分块的大功能，这个做法是很有用的；  </p><h5 id="小红开发功能"><a href="#小红开发功能" class="headerlink" title="小红开发功能"></a>小红开发功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX3AhXN0w*Kh7FwIloQiq3PMOUwp*anqXsBqPo.yaxL1hWnR.kZm*XseG5RhBNtuoS8.PVSKuKSdHEw1x7MixOxA!/r" alt="小红开发功能"></p><p>与此同时，小红在自己的本地仓库中用相同的编辑、暂存和提交过程开发功能。  </p><p>和小明一样，她也不关心中央仓库有没有新提交；当然更不关心小明在他的本地仓库中的操作，因为所有本地仓库都是私有的。  </p><h5 id="小明发布功能"><a href="#小明发布功能" class="headerlink" title="小明发布功能"></a>小明发布功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX2DDMKOOXZiA6a0j82260kNXKGqba7MbMMt5OmvuzTfK3A*Lxszb8CTdFEjjZXvIDOZez3cKxhQHt2dZMB.G9S4!/r" alt="小明发布功能"></p><p>一旦小明完成了他的功能开发，会发布他的本地提交到中央仓库中，这样其他团队成员可以看到他的修改。  </p><p>他可以用下面的git push  命令：  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><p>注意，origin是小明克隆仓库时Git创建的远程中央仓库别名。  </p><p>master参数告诉Git推送的分支。  </p><p>由于中央仓库自从小明克隆以来还没有被更新过，所以push操作不会有冲突，成功完成。  </p><h5 id="小红试着发布功能"><a href="#小红试着发布功能" class="headerlink" title="小红试着发布功能"></a>小红试着发布功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX49Hssuuk2yHbmsbkSdUuOtLRbTxRlP3xEORKm5txDWaExKbZyYnyzyBD0oDqcjETeUWkabVFxZpo*3gs9yQWHs!/r" alt="小红试着发布功能"></p><p>一起来看看在小明发布修改后，小红push修改会怎么样？  </p><p>她使用完全一样的push命令：  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><p>但她的本地历史已经和中央仓库有分歧了，Git拒绝操作并给出下面很长的出错消息：  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error: failed <span class="keyword">to</span> push some refs <span class="keyword">to</span> <span class="string">'/path/to/repo.git'</span></span><br><span class="line">hin<span class="variable">t:</span> Updates were rejected because the tip of your current branch <span class="keyword">is</span> behind</span><br><span class="line">hin<span class="variable">t:</span> its remote counterpart. Merge the remote <span class="keyword">changes</span>(<span class="keyword">e</span>.g. <span class="string">'git pull'</span>)</span><br><span class="line">hin<span class="variable">t:</span> before pushing again.</span><br><span class="line">hin<span class="variable">t:</span> See the <span class="string">'Note about fast-forwards'</span> in <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>这避免了小红覆写正式的提交。  </p><p>她要先pull小明的更新到她本地仓库合并上她的本地修改后，再重试。  </p><h5 id="小红在小明的提交之上rebase"><a href="#小红在小明的提交之上rebase" class="headerlink" title="小红在小明的提交之上rebase"></a>小红在小明的提交之上rebase</h5><p>小红用git pull 合并上游的修改到自己的仓库中。  </p><p>这条命令类似svn update ——-拉取所有上游提交命令到小红的本地仓库，并尝试和她本地修改合并。  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">--rebase origin master</span></span><br></pre></td></tr></table></figure><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXyi6Y8l5sb1aRwQRlb0CiRDNdgM9NZtfk5D41PvfJEccriZP3FT6WnQ4PWKvEqz*e7LpBOfcXui.l9nUXAPUgd4!/r" alt="images"></p><p>–rebase 选项告诉Git把小红的提交移到同步了中央仓库修改后的master分支的顶部；  </p><p>如果忘了加这个选项，pull操作仍然可以完成，但每次pull操作要同步中央仓库别人修改时，提交历史会以一个多余的【合并提交】结尾。  </p><p>对于集中式工作流，最好是使用rebase而不是生成一个合并提交。  </p><h5 id="小红解决合并冲突"><a href="#小红解决合并冲突" class="headerlink" title="小红解决合并冲突"></a>小红解决合并冲突</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7FxPBYYYsKKPOWXqC*0rCPhZKJRqU86pJwCJIVi3g31ZcpHEH2b76upvPK6lrEAQ9UWa9VqeFjlEC4dX2PAHTw!/r" alt="小红解决合并冲突"></p><p>rebase操作过程是把本地提交一次一个地迁移到更新了的中央仓库master分支之上，这意味着可能要解决在迁移某个提交时出现的合并冲突，而不是解决包含了所有提交的大型合并时所出现的冲突。  </p><p>这样的方式让你尽可能保持每个提交的聚焦和项目历史的整洁。  </p><p>反过来，简化了哪里引入Bug的分析，如果有必要，回滚修改也可以做到对项目影响最小。  </p><p>如果小红和小明的功能是相关的，不大可能在rebase过程中有冲突。  </p><p>如果有，Git在合并有冲突的提交出暂停rebase过程，输出下面的信息并带上相关的指令：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONFLICT</span> (content): Merge <span class="keyword">conflict</span> <span class="keyword">in</span></span><br></pre></td></tr></table></figure><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX5fiCqpawh2bvFoyuusAOSGHKu5sc59EGgvKP1aVmHVmey3BEhEwMSvuvtOXh1oSZU1zNvf5QV2G*SN2a1sgwiA!/r" alt="images"></p><p>Git 很赞的一点是，任何人可以解决他自己的冲突。  </p><p>在这个例子中，小红可以简单的运行 git status 命令来查看哪里有问题。  </p><p>冲突文件列在 Unmerged paths（未合并路径）一节中：  </p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Unmerged paths：</span><br><span class="line"><span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">use</span> <span class="string">"git reset HEAD &lt;some-file&gt;..."</span> <span class="variable">to</span> <span class="variable">unstage</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">use</span> <span class="string">"git add/rm &lt;some-file&gt;..."</span> <span class="variable">as</span> <span class="variable">appropriate</span> <span class="variable">to</span> <span class="variable">mark</span> <span class="variable">resolution</span>)</span></span></span><br><span class="line">#</span><br><span class="line"># both modified:&lt;some-file&gt;</span><br></pre></td></tr></table></figure><p>接着小红编辑这些文件。  </p><p>修改完成后，用老套路暂存这些文件，并让git rebase 完成剩下的事情：  </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span></span><br><span class="line"><span class="bash">git rebase --<span class="built_in">continue</span></span></span><br></pre></td></tr></table></figure><p>要做的就这些了。  </p><p>Git会继续一个一个的合并后面的提交，如其他的提交有冲突就重复这个过程。  </p><p>如果你碰到了冲突，但是发现搞不定，不要惊慌。  </p><p>只要执行下面这条命令，就可以回到你执行git pull –rebase命令前的样子：  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase <span class="comment">--abort</span></span><br></pre></td></tr></table></figure><h5 id="小红成功发布功能"><a href="#小红成功发布功能" class="headerlink" title="小红成功发布功能"></a>小红成功发布功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX0kBnWeNL8ejRYU6ro4.2u6jfdf4WmDKrAtmoAnmJ9TQ4sDBTQl0i3xlqRsJMoYZns72c0lo3zm5ObKWH4CoUG0!/r" alt="小红成功发布功能"></p><p>小红完成和中央仓库的同步之后，就能成功发布她的修改了。  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>如你所见，仅仅使用几个Git命令，就可以模拟出传统Subversion开发环境。  </p><p>对于要从SVN迁移过来的团队来说这太好了，但是没有发挥出Git分布式本质的优势。  </p><p>如果你的团队适应了集中式工作流，但想要更流畅的协作效果，绝对值得探索一下功能分支工作流的收益。  </p><p>通过为一个功能分配一个专门的分支，能够做到一个新增功能集成到正式项目之前对新功能进行深入讨论。  </p><h3 id="功能分支工作流-1"><a href="#功能分支工作流-1" class="headerlink" title="功能分支工作流"></a>功能分支工作流</h3><p>一旦玩转了集中式工作流，在开发过程中可以很简单地加上功能分支，用来鼓励开发者之间协作和简化交流。  </p><p>功能分支工作流背后的核心思路是所有的功能开发应该在一个专门的分支，而不是在master分支上。  </p><p>这个隔离可以方便多个开发者在各自的功能上开发而不会弄乱主干代码。  </p><p>另外，也保证了master分支的代码一定不会是有问题的，极大有利于集成环境。  </p><p>功能开发隔离也让pull  requests工作流成为可能， pull requests工作流能为每一个分支发起一个讨论，在分支合入正式项目之前，给其它开发者有表示赞同的机会。  </p><p>另外，如果你在功能开发中有问题卡出了，可以开一个pull Requests来向同学们征求建议。  </p><p>这些做法的重点就是，pull Requests让团队成员之间互相评论工作变成非常方便！  </p><h4 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h4><p>功能分支工作流仍然用中央仓库，并且master分支还是代表了正式项目的历史。  </p><p>但不是直接提交本地历史到各自的本地master分支，开发者每次在开始新功能前先创建一个新分支。  </p><p>功能分支应该有个描述性的名字，比如 animated-menu-items 或者  issue-#1061，这样可以让分支有个清楚且高聚焦的用途。  </p><p>在master分支和功能分支之间，Git是没有技术上的区别，所以开发者可以用和集中式工作流完全一样的方式编辑、暂存和提交修改到功能分支上。  </p><p>另外，功能分支也可以（且应该）push到中央仓库中。  </p><p>这样不修改正是代码就可以和其他开发者分享提交的功能。  </p><p>由于master仅有的一个【特殊】分支，在中央仓库上存在多个功能分支不会有任何问题。  </p><p>当然这样做也可以很方便地备份各自的本地提交。  </p><h4 id="Pull-Requests-1"><a href="#Pull-Requests-1" class="headerlink" title="Pull Requests"></a>Pull Requests</h4><p>功能分支除了可以隔离功能的开发，也使得通过 Pull Requests讨论变更称为可能。  </p><p>一旦某个开发完成一个功能，不是立即合并到master，而是push到中央仓库的功能分支上并发起一个Pull Requests的请求去合并并修改到master。  </p><p>在修改成为主干代码之前，这让其他的开发者有机会先去Review变更。  </p><p>Code Review是Pull Requests的一个重要的收益。  </p><p>但是pull Requests目的是讨论代码一个通用方式。  </p><p>你可以把Pull  Requests作为专门给某个分支的讨论。  </p><p>这意味着可以在更早的开发过程中就可以进行Code Review。  </p><p>比如，一个开发者开发功能需要帮助时，要做的就是发起一个Pull Requests，相关的人就会自动收到通知，在相关的提交旁边能看到需要帮助解决的问题。  </p><p>一旦Pull  Requests被接受了，发布功能要做的就和集中式工作流就很像了。  </p><p>（1）首先，确定本地的master分支和上游的master分支是同步的。  </p><p>（2）然后合并功能分支到本地master分支，并push已经更新的本地master分支到中央仓库。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>下面的示例演示了如何把Pull Requests作为Code Review的方式，但注意Pull Requests可以用于很多其他的目的。  </p><h5 id="小红开始开发一个新功能"><a href="#小红开始开发一个新功能" class="headerlink" title="小红开始开发一个新功能"></a>小红开始开发一个新功能</h5><p>在开始开发功能之前，小红需要一个独立的分支。  </p><p>使用下面的命令新建一个分支。  </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> checkout -<span class="keyword">b </span><span class="keyword">marys-feature </span>master</span><br></pre></td></tr></table></figure><p>这个命令检出一个基于master名为marys-feature的分支，Git的-b选项表示如果分支还不存在则新建分支。  </p><p>这个新分支上，小红按照老套路编辑、暂存和提交修改，按需要提交以实现功能：  </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span>  <span class="string">status</span></span><br><span class="line"><span class="attr">git</span> <span class="string">add</span></span><br><span class="line"><span class="attr">git</span> <span class="string">commit</span></span><br></pre></td></tr></table></figure><h5 id="小红要去吃个午饭"><a href="#小红要去吃个午饭" class="headerlink" title="小红要去吃个午饭"></a>小红要去吃个午饭</h5><p>（两个人、多个人同时开发，称之为协同开发）  </p><p>仓库：github、码云、码市、gitlab  </p><p>review 代码审核；  </p><p>早上小红为新功能添加了一些提交。  </p><p>去吃午饭前，push功能分支到中央仓库是很好的做法，这样可以方便地备份，如果和其他开发协作，也让他们可以看到小红的提交。  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> -u <span class="built_in">origin</span> marys-<span class="built_in">feature</span></span><br></pre></td></tr></table></figure><p>这条命令  push marys-feature 分支到中央仓库（origin），-u选项设置本地分支去跟踪远程对应的分支。  </p><p>设置好跟踪的分支后，小红就可以使用git push 命令省去指定推送分支的参数。  </p><h5 id="小红完成功能开发"><a href="#小红完成功能开发" class="headerlink" title="小红完成功能开发"></a>小红完成功能开发</h5><p>小红吃完午饭回来，完成整个功能的开发。  </p><p>在合并到master之前，她发起一个Pull Requests让团队的其他人知道功能已经完成。  </p><p>但是首先，她要确认中央仓库中已经有她最近的提交。  </p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure><p>然后，在她的Git GUI客户端中发起Pull Request，请求合并marys-feature到master，团队成员会自动收到通知。  </p><p>Pull Request很酷的是可以在相关的提交旁边显示评注，所以你可以很对某个变更集提问。  </p><h5 id="小黑收到Pull-Request"><a href="#小黑收到Pull-Request" class="headerlink" title="小黑收到Pull  Request"></a>小黑收到Pull  Request</h5><p>小黑收到Pull Request后会查看marys-feature的修改。  </p><p>决定在合并到正式项目前是否要做些修改，且通过Pull Request和小红来回的讨论。  </p><h5 id="小红再做修改"><a href="#小红再做修改" class="headerlink" title="小红再做修改"></a>小红再做修改</h5><p>要在做修改，小红用和功能第一个迭代完全一样的过程。  </p><p>编辑、暂存、提交并push更新到中央仓库。  </p><p>小红这些活动都会显示在Pull Request上，小黑可以断续做评注。  </p><p>如果小黑有需要，也可以把marys-feature分支拉到本地，自己来修改，他加的提交也会一样显示在Pull Request上。  </p><h5 id="小红发布她的功能"><a href="#小红发布她的功能" class="headerlink" title="小红发布她的功能"></a>小红发布她的功能</h5><p>一旦小黑可以接受Pull Request，就可以合并功能到稳定项目代码中（可以由小黑或者是小红来做这个操作）：  </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">checkout master</span></span><br><span class="line"><span class="attr">git</span> <span class="string">pull</span></span><br><span class="line"><span class="attr">git</span> <span class="string">pull origin marys-feature</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push</span></span><br></pre></td></tr></table></figure><p>无论谁来做合并，首先要检出master分支并确认它是最新的。  </p><p>然后执行 git pull origin marys-feature 合并 marys-feature 分支到已经和远程一直的本地 master分支。  </p><p>你可以使用简单 git merge marys-feature命令，但是前面的命令可以保证总是最新的新功能分支。  </p><p>最后更新的master分支要重新push回到origin。  </p><p>这个过程常常会生成一个和并提交。  </p><p>有些开发者喜欢有合并提交。  </p><p>因为它像一个新功能和原来代码基线的连通符。  </p><p>但如果你偏爱线性的提交历史，可以在执行合并rebase新功能到master分支的顶部，这样生成一个快进（fast-forward）的合并。  </p><p>一些GUI客户端只要点一下【接受】按钮执行好上面的命令来自动化Pull Request接受过程。  </p><p>如果你的不能这样，至少在功能合并到master分子后自动关闭Pull Request。  </p><h5 id="与此同时，小明在做和小红一样的事情"><a href="#与此同时，小明在做和小红一样的事情" class="headerlink" title="与此同时，小明在做和小红一样的事情"></a>与此同时，小明在做和小红一样的事情</h5><p>当小红和小黑在marys-feature上工作并讨论她的Pull  Request的时候，小明在自己的功能分支上做完全一样的事情。  </p><p>通过隔离功能能到独立的分支上，每个人都可以自主的工作，当然必要的时候在开发者之间分享变更还是比较繁琐的。  </p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>到了这里，但愿你发现了功能分支可以很直接地在集中式工作流的仅有的master分支上完成多功能的开发。  </p><p>另外，功能分支还使用了Pull Request，使得可以在你的版本控制GUI客户端中讨论某个提交。  </p><p>功能分支工作流是开发项目异常灵活的方式。  </p><p>问题是，有时候太灵活了。  </p><p>对于大型团队，常常需要给不同分支分配一个更具体的角色。  </p><p>GitFlow工作流是管理功能开发、发布准备和维护的常用模式。  </p><h3 id="GitFlow工作流"><a href="#GitFlow工作流" class="headerlink" title="GitFlow工作流"></a>GitFlow工作流</h3><p>在实际开发当中，可能通常使用GitFlow工作流。  </p><p>GitFlow工作流定义了一个围绕项目发布的严格分支模型。  </p><p>虽然比功能分支工作流复杂几分，但是提供了一个用于健壮的用于管理大型项目的框架。  </p><p>GitFlow工作流没有用超出功能分支工作流的概念和命令。  </p><p>而是为不同的分支分配了一个很明确的角色，并定义分支之间如何交互和什么时候进行交互。  </p><p>除了使用功能分支，在做准备、维护和记录发布也是用各自的分支。  </p><p>当然你可以用上功能分支工作流所有的好处：Pull Request、隔离实验性开发和更高效的工作。  </p><h4 id="工作方式-2"><a href="#工作方式-2" class="headerlink" title="工作方式"></a>工作方式</h4><p>GitFlow工作流仍然用中央仓库作为所有开发者的交互中心。  </p><p>和其他工作流一样，开发者在本地工作并push分子到中央分支去。  </p><h5 id="历史分支"><a href="#历史分支" class="headerlink" title="历史分支"></a>历史分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX0DucqArpSZN8V1mN.Djx7WchltIFUxePFkxo0wF6tL9hJ92GPpyK1meBHYC6jQnh92Uk6*6zENCWbjq21uqLsI!/r" alt="历史分支"></p><p>相对使用仅有的一个master分支，GitFlow工作流使用两个分支来记录项目的历史。  </p><p>master分支存储了正式发布的历史，而develop分支作为功能的集成分支，这样也方便master分支上的所有提交分配一个版本号。  </p><p>剩下要说明的问题就是围绕这两个分支的区别展开。  </p><h5 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX4suzD8O2OoWbYPwQ150IFWgQS3qSKoLWdglLxIjfri4eWAHC*W6m9OYJM0vFH4CxIhXiOdTBQYoWLsUJ3d8M.k!/r" alt="功能分支"></p><p>每个新功能位于一个自己的分支，这样可以push到中央仓库以备份和协作。  </p><p>但是功能分支不是从master分支上拉出新分支，而是使用develop分支作为父分支。  </p><p>当新功能完成时，合并会develop分支。  </p><p>新功能提交应该从不直接与master分支交互。  </p><p>开源软件基本上是使用GitFlow来做代码版本管理的控制。  </p><p>注意，从各种含义和目的上来看，功能分支加上develop分支就是功能分支工作流的用法。  </p><p>但是GitFlow工作流没有在这里止步。  </p><h5 id="发布分支"><a href="#发布分支" class="headerlink" title="发布分支"></a>发布分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX1K5y5ivKrS*rhk3l.NtQVVaNHmKMdlqKelqYaRENh70*1X*IrEmFCJIhfs5U7wXELfZbYI1tihPDOGBwBPqt6E!/r" alt="发布分支"></p><p>一旦develop分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从develop分支上fork一个发布分支。  </p><p>新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上——-这个分支只应该叫Bug修复、文档生成或其他面向发布任务。  </p><p>一旦对外发布的工作都完成了，发布分支合并到master分支并飞配一个版本号打好Tag。  </p><p>另外，这些新建发部分之以来做的修改要合并回develop分支。  </p><p>使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。  </p><p>这也打造定义良好的开发阶段（比如，可以很轻松的说，【这周我们要做准备发布版本4.0】，并且在仓库的目录结构中可以实际看到）  </p><p>常用的分支约定：  </p><ul><li>用于新建发布分支的分支：develop</li><li>用于合并的分支：master</li><li>分支命名：release- 或 release/</li></ul><h5 id="维护分支"><a href="#维护分支" class="headerlink" title="维护分支"></a>维护分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX8qfvx9q8UhYcwpU4tSoxZoCzp2TGnchoEgJnBAd**ejGrSWx7H1n1RbZFVAdVlD7v3kEO6EHjpPFNMCD9pabTQ!/r" alt="维护分支"></p><p>维护分支或者说是热修复（hotfix）分支用于生成快速给产品发布版本（production release）打补丁，这是唯一可以从master分支fork出来的分支。  </p><p>修复完成，修改应该马上合并回master分支和develop分支（当前的发部分支），master分支应该用新的版本号打好Tag。  </p><p>为了Bug修复使用专门分支，让团队可以处理问题而不用打断其他工作或者是等待下一个发布循环。  </p><p>你可以把维护分支想成是一个直接在master分支上处理的临时发布。  </p><p>即hotfix，维护的是v1.0.0—&gt;v1.0.1这种；<br>第三位数修改的是Bug（hotfix维护版本第三位数）；第二位数修改的是功能（功能分支维护的是版本的第二位数）；第一位为大架构改变的时候进行修改（维护版本的第一位数）；  </p><p>GitFlow从这点上就可以与语义化规范牵扯上联系；  </p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>下面的示例演示本工作流如何用于管理单个发布循环。  </p><p>假设你已经创建了一个中央仓库。  </p><h5 id="创建开发分支"><a href="#创建开发分支" class="headerlink" title="创建开发分支"></a>创建开发分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX4Xsg92Awirp0bThQ4n*YW8UWB.U5*XFBFsn5hkNOcst0hBz.q1uwuu*KDADM.W9naZBQq8eKQyo4iLkzk28e1g!/r" alt="创建开发分支"></p><p>第一步为master分支配套一个develop分支。  </p><p>简单来做可以本地创建一个空的develop分支，push到服务器上：  </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>develop</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>-u origin master</span><br></pre></td></tr></table></figure><p>以后这个分支将会包含了项目的全部历史。  </p><p>而master分支将只包含部分历史。  </p><p>其他开发者这时应该克隆中央仓库，建好develop分支的跟踪分支：  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">ssh</span>://user@host/path/to/repo.git</span><br><span class="line">git checkout -b develop origin/develop</span><br></pre></td></tr></table></figure><p>现在每个开发都有了这些历史分支的本地拷贝。  </p><h5 id="小红和小明开始开发新功能"><a href="#小红和小明开始开发新功能" class="headerlink" title="小红和小明开始开发新功能"></a>小红和小明开始开发新功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX2X16EiSaoizI9a2HRgo6HRlddb*dD0yGRzorFtrKInoqDMveDkX4.ujU1ZgrgxXoZf1vY83YLzd6Dl2YO5SDUc!/r" alt="小红和小明开始开发新功能"></p><p>这个示例中，小红和小明开始各自的功能开发。  </p><p>他们需要为各自的功能创建相应的分支。  </p><p>新分支不是基于master分支，而是应该基于develop分支：  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="built_in">some</span>-<span class="built_in">feature</span> develop</span><br></pre></td></tr></table></figure><p>他们用老套路添加提交到各自功能分支上：编辑、暂存、提交；  </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">status</span></span><br><span class="line"><span class="attr">git</span> <span class="string">add</span></span><br><span class="line"><span class="attr">git</span> <span class="string">commit</span></span><br></pre></td></tr></table></figure><h5 id="小红完成功能开发-1"><a href="#小红完成功能开发-1" class="headerlink" title="小红完成功能开发"></a>小红完成功能开发</h5><p>添加了提交后，小红觉得她的功能OK了。  </p><p>如果团队使用Pull Requests，这时候可以发起一个用于合并到develop分支。  </p><p>否则她可以直接合并到她本地的develop分之后push到中央仓库：  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="built_in">origin</span> develop</span><br><span class="line">git checkout develop</span><br><span class="line">git merge <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line">git <span class="built_in">push</span></span><br><span class="line">git branch -d <span class="built_in">some</span>-<span class="built_in">feature</span></span><br></pre></td></tr></table></figure><p>第一条命令在合并功能前确保develop分支是最新的。  </p><p>注意，功能绝不应该直接合并到master分支。  </p><p>冲突解决方法和集中式工作流一样。  </p><h5 id="小红开始准备发布"><a href="#小红开始准备发布" class="headerlink" title="小红开始准备发布"></a>小红开始准备发布</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXxm6aYd1gMGOxylETc6cDcj7kTwBnGuyoyzYDL7pNxxvtXeo*D5bCxnVfWE*k.cQe8O4lhgkHo2zR.IIDII1kmA!/r" alt="小红开始准备发布"></p><p>这个时候小明正在实现他的功能。  </p><p>小红开始准备她的第一个项目正式发布（发布分支也叫预发布分支，预发布分支基于develop，只有预发布版本分支才能够去合并到master分支，而预发布版本是经过测试人员测试之后的没有问题的一个版本；master分支代码必须可以执行，没有被污染）。  </p><p>像功能开发一样，她用一个新的分支来做发布准备。  </p><p>这一步也确定了发布的版本号：  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b release<span class="number">-0.1</span> develop</span><br></pre></td></tr></table></figure><p>这个分支是清理分支、执行所有测试、更新文档和其他为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。  </p><p>只要小红创建的这个分支push到中央仓库，这个发布就是功能冻结的。  </p><p>任何不在develop分支中的新功能都推到下一个发布循环中。  </p><h5 id="小红完成发布"><a href="#小红完成发布" class="headerlink" title="小红完成发布"></a>小红完成发布</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXx2fdZ*.CxsTwPMg235DDXkchbPbk7hNVec6.FIcmcf72k0vjzhdQvVlYt8u8ao*65n3gyQAyN5GOxndJKhwiNk!/r" alt="小红完成发布"></p><p>一旦准备好了对外发布，小红合并修改到master分支和develop分支上，删除发布分支。  </p><p>合并回develop分支很重要，因为在发布分支中已经提交的更新需要在后面的新功能中也要是可用的。  </p><p>另外，如果小红的团队要求Code  Review，这是一个发起Pull Request的理想时机。  </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">checkout master</span></span><br><span class="line"><span class="attr">git</span> <span class="string">merge release-0.1</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push</span></span><br><span class="line"><span class="attr">git</span> <span class="string">checkout develop</span></span><br><span class="line"><span class="attr">git</span> <span class="string">merge release-0.1</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push</span></span><br><span class="line"><span class="attr">git</span> <span class="string">branch -d release-0.1</span></span><br></pre></td></tr></table></figure><p>发布分支是作为功能开发（develop分支）和对外发布（master分支）间的缓冲。  </p><p>只要有合并到master分支，就应该打好Tag以方便跟踪。  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-a</span> <span class="number">0.1</span> -m <span class="string">"Initial public release"</span> <span class="literal">master</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p>Git有提供各种钩子（hook），即仓库有时间发生时触发执行的脚本。  </p><p>可以配置一个钩子，在你push中央仓库的master分支时，自动构建好对外发布。  </p><h5 id="最终用户发现Bug"><a href="#最终用户发现Bug" class="headerlink" title="最终用户发现Bug"></a>最终用户发现Bug</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXzsQH1hJotlrx1khR6EZ0dUlyxkaf9L1Yi66Fs6sohYE0UTifJNygNHa*okiIgZc5dg2qSXBW*VyQGtiyMr0yo8!/r" alt="最终用户发现Bug"></p><p>对外发布后，小红回去和小明一起做下个发布的新功能开发，直到有最终用户开了一个Ticket抱怨当前版本的一个Bug。  </p><p>为了处理Bug，小红（或者小明）从master分支上来去了一个维护分支（hotfix），提交修改以解决问题，然后直接合并回master分支：  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b issue-<span class="comment">#001 master</span></span><br><span class="line"><span class="comment"># Fix the bug</span></span><br><span class="line">git checkout <span class="literal">master</span></span><br><span class="line">git merge issue-<span class="comment">#001</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>就像发布分支，维护分支中新加这些重要修改需要包含到develop分支中，所以小红要执行一个合并操作，然后就可以安全地删除这个分支了：  </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">checkout develop</span></span><br><span class="line"><span class="attr">git</span> <span class="string">merge issue-#001</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push</span></span><br><span class="line"><span class="attr">git</span> <span class="string">branch -d issue-#001</span></span><br></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>到了这里，但愿你对集中式工作流、功能分支工作流和GitFlow工作流已经感觉很舒适了。  </p><p>你应该也牢固的掌握了本地仓库的潜能，push/pull模式和Git健壮的分支和合并模型。  </p><p>记住，这里演示的工作流只是可能用法的例子，而不是在实际工作中使用Git不可违逆的条例。  </p><p>所以不要畏惧按自己需要对工作流的用法做取舍，不变的目标就是让Git为你所用。  </p><p>（在整个GitFlow工作流当中，只会去进行省略功能分支Feature，Master、HotFix、Release、Develop是必不可少的分支，以便控制每一次版本的迭代）  </p><h3 id="Forking工作流-1"><a href="#Forking工作流-1" class="headerlink" title="Forking工作流"></a>Forking工作流</h3><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX2qjPC0eDN.Xf29HcBYoAsTtpBFvJhu8qPVkh5cv575QWLsHx3q8JbFYK3X5cts.Zn43gkCjc7OzyBcDFaNdl.g!/r" alt="Forking工作流"></p><p>Forking工作流和前面讨论的几种工作流有根本的不同。  </p><p>这种工作流不是适用单个服务器端仓库作为【中央】代码基线，而让各个开发者都有一个服务端仓库。  </p><p>这意味着各个代码贡献者有2个Git仓库而不是1个：一个本地私有的，另一个服务端公开的。  </p><p>Forking工作流的一个主要优势是，贡献的代码可以被集成，而不需要所有人都能push代码到仅有的中央仓库中。  </p><p>开发者push到自己的服务端仓库，而只有项目维护者才能push到正式仓库。  </p><p>这样项目维护者可以接受任何开发者的提交，但无需给他正式代码库的写权限。  </p><p>效果就是一个分布式的工作流，能为大型、自发性的团队（包括了不受信的第三方）提供灵活的方式来安全的写作。  </p><p>也让这个工作流称为开源项目的理想工作流。  </p><h4 id="工作方式-3"><a href="#工作方式-3" class="headerlink" title="工作方式"></a>工作方式</h4><p>和其他的Git工作流一样，Forking工作流要先有一个公开的正式仓库存储在服务器上，但一个新的开发者想要在项目上工作时，不是直接从正式仓库克隆，而是fork正式项目在服务器上创建一个拷贝。  </p><p>这个仓库拷贝作为他人公开仓库—–其他开发者不允许push到这个仓库，但可以pull到修改（后面很快就会看到这点很重要）。  </p><p>在创建了自己服务端拷贝之后，和之前的工作流一样，开发者执行git clone命令克隆仓库到本地机器上，作为私有的开发环境。  </p><p>要提交本地修改时，push提交到自己公开仓库中——-而不是正式仓库中。  </p><p>然后，给正式仓库发起一个pull request，让项目维护者知道有更新已经准备好可以集成了。  </p><p>对于贡献的代码，pull request也可以很方便地作为一个讨论的地方。  </p><p>为了集成功能到正式代码库，维护者pull贡献者的变更到自己的本地仓库中，检查变更以确保不会让项目出错，合并变更到自己本地的master分支，然后push master分支到服务器的正式仓库中。  </p><p>到此，贡献的提交成为了项目的一部分，其他的开发者应该执行pull操作与正式仓库同步自己本地仓库。  </p><h5 id="正式仓库"><a href="#正式仓库" class="headerlink" title="正式仓库"></a>正式仓库</h5><p>在Forking工作流中，【官方】仓库的叫法只是一个约定，理解这点很重要。  </p><p>从技术上来看，各个开发者仓库和正式仓库在Git卡那里没有任何区别。  </p><p>事实上，让正式仓库之所以正式的唯一原因是他是项目维护者的公开仓库。  </p><h5 id="Forking工作流的分支使用方式"><a href="#Forking工作流的分支使用方式" class="headerlink" title="Forking工作流的分支使用方式"></a>Forking工作流的分支使用方式</h5><p>所有的个人公开仓库实际商只是为了方便和其他的开发者共享分支。  </p><p>各个开发者应该用分支隔离各个功能，就像功能分支工作流和GitFlow工作流一样。  </p><p>唯一的区别是这些分支被共享了。  </p><p>在Forking工作流中这些分支会被pull到另一个开发者的本地仓库中，而在功能分支工作流和GitFlow工作流中是直接被push到正式仓库当中。  </p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><h5 id="项目维护者初始化正式仓库"><a href="#项目维护者初始化正式仓库" class="headerlink" title="项目维护者初始化正式仓库"></a>项目维护者初始化正式仓库</h5><p>和任何使用Git项目一样，第一步还是创建在服务器上一个正式仓库，让所有团队成员都可以访问到。  </p><p>通常这个仓库也会作为项目维护者的公开仓库。  </p><p>公开仓库应该是裸仓库，不管是不是正式代码库。  </p><p>所以项目维护者会运行像下面的命令来搭建正式仓库：  </p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh user<span class="symbol">@host</span></span><br><span class="line">git init --bare /path/<span class="keyword">to</span>/repo.git</span><br></pre></td></tr></table></figure><p>Bitbucket和Stash提供了一个方便的GUI客户端已完成上面命令行做的事。  </p><p>这个搭建中央仓库的过程和前面提到的工作流完全一样。  </p><p>如果有现存的代码库，维护者也要push到这个仓库中。  </p><h5 id="开发者fork正式仓库"><a href="#开发者fork正式仓库" class="headerlink" title="开发者fork正式仓库"></a>开发者fork正式仓库</h5><p>其他所有的开发需要fork正式仓库。  </p><p>可以用git clone命令用SSH协议连通到服务器，拷贝仓库到服务器另一个位置—–是的，fork操作基本上就只是一个服务端的克隆。  </p><p>Bitbucket和Stash上可以点一下按钮就让开发者完成仓库的fork操作。  </p><p>这一步完成后，每个开发都在服务端有一个自己的仓库。  </p><p>和正式仓库一样，这些仓库应该是裸仓库。  </p><h5 id="开发者克隆自己fork出来的仓库"><a href="#开发者克隆自己fork出来的仓库" class="headerlink" title="开发者克隆自己fork出来的仓库"></a>开发者克隆自己fork出来的仓库</h5><p>下一步，各个开发者要克隆自己的公开仓库，用熟悉的git clone命令。  </p><p>在这个示例中，假定用Bitbucket托管了仓库。  </p><p>记住，如果这样的话各个开发者需要有各自的Bitbucket账号，使用下面命令克隆服务端自己的仓库。  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://user@bitbucket.org/user/repo.git</span><br></pre></td></tr></table></figure><p>相比前面介绍的工作流只用了一个origin远程别名指向中央仓库，Forking工作流需要2个远程别名——-一个指向正式仓库，另一个指向开发者自己的服务端仓库。  </p><p>别名的名字可以任意命名，常见的约定是使用origin作为远程克隆的仓库的别名（这个别名会在运行git clone自动创建），upstream（上游）作为正式仓库的别名。  </p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span> upstream https://bitbucket<span class="meta">.org</span>/maintainer/repo</span><br></pre></td></tr></table></figure><p>需要自己用上面的命令创建upstream别名。  </p><p>这样可以简单地保持本地仓库和正式仓库的同步更新。  </p><p>注意，如果上游仓库需要认证（比如不是开源的），你需要提供用户：  </p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span> upstream https://user@bitbucket<span class="meta">.org</span>/maintainer/repo</span><br></pre></td></tr></table></figure><p>这时在克隆和pull正式仓库时，需要提供用户的密码。  </p><h5 id="开发者开发自己的功能"><a href="#开发者开发自己的功能" class="headerlink" title="开发者开发自己的功能"></a>开发者开发自己的功能</h5><p>在刚克隆的本地仓库中，开发者可以向其他工作流一样的编辑代码、提交修改和新建分支：  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line">// Edit <span class="built_in">some</span> code</span><br><span class="line">git commit -a -m <span class="string">"Add first draft of some feature"</span></span><br></pre></td></tr></table></figure><p>所有的修改都是私有的直到push到自己公开仓库中。  </p><p>如果正式项目已经向前走了，可以用git pull命令获得新的提交：  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull upstream <span class="literal">master</span></span><br></pre></td></tr></table></figure><p>由于开发者应该都在专门的功能分支上工作，pull操作结果会都是快进合并。  </p><h5 id="开发者发布自己的功能"><a href="#开发者发布自己的功能" class="headerlink" title="开发者发布自己的功能"></a>开发者发布自己的功能</h5><p>一旦开发者准备好了分享新功能，需要做两件事。  </p><p>（1）首先，通过push他的贡献代码到自己的公开仓库中，让其他的开发者都可以访问到。他的origin远程别名应该已经有了，所有要做的就是：  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span>  <span class="built_in">feature</span>-branch</span><br></pre></td></tr></table></figure><p>这里和之前的工作流的差异是，origin远程别名指向开发者自己的服务端仓库，而不是正式仓库。  </p><p>（2）第二件事，开发者要通知项目维护者，想要合并他的新功能到正式库中。Bitbucket和Stash提供了Pull Request按钮，弹出个表单让你指定哪个分支要合并到正式仓库。一般你会想集成你的功能分支到上游远程仓库的master分支中。  </p><h5 id="项目维护者集成开发者的功能"><a href="#项目维护者集成开发者的功能" class="headerlink" title="项目维护者集成开发者的功能"></a>项目维护者集成开发者的功能</h5><p>当项目维护者收到pull request时，他要做的是决定是否集成它到正式代码库中。  </p><p>有两种方式来做：  </p><ul><li>直接在pull request中查看代码</li><li>pull代码到他自己的本地仓库，再手动合并</li></ul><p>第一种做法更简单，维护者可以在GUI中查看变更的差异，做评注和执行合并。  </p><p>但如果出现了合并冲突，需要第二种做法来解决。  </p><p>这种情况下，维护者需要从开发者的服务端仓库中fetch功能分支，合并到他本地的master分支，解决冲突：  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch https:<span class="regexp">//</span>bitbucket.org<span class="regexp">/user/</span>repo feature-branch</span><br><span class="line"><span class="regexp">//</span>查看变更</span><br><span class="line">git checkout master</span><br><span class="line">git merge FETCH_HEAD</span><br></pre></td></tr></table></figure><p>变更集成到本地的master分支后，维护者要push变更到服务器上的正式仓库，这样其他的开发者都能访问到：  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><p>注意，维护者的origin是指向他自己公开仓库的，即是项目的正式代码库。  </p><p>到此，开发者的贡献完全集成到了项目中。  </p><h5 id="开发者和正式仓库做同步"><a href="#开发者和正式仓库做同步" class="headerlink" title="开发者和正式仓库做同步"></a>开发者和正式仓库做同步</h5><p>由于正式代码库往前走了，其他的开发需要和正式仓库做同步：  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull upstream <span class="literal">master</span></span><br></pre></td></tr></table></figure><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>如果你之前是使用SVN，Forking工作流可能看起来像是一个激进的范式切换（paradigm shift）。  </p><p>但是不要害怕，这个工作流实际上就是在功能分支工作流之上引入了另一个抽象层。  </p><p>不是直接通过单个中央仓库来分享分支，而是把贡献代码发布到开发者自己的服务端仓库中。  </p><p>示例中解释了，一个贡献如何从一个开发者流到正式的master分支中，但是同样的方法可以把贡献集中到任意一个仓库中。  </p><p>比如，如果团队的几个人协作实现一个功能，可以在开发之间用相同的方法分享变更，完全不涉及正式仓库。  </p><p>这使得Forking工作流对于松散组织的团队来说是个非常强大的工具。  </p><p>任一开发者可以方便地和另一开发者分享变更，任何分支都能有效地合并到正式代码库中。  </p><h3 id="Pull-Requests-2"><a href="#Pull-Requests-2" class="headerlink" title="Pull Requests"></a>Pull Requests</h3><p>Pull Requests 是Bitbucket上方便开发者之间协作的功能。  </p><p>提供了一个用户友好的Web界面，在集成提交的变更到正式向目前可以对变更进行讨论。  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX1zLLMp65VmnavK5XDJUKS6zYUJDvvIJN*Lt1FNUoIJG0DkTCKRNuOGToGtjWmjIrVLu*fSpHVogAtzO4DgCm80!/r" alt="images"></p><p>开发者向团队成员通知功能开发已经完成，pull Requests是最简单的用法。  </p><p>开发者完成功能开发后，通过Bitbucket账号发起一个pull Request。这样让涉及这个功能的所有人知道，要去做Code Review和合并到master分支。  </p><p>但是，Pull  Request远不止一个简单的通知，而是为讨论提交的功能的一个专门论坛。  </p><p>如果变更有任何问题，团队成员反馈在Pull Request中，甚至pull新的提交微调功能。  </p><p>所有的这些活动都直接跟踪在Pull Request中。  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7SLIJSUYxrmcZpwuXYsQB1Ya2zpcBawWJ7atpdZcoSsGWSrxt3XnkjpSfeaAffmHrs3SyEpgZCaBKHAdN3ReSA!/r" alt="images"></p><p>相比其他的协作模型，这种分享提交的形式有助于打造一个更流畅的工作流。  </p><p>SVN和Git都能通过一个简单的脚本收到通知邮件；  </p><p>但是，讨论变更时，开发者通常只能去回复邮件。  </p><p>这样做会变得杂乱，尤其还要涉及后面的几个提交时。  </p><p>Pull Requests吧所有相关功能整合到一个和Bitbucket仓库界面集成的用户友好Web界面中。  </p><h4 id="解析Pull-Request"><a href="#解析Pull-Request" class="headerlink" title="解析Pull Request"></a>解析Pull Request</h4><p>当腰发起一个pull Request，你所要做的就是请求（Request）另一个开发者（比如项目的维护者），来pull你仓库中一个分支到他的仓库中。  </p><p>这意味着你要提供4个信息（源仓库、源分支、目的仓库、目的分支），以发起Pull Request。  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7SLIJSUYxrmcZpwuXYsQB1Ya2zpcBawWJ7atpdZcoSsGWSrxt3XnkjpSfeaAffmHrs3SyEpgZCaBKHAdN3ReSA!/r" alt="images"></p><h4 id="工作方式-4"><a href="#工作方式-4" class="headerlink" title="工作方式"></a>工作方式</h4><p>Pull Request可以和功能分支工作流、GitFlow工作流或Forking工作流一起使用。  </p><p>但Pull Request要求要么分支不同，要么仓库不同，所以不能用于集中式工作流。  </p><p>在不同的工作流中使用pull  Request会有一些不同，但基本的过程是这样的：  </p><ul><li>开发者在本地仓库新建一个专门的分支开发功能；</li><li>开发者push分支修改到公开的Bitbucket仓库中；</li><li>开发者通过Bitbucket发起一个Pull Request；</li><li>团队的其他成员review code，讨论并修改；</li><li>项目维护者合并功能到官方仓库中并关闭Pull Request；</li></ul><h4 id="在功能分支工作流中使用Pull-Request"><a href="#在功能分支工作流中使用Pull-Request" class="headerlink" title="在功能分支工作流中使用Pull Request"></a>在功能分支工作流中使用Pull Request</h4><p>功能分支工作流用一个共享的Bitbucket仓库来管理协作，开发者在专门的分支上开发功能。  </p><p>但不是立即合并到master分支上，而是在合并到主代码之前开发这应该开一个Pull Request发起功能的讨论。  </p><p>功能分支工作流只有一个公开的仓库，所以Pull Request的目的仓库和源仓库总是同一个。  </p><p>通常开发者会指定他的功能分支作为源分支，master分支作为目的分支。  </p><p>收到Pull Request后，项目维护者要决定如何做。  </p><p>如果功能没问题，就简单地合并到master分支，关闭Pull Request。  </p><p>但如果提交的变更有问题，他可以在Pull Request中反馈，之后的新加的评论也会评论之后接着显示出来。  </p><p>在功能还没有完全开发完的时候，也可能发起一个pull Request。  </p><p>比如开发者在实现某个需求时遇到了麻烦。  </p><p>他可以发一个包含正在进行工作的Pull Request。  </p><p>其他的开发者可以在Pull Request提供建议，或者甚至直接添加提交来解决问题。  </p><h4 id="在GitFlow工作流中使用Pull-Request"><a href="#在GitFlow工作流中使用Pull-Request" class="headerlink" title="在GitFlow工作流中使用Pull Request"></a>在GitFlow工作流中使用Pull Request</h4><p>GitFlow工作流和功能分支工作流类似，单围绕项目发布定义一个严格的分支模型。  </p><p>在GitFlow工作流中使用Pull Request让开发者在发布分支或者是维护分支上工作时，可以有个方便的地方对关于发布分支或者是维护分支的问题进行交流。  </p><p>GitFlow工作流中Pull Request的使用过程和上一节中完全一致：当一个功能、发布或者是热修复分支需要Review时，开发者简单发起一个Pull Request，团队的其他成员会通过Bitbucket收到通知。  </p><p>新功能一般合并到develop分支，而发布和热修复则要同时合并到develop分支和master分支上。  </p><p>Pull Request可能用作所有合并的正式管理。  </p><h4 id="在Forking工作流中使用Pull-Request"><a href="#在Forking工作流中使用Pull-Request" class="headerlink" title="在Forking工作流中使用Pull Request"></a>在Forking工作流中使用Pull Request</h4><p>在Forking工作流中，开发者push完成的功能到他自己的仓库中，而不是共享仓库。  </p><p>然后，他发一个Pull  Request，让项目维护者知道他的功能已经可以Review了。  </p><p>在这个工作流，Pull Request的通知功能非常有用，因为项目维护者不可能知道其他开发者在他们自己的仓库添加了提交。  </p><p>由于各个开发者有自己的公开仓库，Pull Request的源仓库和目标仓库不是同一个。  </p><p>源仓库是开发者的公开仓库，源分支是包含了修改的分支。  </p><p>如果开发者要合并修改到正式代码库中，那么目标仓库是正式仓库，目标分支是master分支。  </p><p>Pull Request也可以用于正式项目之外的其他开发者之间的协作。  </p><p>比如，如果一个开发者和一个团队成员一起开发一个功能，他们可以发起一个Pull Request，用团队成员的Bitbucket仓库作为目标，而不是正式项目的仓库。  </p><p>然后使用相同的功能分支作为源和目标分支。  </p><p>2个开发者之间可以在Pull Request中讨论和开发功能。  </p><p>完成开发后，他们可以发起另一个Pull  Request，请求合并功能到正式的master分支。  </p><p>在Forking工作流中，这样的灵活性称为一个强有力的协作工具。  </p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>下面的示例演示了Pull Request如何在Forking工作流中使用。  </p><p>也同样适用于小团队的开发协作和第三方开发者向开源项目的贡献。  </p><p>在示例中，小红是个开发，小明是项目维护者。  </p><p>他们各自有一个公开的Bitbucket仓库，而小明的仓库包含了正式工程。  </p><h5 id="小红fork正式项目"><a href="#小红fork正式项目" class="headerlink" title="小红fork正式项目"></a>小红fork正式项目</h5><p>小红先要fork小明的Bitbucket仓库，开始项目的开发。  </p><p>她登录Bitbucket，浏览到小明的仓库页面，点fork按钮。  </p><p>然后为fork出来的仓库填写名字和描述，这样小红就有了服务端的项目拷贝了。  </p><h5 id="小红克隆她的Bitbucket仓库"><a href="#小红克隆她的Bitbucket仓库" class="headerlink" title="小红克隆她的Bitbucket仓库"></a>小红克隆她的Bitbucket仓库</h5><p>下一步，小红克隆自己刚才fork出来的Bitbucket仓库，以在本机上准备出工作拷贝。  </p><p>命令如下：  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://user@bitbucket.org/user/repo.git</span><br></pre></td></tr></table></figure><p>请记住，git clone 会自动创建origin远程别名，是指向小红fork出来的仓库。  </p><h5 id="小红开发新功能"><a href="#小红开发新功能" class="headerlink" title="小红开发新功能"></a>小红开发新功能</h5><p>在开始改代码前，小红要为新功能新建一个新分支。  </p><p>她会用这个分支作为Pull Request的源分支。  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="built_in">some</span>-<span class="built_in">feature</span></span><br></pre></td></tr></table></figure><h5 id="编辑代码"><a href="#编辑代码" class="headerlink" title="编辑代码"></a>编辑代码</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -<span class="keyword">a</span> -m <span class="string">"Add first draft of some feature"</span></span><br></pre></td></tr></table></figure><p>在新功能分支上，小红按照需要添加提交。  </p><p>甚至如果小红觉得功能分支上的提交历史太乱了，她可以用交互式rebase来删除或者压制提交。  </p><p>对于大型项目，整理功能分支的历史可以让项目维护者更容易看出在pull Request中做了什么内容。  </p><h5 id="小红push功能到她的Bitbucket仓库中"><a href="#小红push功能到她的Bitbucket仓库中" class="headerlink" title="小红push功能到她的Bitbucket仓库中"></a>小红push功能到她的Bitbucket仓库中</h5><p>小红完成功能后，push功能到她自己的Bitbucket仓库中（不是正是仓库），用下面简单的命令。  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> <span class="built_in">some</span>-branch</span><br></pre></td></tr></table></figure><p>这时她的变更可以让项目维护者看到了（后者任何想要看的协作者）  </p><h5 id="小红发起Pull-Request"><a href="#小红发起Pull-Request" class="headerlink" title="小红发起Pull Request"></a>小红发起Pull Request</h5><p>Bitbucket上有了她的功能分支后，小红可以用她的Bitbucket账号浏览到她fork出来的仓库页面，点右上角的[ Pull Request ]按钮，发起一个Pull Request。  </p><p>弹出的表单自动设置小红的仓库为源仓库，询问小红以指定源分支、目标仓库和目标分支。  </p><p>小红想要合并功能到正式仓库，所以源分支是她的功能分支，目标仓库是小明的公开仓库，而目标分支是master分支。  </p><p>另外，小红需要提供Pull Request的标题和描述信息。  </p><p>如果需要小明以外的人审核批准diamante，她可以把这些人填在[ Reviewers ]文本框中。  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX4eBUNEH.PnD8cXLFX3FNQ1TY28uOV3j2Ic*FLo6qk1HERoVGDzy.ccPi6KWHQ1Ha7aF4qrprhr6a71aswRPe1s!/r" alt="images"></p><p>创建好了Pull Request，通知会通过Bitbucket系统消息或者邮件（可选）发给小明。  </p><h5 id="小明-review-Pull-Request"><a href="#小明-review-Pull-Request" class="headerlink" title="小明 review Pull Request"></a>小明 review Pull Request</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXz.TEdJt9fHfFvRXR*aihUCZBZl8OSFD1T7r*7GIRRSRDePO5EI5YO0pxG7Qo02eHht0.LfxlnFiUPPKgPzRY4U!/r" alt="images"></p><p>在小明的Bitbucket仓库页面的[ Pull Request ]Tab可以看到所有人发起的Pull Request。  </p><p>点击小红的Pull Request会显示Pull Request的描述、功能的提交历史和每个变更的差异（diff）。  </p><p>如果小明想要合并到项目中，只要点一下[ Merge ]按钮，就可以同意Pull Request并合并到master分支。  </p><p>但如果像这个示例中一样，小明发现了在小红的代码中的一个小Bug，要在小红合并前修复。  </p><p>小明可以在整个Pull Request上加上评注，或者是选择历史中的某个提交加上评注。  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXywJcEdXUnF5drr2Tn8vpOshxucsOMz.iW9qg*vXiM80CBz6VcPZTn4e7NC2txFi9Xf.oe9HyW39vilYdBhizv0!/r" alt="images"></p><h5 id="小红补加提交"><a href="#小红补加提交" class="headerlink" title="小红补加提交"></a>小红补加提交</h5><p>如果小红对反馈有任何疑问，可以在Pull Request中响应，把Pull Request当做是她功能讨论的论坛。  </p><p>小红在她的功能分支新加提交以解决代码问题，并push到她的Bitbucket仓库中，就像前一轮中的做饭一样。  </p><p>这些提交会进入到Pull Request，小明在原来的评注旁边可以再次Review 变更。  </p><h5 id="小明接受Pull-Request"><a href="#小明接受Pull-Request" class="headerlink" title="小明接受Pull Request"></a>小明接受Pull Request</h5><p>最终，小明接受变更，合并功能分支到master分支，并关闭Pull Request。  </p><p>至此，功能集成到项目中，其他的项目开发者可以用标准的git pull命令pull这些变更到自己的本地仓库中。  </p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>到了这里，你应该有了所有需要的工具来集成Pull Request到你自己的工作流。  </p><p>请记住，Pull Request并不是为了替代任何基于Git的协作工作流，而是它们的一个便利的补充，让团队成员间的协作更加轻松方便。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git工作流指南-分布式版本控制系统&quot;&gt;&lt;a href=&quot;#Git工作流指南-分布式版本控制系统&quot; class=&quot;headerlink&quot; title=&quot;Git工作流指南 分布式版本控制系统&quot;&gt;&lt;/a&gt;Git工作流指南 分布式版本控制系统&lt;/h2&gt;&lt;p&gt;观看笔记：&lt;
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Git工作流" scheme="https://fengshana.github.io/tags/Git%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构的分布式事务控制解决方案</title>
    <link href="https://fengshana.github.io/2020/04/20/%E9%9D%A2%E8%AF%95/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://fengshana.github.io/2020/04/20/%E9%9D%A2%E8%AF%95/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-04-19T21:51:43.005Z</published>
    <updated>2020-04-22T00:41:35.015Z</updated>
    
    <content type="html"><![CDATA[<p>希望这句话不只是送给我，也送给那些跟我当时心境一样的人。  </p><p>就像妈妈每次给我打电话的结尾是：要天天开开心心的。保持好心情。  </p><p>一样。  </p><p>观看笔记： <a href="https://www.bilibili.com/video/BV1Q4411y7ip?from=search&amp;seid=11158504841670855744" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Q4411y7ip?from=search&amp;seid=11158504841670855744</a>  </p><p>相关的笔记截图放在QQ号为：198866436的空间相册当中了；  </p><p>视频可以选择2x倍速观看；不知道为什么它的那个原本的速度我感觉好像放慢了一样，放到2x速度的时候感觉才像是刚刚好；  </p><h2 id="技术专题：分布式事务专题"><a href="#技术专题：分布式事务专题" class="headerlink" title="技术专题：分布式事务专题"></a>技术专题：分布式事务专题</h2><ol><li>基础概念</li></ol><ul><li>什么是事务</li><li>本地事务</li><li>分布式事务</li><li>分布式事务产生的场景</li></ul><ol start="2"><li>分布式事务基础理论</li></ol><ul><li>CAP理论<ul><li>理解CAP</li><li>CAP组合方式</li><li>总结</li></ul></li><li>BASE理论</li></ul><ol start="3"><li>分布式事务解决方案之2PC（两阶段提交）</li></ol><ul><li>什么是2PC</li><li>解决方案<ul><li>传统2PC</li><li>Seata实现2PC</li></ul></li><li>Seata实现2PC事务（seata阿里开源框架）<ul><li>业务说明</li><li>程序组成部分</li><li>创建数据库</li><li>启动TC（事务协调器）</li><li>discover-server</li><li>导入dtx-seata-demo</li><li>dtx-seata-demo-bank1</li><li>dtx-seata-demo-bank2</li><li>测试场景</li><li>原理分析</li></ul></li><li>小结</li></ul><ol start="4"><li>分布式事务解决方案之TCC</li></ol><ul><li>什么是TCC事务</li><li>解决方案</li><li>Hmily实现TCC事务（Hmily轻量级框架）<ul><li>业务说明</li><li>程序组成部分</li><li>创建数据库</li><li>discover-server</li><li>导入dtx-tcc-demo</li><li>dtx-tcc-demo-bank1</li><li>dtx-tcc-demo-bank2</li><li>测试场景</li></ul></li><li>小结</li></ul><ol start="5"><li>分布式事务解决方案之可靠消息最终一致性</li></ol><ul><li>什么是可靠消息最终一致性事务</li><li>解决方案<ul><li>本地消息表方案</li><li>RocketMQ事务消息方案</li></ul></li><li>RocketMQ实现可靠消息最终一致性事务（RocketMQ阿里开源的消息队列）<ul><li>业务说明</li><li>程序组成部分</li><li>创建数据库</li><li>启动RocketMQ</li><li>discover-server</li><li>导入dtx-txmsg-demo</li><li>dtx-txmsg-demo-bank1</li><li>dtx-txmsg-demo-bank2</li><li>测试场景</li></ul></li><li>小结</li></ul><ol start="6"><li>分布式事务解决方案之最大努力通知</li></ol><ul><li>什么是最大努力通知</li><li>解决方案</li><li>RocketMQ实现最大努力通知型事务<ul><li>业务说明</li><li>程序组成部分</li><li>创建数据库</li><li>启动RocketMQ</li><li>导入dtx-notifymsg-demo</li><li>dtx-notifydemo-pay</li><li>dtx-notifydemo-bank1</li><li>测试场景</li></ul></li><li>小结</li></ul><ol start="7"><li>分布式事务综合案例</li></ol><ul><li>系统介绍<ul><li>P2P介绍</li><li>总体业务流程</li><li>业务术语</li><li>模块说明</li></ul></li><li>注册账号案例分析<ul><li>业务流程</li><li>解决方案分析</li></ul></li><li>存管开户<ul><li>业务流程</li><li>解决方案分析</li></ul></li><li>满标审核<ul><li>业务流程</li><li>解决方案分析</li></ul></li></ul><ol start="8"><li>课程总结</li></ol><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>什么是事务？<br>举个生活中的例子：你去小卖铺买东西，“一手交钱，一手交货”就是一个事务的例子，交钱和交货必须全部成功，事务才算成功，任何一个活动失败，事务将撤销所有已成功的活动；  </p><p>明白上述例子，再来看事务的定义：  </p><blockquote><p>事务可以看做是一次大的活动，它由不同的小活动组成，这些小活动要么全部成功，要么全部失败；  </p></blockquote><h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>在计算机系统中，更多的是通过关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫做数据库事务；  </p><p>由于应用主要靠数据库来控制事务，而数据库通常和应用在同一个服务器，所以基于关系型数据库的事务又称为本地事务；  </p><p>回顾一下数据库事务的四大特性ACID：  </p><ul><li>A（Atomic）：  <ul><li>原子性；</li><li>构成事物的所有操作，要么都执行完成，要么全部不执行；</li><li>不可能出现部分成功部分失败的情况。  </li></ul></li><li>C（Consistency）：  <ul><li>一致性；</li><li>在事务执行前后，数据库的一致性约束没有被破坏。</li><li>比如：张三向李四转100元，转账前和转账后的数据是正确的状态这就叫做一致性；如果出现张三转出100元，李四账户没有增加100元这就出现了数据错误，就没有达到一致性。</li></ul></li><li>I（Isolation）：  <ul><li>隔离性；</li><li>数据库中的事务一般都是并发的；</li><li>隔离性是指并发的两个事务的执行互不干扰；</li><li>一个事务不能看到其他事务运行过程的中间状态。  </li><li>通过配置事务隔离级别可以避免脏读、重复读等问题。</li></ul></li><li>D（Durability）：  <ul><li>持久性；</li><li>事务完成之后，该事务对数据的更改会被持久化到数据库，且不会被回滚。  </li></ul></li></ul><p>数据库事务在实现时，会将一次事务涉及的所有操作全部纳入到一个不可分割的执行单元，该执行单元中的所有操作要么都成功，要么都失败，只要其中任一操作执行失败，都将导致整个事务的回滚。  </p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>随着互联网的快速发展，软件系统由原来的单体应用转变为分布式应用。  </p><p>下图描述了单体应用向微服务的演变：  </p><p>分布式系统会把一个应用系统拆分为可独立部署的多个服务。  </p><p>因此需要服务与服务之间远程协作才能完成事务操作。  </p><p>这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为【分布式事务】。  </p><p>例如用户注册送积分事务、创建订单减库存事务、银行转账事务等都是分布式事务。  </p><p>用户服务当中要增加用户/积分服务当中要增加积分；<br>我突然想起来了，其实信666这个项目当中增加用户还有一个充值90的一个操作，其实也应该是一个事务；当时增加用户后我是直接发送了一个队列进行充值90元；通过这个mq发送消息队列，这个不也是属于远程协作吗？加入我在进行操作增加增加账户的时候进行发送了队列这个时候如果增加账户出事情了那么势必就需要分布式事务了；倘若我当时好像处理的是当用户账户增加成功了之后然后再去发送的队列呢？这个时候就应该不会出现了吧？哦哦，不对，倘若我消息队列当中的业务逻辑处理增加90元的这个操作失败了呢？那么这个时候增加账户的这个业务操作就应该需要进行回滚？这两个操作构成一个事务（原子性），且需要达到一致性，即账户增加需要成功，充值也需要成功；  </p><p>订单服务中需要加订单/库存服务当中需要减少库存；  </p><p>本地事务依赖数据库依赖数据库本身提供的事务特性来实现，因此以下逻辑可以控制本地事务：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> <span class="keyword">transaction</span>;</span><br><span class="line">      //1. 本地数据库操作：张三减少金额</span><br><span class="line">      //2. 本地数据库操作：李四增加金额</span><br><span class="line"><span class="keyword">commit</span> <span class="keyword">transaction</span>;</span><br></pre></td></tr></table></figure><p>但是在分布式环境下，会变成这样：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> <span class="keyword">transaction</span>;</span><br><span class="line">      //1. 本地数据库操作：张三减少金额</span><br><span class="line">      //2. 远程调用：让李四增加金额</span><br><span class="line"><span class="keyword">commit</span> <span class="keyword">transaction</span>;</span><br></pre></td></tr></table></figure><p>可以设想，当远程调用让李四增加金额成功了，由于网络问题远程调用并没有返回，此时本地事务提交事务就回滚了张三减少金额的操作，此时张三和李四的数据就不一致了。  </p><p>因此在分布式架构的基础上，传统数据库事务就无法使用了。  </p><p>张三和李四的账户不在一个数据库中甚至不在一个应用系统里，实现转账事务需要通过远程调用，由于网络问题就会导致分布式事务问题。  </p><p>三种事务异常情况：<br>（1）本地数据库操作：张三减少金额失败了；那么远程调用：让李四增加金额也需要失败；<br>（2）远程调用：让李四增加金额失败了；那么本地数据库操作：让张三减少金额也需要失败；<br>（3）本地数据库操作以及远程调用都成功了；但是远程调用由于网络问题，没有及时返回相应的结果，事务的时间超时了，那么这个时候会造成异常，也就是本地数据库操作就会发生回滚；而远程调用已经成功了；则事务不一致了此时；  </p><p>所以说分布式事务去使用本地事务的思想解决是行不通的；  </p><h3 id="分布式事务产生的场景"><a href="#分布式事务产生的场景" class="headerlink" title="分布式事务产生的场景"></a>分布式事务产生的场景</h3><ol><li>典型的场景就是微服务架构</li></ol><p>微服务之间通过远程调用完成事务操作。  </p><p>比如：订单微服务和库存微服务，下单的同时订单微服务请求库存微服务减少库存。  </p><p>简言之: 跨JVM进程产生分布式事务。  </p><ol start="2"><li>单体系统访问多个数据库实例</li></ol><p>当单体系统需要访问多个数据库（实例）时就会产生分布式事务；  </p><p>比如：用户信息和订单信息分别在两个MySQL实例存储，用户管理系统删除用户信息，需要分别删除用户信息及用户的订单信息，由于数据分布在不同的数据实例，需要通过不同的数据库链接去操作数据，此时产生分布式事务。  </p><p>简言之：跨数据库实例产生分布式事务。  </p><ol start="3"><li>多服务访问同一个数据库实例</li></ol><p>比如：订单微服务和库存微服务即使访问同一个数据库也会产生分布式事务，原因就是跨JVM进程，两个微服务持有了不同的数据库链接进行数据库操作，此时产生分布式事务。  </p><h2 id="分布式事务基础理论"><a href="#分布式事务基础理论" class="headerlink" title="分布式事务基础理论"></a>分布式事务基础理论</h2><p>通过前面的学习，了解到了分布式事务的基础概念。  </p><p>与本地事务不同的是，分布式系统之所以叫做分布式，是因为提供服务的各个节点分步在不同的机器上，相互之间通过网络交互，不能因为有一点网络问题就导致整个系统无法提供服务，网络因素成为了分布式事务的考量标准之一。  </p><p>因此，分布式事务需要更进一步的理论支持，接下来，学习一下分布式事务的CAP理论。  </p><p>在安静街分布式事务控制解决方案之前需要先学习一些基础理论，通过理论知识指导确定分布式事务控制的目标，从而帮助理解每个解决方案。  </p><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>进行分布式事务控制，需要控制到什么程度：  </p><p>（1）出现了网络问题之后，数据不一致；  </p><p>（2）出现了网络问题后，某一个服务不可用；  </p><h4 id="理解CAP"><a href="#理解CAP" class="headerlink" title="理解CAP"></a>理解CAP</h4><p>CAP是Consistency、Availability、Partition tolerance三个词语的缩写，分别表示一致性、可用性、分区容忍性。  </p><p>下边分别来解释：  </p><p>  为了方便对CAP理论的理解，结合电商系统中的一些业务场景来理解CAP。  </p><p>  如下图，是商品信息管理的执行流程：  </p><p>整体执行流程如下：  </p><ol><li>商品服务请求主数据库写入商品信息（添加商品、修改商品、删除商品）</li><li>主数据库向商品服务响应写入成功</li><li>商品服务请求从数据库读取商品信息</li></ol><p>数据库读写分离好处：分担数据库的压力；  </p><p>主数据库只管提供写入操作，从数据库只管提供查询操作；  </p><blockquote><p>C - Consistency</p></blockquote><p>一致性是指写入操作的读操作可以读取到最新的数据状态，当数据分步到多个结点上，从任意节点读取到的数据都是最新的状态。  </p><p>上图中，商品信息的读写要满足一致性就是要实现如下目标：  </p><p>（1）商品服务写入主数据库成功，则向从数据库查询新数据也成功；<br>（2）商品服务写入主数据库失败，则向从数据库查询新数据也失败；  </p><p>如何实现一致性？（此时的一致性则指的是主从数据库的数据一致性）  </p><p>（1）写入主数据库后要将数据同步到从数据库；<br>（2）写入主数据库后，在向从数据库同步期间要将数据库锁定，待同步完成后再释放锁，以免在新数据写入成功后，向从数据库查询到旧的数据。  </p><p>同步的方式：<br>（1）主从复制；  </p><p>分布式系统一致性的特定：  </p><p>（1）由于存在数据同步的过程，写操作的响应会有一定的延迟；<br>（2）为了保证数据一致性会对资源暂时锁定，待数据同步完成释放锁定资源。<br>（3）如果请求数据同步失败的结点则会返回错误信息，一定不会返回旧数据。  </p><blockquote><p>A - Availability</p></blockquote><p>可用性是指任何事物操作都可以得到响应结果，且不会出现响应超时或者响应错误。  </p><p>上图中，商品信息读取满足可用性就要实现如下目标：  </p><p>（1）从数据库接收到数据查询的请求则立即能够响应数据查询结果；<br>（2）从数据库不允许出现响应超时或者响应错误。<br>（3）即使数据还没有同步过来，从数据库也要返回查询的数据，哪怕是旧数据，如果连就数据库也没有则可以按照约定返回一个默认信息，但不能返回错误或者响应超时。  </p><p>分布式可用性的特定：  </p><p>（1）所有请求都有响应，且不会出现响应超时或者响应错误。  </p><blockquote><p>P - Partition tolerance</p></blockquote><p>通常分布式系统的各个结点部署在不同的子网，这就是网络分区。  </p><p>不可避免的会出现由于网络问题而导致结点之间的通信失败，此时仍然可以对外提供服务，这就叫分区容忍性。  </p><p>上图中，商品信息读写满足分区容忍性就是要实现如下目标：  </p><p>（1）主数据库向从数据库同步数据失败不影响读写操作。<br>（2）其中一个结点挂掉不影响另一个节点对外提供服务。  </p><p>如何实现分区容忍性？  </p><p>（1）尽量使用异步取代同步操作，例如使用异步方式将数据从主数据库同步到从数据，这样结点之间才能有效的实现松耦合。<br>（2）添加从数据库结点，其中一个结点挂掉其他从结点提供服务。  </p><p>分布式分区容忍的特点：  </p><p>（1）分区容忍性是分布式系统具备的基本能力。  </p><h4 id="CAP组合方式"><a href="#CAP组合方式" class="headerlink" title="CAP组合方式"></a>CAP组合方式</h4><ol><li>上边商品管理的例子是否同时具备CAP呢？  </li></ol><p><strong>在所有分布式事务场景中不会同时具备CAP三个特性，因为在具备了P的的前提下C和A是不能共存的。</strong>  </p><p>比如：  </p><p>下图满足了P即表示分区容忍：  </p><p>本图分区容忍的含义是：  </p><p>（1）主数据库通过网络向从数据库同步数据，可以认为主从数据库部署在不同的分区，通过网络进行交互;<br>（2）当主数据库和从数据库之间的网络出现问题不影响主数据和从数据库对外提供服务。<br>（3）其中一个结点挂掉不影响另一节点对外提供服务。  </p><p>如果要实现C则必须保证数据一致性，在数据同步的时候为防止向从数据库查询不一致的数据则需要从数据库数据锁定，待同步完成之后解锁，如果同步失败从数据库要返回错误信息或超时信息。  </p><p>如果要实现A则必须保证数据可用性，不管任何时候都可以向从数据库查询数据，则不会响应超时或者返回错误信息。  </p><p>通过分析发现在满足P的前提下C和A存在矛盾性。  </p><ol start="2"><li>CAP有哪些组合方式呢？</li></ol><p>所以在生产中对分布式事务处理时要根据需求来确定满足CAP的哪两个方面。  </p><p>（1）AP：  </p><p>放弃一致性，追求分区容忍性和可用性。<br>这是很多分布式系统设计时的选择。  </p><p>例如：<br>上边的商品管理，完全可以实现AP，前提是只要用户可以接受所查询到的数据在一定时间内不是最新的即可。  </p><p>通常实现AP都会保证最终一致性，后面讲的BASE理论就是根据AP来实现的，一些业务场景，比如：订单退款、今日退款成功，明日账户到账，只要用户可以接受在一定时间内到账即可。  </p><p>我突然想到一个问题；就是现在深圳通或者是乘车码有个时候会出现延迟扣费的一个情况。是不是也是额，放弃数据一致性而追求可用性和分区容忍性？深圳通和乘车码肯定是一个分布式的一个系统架构，我觉得，因为这个使用的这个人群数量很高，且每一个人进行的交易也就是乘车的这个次数的交易量也很大，好了不说这个了。也就是说，它会有一个温馨提示：因扫码设备网络不稳定等原因，该笔乘车扣款有延迟。的这样一个信息。当没有及时进行扣款遵循可用性的原则应该是返回了一个默认或者是双方规定好的一个原则，没有去响应超时或者是这个响应错误信息，而是没有提示什么东西；然后事后去保证最终一致性，也就是进行了延迟扣款。我猜的。  </p><p>（2）CP：  </p><p>放弃可用性，追求一致性和分区容错性，zookeeper其实就是追求的强一致性，又比如说跨行转账，一次转账请求要求等待双方银行都完成整个事务才算完成。  </p><p>对对对，我之前我想的也是这个分区容忍性和容错好像啊。  </p><p>（3）CA：  </p><p>放弃分区容忍性，即不进行分区，不考虑由于网络不同或者结点挂掉的情况，则可以实现一致性和可用性，那么系统将不是一个标准的分布式系统，最常用的关系型数据库就满足了CA。  </p><p>上边的商品管理，如果要实现CA则架构如下：  </p><p>主数据库和从数据库中间不再进行数据同步，数据库可以响应每次的查询请求，通过事务隔离级别实现每个查询请求都可以返回最新的数据。  </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过上面已经学习了CAP理论的相关知识，CAP是一个已经被证实的理论：  </p><p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三项中的两项。  </p><p>它可以作为进行架构设计、技术选型的考量标准。  </p><p>对于多数大型互联网应用的场景，结点众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9（99.99…%），并且要达到良好的响应性能来提高用户体验，因此一般都会做出如下选择：保证P和A，舍弃C强一致，保证最终一致性。  </p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><ol><li>理解强一致性（CA、CP）和最终一致性（AP）</li></ol><p>CAP理论告诉我们一个分布式系统做多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三项中的两项。  </p><p>其中AP在实际应用中较多，AP即舍弃一致性，保证可用性和分区容忍性。  </p><p>但是在实际生产中很多场景都要实现一致性，比如前面举的例子，主数据库向从数据库同步数据，即使不要一致性，但是最终也要将数据库同步成功来保证数据一致，这种一致性和CAP中的一致性不同：<br>（1）CAP中的一致性要求在任何时间查询每个节点数据都必须一致，它强调的是强一致性；<br>（2）但是最终一致性是允许在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。  </p><ol start="2"><li>BASE理论介绍</li></ol><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。  </p><p>BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。  </p><p>满足BASE理论的事务，称之为“<strong>柔性事务</strong>”。  </p><ul><li>基本可用（Basically Available）：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如，电商网站交易付款时出现问题了，商品依然可以正常浏览。  </li><li>软状态（Soft state）：由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用性，如订单的“支付中”、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。  </li><li>最终一致性（Eventually consistent）：最终一致是指经过一段时间后，所有结点数据都将会达到一致，如订单的“支付中”状态，最终会变为“支付成功”或者“支付失败”，使订单状态与实际交易结果达成一致，但是需要一定时间的延迟、等待。  </li></ul><h2 id="分布式事务解决方案之2PC（两阶段提交）"><a href="#分布式事务解决方案之2PC（两阶段提交）" class="headerlink" title="分布式事务解决方案之2PC（两阶段提交）"></a>分布式事务解决方案之2PC（两阶段提交）</h2><p>前面已经学习了分布式事务的基础理论，以理论为基础，针对不同的分布式场景业界常见的解决方案有2PC、TCC、可靠消息最终一致性、最大努力通知这几种。  </p><h3 id="什么是2PC"><a href="#什么是2PC" class="headerlink" title="什么是2PC"></a>什么是2PC</h3><p>2PC即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase），2是指两个阶段，P是指准备阶段，C是指提交阶段。  </p><p>举例： 张三和李四好久不见，老友约起聚餐，饭店老板要求先买单，才能出票。  </p><p>这时张三和李四分别抱怨近况不如意，囊中羞涩，都不愿意请客，这时只能AA。  </p><p>只有张三和李四都付款，老板才能出票安排就餐。  </p><p>但是由于张三和李四都是铁公鸡，形成了尴尬的一幕：  </p><p>准备阶段：老板要求张三付款，张三付款。老板要求李四付款，李四付款。  </p><p>提交阶段：老板出票，两人拿票纷纷落座就餐。  </p><p>例子中形成了一个事务，若张三或者李四其中一个人拒绝付款，或者钱不够，店家老板都不会给出票，并且会把已收款退回。  </p><p>整个失误过程由事务管理器和参与者完成，店家老板就是事务管理器，张三、李四就是事务参与者，事务管理器负责决策整个分布式事务的提交和回滚，事务参与者负责自己本地事务的提交和回滚。  </p><p>在计算机中部分关系数据库如Oracle、MySQL支持两阶段提交协议，如下图：  </p><p>（1）准备阶段（Prepare phase）：事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有提交。  </p><p>（Undo日志是记录修改前的数据，用于数据库回滚；Redo日志是记录修改后的数据，用于提交事务后写入数据库文件）  </p><p>（2）提交阶段（Commit phase）：如果事务管理器受到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意：必须在最后阶段释放锁资源。  </p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="XA方案"><a href="#XA方案" class="headerlink" title="XA方案"></a>XA方案</h4><p>2PC的传统方案是在数据库层面实现的。  </p><p>如Oracle、MySQL都支持2PC协议，为了统一标准减少行业内不比要的对接成本，需要制定标准化的处理模型以及接口标准，国际开发标准组织Open Group定义了分布式事务处理模型DTP（Distributed Transaction Processing Reference Model）。  </p><p>这套模型就是为了规范数据库支持2PC协议的整个实现的过程。  </p><p>为了更明确XA方案的内容，下面<strong>新用户注册送积分</strong>为例来说明：  </p><p>执行流程如下：  </p><p>（1）应用程序（AP）持有用户库和积分库两个数据源。<br>（2）准备阶段：应用程序（AP）通过TM通知用户库RM（Resource Manager）新增用户，同时通知积分库RM为该用户新增积分，RM此时并未提交事务，此时用户和积分资源锁定。<br>（3）TM（事务管理器Transaction Manager）收到执行回复，只要有一方失败则分别向其他RM发起回滚事务，回滚完毕，资源锁释放。<br>（4）TM收到执行回复，全部成功，此时向所有RM发起提交事务，提交完毕，资源锁释放。  </p><p>DTP模型定义如下角色：  </p><ul><li><strong>AP</strong>（Application Program）：即应用程序，可以理解为使用DTP分布式事务的程序。  </li><li><strong>RM</strong>（Resource Manager）：即资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过资源管理器对该数据库进行控制，资源管理器控制着分支事务。  </li><li><strong>TM</strong>（Transaction Manager）：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个RM。<strong>全局事务</strong>是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个全局事务。  </li><li>DTP模型定义TM和RM之间通讯的接口规范叫<strong>XA</strong>，简单理解为数据库提供的2PC接口协议，<strong>基于数据库的XA协议来实现2PC又称为XA方案</strong>。</li><li>以上三个角色之间的交互方式如下：<br>（1）TM向AP提供应用程序编程接口，AP通过TM提交以及回滚事务。<br>（2）TM消息中间件通过XA接口来通知RM数据库事务的开始、结束以及提交、回滚等。  </li></ul><p>总结：  </p><p>整个2PC的事务流程涉及到三个流程AP、RM、TM。<br>AP指的是2PC分布式事务的应用程序；<br>RM指的是资源管理器；它控制着分支事务；<br>TM指的是事务管理器，它控制着整个全局事务；  </p><p>（1）在<strong>准备阶段</strong>RM执行实际的业务操作，但是不提交事务，自愿锁定；<br>（2）在<strong>提交阶段</strong>TM会接受RM在准备阶段的执行回复，只要有任意一个RM执行失败，TM会通知所有RM执行回滚操作；否则，TM将会通知所有的RM提交该事务，提交阶段结束资源释放锁；  </p><p>XA方案的问题：<br>（1）需要本地数据库支持XA协议。<br>（2）资源锁需要等到两个阶段结束才释放，性能较差。  </p><h4 id="Seata方案"><a href="#Seata方案" class="headerlink" title="Seata方案"></a>Seata方案</h4><p>Seata是由阿里中间件团队发起的开源项目Fescar，后更名为Seata，它是一个开源的分布式事务框架。  </p><p>传统2PC的问题在Seata中得到了解决，它通过对本地关系数据库的分支事务的协调来驱动完成全局事务，是工作在应用层的中间件。  </p><p>（Seata不要求关系数据库是否遵从2PC协议）  </p><p>主要优点是性能较好，且不长时间占用连接资源，它以高效并且对业务零侵入的方式解决微服务场景下面临的分布式事务问题，他目前提供AT模式（即2PC）以及TCC模式的分布式事务解决方案。  </p><p><strong>Seata的设计思想如下：</strong>  </p><p>Seata的设计目标其一是对业务目标无侵入，因此从业务无侵入的2PC方案着手，在<strong>传统2PC</strong>的基础上演进，并解决2PC方案面临的问题。  </p><p>Seata把一个分布式事务理解成一个包含了若干<strong>分支事务</strong>的<strong>全局事务</strong>。  </p><p>全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功，要么一起失败回滚。  </p><p>此外，通常分支事务本身就是一个关系数据库的本地事务，下图是全局事务与分支事务的关系图：  </p><p>与传统的2PC的模型类似，Seata定义了3个组件来协议分布式事务的处理过程：  </p><ul><li>Transaction Coordinator（TC）：事务协调器，它是独立的中间件，需要独立部署运行，它维护全局事务的运行状态，接受TM指令发起全局事务的提交与回滚，负责与RM通信协调各个分支事务的提交或者回滚。  </li><li>Transaction Manager（TM）：事务管理器，TM需要嵌入应用程序中工作，它负责开启一个全局事务，并最终向TC发起全局提交护着全局回滚的指令。  </li><li>Resource Manager（RM）：控制分支事务，负责分支注册、状态汇报，并接收事务协调器TC的指令，驱动分支（本地）事务的提交和回滚。  </li></ul><p>还拿<strong>新用户注册送积分</strong>举例Seata的分布式事务过程：  </p><p>具体的执行流程如下：  </p><p>（1）用户服务的TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID；<br>（2）用户服务的RM向TC注册分支事务，该分支事务在用户服务执行新增用户逻辑（该事务提交，即第一个阶段当中就提交了事务），并将其纳入XID对应全局事务的管辖。<br>（3）用户服务执行分支事务，向用户表插入一条记录。<br>（4）逻辑执行到远程调用 积分服务 时（XID在微服务调用链路的上下文中传播）。积分服务的RM向TC注册分支事务，该分支事务执行增加积分的逻辑，并将其纳入到XID对应全局事务的管辖。<br>（5）积分服务执行分支事务，向积分记录表插入一条记录，执行完毕后（完成分支事务，即已经提交分支事务，释放锁），返回用户服务。（如当其他的分支事务后期没有成功，导致需要回滚，即将向积分记录表当中插入的该条记录进行删除即可）<br>（6）用户服务分支事务执行完毕。<br>（7）TM向TC发起针对XID的全局提交或者回滚决议。<br>（8）TC调度XID下管辖的全部分支事务完成提交或者回滚请求。  </p><p><strong>Seata实现2PC与传统2PC的差别：</strong>  </p><p>架构层次方面，<strong>传统2PC</strong> 方案的RM实际上就是在数据库底层，RM本质上就是数据库自身，通过XA协议实现，而Seata的RM是以jar包的形式作为中间件层部署在应用程序这一侧的。  </p><p>两阶段提交方面，<strong>传统2PC</strong> 无论第二阶段的决议是commit还是rollback，事务性资源的锁都要保持到Phase2完成才释放。  </p><p>而Seata的做法是在Phase1就将本地事务提交，这样就可以省去Phase2持锁的时间，整体提高效率。  </p><h3 id="Seata实现2PC事务"><a href="#Seata实现2PC事务" class="headerlink" title="Seata实现2PC事务"></a>Seata实现2PC事务</h3><h4 id="业务说明"><a href="#业务说明" class="headerlink" title="业务说明"></a>业务说明</h4><p>本示例通过Seata中间件实现分布式事务，模拟三个账户的转账交易过程。  </p><p>两个账户在两个个不同的银行（张三在bank1、李四在bank2），bank1和bank2是两个微服务。  </p><p>交易过程是：张三给李四转账指定金额。  </p><p>上述交易步骤，要么一起成功，要么一起失败，必须是一个整体性的事务。  </p><h4 id="本示例程序组成部分如下"><a href="#本示例程序组成部分如下" class="headerlink" title="本示例程序组成部分如下"></a>本示例程序组成部分如下</h4><p>数据库：MySQL-5.7.25（包括bank1和bank2两个数据库）<br>JDK：64位jdk1.8.0_201<br>微服务框架：spring-boot-2.1.3、spring-cloud-Greenwich.RELEASE<br>seata客户端（RM、TM）：spring-cloud-alibaba-seata-2.1.0.RELEASE<br>seata服务端（TC）：seata-server-0.7.1<br>微服务以及数据库的关系：<br>  dtx/dtx-seata-demo/seata-demo-bank1 银行1，操作张三账户，连接数据库1<br>  dtx/dtx-seata-demo/seata-demo-bank2 银行2，操作李四账户，连接数据库2<br>服务注册中心：dtx/discover-server  </p><p>本示例程序技术架构如下：  </p><p>交互流程如下:  </p><ol><li>请求bank1进行转账，传入转账金额。  </li><li>bank1减少转账金额，调用bank2，传入转账金额。  </li></ol><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><h4 id="启动TC事务协调器"><a href="#启动TC事务协调器" class="headerlink" title="启动TC事务协调器"></a>启动TC事务协调器</h4><p>（1）下载Seata服务器<br>（2）解压并启动  </p><p>运行模式（file，nacos，eureka，redis，zk，consul，etcd3，sofa；file模式，因为TC，Seata-server是事务协调器，记录各个分支事务的执行情况，所以数据以文本的方式写到了文件/本地的一个目录当中，还有数据库的方式就将写到数据库当中还支持其他方式）  </p><h4 id="discover-server"><a href="#discover-server" class="headerlink" title="discover-server"></a>discover-server</h4><h4 id="导入案例工程dtx-seata-demo"><a href="#导入案例工程dtx-seata-demo" class="headerlink" title="导入案例工程dtx-seata-demo"></a>导入案例工程dtx-seata-demo</h4><h4 id="启动TC事务协调器-1"><a href="#启动TC事务协调器-1" class="headerlink" title="启动TC事务协调器"></a>启动TC事务协调器</h4><h4 id="Seata执行流程"><a href="#Seata执行流程" class="headerlink" title="Seata执行流程"></a>Seata执行流程</h4><ol><li><p>正常提交流程  </p></li><li><p>回滚流程</p></li></ol><p>要点说明：  </p><ol><li>每个RM使用DataSourceProxy连接数据库，其目的是使用ConnectionProxy，使用数据源和数据连接代理的目的就是在第一阶段将undo_log和业务数据放在一个本地事务提交，这样就保存了只要有业务操作就一定有undo_log。  </li><li>在第一阶段undo_log中存放了数据修改前和修改后的数据，为事务回滚做好准备，所以第一阶段完成就已经将分支事务提交，也就释放了锁资源。  </li><li>TM开启全局事务开始，将XID全局事务id放在事务上下文中，通过feign调用也将XID传入下游分支事务，每个分支事务将自己的Branch ID分支事务与XID关联。</li><li>第二阶段全局事务提交，TC会通知各个分支参与者提交分支事务，在第一阶段就已经提交了分支事务，这里各个参与者只需要删除undo_log即可，并且可以异步执行，第二阶段很快就可以完成。</li><li>第二阶段全局事务回滚，TC会通知各个分之参与者回滚事务，通过XID与Branch ID找到相应的回滚日志，通过回滚日志生成反向的SQL并执行，以完成分支事务回滚到之前的状态，如果回滚失败则会重试回滚操作。</li></ol><h4 id="dtx-seata-demo-bank1"><a href="#dtx-seata-demo-bank1" class="headerlink" title="dtx-seata-demo-bank1"></a>dtx-seata-demo-bank1</h4><p>为什么要有注册中心；因为张三要调用李四的微服务，要进行转账，所以让微服务都注册到注册中心；实现远程的调用；这个注册中心用的是spring-cloud的seata；  </p><h4 id="dtx-seata-demo-bank2"><a href="#dtx-seata-demo-bank2" class="headerlink" title="dtx-seata-demo-bank2"></a>dtx-seata-demo-bank2</h4><h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h4><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本节讲解了传统2PC（基于数据库XA协议）和Seata实现2PC的两种2PC方案，由于Seata的零侵入并解决了传统2PC长期锁资源的问题，所以推荐采用Seata实现2PC。  </p><p>Seata实现2PC要点：  </p><ol><li>全局事务开始使用@GolobalTransaction标识；</li><li>每个本地事务方案仍然使用@Transactional标识；</li><li>每个数据都需要创建undo_log表，此表是Seata保证本地事务一致性的关键；  </li></ol><h2 id="分布式事务解决方案之TCC"><a href="#分布式事务解决方案之TCC" class="headerlink" title="分布式事务解决方案之TCC"></a>分布式事务解决方案之TCC</h2><h3 id="什么是TCC事务"><a href="#什么是TCC事务" class="headerlink" title="什么是TCC事务"></a>什么是TCC事务</h3><p>2PC：两阶段提交协议（一个是准备阶段一个是提交阶段）；有两种处理方式（一种是XA方案一种是阿里的Seata方案）；协议本身是一致的也就是都存在两个阶段；  </p><p>2PC和TCC都是用来执行控制分布式事务的；  </p><p>TCC是Try、Confirm、Cancel三个词语的缩写；  </p><p>TCC要求每个分支事务实现三个操作：预处理Try、确认Confirm、撤销Cancel。  </p><p>Try操作做业务检查以及资源预留，Confirm做业务确认操作，Cancel实现一个与Try相反的操作即回滚操作。  </p><p>TM首先发起所有的分支事务的Try操作，任何一个事务的Try操作执行失败，TM将会发起所有分支事务的Cancel操作；若Try操作全部成功，TM将会发起所有分支事务的Confirm操作，其中Confirm/Cancel操作若执行失败，TM会进行重试。  </p><p>TCC分为三个阶段：  </p><ol><li><strong>Try</strong>阶段是做业务检查（一致性）以及资源预留（隔离），此阶段仅是一个初步操作，它和后续的Confirm一起才能真正构成一个完整的业务逻辑。  </li><li><strong>Confirm</strong>阶段是做确认提交，Try阶段所有分支事务执行成功后开始执行Confirm。通常情况下，采用TCC则认为Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。若Confirm阶段真的出错了，需要引入重试机制或者人工处理。  </li><li><strong>Cancel</strong>阶段是在业务执行错误需要回滚的状态下执行分支事务的业务徐晓，预留资源释放。通常情况下，采用TCC则认为Cancel阶段也是一定成功的。若Cancel阶段真的出错了，需要引入重试机制或者人工处理。  </li><li>TM事务管理器  </li></ol><p>TM事务管理器可以实现独立的服务，也可以让<strong>全局事务发起方</strong>充当TM的角色，TM独立出来是为了成为公用组件，是为了考虑系统结构和软件复用。  </p><p>TM在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条。用来记录事务上下文，追踪和记录状态，由于Confirm和Cancel失败需要进行重试，因此需要实现为幂等，幂等性是指同一个操作无论请求多少次，其结果都相同。  </p><h3 id="TCC解决方案"><a href="#TCC解决方案" class="headerlink" title="TCC解决方案"></a>TCC解决方案</h3><p>转账是一种业务，注册送积分也是一种业务，抛开业务的话，其实TCC本身的技术协议是一致的，所以在市面上存在有很多的框架来处理TCC的事务。  </p><p>目前市面上的TCC框架众多比如下面这几种：  </p><table>  <thead>    <tr>      <th>框架名称</th>      <th>GitHub地址</th>      <th>star数量</th>    </tr>  </thead>  <tbody>    <tr>      <td>tcc-transaction(类似Seata也需要单独进行部署相关的seata server)</td>      <td>https://xxxxx</td>      <td>xxxxx</td>    </tr>    <tr>      <td>Hmily</td>      <td>https://xxxxx</td>      <td>xxxxx</td>    </tr>    <tr>      <td>ByteTCC</td>      <td>https://xxxxx</td>      <td>xxxxx</td>    </tr>    <tr>      <td>EasyTransaction</td>      <td>https://xxxxx</td>      <td>xxxxx</td>    </tr>  </tbody></table><p>上一节所讲的Seata也支持TCC，但是Seata的TCC模式对于Spring Cloud并没有提供支持。<br>目标是理解TCC原理以及事务协调运作的过程，因此更倾向于轻量级易于理解的框架，因此最终确定了Hmily。  </p><p>Hmily是一个功性能分布式事务TCC开源框架。  </p><p>基于Java语言来开发（JDK1.8），支持Dubbo、Spring Cloud等RPC框架进行分布式事务。（且支持版本较新）  </p><p>它目前支持一下特性:  </p><ul><li>支持嵌套事务（Nested transaction support）；</li><li>采用disruptor框架进行事务日志的异步读写，与RPC框架的性能毫无差别；</li><li>支持SpringBoot-starter项目启动，使用简单；  </li><li>RPC框架支持：dubbo、motan、springcloud</li><li>本地事务存储支持：redis、mongodb、zookeeper、file、mysql；</li><li>采用Aspect Aop切面思想与Spring无缝集成，天然支持集群。  </li><li>RPC事务恢复，超时异常恢复等；</li></ul><p>Hmily利用AOP对参与分布式事务的本地方法与远程方法进行拦截处理，通过多方拦截，事务参与者能透明的调用到另一方的Try、Confirm、Cancel方法；传递事务上下文；并记录事务日志；酌情进行补偿，重试等；  </p><p>Hmily不需要事务协调服务，但需要提供一个数据库（mysql/mongodb/zookeeper/redis/file）来进行日志存储。  </p><p>Hmily实现的TCC服务于普通的服务一样，只需要暴露一个接口，也就是它的Try业务。<br>Confirm/Cancel业务逻辑，只是因为全局事务提交/回滚的需要才提供的，因此Confirm/Cancel业务只需要被HmilyTCC事务框架发现即可，不需要被调用它的其他业务服务所感知。  </p><p><strong>TCC需要注意三种异常处理分别是空回滚、幂等、悬挂；</strong>  </p><p><strong>空回滚：</strong>  </p><p>在没有调用TCC资源Try方法的情况下，调用了二阶段的Cancel方法，Cancel方法需要识别出这是一个空回滚，然后直接返回成功；  </p><p>出现原因是：当一个分支事务所在服务宕机或者是网络异常，分支事务调用记录为失败；这个时候其实是没有执行Try阶段，当故障恢复后，分布式事务进行回滚则会调用二阶段的Cancel方法，从而形成空回滚。  </p><p>解决思路是关键就是要识别出这个空回滚。  </p><p>思路很简单就是需要知道一阶段是否执行，如果执行了，那么就是正常回滚；如果没有执行，那么就是空回滚；  </p><p>前面已经说过:TM在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条。在额外增加一张分支事务记录表，其中有全局事务ID和分支事务ID，第一阶段Try方法里会插入一条记录，表示一阶段执行了。<br>Cancel接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。  </p><p><strong>幂等：</strong>  </p><p>通过前面的介绍已经了解到，为了保证TCC二阶段提交重试机制不会引发数据不一致，要求TCC阶段Try、Confirm、Cancel接口保证幂等，这样不会重复使用或者释放资源。  </p><p>如果幂等控制没有做好，很有可能导致数据不一致等严重问题；  </p><p>解决思路在上述“分支事务记录”中增加执行状态，每次执行前都查询该状态。  </p><p><strong>悬挂：</strong>  </p><p>悬挂就是对一个分布式事务，其二阶段Cancel接口比Try接口先执行。  </p><p>出现原因是在RPC调用分支事务Try时，先注册分支事务，再调用RPC调用；  </p><p>如果此时RPC调用的网络发生拥堵，通常RPC调用是有超时时间的，RPC超时以后，TM就会通知RM回滚该分布式事务，可能回滚完成后，RPC请求才到达参与者真正执行，而一个Try方法预留的业务资源，只有该分布式事务才能使用，该分布式事务第一阶段预留的业务资源就再也没有人能够处理了。对于这种情况，称之为悬挂。即业务资源预留后没有办法继续处理。  </p><p>解决思路时候如果二阶段执行完成，那一阶段就不能再继续执行。<br>在执行一阶段事务时判断在全局事务下，“分支事务记录”表中是否已经有二阶段事务记录，如果有则不执行Try；  </p><p><strong>举例，场景为A转账30元给B，A和B账户在不同的服务。</strong><br><strong>方案一：</strong><br>账户A  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    检查余额是否够<span class="number">30</span>元；</span><br><span class="line">    扣减<span class="number">30</span>元；</span><br><span class="line">confirm：</span><br><span class="line">    空；</span><br><span class="line">cancel：</span><br><span class="line">    增加<span class="number">30</span>元；</span><br></pre></td></tr></table></figure><p>账户B  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    增加<span class="number">30</span>元</span><br><span class="line">confirm：</span><br><span class="line">    空</span><br><span class="line">cancel：</span><br><span class="line">    减少<span class="number">30</span>元</span><br></pre></td></tr></table></figure><p><strong>方案1说明：</strong>  </p><p>（1）账户A，这里的余额就是所谓的业务资源，按照前面提到的原则：<br>在第一阶段需要检查并预留业务资源；<br>因此，在扣钱TCC资源的Try接口里先检查A账户余额是否足够，如果足够则扣除30元。<br>Confirm接口表示正式提交，由于业务资源已经在Try接口里扣除掉了，那么在第二阶段的Confirm接口里可以什么都不用做。<br>Cancel接口的执行表示整个事务的回滚，账户A回滚则需要把Try接口里扣除掉的30元还给账户A。<br>（2）账户B，在第一阶段Try接口里实现给账户B加钱；<br>Cancel接口的执行表示整个事务的回滚；<br>账户B回滚则需要把Try接口里加的30元再减去；  </p><p><strong>方案1的问题分析：</strong>  </p><p>（1）如果账户A的try没有执行；在Cancel则就多加了30元（需要空回滚判断）；<br>（2）由于Try、Confirm、Cancel都是由单独的线程去调用，且会出现重复调用，所以都需要实现幂等（幂等）；<br>（3）账户B在try中增加了30元，当Try执行完成后可能会被其他线程给消费了；<br>（4）如果账户B的Try没有执行在Cancel则就多减了30元（需要空回滚判断）；  </p><p><strong>问题解决：</strong>  </p><p>（1）账户A的Cancel方法需要判断Try方法是否执行，正常执行Try后方可执行Cancel；避免空回滚的发生；<br>（2）Try、Cancel、Confirm方法都需要进行实现幂等；<br>（3）账户B在Try中不允许更新账户金额，在Confirm中更新账户金额；以免提前新增的30元被其他的业务逻辑给消费掉；<br>（4）账户B的Cancel方法需要判断Try方法是否执行，正常执行Try后方可执行Cancel；  </p><p><strong>优化方案：</strong>  </p><p>账户A  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">try</span>幂等校验</span><br><span class="line">    <span class="keyword">try</span>悬挂处理（即Confirm/Cancel二阶段当中有一个执行了，那么Try阶段则不进行执行）</span><br><span class="line">    检查余额是否够<span class="number">30</span>元</span><br><span class="line">    扣减<span class="number">30</span>元</span><br><span class="line">confirm:</span><br><span class="line">    空</span><br><span class="line">cancel:</span><br><span class="line">    cancel幂等校验</span><br><span class="line">    cancel空回滚处理（如果Try没有执行，那么Cancel就不进行执行）</span><br><span class="line">    增加可用余额<span class="number">30</span>元</span><br></pre></td></tr></table></figure><p>账户B  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    空</span><br><span class="line"><span class="keyword">confirm</span>:</span><br><span class="line">    <span class="keyword">confirm</span>幂等校验</span><br><span class="line">    正式增加<span class="number">30</span>元</span><br><span class="line">cancel：</span><br><span class="line">    空</span><br></pre></td></tr></table></figure><h3 id="Hmily实现TCC事务"><a href="#Hmily实现TCC事务" class="headerlink" title="Hmily实现TCC事务"></a>Hmily实现TCC事务</h3><h4 id="业务说明-1"><a href="#业务说明-1" class="headerlink" title="业务说明"></a>业务说明</h4><p>本实例通过Hmily实现TCC分布式事务，模拟两个账户的转账交易过程。  </p><p>两个账户分别在不同的银行（张三在bank1、李四在bank2），bank1、bank2是两个微服务。<br>交易过程是：张三给李四转账指定金额；<br>上述交易步骤，要么一起成功，要么一起失败，必须是一个整体性的事务；  </p><h4 id="程序组成部分"><a href="#程序组成部分" class="headerlink" title="程序组成部分"></a>程序组成部分</h4><p>数据库：MySQL-5.7.25（包括bank1和bank2两个数据库）<br>JDK：64位jdk1.8.0_201<br>微服务框架：spring-boot-2.1.3、spring-cloud-Greenwich.RELEASE<br>Hmily：hmily-springcloud.2.0.4-RELEASE<br>seata客户端（RM、TM）：spring-cloud-alibaba-seata-2.1.0.RELEASE<br>seata服务端（TC）：seata-server-0.7.1<br>微服务以及数据库的关系：<br>  dtx/dtx-seata-demo/seata-demo-bank1 银行1，操作张三账户，连接数据库1<br>  dtx/dtx-seata-demo/seata-demo-bank2 银行2，操作李四账户，连接数据库2<br>服务注册中心：dtx/discover-server  </p><h4 id="创建数据库-1"><a href="#创建数据库-1" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>创建hmily数据库，用于存储hmily框架记录的数据；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="string">'hmily'</span> <span class="built_in">character</span> <span class="keyword">set</span> <span class="string">'utf8'</span> <span class="keyword">collate</span> <span class="string">'utf8_general_ci'</span>;</span><br></pre></td></tr></table></figure><h4 id="discover-server-1"><a href="#discover-server-1" class="headerlink" title="discover-server"></a>discover-server</h4><h4 id="导入案例工程dtx-tcc-demo"><a href="#导入案例工程dtx-tcc-demo" class="headerlink" title="导入案例工程dtx-tcc-demo"></a>导入案例工程dtx-tcc-demo</h4><h4 id="dtx-tcc-demo-bank1"><a href="#dtx-tcc-demo-bank1" class="headerlink" title="dtx-tcc-demo-bank1"></a>dtx-tcc-demo-bank1</h4><h4 id="dtx-tcc-demo-bank2"><a href="#dtx-tcc-demo-bank2" class="headerlink" title="dtx-tcc-demo-bank2"></a>dtx-tcc-demo-bank2</h4><h4 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a>测试场景</h4><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>如果拿TCC事务的处理流程与2PC两阶段提交做比较，2PC通常是在跨库的DB层面，而TCC则在应用层面的处理，需要通过业务逻辑来实现，这种分布式事务的实现的优势在于，可以让<strong>应用自己定义数据操作的粒度，使得降低锁冲突，提高吞吐量称为可能</strong>。  </p><p>而不足之处则在于对应用的侵入性非常强，业务逻辑处理的每个分支都需要实现try、confirm、cancel三个操作。<br>此外，其实实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。  </p><h2 id="分布式事务解决方案之可靠消息最终一致性"><a href="#分布式事务解决方案之可靠消息最终一致性" class="headerlink" title="分布式事务解决方案之可靠消息最终一致性"></a>分布式事务解决方案之可靠消息最终一致性</h2><h3 id="什么是可靠消息最终一致性事务"><a href="#什么是可靠消息最终一致性事务" class="headerlink" title="什么是可靠消息最终一致性事务"></a>什么是可靠消息最终一致性事务</h3><p>可靠消息最终一致性方案是指：当事务发起方执行完成本地事务后并发出一条消息，事务参与者（消息消费者）一定能够接收消息并处理事务成功；此方案强调的是只要消息发给事务参与方，最终事务要达到一致。  </p><p>此方案是利用消息中间件来完成。如下图：  </p><p>事务发起方（消息生产方）将消息发给消息中间件，事务参与方从消息中间件当中接收消息，事务发起方和消息中间件之间，事务参与方（消息消费方）和消息中间件之间都是通过网络通讯，由于网络通讯的不确定性会导致分布式事务问题。  </p><p>因此可靠消息最终一致性要解决一下几个问题：  </p><ol><li><strong>本地事务与消息发送的原子性问题</strong>  </li></ol><p>事务的发起方到事务的参与方，这个消息必须可靠；也就是张三必须将消息发送到李四；李四必须能够接受到这个消息；并且这个可靠消息最终一致性最终还要强调一点的是最终一致性；即张三在把这个钱扣掉之后，他会要保证这个消息一定会要发给李四，那么李四接收到这个消息之后就可以进行处理加钱的这个业务逻辑处理；在这过程当中如果李四加钱失败怎么办，张三能够回滚事务吗？不能回滚。所以这个叫做可靠消息最终一致性分成两部分进行解读；一部分是可靠消息；一部分是最终一致性；可靠消息是指消息从张三传给李四，从事务的发起方传给事务的参与方，这个过程需要是可靠的；那么最终一致性是：张三，即事务的发起方，执行完本地事务；并且张三一定保证消息发给李四；那最终李四就需要保证最终一致性即无论如何都要将钱加上；这也就是所说的可靠消息最终一致性；  </p><p>本地事务与消息发送的原子性问题即：事务发起方在本地事务执行成功后消息必须发出去，否则就丢弃消息。<br>即实现本地事务和消息发送的原子性，要么都成功，要么都失败；<br>本地事务与消息发送的原子性问题是实现可靠消息最终一致性方案的关键问题：  </p><p>先来尝试下这种操作，先发送消息，再操作数据库:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> <span class="keyword">transaction</span>:</span><br><span class="line">        //<span class="number">1.</span>发送MQ</span><br><span class="line">        //<span class="number">2.</span>数据库操作</span><br><span class="line"><span class="keyword">commit</span> <span class="keyword">transaction</span>;</span><br></pre></td></tr></table></figure><p>这种情况下无法保证数据库操作与发送消息的一致性，因为可能发送消息成功，数据库操作失败；  </p><p>你立马想到第二种方案，先进行数据库操作，再发送消息：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> <span class="keyword">transaction</span>:</span><br><span class="line">        //<span class="number">1.</span>数据库操作</span><br><span class="line">        //<span class="number">2.</span>发送MQ</span><br><span class="line"><span class="keyword">commit</span> <span class="keyword">transaction</span>;</span><br></pre></td></tr></table></figure><p>这种情况下貌似没有问题，如果发送MQ消息失败，就会抛出异常，导致数据库事务回滚。<br>但如果是超时异常，数据库回滚，但是MQ已经正常发送出去了，同样就会导致不一致。  </p><ol start="2"><li><strong>事务参与方接受消息的可靠性</strong></li></ol><p>事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息。  </p><ol start="3"><li><strong>消息重复消费的问题</strong>  </li></ol><p>由于网络的存在，若某一个消费结点超时但是消费成功，此时消息中间件会重复投递此消息，就导致了消息的重复消费。<br>要解决消息重复消费的问题就要实现事务参与方的方法幂等性。  </p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>上节讨论了可靠消息最终一致性事务方案需要解决的问题，本节讨论具体的解决方案；  </p><h4 id="本地消息表方案"><a href="#本地消息表方案" class="headerlink" title="本地消息表方案"></a>本地消息表方案</h4><p>本地消息表这个方案最初是eBay提出的，此方案的核心是通过本地事务保证数据业务操作和消息的一致性，然后通过定时任务将消息发送至消息中间件，待确认消息发送给消费成功再将消息删除；  </p><p>下面以注册送积分为例来说明：  </p><p>下例共有两个微服务交互，用户服务和积分服务，用户服务负责添加用户，积分服务负责增加积分。  </p><p>交互流程如下:  </p><ol><li><strong>用户注册</strong>  </li></ol><p>用户服务在本地新增用户和增加“积分消息日志”。（用户表和消息表通过本地事务保证一致）  </p><p>下边是伪代码：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> <span class="keyword">transaction</span>;</span><br><span class="line">      //1.新增用户</span><br><span class="line">      //2.存储积分消息日志</span><br><span class="line"><span class="keyword">commit</span> <span class="keyword">transaction</span>;</span><br></pre></td></tr></table></figure><p>这种情况下，本地数据库操作与存储积分消息日志处于同一个事务中，本地数据库操作与记录消息日志操作具备原子性。  </p><ol start="2"><li><strong>定时任务扫描日志</strong>  </li></ol><p>如何保证将消息发送给消息队列？  </p><p>经过第一步消息已经写到消息日志表中，可以启动独立的线程，定时对消息日志表中的消息进行扫描并发送至消息中间件，在消息中间件反馈发送成功后删除该消息日志，否则等待定时任务下一周期重试。  </p><ol start="3"><li><strong>消费消息</strong>  </li></ol><p>如何保证消费者一定能消费到消息？  </p><p>这里可以使用MQ的Ack（即消息确认机制）机制，消费者监听MQ，如果消费者接收到消息并且业务处理完成后向MQ发送Ack（即消息确认），此时说明消费者正常消费消息完成，MQ将不再向消费者推送消息，否则消费者户不断重试向消费者来发送消息。  </p><p>积分服务接收到“增加积分”消息，开始增加积分，积分增加成功后向消息中间件回应Ack，否则消息中间件将重复投递此消息；  </p><p>由于消息会重复投递，积分服务的“增加积分”功能需要实现幂等性；  </p><h4 id="RocketMQ事务消息方案"><a href="#RocketMQ事务消息方案" class="headerlink" title="RocketMQ事务消息方案"></a>RocketMQ事务消息方案</h4><p>RocketMQ是一个来自阿里的分布式消息中间件。  </p><p>于2012年开源，并在2017年正式成为Apache顶级项目。  </p><p>据了解，包括阿里云上的消息产品以及收购的子公司在内，阿里集团的消息产品全线都运行在RocketMQ之上，并且最近几年的双十一大促中，RocketMQ都有抢眼表现。<br>Apache RocketMQ4.3之后的版本正式支持事务消息，为分布式事务实现提供了便利性支持。  </p><p>RocketMQ事务消息设计则主要是为了解决Producer端的消息发送与本地事务执行的原子性问题，RocketMQ的设计中broker与producer端的双向通信能力，使得broker天生可以作为一个事务协调者存在；<br>而RocketMQ本身提供的存储机制为事务消息提供了持久化能力；<br>RocketMQ的高可用机制以及可靠消息设计则为事务消息在系统发生异常时依然能够保证达成事务的最终一致性；<br>在RocketMQ4.3后实现了完整的事务消息，实际上其实是对本地消息表的一个封装，将本地消息表移动到MQ内部，解决Producer端的消息发送与本地事务执行的原子性问题。  </p><p>执行流程如下：  </p><p>为方便理解，还是以注册送积分这个例子来描述整个流程。  </p><p>Producer即MQ发送方，本例中是用户服务，负责新增用户；<br>MQ订阅方即消息消费方，本例中是积分服务，负责新增积分。  </p><ol><li>Producer发送事务消息。</li></ol><p>Producer（MQ发送方）发送事务消息至MQ Server，MQ Server将消息标记为Prepared（预备状态），注意此时这条消息消费者（MQ订阅方）是无法消费得到的。  </p><p>本例中，Producer发送“增加积分消息”到MQ Server。  </p><ol start="2"><li>MQ Server回应消息发送成功</li></ol><p>MQ Server接受到Producer发送的消息则回应发送成功表示MQ已经接收到消息。  </p><ol start="3"><li>Producer执行本地事务</li></ol><p>Producer端执行业务代码逻辑，通过本地数据库事务控制。<br>本例中，Producer执行添加用户操作。  </p><ol start="4"><li>消息投递</li></ol><p>若Producer本地事务执行成功，则自动向MQ Server发送commit消息；<br>MQ Server接收到commit消息后将“增加积分消息”状态标记为可消费，此时MQ订阅方（积分服务）即正常消费消息；<br>若Producer本地事务执行失败则自动向MQ Server发送rollback消息，MQ Server接收到rollback消息后将删除“增加积分消息”；  </p><p>MQ订阅方（积分服务）消费消息，消费成功则向MQ回应Ack；否则将重复接收消息，这里ack默认自动回应，即程序执行正常则自动回应ack。  </p><ol start="5"><li>事务回查</li></ol><p>如果执行Producer端本地事务过程中，执行端挂掉，或者超时，MQ Server将会不停的询问同组的其他Producer来获取事务执行状态，这个过程叫做<strong>事务回查</strong>，MQ Server会根据事务回查结果来决定是否投递消息。  </p><p>以上主干流程已经由RocketMQ实现，对于用户来说，用户需要分别实现本地事务执行以及本地事务回查方法，因此只需要关注本地事务的执行状态即可。  </p><p>RocketMQ提供的RocketMQLocalTransactionListener接口：  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RocketMQLocalTransactionListener</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    发送prepare消息成功则此方法被调用，该方法用于执行本地事务</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> msg 回传的消息，利用transactionId即可获取到该消息的唯一id</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> arg 调用send方法时传递的参数，当send时候，若有额外的参数可以传递到send方法中，这里能获取到</span></span><br><span class="line"><span class="comment">    <span class="doctag">@return</span> 返回事务状态，COMMIT：提交  ROLLBACK：回滚 UNKNOW：回调</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    RocketMQLocalTransactionState executeLocalTransaction（Message msg，Object arg）;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> msg 通过获取transactionId来判断这条消息的本地事务执行状态</span></span><br><span class="line"><span class="comment">    <span class="doctag">@return</span> 返回事务状态  COMMIT：提交  ROLLBACK：回滚 UNKNOW：回调</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  RocketMQLocalTransactionState checkLocalTransaction（Message msg）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>发送事务消息</li></ul><p>以下是RocketMQ提供用于发送事务消息的API：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TransactionMQProducer producer=<span class="keyword">new</span> <span class="constructor">TransactionMQProducer(<span class="string">"ProducerGroup"</span>)</span>;</span><br><span class="line">producer.set<span class="constructor">NamesAddr(<span class="string">"127.0.0.1:9876"</span>)</span>;</span><br><span class="line">producer.start<span class="literal">()</span>;</span><br><span class="line"><span class="comment">//设置TransactionListener实现</span></span><br><span class="line">producer.set<span class="constructor">TransactionListener(<span class="params">transactionListener</span>)</span>;</span><br><span class="line"><span class="comment">//发送事务消息</span></span><br><span class="line">SendResult sendResult=producer.send<span class="constructor">MessageTransaction(<span class="params">msg</span>,<span class="params">null</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="RocketMQ实现可靠消息最终一致性事务"><a href="#RocketMQ实现可靠消息最终一致性事务" class="headerlink" title="RocketMQ实现可靠消息最终一致性事务"></a>RocketMQ实现可靠消息最终一致性事务</h3><h4 id="业务说明-2"><a href="#业务说明-2" class="headerlink" title="业务说明"></a>业务说明</h4><p>本示例通过RocketMQ中间件实现可靠消息最终一致性分布式事务，模拟两个账户的转账交易过程。  </p><p>两个账户在分别不同的银行（张三在bank1、李四在bank2），bank1、bank2是两个微服务。<br>交易过程是：张三给李四转账指定金额。  </p><p>上述交易步骤，张三扣减金额与给bank2发转账消息，两个操作必须是一个整体性的事务（原子性）；  </p><h4 id="程序组成部分-1"><a href="#程序组成部分-1" class="headerlink" title="程序组成部分"></a>程序组成部分</h4><p>数据库：MySQL-5.7.25（包括bank1和bank2两个数据库）<br>JDK：64位jdk1.8.0_201<br>rocketmq 服务端: RocketMQ-4.5.0<br>rocketmq 客户端：RocketMQ-Spring-Boot-starter.2.0.2-RELEASE<br>微服务框架：spring-boot-2.1.3、spring-cloud-Greenwich.RELEASE<br>微服务以及数据库的关系：<br>  dtx/dtx-seata-demo/seata-demo-bank1 银行1，操作张三账户，连接数据库1<br>  dtx/dtx-seata-demo/seata-demo-bank2 银行2，操作李四账户，连接数据库2  </p><p>本示例程序技术架构如下：  </p><p>交互流程如下：<br>1、Bank1向MQ Server发送转账消息<br>2、Bank1执行本地事务，扣减金额<br>3、Bank2接受消息，执行本地事务，添加金额  </p><h4 id="创建数据库-2"><a href="#创建数据库-2" class="headerlink" title="创建数据库"></a>创建数据库</h4><h4 id="启动RocketMQ"><a href="#启动RocketMQ" class="headerlink" title="启动RocketMQ"></a>启动RocketMQ</h4><h4 id="导入dtx-txmsg-demo"><a href="#导入dtx-txmsg-demo" class="headerlink" title="导入dtx-txmsg-demo"></a>导入dtx-txmsg-demo</h4><h4 id="dtx-txmsg-demo-bank1"><a href="#dtx-txmsg-demo-bank1" class="headerlink" title="dtx-txmsg-demo-bank1"></a>dtx-txmsg-demo-bank1</h4><h4 id="dtx-txmsg-demo-bank2"><a href="#dtx-txmsg-demo-bank2" class="headerlink" title="dtx-txmsg-demo-bank2"></a>dtx-txmsg-demo-bank2</h4><h4 id="测试场景-1"><a href="#测试场景-1" class="headerlink" title="测试场景"></a>测试场景</h4><ul><li>bank1本地事务失败，则bank1不发送转账消息</li><li>bank2接收转账消息失败，会进行重试发送消息</li><li>bank2多次消费同一个消息，实现幂等</li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>可靠消息最终一致性就是保证消息从生产方经过消息中间件传递到消息方的一致性，本案例使用了RocketMQ作为消息中间件，RocketMQ主要解决了两个功能：  </p><p>1、本地事务与消息发送的原子性问题；<br>2、事务参与方接收消息的可靠性。  </p><p>可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景。<br>引入消息机制后，同步的事务操作变为基于消息执行的异步操作，避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。  </p><h2 id="分布式解决方案之最大努力通知"><a href="#分布式解决方案之最大努力通知" class="headerlink" title="分布式解决方案之最大努力通知"></a>分布式解决方案之最大努力通知</h2><h3 id="什么是最大努力通知"><a href="#什么是最大努力通知" class="headerlink" title="什么是最大努力通知"></a>什么是最大努力通知</h3><p>最大努力通知也是一种解决分布式事务的方案，下边是一个充值的例子。  </p><p>交互流程：<br>1、账户系统调用充值系统接口；<br>2、充值系统完成支付处理向账户系统发起充值结果通知；若通知失败，则充值系统按照策略进行重复通知；<br>3、账户系统接收到充值结果通知修改充值状态；<br>4、账户系统未接收到通知会主动调用充值系统的接口查询充值结果。  </p><p>通过上边的例子，总结最大努力通知方案的目标：  </p><p>目标：发起通知方通过一定的机制最大努力将业务处理结果通知到接收方；  </p><p>具体包括：<br>1、有一定的消息重复通知机制；<br>  因为接受通知方可能没有接收到通知，此时要有一定的机制对消息重复通知；<br>2、消息校对机制<br>  如果是最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询信息来满足需求。  </p><p>这个跟我们信666当中的交易模块很相似，也是进行查询交易结果的时候，如果在一定的查询次数下没有查找得到结果即一分钟查询多少次等，那么就更改成2分钟查询多少次；两分钟查询后仍然没有结果就再次换成3分钟查询多少次；这个一分钟两分钟三分钟，是间隔，间隔时间；因为交易量大的缘故，所以也是为了减轻下服务器压力；是的有些是异步主动去通知下游系统，就是接入第三方支付的时候，上游渠道可能会需要你提供一个异步回调的一个接口，那么这个接口用于交易结果通知或者其他的绑卡结果通知等这种，你可以提供一个接口，当然了也可以提供一个假的接口，就是系统中不存在此接口也行；当然了如果不存在该接口的话，那么就需要去使用系统当中的查询机制，即主动去查询上游渠道系统当中该笔交易的交易结果。在第三方这种支付方面就大概使用了最大努力通知的方式实现分布式事务方案。很多的第三方支付会去提供这个订单/交易结果查询的这样一个接口；而我们自己对接下游就比较缺德了，就每次我们向上游查询完交易结果之后，在处理完业务逻辑后，我们就通过try catch住，http直接发送一次交易结果给上送了回调地址接口的下游；没有上送回调接口就让他们自己来查询，上送了的话我们就回调一次；就这样。  </p><p>最大努力通知与可靠消息一致性有什么不同？  </p><p>1、解决方案思想不同  </p><p>  可靠消息一致性，发起通知方需要保证将消息发送出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知方来保证。  </p><p>  最大努力通知，发起通知方尽最大的努力将业务处理结果通知给接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性在于接收通知方。  </p><p>2、两者的业务应用场景不同  </p><p>  可靠消息一致性关注的是交易过程的事务一致，以异步的方式完成交易。  </p><p>  最大努力通知关注的是交易后的通知事务，即将交易结果可靠的通知出去。  </p><p>3、技术解决方向不同  </p><p>  可靠消息一致性要解决消息从发出到接收的一致性，即消息发出并且被接收到。  </p><p>  最大努力通知无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制，可靠机制是，最大努力的将消息通知给接收方，当消息无法被接收方接收时，由接收方主动查询消息（业务处理结果）；  </p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>通过对最大努力通知的理解，采用MQ的ack机制就可以实现最大努力通知；  </p><p>方案一：  </p><p>本方案是利用MQ的ack机制由MQ向接收通知方发送通知，流程如下：  </p><ol><li>发起通知方将通知发给MQ；  </li></ol><p>使用普通消息机制将通知发给MQ；  </p><p>注意:如果消息没有发出去可由接收通知方主动请求发起通知方查询业务执行结果。  </p><ol start="2"><li><p>接收通知方监听MQ；</p></li><li><p>接收通知方接收消息，业务处理完成回应Ack；  </p></li><li><p>接收通知方若没有会用ack则MQ会重复通知；  </p></li></ol><p>MQ会<strong>按照间隔1min、5min、10min、30min、1h、2h、5h、10h的方式，逐步拉大通知间隔</strong>（如果MQ采用RocketMQ，在broker中可以进行配置），直到达到通知要求的时间窗口上限。  </p><ol start="5"><li>接收通知方可通过消息校对接口来校对消息的一致性。  </li></ol><p>方案二：  </p><p>本方案也是利用MQ的Ack机制，与方案一不同的是应用程序向接收通知方发送通知，如下图：  </p><p>交互流程如下:  </p><ol><li><p>发起通知方将通知发给MQ；</p><p>使用可靠消息一致方案中的事务消息保证本地事务与消息的原子性，最终将通知先发给MQ。  </p></li><li><p>通知程序监听MQ，接收MQ的消息；  </p><p>方案1中接收通知方直接监听MQ，方案2中由通知程序监听MQ；  </p><p>通知程序若没有回应Ack则MQ会重复通知；  </p></li><li><p>通知程序通过互联网接口协议（如http、webservice）调用接受通知方案接口，完成通知。  </p><p>通知程序调用接受通知方案接口成功就表示通知成功，即MQ消费成功，MQ将不再向通知程序投递通知消息。  </p></li><li><p>接受通知方可通过消息校对接口来校对消息的一致性。  </p></li></ol><p>方案1和方案2的不同点：  </p><p>（1）方案1中接收通知方与MQ接口，即接收通知方监听MQ，次方案主要应用与内部应用之间的通知；<br>（2）方案2中由通知程序与MQ接口，通知程序监听MQ，收到MQ的消息后，由通知程序通过互联网接口协议调用接收通知方。此方案主要应用于外部应用之间的通知，例如支付宝、微信的支付结果通知。  </p><p>方案一针对内部系统；方案二针对外部系统；  </p><h3 id="RocketMQ实现最大努力通知型事务"><a href="#RocketMQ实现最大努力通知型事务" class="headerlink" title="RocketMQ实现最大努力通知型事务"></a>RocketMQ实现最大努力通知型事务</h3><h4 id="业务说明-3"><a href="#业务说明-3" class="headerlink" title="业务说明"></a>业务说明</h4><p>本示例通过RocketMQ中间件实现最大努力通知型分布式事务，模拟充值过程。  </p><p>本案例有账户系统和充值系统两个微服务，其中账户系统的数据库是bank1数据库，其中有张三账户。<br>充值系统的数据库使用bank1_pay数据库，记录了账户的充值记录。  </p><p>业务流程如下图：  </p><p>交互流程如下：  </p><ol><li>用户请求充值系统进行充值；  </li><li>充值系统完成充值将充值结果发送给MQ。</li><li>账户系统监听MQ，接收充值结果通知，如果接收不到消息，MQ会重复发送通知。接收到充值结果通知账户系统增加充值金额。  </li><li>账户系统也可以主动查询充值系统的充值查询接口，增加金额。  </li></ol><h4 id="程序组成部分-2"><a href="#程序组成部分-2" class="headerlink" title="程序组成部分"></a>程序组成部分</h4><p>数据库：MySQL-5.7.25（包括bank1和bank1_pay两个数据库）<br>JDK：64位jdk1.8.0_201<br>rocketmq 服务端: RocketMQ-4.5.0<br>rocketmq 客户端：RocketMQ-Spring-Boot-starter.2.0.2-RELEASE<br>微服务框架：spring-boot-2.1.3、spring-cloud-Greenwich.RELEASE<br>微服务以及数据库的关系：<br>  dtx/dtx-notifymsg-demo/dtx-notifymsg-demo-bank1 银行1，操作张三账户，连接数据库bank1<br>  dtx/dtx-notifymsg-demo/dtx-notifymsg-demo-pay 银行2，操作李四账户，连接数据库bank1_pay  </p><p>交互流程如下：  </p><p>1、用户请求充值系统进行充值；<br>2、充值系统完成充值将充值结果发给MQ；<br>3、账户系统监听MQ，接收充值结果通知，如果接收不到消息，MQ会重复发送通知。接收到充值结果通知账户系统增加充值金额。<br>4、账户系统也可以主动查询传给你藕汁系统的充值结果查询接口，增加金额。  </p><h4 id="创建数据库-3"><a href="#创建数据库-3" class="headerlink" title="创建数据库"></a>创建数据库</h4><h4 id="启动RocketMQ-1"><a href="#启动RocketMQ-1" class="headerlink" title="启动RocketMQ"></a>启动RocketMQ</h4><h4 id="导入dtx-notifymsg-demo"><a href="#导入dtx-notifymsg-demo" class="headerlink" title="导入dtx-notifymsg-demo"></a>导入dtx-notifymsg-demo</h4><h4 id="dtx-notifydemo-pay"><a href="#dtx-notifydemo-pay" class="headerlink" title="dtx-notifydemo-pay"></a>dtx-notifydemo-pay</h4><h4 id="dtx-notifydemo-bank1"><a href="#dtx-notifydemo-bank1" class="headerlink" title="dtx-notifydemo-bank1"></a>dtx-notifydemo-bank1</h4><h4 id="测试场景-2"><a href="#测试场景-2" class="headerlink" title="测试场景"></a>测试场景</h4><ul><li>充值系统充值成功，账户系统主动查询充值结果，修改中户金额</li><li>充值系统充值成功，发送消息，账户系统接收消息，修改账户金额。</li><li>账户系统修改账户金额幂等测试。</li></ul><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>最大努力通知方案是分布式中对已执行要求最低的一种，适用于一些最终一致性时间敏感度低的业务；<br>最大努力通知方案需要实现如下功能：  </p><ol><li>消息重复通知机制</li><li>消息校对机制</li></ol><h2 id="分布式事务综合案例"><a href="#分布式事务综合案例" class="headerlink" title="分布式事务综合案例"></a>分布式事务综合案例</h2><p>前边已经学习了四种分布式事务解决方案，2PC，TCC，可靠消息最终一致性，最大努力通知，每种解决方案通过案例开发进行学习，本章节结合互联网金融项目中的业务场景，来进行分布式事务解决方案可行性分析。  </p><h3 id="系统介绍"><a href="#系统介绍" class="headerlink" title="系统介绍"></a>系统介绍</h3><h4 id="P2P介绍"><a href="#P2P介绍" class="headerlink" title="P2P介绍"></a>P2P介绍</h4><p>P2P金融又叫P2P信贷，其中P2P是peer-to-peer或者person-to-person的缩写，意思是：个人对个人。  </p><p>P2P金融指的是个人与个人之间的小额借贷交易，一般需要借助电子商务专业网络平台帮助借贷双方确立借贷关系并完成相关交易手续。  </p><p>借款者可以自行发布借款消息，包括金额、利息、还款方式和时间，实现自助式借款；<br>投资者根据借款人发布的消息，自行决定出借金额，实现自助式借贷。  </p><p>目前，国家对P2P行业的监控与规范性控制越来越严格，出台了很多政策来对其专项整治。<br>并主张采用“银行存管模式”来规避P2P平台挪用借投人资金的风险，通过银行开发的“银行存管系统”管理投资者的资金，<strong>每位P2P平台用户在银行的存管系统内都会有一个独立账号，</strong>平台来管理交易，做到资金和交易分开，让P2P平台不能接触到资金，就可以一定程度上避免资金被挪用的风险。  </p><p>什么是银行存管模式？  </p><p>银行存管模式涉及到2套账户体系，P2P平台和银行各有一套账户体系。<br>投资人在P2P平台注册后，会同时跳转到银行再开一个电子账户，2个账户之间有一一对应的关系。<br>当投资人投资时，资金进入的是平台在银行为投资人开设的二级账户当中，每一笔交易，是银行在投资人与借款人之间的交易划转，P2P平台仅能看到信息的流动。  </p><h4 id="总体业务流程"><a href="#总体业务流程" class="headerlink" title="总体业务流程"></a>总体业务流程</h4><h4 id="业务术语"><a href="#业务术语" class="headerlink" title="业务术语"></a>业务术语</h4><table>  <thead>    <tr>      <th>术语</th>      <th>描述</th>    </tr>  </thead>  <tbody>    <tr>      <td>银行存管模式</td>      <td>此种模式下，涉及到2套账户体系，P2P平台和银行各有一套账户体系。投资人在P2P平台注册后会同时跳转到银行再开一个电子账户，2个账户之间有一个一一对应的关系。当投资人投资时，资金进入的是平台在银行为投资人开设的二进账户中，每一笔交易，是由银行在投资人与借款人之间的交易划转，P2P平台仅能看到信息的流动。</td>    </tr>    <tr>      <td>标的</td>      <td>P2P业内，习惯把借款人的投资项目称之为“标的”</td>    </tr>    <tr>      <td>发标</td>      <td>借款人在P2P平台中创建并发布“标的”过程</td>    </tr>    <tr>      <td>投标</td>      <td>投资人在认可相关借款人之后进行的一种借贷行为，对自己中意的借款标的进行投资操作，一个借款标可由单个投资人或多个投资人承接。</td>    </tr>    <tr>      <td>满标</td>      <td>单笔借款标筹集齐所有借款资金即为满标，计息时间是以标满当日开始计息，投资人较多的平台多数会当天满标。</td>    </tr>  </tbody></table><h4 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h4><ul><li><p><strong>统一账号服务</strong>  </p><p>用户的登录账户、密码、角色、权限、资源等系统级信息的管理，不包含用户业务信息。  </p></li><li><p><strong>用户中心</strong>  </p><p>提供用户业务信息的管理，如会员信息、实名认证信息、绑定银行卡信息等，“用户中心”的每个用户与“<strong>统一账号服务</strong>”中的账号关联。  </p></li><li><p><strong>交易中心</strong>  </p><p>提供发标、投标等业务。  </p></li><li><p><strong>还款业务</strong>  </p><p>提供还款计划的生成、执行、记录与归档。  </p></li><li><p><strong>银行存管系统（模拟）</strong>  </p><p>  模拟银行存管系统，进行资金的存管，划转。  </p></li></ul><h3 id="注册账号案例分析"><a href="#注册账号案例分析" class="headerlink" title="注册账号案例分析"></a>注册账号案例分析</h3><h4 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h4><p>  采用用户、账号分离设计（这样设计的好处是：当用户的业务信息发生变化时，不会影响的认证、授权等系统机制），因此需要保证用户信息与账号信息的一致性。  </p><p>  用户向用户中心发起注册请求，用户中心保存用户业务信息，然后通知统一账号服务新建该用户所对应登录账号。  </p><h4 id="解决方案分析"><a href="#解决方案分析" class="headerlink" title="解决方案分析"></a>解决方案分析</h4><p>  针对注册业务，如果用户与账户信息不一致，则会导致严重问题，因此该业务对一致性要求较为严格，即当用户服务和账号服务任意一方出现问题都需要回滚事务。  </p><p>  根据上述需求进行解决方案分析：  </p><ol><li><p>采用可靠消息一致性方案  </p><p> 可靠消息一致性要求只要消息发出，事务参与者接到消息就要将事务执行成功，不存在回滚的要求，所以不适用。  </p></li><li><p>最大努力通知方案</p><p> 最大努力通知表示发起通知方执行完本地事务后将结果通知给事务参与者，即使事务参与者执行业务处理失败发起通知方也不会回滚事务，所以不适用。  </p></li><li><p>采用Seata实现2PC  </p><p> 在用户中心发起去全局事务，统一账户服务为事务参与者，用户中心和统一账户服务只要由一方出现问题则全局事务回滚，符合要求。  </p><p> 实现方法如下：  </p><ol><li>用户中心添加用户信息，开启全局事务；  </li><li>统一账号服务添加账号信息，作为事务参与者；  </li><li>其中一方执行失败Seata对SQL进行逆操作删除用户信息和账号信息，实现回滚。  </li></ol><ol start="4"><li><p>采用Hmily实现TCC</p><p>TCC也可以实现用户中心和统一账户服务只要有一方出现问题则全局事务回滚，符合要求。  </p><p>实现方法如下：  </p><ol><li><p>用户中心  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>：</span><br><span class="line">    添加用户，状态为不可用</span><br><span class="line"><span class="keyword">confirm</span>：</span><br><span class="line">    更新用户状态为可用</span><br><span class="line">cance<span class="variable">l:</span></span><br><span class="line">    删除用户</span><br></pre></td></tr></table></figure></li><li><p>统一账号服务</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">try:</span></span><br><span class="line">    添加账号，状态为不可用</span><br><span class="line"><span class="symbol">confirm:</span></span><br><span class="line">    更新账号状态为可用</span><br><span class="line"><span class="symbol">cancel:</span></span><br><span class="line">    删除账号</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="存管开户"><a href="#存管开户" class="headerlink" title="存管开户"></a>存管开户</h3><h4 id="业务流程-1"><a href="#业务流程-1" class="headerlink" title="业务流程"></a>业务流程</h4><p>根据政策要求，P2P业务必须让银行存管资金，用户的资金在银行存管系统的账户中，而不在P2P平台中，因此用户要在银行存管系统开户。  </p><p>用户向用户中心提交开户资料，用户中心生成开户请求号并重定向至银行存管系统开户页面。<br>用户设置存管密码并确认开户后，银行存管立即返回“请求已受理”。<br>在某一时刻，银行存管系统处理完该开户请求后，将调用毁掉地址通知处理结果，若通知失败，则按照一定策略重试通知。<br>同时，以你航存管系统应提供<strong>开户结果查询的接口</strong>，以供用户中心校对结果。  </p><h4 id="解决方案分析-1"><a href="#解决方案分析-1" class="headerlink" title="解决方案分析"></a>解决方案分析</h4><p>P2P平台的用户中心与银行存管系统之间属于跨系统交互，银行存管系统属于外部系统；用户中心无法干预银行存管系统；<br>所以用户中心只能在收到银行存管系统的业务处理结果通知后积极处理，开户后的使用情况完全由用户中心来控制。<br>根据上述需求来进行解决方案分析：  </p><ol><li><p>采用Seata实现2PC</p><p>需要侵入银行存管系统的数据库，由于它是外部系统，所以不适用。  </p></li><li><p>采用Hmily实现TCC</p><p>TCC侵入性更强，所以不适用；  </p></li><li><p>基于MQ的可靠消息一致性</p><p>如果让银行存管系统监听MQ则不合适，因为它是外部系统。  </p><p>如果银行存管系统将消息发给MQ用户中心监听MQ是可以的；<br>但是由于相对银行存管系统来说用户中心属于外部系统，银行存管系统是不会让外部系统直接监听自己的MQ的，基于MQ的通信协议也不方便外部系统间的交互，所以本方案不合适。  </p></li><li><p>最大努力通知方案</p><p> 银行存管系统内部使用MQ，银行存管系统处理完业务后将处理结果发给MQ。<br> 由银行存管系统的通知程序专门发送通知方</p></li></ol><h3 id="满标审核"><a href="#满标审核" class="headerlink" title="满标审核"></a>满标审核</h3><h4 id="业务流程-2"><a href="#业务流程-2" class="headerlink" title="业务流程"></a>业务流程</h4><p>在借款人标的募集所有的资金后，P2P运营管理员审批该标的，触发放款，并开启还款流程。<br>管理员对某标的满标审批通过，交易中心修改标的状态为“还款中”，同时还要通知还款服务生成还款计划。  </p><h4 id="解决方案分析-2"><a href="#解决方案分析-2" class="headerlink" title="解决方案分析"></a>解决方案分析</h4><p>生成还款计划是一个执行时长较长的业务，不建议阻塞主业务流程，此业务对一致性要求较低。<br>根据上述需求进行解决方案分析：  </p><ol><li><p>采用Seata实现2PC</p><p>Seata在食物执行过程中或进行数据库资源锁定，由于事务执行时长较长会将资源锁定较长时间，所以不适用。  </p></li><li><p>采用Hmily实现TCC</p><p>本需求对业务一致性要求较低，因为生成还款计划的时长较长，所以不要求交易中心修改标的状态为“还款中”就立即生成还款计划，所以本方案不适用；  </p></li><li><p>基于MQ的可靠消息一致性</p><p>满标审批通过后，由交易中心修改标的状态为“还款中”并且向还款服务发送消息，还款服务接收到消息开始生成还款计划，基本与MQ的可靠消息一致性方案适用此场景。  </p></li><li><p>最大努力通知方案</p><p>满标审批通过后，由交易中心向还款服务发送通知要求生成还款计划，还款服务并且对外提供还款计划生成结果校对接口供其他服务查询，最大努力通知方案也适用本场景。  </p></li></ol><h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><ul><li><strong>重点知识回顾：</strong>  </li></ul><p>事务的基本概念以及本地事务特性。  </p><p>CAP、BASE理论的概念。  </p><p>2PC、TCC、可靠消息最终一致性、最大努力通知各个类型原理以及其特性；  </p><p>不同分布式事务类型的应用场景讨论。  </p><p>RocketMQ事务消息机制；  </p><p>Seata与传统XA原理上的差异。  </p><ul><li><strong>分布式事务对比分析：</strong>  </li></ul><p>在学习各种分布式事务的解决方案后，了解到各种方案的优缺点：  </p><p><strong>2PC</strong>最大的诟病就是一个阻塞协议。RM在执行分支事务后需要等待TM的决定，此服务会阻塞并锁定资源。<br>由于其阻塞机制和最差时间复杂高度。<br>因此，这种实际不能适应着事务涉及的服务数量增加而扩展的需要，很难用于并发较高以及子事务生命周期较长（long-running transactions）的分布式服务中。  </p><p>如果拿<strong>TCC</strong>事务的处理流程与2PC两阶段提交作比较，2PC同行都是在跨库的DB层面，而TCC则是在应用层面的处理，需要通过业务逻辑来实现。<br>这种分布式事务的实现方式的又是在于，可以让<strong>应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量称为可能</strong>。<br>而不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。<br>此外，其实现难度也比较大，需要按照网络状态，系统故障等不同的失败原因实现不同的回滚策略。<br>典型的使用场景：满xx/登录送优惠券等。  </p><p><strong>可靠消息最终一致性事务</strong>适合知性周期长且实时性要求不高的场景。<br>引入消息机制后，同步的事务操作变为基于消息执行的异步操作，避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。<br>典型的使用场景：注册送积分、登录送优惠券等。  </p><p><strong>最大努力通知</strong> 是分布式事务中要求最低的一种，适用于一些最终一致性敏感度低的业务；<br>允许发起通知方处理业务失败，在接收通知方收到通知后积极进行失败处理，无论发起通知方如何处理结果都会不影响到接收通知方的后续处理；<br>发起通知方需要提供查询执行情况接口，用于接收通知方校对结果。<br>典型的使用场景：银行通知、支付结果通知等；  </p><table>  <thead>    <tr>      <th></th>      <th>2PC</th>      <th>TCC</th>      <th>可靠消息</th>      <th>最大努力通知</th>    </tr>  </thead>  <tbody>    <tr>      <td>一致性</td>      <td>强一致性</td>      <td>最终一致</td>      <td>最终一致</td>      <td>最终一致</td>    </tr>    <tr>      <td>吞吐量</td>      <td>低</td>      <td>中</td>      <td>高</td>      <td>高</td>    </tr>    <tr>      <td>实现复杂度</td>      <td>易</td>      <td>难</td>      <td>中</td>      <td>易</td>    </tr>  </tbody></table><p><strong>总结：</strong>  </p><p>在条件允许的情况下，尽可能选择本地事务单数据源，因为它减少了网络交互带来的性能消耗，且避免了数据弱一致性带来的种种问题。<br>若某系统频繁且不合理的使用分布式事务，应首先从整体设计角度观察服务的拆分是否合理，是否高内聚低耦合？是否粒度太小？分布式事务一直是业界难题，因为网络的不确定性，而且我们习惯拿分布式事务与单机事务ACID作对比；  </p><p>无论是数据库层的XA、还是应用层的TCC、可靠消息、最大努力通知等方案，都没有完美解决分布式事务问题，他们不过是在各自在性能、一致性、可用性等方面作取舍，寻求某些场景偏好下的权衡。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;希望这句话不只是送给我，也送给那些跟我当时心境一样的人。  &lt;/p&gt;
&lt;p&gt;就像妈妈每次给我打电话的结尾是：要天天开开心心的。保持好心情。  &lt;/p&gt;
&lt;p&gt;一样。  &lt;/p&gt;
&lt;p&gt;观看笔记： &lt;a href=&quot;https://www.bilibili.com/video
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="微服务" scheme="https://fengshana.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="分布式" scheme="https://fengshana.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="事务" scheme="https://fengshana.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>整数反转</title>
    <link href="https://fengshana.github.io/2020/04/18/LeetCode/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>https://fengshana.github.io/2020/04/18/LeetCode/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</id>
    <published>2020-04-18T03:10:12.003Z</published>
    <updated>2020-04-18T03:19:07.668Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得还是得多看点优秀的代码，我这个太low了；<br>可以看这个的：<a href="https://drawcode.mdnice.com/algorithm/intro/" target="_blank" rel="noopener">https://drawcode.mdnice.com/algorithm/intro/</a><br>体会到差距就是执行用时与内存消耗上面；<br>害；<br>基础不扎实；<br>晚上有时间看下别人优秀的代码解析；<br>害；别说；还是蛮沉浸其中的；  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    static Long <span class="keyword">minValue</span>=new Long(<span class="number">-2</span>);</span><br><span class="line">    static Long <span class="keyword">maxValue</span>=new Long(<span class="number">2</span>);</span><br><span class="line">    static&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">minValue</span>=<span class="keyword">minValue</span>*(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">maxValue</span>=<span class="keyword">maxValue</span>*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">maxValue</span>=<span class="keyword">maxValue</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    给出一个32位的有符号整数，</span></span><br><span class="line"><span class="comment">    你需要将这个整数中每位上的数字进行反转；</span></span><br><span class="line"><span class="comment">    int x  32位的有符号整数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">public</span> <span class="type">int</span> reverse(<span class="type">int</span> x) &#123;</span><br><span class="line">        String s=x&lt;<span class="number">0</span>?(x+"").substring(<span class="number">1</span>,(x+"").length()):x+"";</span><br><span class="line">        Long result=<span class="built_in">new</span> Long(<span class="number">0</span>);</span><br><span class="line">        StringBuilder stringBuilder=<span class="built_in">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.length();i&gt;<span class="number">0</span>;i<span class="comment">--)&#123;</span></span><br><span class="line">            stringBuilder.append(s.substring(i<span class="number">-1</span>,i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            Long <span class="keyword">value</span>=Long.parseLong("-"+stringBuilder.toString());</span><br><span class="line">            result=<span class="keyword">value</span>&lt;<span class="keyword">minValue</span>?result:value;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Long value=Long.parseLong(stringBuilder.toString());</span><br><span class="line">            result=value&gt;<span class="keyword">maxValue</span>?result:value;</span><br><span class="line">        &#125;</span><br><span class="line">        return result.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我觉得还是得多看点优秀的代码，我这个太low了；&lt;br&gt;可以看这个的：&lt;a href=&quot;https://drawcode.mdnice.com/algorithm/intro/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://drawcode
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://fengshana.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://fengshana.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="https://fengshana.github.io/2020/04/18/LeetCode/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://fengshana.github.io/2020/04/18/LeetCode/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-04-18T00:55:01.818Z</published>
    <updated>2020-04-18T01:09:52.993Z</updated>
    
    <content type="html"><![CDATA[<p>写了两种方法；<br>很奇怪执行用时和内存消耗不知道怎么降下去；<br>我开始就搜了下：java 定义变量会消耗内存是吗？<br>我这个傻逼问题；<br>抱歉抱歉，我刚入门，对不住；  </p><p> <img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXyrH0mn2colZek3cguDxrWyGXx4pLFnHCZcZ9eF4N289iZ2JtlaYYYeWf2LHQ5qRWF8Mf0xWoO6sbLjgob1pXQM!/r" alt="两数之和"></p><p>想一想办法应该还可以优化下；<br>一开始使用Map，觉得内存消耗可能会大；不知道莫名就是给我的感觉就是这种结构给我的感觉要大；后来就换成了用数组；<br>刚开始接触，写的不好，还请见谅；  </p><p>诶诶诶，换成js，内存消耗以及运行时间可能会要短一点吗？有时间再去试试js；<br>不知道为什么我感觉js会要短点？<br>好了今天是LeetCode打卡第一天；<br>最近有一首歌挺好听的：(司南-冬眠)</p><blockquote><p>方法一：  </p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     int[] nums 整数数组</span></span><br><span class="line"><span class="comment">     int target 目标值</span></span><br><span class="line"><span class="comment">     int[] 该数组nums中找出和为目标值的那两个整数，并返回他们的数组下标</span></span><br><span class="line"><span class="comment">     每中输入只会对应一个答案，但是数组中同一个元素不能使用两遍。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; <span class="built_in">map</span>=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] twoNums=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> numA=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">map</span>.<span class="built_in">put</span>(i,numA);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> numB=target-numA;</span><br><span class="line">                Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; <span class="built_in">set</span>=<span class="built_in">map</span>.entrySet();</span><br><span class="line">                <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:<span class="built_in">set</span>)&#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"entry.getValue():  "</span>+entry.getValue());</span><br><span class="line">                    <span class="keyword">if</span>(numB==entry.getValue())&#123;</span><br><span class="line">                        twoNums[<span class="number">0</span>]=i&gt;entry.<span class="built_in">getKey</span>()?entry.<span class="built_in">getKey</span>():i;</span><br><span class="line">                        twoNums[<span class="number">1</span>]=i&gt;entry.<span class="built_in">getKey</span>()?i:entry.<span class="built_in">getKey</span>();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">map</span>.<span class="built_in">put</span>(i,numA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> twoNums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>方法二：  </p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">int</span>[] twoSum2(<span class="built_in">int</span>[] nums,<span class="built_in">int</span> target)&#123;</span><br><span class="line">        <span class="built_in">int</span>[] twoNums=new <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">bool</span>ean flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> numA=nums[i];</span><br><span class="line">            <span class="built_in">int</span> numB=target-numA;</span><br><span class="line">           <span class="keyword">for</span>(<span class="built_in">int</span> n=i+<span class="number">1</span>;n&lt;nums.length;n++)&#123;</span><br><span class="line">               <span class="built_in">int</span> numV=nums[n];</span><br><span class="line">               <span class="keyword">if</span>(numB==numV)&#123;</span><br><span class="line">                   twoNums[<span class="number">0</span>]=i;</span><br><span class="line">                   twoNums[<span class="number">1</span>]=n;</span><br><span class="line">                   flag=<span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> twoNums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写了两种方法；&lt;br&gt;很奇怪执行用时和内存消耗不知道怎么降下去；&lt;br&gt;我开始就搜了下：java 定义变量会消耗内存是吗？&lt;br&gt;我这个傻逼问题；&lt;br&gt;抱歉抱歉，我刚入门，对不住；  &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://r.photo.store.qq.c
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://fengshana.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://fengshana.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>PC端直播屏幕变红</title>
    <link href="https://fengshana.github.io/2020/04/17/%E7%9B%B4%E6%92%AD/pc%E7%9B%B4%E6%92%AD%E5%B1%8F%E5%B9%95%E5%8F%98%E7%BA%A2/"/>
    <id>https://fengshana.github.io/2020/04/17/%E7%9B%B4%E6%92%AD/pc%E7%9B%B4%E6%92%AD%E5%B1%8F%E5%B9%95%E5%8F%98%E7%BA%A2/</id>
    <published>2020-04-16T20:01:20.706Z</published>
    <updated>2020-04-16T20:21:11.024Z</updated>
    
    <content type="html"><![CDATA[<p>在这当中协助我完成直播功能的博客：<a href="https://me.csdn.net/eguid_1" target="_blank" rel="noopener">https://me.csdn.net/eguid_1</a>  </p><p>前期使用了有Red5、VLC、OBS；后来就直接使用的就是OBS进行拉流获取直播视频；  </p><p>OBS：<a href="https://obsproject.com/" target="_blank" rel="noopener">https://obsproject.com/</a>  </p><p>由于转化器converter会转化的是IplImage从而获取得到Frame；<br>而robot机器从屏幕读取得到的像素图像只能是BufferedImage；所以这两者需要做一个转化；</p><p>参考一些Blog，发现说是BufferedImage与IplImage之间的转化问题；  </p><p>参考了博客：<a href="https://blog.csdn.net/zwl18210851801/article/details/81279725" target="_blank" rel="noopener">https://blog.csdn.net/zwl18210851801/article/details/81279725</a><br>这篇博客是记录Mat与BufferedImage与我要的不一致；</p><p>因为参考的博客比如：<a href="https://blog.csdn.net/qiao_198911/article/details/52135013" target="_blank" rel="noopener">https://blog.csdn.net/qiao_198911/article/details/52135013</a><br>这篇博客是转化IplImage转化为BufferedImage；而我要的是BufferedImage转化为IplImage；</p><p>后来又找到博客发现：<a href="https://stackoverflow.com/questions/8368078/java-bufferedimage-to-iplimage" target="_blank" rel="noopener">https://stackoverflow.com/questions/8368078/java-bufferedimage-to-iplimage</a><br>这篇博客就记录了BufferedImage转化成IplImage；</p><p>PC端视频直播屏幕变红解决：  </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**bufferedImage to IplImage 的转化*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IplImage toIplImage(BufferedImage bufImage) &#123;</span><br><span class="line">    ToIplImage iplConverter = <span class="keyword">new</span> <span class="type">OpenCVFrameConverter</span>.ToIplImage();</span><br><span class="line">    Java2DFrameConverter java2dConverter = <span class="keyword">new</span> <span class="type">Java2DFrameConverter</span>();</span><br><span class="line">    IplImage iplImage = iplConverter.convert(java2dConverter.convert(bufImage));</span><br><span class="line">    <span class="keyword">return</span> iplImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于不是很明白；所以之前的代码都会做一个注释；贴一下之前的代码：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br></pre></td><td class="code"><pre><span class="line">package com.live;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteOrder;</span><br><span class="line"><span class="keyword">import</span> java.nio.ShortBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sound.sampled.AudioFormat;</span><br><span class="line"><span class="keyword">import</span> javax.sound.sampled.AudioSystem;</span><br><span class="line"><span class="keyword">import</span> javax.sound.sampled.DataLine;</span><br><span class="line"><span class="keyword">import</span> javax.sound.sampled.Line;</span><br><span class="line"><span class="keyword">import</span> javax.sound.sampled.LineUnavailableException;</span><br><span class="line"><span class="keyword">import</span> javax.sound.sampled.Mixer;</span><br><span class="line"><span class="keyword">import</span> javax.sound.sampled.TargetDataLine;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacpp.Loader;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacpp.avcodec;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacpp.opencv_core.IplImage;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacpp.helper.opencv_objdetect;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.CanvasFrame;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FFmpegFrameRecorder;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.Frame;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FrameGrabber;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FrameGrabber.Exception;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FrameRecorder;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.OpenCVFrameConverter;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.OpenCVFrameGrabber;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.AWTException;</span><br><span class="line"><span class="keyword">import</span> java.awt.Dimension;</span><br><span class="line"><span class="keyword">import</span> java.awt.GraphicsDevice;</span><br><span class="line"><span class="keyword">import</span> java.awt.GraphicsEnvironment;</span><br><span class="line"><span class="keyword">import</span> java.awt.Rectangle;</span><br><span class="line"><span class="keyword">import</span> java.awt.Robot;</span><br><span class="line"><span class="keyword">import</span> java.awt.Toolkit;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.DataBufferByte;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.WritableRaster;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacpp.BytePointer;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacpp.Loader;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacpp.avcodec;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacpp.opencv_highgui;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacpp.opencv_core.IplImage;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.CanvasFrame;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.Frame;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FrameGrabber;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FrameGrabber.Exception;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FrameRecorder;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.Java2DFrameConverter;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.OpenCVFrameConverter;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.OpenCVFrameConverter.ToIplImage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.service.VideoService;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JavacvAudioTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**bufferedImage to IplImage 的转化*/</span></span><br><span class="line">public static IplImage toIplImage(BufferedImage bufImage) &#123;</span><br><span class="line">    ToIplImage iplConverter = <span class="keyword">new</span> OpenCVFrameConverter.ToIplImage();</span><br><span class="line">    Java2DFrameConverter java2dConverter = <span class="keyword">new</span> Java2DFrameConverter();</span><br><span class="line">    IplImage iplImage = iplConverter.convert(java2dConverter.convert(bufImage));</span><br><span class="line">    <span class="keyword">return</span> iplImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 推送/录制本机的音/视频(Webcam/Microphone)到流媒体服务器(Stream media server)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param WEBCAM_DEVICE_INDEX</span></span><br><span class="line"><span class="comment"> *            - 视频设备，本机默认是0</span></span><br><span class="line"><span class="comment"> * @param AUDIO_DEVICE_INDEX</span></span><br><span class="line"><span class="comment"> *            - 音频设备，本机默认是4</span></span><br><span class="line"><span class="comment"> * @param outputFile</span></span><br><span class="line"><span class="comment"> *            - 输出文件/地址(可以是本地文件，也可以是流媒体服务器地址)</span></span><br><span class="line"><span class="comment"> * @param captureWidth</span></span><br><span class="line"><span class="comment"> *            - 摄像头宽</span></span><br><span class="line"><span class="comment"> * @param captureHeight</span></span><br><span class="line"><span class="comment"> *            - 摄像头高</span></span><br><span class="line"><span class="comment"> * @param FRAME_RATE</span></span><br><span class="line"><span class="comment"> *            - 视频帧率:最低 25(即每秒25张图片,低于25就会出现闪屏)</span></span><br><span class="line"><span class="comment"> * @throws org.bytedeco.javacv.FrameGrabber.Exception</span></span><br><span class="line"><span class="comment"> * @throws org.bytedeco.javacv.FrameRecorder.Exception </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public static CanvasFrame recordWebcamAndMicrophone(int WEBCAM_DEVICE_INDEX, final int AUDIO_DEVICE_INDEX, String outputFile,</span><br><span class="line">int captureWidth, int captureHeight, final int FRAME_RATE) throws org.bytedeco.javacv.FrameGrabber.Exception, org.bytedeco.javacv.FrameRecorder.Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.录制自己的小窗口进行隐藏，不能有声音</span></span><br><span class="line"><span class="comment"> * 2.将录制屏的不显示出来</span></span><br><span class="line"><span class="comment"> * 4.即通过录制屏将小窗口一起进行录制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//JavacAudioTest.recordWebcamAndMicrophone2(0, 4,"output.mp4", 100, 100,25);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 获取显示器</span><br><span class="line">long startTime = <span class="number">0</span>;</span><br><span class="line">long videoTS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 获取当前屏幕大小</span></span><br><span class="line"><span class="regexp">Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();</span></span><br><span class="line"><span class="regexp">captureWidth=(int)screenSize.getWidth();</span></span><br><span class="line"><span class="regexp">captureHeight=(int)screenSize.getHeight();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 指定捕获屏幕区域大小，这里使用全屏捕获</span><br><span class="line">Rectangle rectangle = <span class="keyword">new</span> Rectangle(screenSize);</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 本地环境</span></span><br><span class="line"><span class="regexp">GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 获取本地屏幕设备列表</span><br><span class="line">GraphicsDevice[] gs = ge.getScreenDevices();</span><br><span class="line">System.err.println(<span class="string">"eguid温馨提示，找到"</span> + gs.length + <span class="string">"个屏幕设备"</span>);</span><br><span class="line"><span class="regexp">// 目的：取到本地屏幕设备当中可以进行获取本地屏幕的设备下标</span></span><br><span class="line"><span class="regexp">//</span> 通过robot可以实例化该获取本地屏幕的设备，大概就是这意思，</span><br><span class="line"><span class="regexp">// 先令该robot机器设置为null,也就是类似于foreach当中的一个变量，所以是不能够放在循环里面的</span></span><br><span class="line"><span class="regexp">//</span> 去循环遍历该本地屏幕设备列表当中的所有设备，即数组gs，通过下标取出数组当中的该元素来进行实例化robot对象</span><br><span class="line"><span class="regexp">// 如果存在数组当中有一个下标所对应的元素实例化了robot对象后，</span></span><br><span class="line"><span class="regexp">//</span> 可以让robot对象切实的获取得到本地屏幕的缓冲图片，且该缓冲图片不为空，并且宽大于<span class="number">0</span></span><br><span class="line"><span class="regexp">// 即说明该下标所对应在数组当中的该元素即，就是我们所需要寻找的设备</span></span><br><span class="line"><span class="regexp">Robot robot = null;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> -<span class="number">1</span> 猜测：极有可能说的是没有这种可以获取本地屏幕的设备</span><br><span class="line">int ret = -<span class="number">1</span>;</span><br><span class="line">BufferedImage img=<span class="literal">null</span>;</span><br><span class="line"><span class="regexp">// 进行本地屏幕设备数组列表的循环</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">for (int index = 0; index &lt; 10; index++) &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 从本地屏幕设备列表当中进行一一取出屏幕设备</span><br><span class="line">GraphicsDevice g = gs[index];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 通过robot来进行生成该种获取本地屏幕的机器设备</span></span><br><span class="line"><span class="regexp">robot = new Robot(g);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 通过该可以获取本地屏幕的机器设备来进行生成本地屏幕，也就是显示器图片</span><br><span class="line"> img = robot.createScreenCapture(rectangle);</span><br><span class="line"></span><br><span class="line"> <span class="regexp">// 判断如果该图片如果不为空的话，并且该图片大于1，也就说明该图片是存在的，有一定宽度，而并不是宽为0，宽为0，即说明该并不是图片了</span></span><br><span class="line"><span class="regexp">if (img != null &amp;&amp; img.getWidth() &gt; 1) &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 获取得到该机器设备的下标，并赋值给ret</span><br><span class="line">ret = index;</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 当下打断循环，跳出，找到该种设备之后立即打断循环，提高效率</span></span><br><span class="line"><span class="regexp">break;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125; catch (AWTException e) &#123;</span></span><br><span class="line"><span class="regexp">System.err.println("打开第" + index + "个屏幕设备失败，尝试打开第" + (index + 1) + "个屏幕设备");</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>/</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FrameGrabber 类包含：OpenCVFrameGrabber</span></span><br><span class="line"><span class="comment"> * (opencv_videoio),C1394FrameGrabber, FlyCaptureFrameGrabber,</span></span><br><span class="line"><span class="comment"> * OpenKinectFrameGrabber,PS3EyeFrameGrabber,VideoInputFrameGrabber, 和</span></span><br><span class="line"><span class="comment"> * FFmpegFrameGrabber.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*OpenCVFrameGrabber grabber = new OpenCVFrameGrabber(WEBCAM_DEVICE_INDEX);</span></span><br><span class="line"><span class="comment">grabber.setImageWidth(captureWidth);</span></span><br><span class="line"><span class="comment">grabber.setImageHeight(captureHeight);</span></span><br><span class="line"><span class="comment">System.out.println("开始抓取摄像头...");</span></span><br><span class="line"><span class="comment">int isTrue = 0;// 摄像头开启状态</span></span><br><span class="line"><span class="comment">try &#123;</span></span><br><span class="line"><span class="comment">grabber.start();</span></span><br><span class="line"><span class="comment">isTrue += 1;</span></span><br><span class="line"><span class="comment">&#125; catch (org.bytedeco.javacv.FrameGrabber.Exception e2) &#123;</span></span><br><span class="line"><span class="comment">if (grabber != null) &#123;</span></span><br><span class="line"><span class="comment">try &#123;</span></span><br><span class="line"><span class="comment">grabber.restart();</span></span><br><span class="line"><span class="comment">isTrue += 1;</span></span><br><span class="line"><span class="comment">&#125; catch (org.bytedeco.javacv.FrameGrabber.Exception e) &#123;</span></span><br><span class="line"><span class="comment">isTrue -= 1;</span></span><br><span class="line"><span class="comment">try &#123;</span></span><br><span class="line"><span class="comment">grabber.stop();</span></span><br><span class="line"><span class="comment">&#125; catch (org.bytedeco.javacv.FrameGrabber.Exception e1) &#123;</span></span><br><span class="line"><span class="comment">isTrue -= 1;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if (isTrue &lt; 0) &#123;</span></span><br><span class="line"><span class="comment">System.err.println("摄像头首次开启失败，尝试重启也失败！");</span></span><br><span class="line"><span class="comment">return;</span></span><br><span class="line"><span class="comment">&#125; else if (isTrue &lt; 1) &#123;</span></span><br><span class="line"><span class="comment">System.err.println("摄像头开启失败！");</span></span><br><span class="line"><span class="comment">return;</span></span><br><span class="line"><span class="comment">&#125; else if (isTrue == 1) &#123;</span></span><br><span class="line"><span class="comment">System.err.println("摄像头开启成功！");</span></span><br><span class="line"><span class="comment">&#125; else if (isTrue == 1) &#123;</span></span><br><span class="line"><span class="comment">System.err.println("摄像头首次开启失败，重新启动成功！");</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 本机摄像头默认<span class="number">0</span>，这里使用javacv的帧抓取器，至于使用的是ffmpeg还是opencv，请自行查看源码</span><br><span class="line">FrameGrabber grabber = FrameGrabber.createDefault(ret);</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 开启抓取器</span></span><br><span class="line"><span class="regexp">grabber.start();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 播放窗口的设置</span><br><span class="line">System.err.println(<span class="string">"打开的屏幕序号："</span> + ret);</span><br><span class="line"></span><br><span class="line"><span class="regexp">// javacv提供的图像展现窗口</span></span><br><span class="line"><span class="regexp">//</span> title 颜色的校正值</span><br><span class="line">CanvasFrame frame = <span class="keyword">new</span> CanvasFrame(<span class="string">"camera"</span>, CanvasFrame.getDefaultGamma() / grabber.getGamma());</span><br><span class="line"></span><br><span class="line">int width = <span class="number">800</span>;</span><br><span class="line">int height = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 窗口居中</span></span><br><span class="line"><span class="regexp">frame.setBounds((int) (screenSize.getWidth() - width) / 2, (int) (screenSize.getHeight() - height) / 2, width, height);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 设置CanvasFrame窗口大小</span><br><span class="line">frame.setCanvasSize(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//frame.setVisible(false);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 转换器的获取以及配置</span><br><span class="line">OpenCVFrameConverter.ToIplImage converter = <span class="keyword">new</span> OpenCVFrameConverter.ToIplImage();</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 转换器通过抓取器grabber获取当前Frame进行来获取得到IplImage</span></span><br><span class="line"><span class="regexp">//</span> 抓取一帧视频并将其转换为图像，至于用这个图像用来做什么？加水印，人脸识别等等自行添加</span><br><span class="line">IplImage grabbedImage = converter.convert(grabber.grab());</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 通过当前视频直播放映内容的存储地址以及当前视频直播放映界面的大小来进行创建视频记录器，也就是界面的记录</span></span><br><span class="line"><span class="regexp">final FrameRecorder recorder = FrameRecorder.createDefault(outputFile, width, height);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 设置该视频记录器的编码，即将视频直播的流进行编码，也就是直播流/推流进行编码</span><br><span class="line"><span class="regexp">// avcodec.AV_CODEC_ID_H264，编码</span></span><br><span class="line"><span class="regexp">recorder.setVideoCodec(avcodec.AV_CODEC_ID_H264);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 设置记录器的记录视频的格式</span><br><span class="line"><span class="regexp">// 封装格式，如果是推送到rtmp就必须是flv封装格式</span></span><br><span class="line"><span class="regexp">recorder.setFormat("flv");</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 设置记录器的记录视频的速率</span><br><span class="line">recorder.setFrameRate(FRAME_RATE);</span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FFmpegFrameRecorder(String filename, int imageWidth, int imageHeight, int audioChannels) </span></span><br><span class="line"><span class="comment"> * fileName可以是本地文件（会自动创建），也可以是RTMP路径（发布到流媒体服务器）</span></span><br><span class="line"><span class="comment"> * imageWidth = width （为捕获器设置宽） </span></span><br><span class="line"><span class="comment"> * imageHeight = height （为捕获器设置高）</span></span><br><span class="line"><span class="comment"> * audioChannels = 2（立体声）；1（单声道）；0（无音频）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="regexp">//final FFmpegFrameRecorder recorder = new FFmpegFrameRecorder(outputFile, captureWidth, captureHeight, 2);</span></span><br><span class="line"><span class="regexp">recorder.setInterleaved(true);</span></span><br><span class="line"><span class="regexp">recorder.setAudioChannels(2);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/**</span></span><br><span class="line"><span class="regexp"> * 该参数用于降低延迟 参考FFMPEG官方文档：https://</span>trac.ffmpeg.org/wiki/StreamingGuide</span><br><span class="line"> * 官方原文参考：ffmpeg -f dshow -i video=<span class="string">"Virtual-Camera"</span> -vcodec libx264</span><br><span class="line"> * -tune zerolatency -b <span class="number">900k</span> -f mpegts udp:<span class="regexp">//10.1.0.102:1234</span></span><br><span class="line"><span class="regexp"> */</span></span><br><span class="line"><span class="regexp">recorder.setVideoOption("tune", "zerolatency");</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/**</span></span><br><span class="line"><span class="regexp"> * 权衡quality(视频质量)和encode speed(编码速度) values(值)：</span></span><br><span class="line"><span class="regexp"> * ultrafast(终极快),</span></span><br><span class="line"><span class="regexp"> * superfast(超级快),</span></span><br><span class="line"><span class="regexp"> * veryfast(非常快), </span></span><br><span class="line"><span class="regexp"> * faster(很快), </span></span><br><span class="line"><span class="regexp"> * fast(快),</span></span><br><span class="line"><span class="regexp"> * medium(中等), </span></span><br><span class="line"><span class="regexp"> * slow(慢), </span></span><br><span class="line"><span class="regexp"> * slower(很慢), </span></span><br><span class="line"><span class="regexp"> * veryslow(非常慢)</span></span><br><span class="line"><span class="regexp"> * ultrafast(终极快)提供最少的压缩（低编码器CPU）和最大的视频流大小；</span></span><br><span class="line"><span class="regexp"> * 而veryslow(非常慢)提供最佳的压缩（高编码器CPU）的同时降低视频流的大小</span></span><br><span class="line"><span class="regexp"> * 参考：https://</span>trac.ffmpeg.org/wiki/Encode/H.<span class="number">264</span> 官方原文参考：-preset ultrafast</span><br><span class="line"> * as the name implies provides <span class="keyword">for</span> the fastest possible encoding. If</span><br><span class="line"> * some tradeoff between quality <span class="keyword">and</span> encode speed, go <span class="keyword">for</span> the speed.</span><br><span class="line"> * This might be needed <span class="keyword">if</span> you are going <span class="keyword">to</span> be transcoding multiple</span><br><span class="line"> * streams <span class="literal">on</span> one machine.</span><br><span class="line"> */</span><br><span class="line">recorder.setVideoOption(<span class="string">"preset"</span>, <span class="string">"ultrafast"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参考转流命令: ffmpeg</span></span><br><span class="line"><span class="comment"> * -i'udp://localhost:5000?fifo_size=1000000&amp;overrun_nonfatal=1' -crf 30</span></span><br><span class="line"><span class="comment"> * -preset ultrafast -acodec aac -strict experimental -ar 44100 -ac</span></span><br><span class="line"><span class="comment"> * 2-b:a 96k -vcodec libx264 -r 25 -b:v 500k -f flv 'rtmp://&lt;wowza</span></span><br><span class="line"><span class="comment"> * serverIP&gt;/live/cam0' -crf 30</span></span><br><span class="line"><span class="comment"> * -设置内容速率因子,这是一个x264的动态比特率参数，它能够在复杂场景下(使用不同比特率，即可变比特率)保持视频质量；</span></span><br><span class="line"><span class="comment"> * 可以设置更低的质量(quality)和比特率(bit rate),参考Encode/H.264 -preset ultrafast</span></span><br><span class="line"><span class="comment"> * -参考上面preset参数，与视频压缩率(视频大小)和速度有关,需要根据情况平衡两大点：压缩率(视频大小)，编/解码速度 -acodec</span></span><br><span class="line"><span class="comment"> * aac -设置音频编/解码器 (内部AAC编码) -strict experimental</span></span><br><span class="line"><span class="comment"> * -允许使用一些实验的编解码器(比如上面的内部AAC属于实验编解码器) -ar 44100 设置音频采样率(audio sample</span></span><br><span class="line"><span class="comment"> * rate) -ac 2 指定双通道音频(即立体声) -b:a 96k 设置音频比特率(bit rate) -vcodec libx264</span></span><br><span class="line"><span class="comment"> * 设置视频编解码器(codec) -r 25 -设置帧率(frame rate) -b:v 500k -设置视频比特率(bit</span></span><br><span class="line"><span class="comment"> * rate),比特率越高视频越清晰,视频体积也会变大,需要根据实际选择合理范围 -f flv</span></span><br><span class="line"><span class="comment"> * -提供输出流封装格式(rtmp协议只支持flv封装格式) 'rtmp://&lt;FMS server</span></span><br><span class="line"><span class="comment"> * IP&gt;/live/cam0'-流媒体服务器地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">recorder.setVideoOption(<span class="string">"crf"</span>, <span class="string">"25"</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 2000 kb/s, 720P视频的合理比特率范围</span></span><br><span class="line"><span class="regexp">recorder.setVideoBitrate(2000000);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> h264编/解码器</span><br><span class="line"><span class="regexp">//recorder.setVideoCodec(avcodec.AV_CODEC_ID_H264);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 封装格式flv</span><br><span class="line"><span class="regexp">//recorder.setFormat("flv");</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 视频帧率(保证视频质量的情况下最低<span class="number">25</span>，低于<span class="number">25</span>会出现闪屏)</span><br><span class="line"><span class="regexp">//recorder.setFrameRate(FRAME_RATE);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 关键帧间隔，一般与帧率相同或者是视频帧率的两倍</span><br><span class="line">recorder.setGopSize(FRAME_RATE * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 不可变(固定)音频比特率</span></span><br><span class="line"><span class="regexp">recorder.setAudioOption("crf", "0");</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 最高质量</span><br><span class="line">recorder.setAudioQuality(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 音频比特率</span></span><br><span class="line"><span class="regexp">recorder.setAudioBitrate(192000);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 音频采样率</span><br><span class="line">recorder.setSampleRate(<span class="number">44100</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 双通道(立体声)</span></span><br><span class="line"><span class="regexp">recorder.setAudioChannels(2);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 音频编/解码器</span><br><span class="line">recorder.setAudioCodec(avcodec.AV_CODEC_ID_AAC);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"开始录制..."</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">recorder.start();</span><br><span class="line">&#125; <span class="keyword">catch</span> (org.bytedeco.javacv.FrameRecorder.Exception e2) &#123;</span><br><span class="line"><span class="keyword">if</span> (recorder != <span class="literal">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"关闭失败，尝试重启"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">recorder.stop();</span><br><span class="line">recorder.start();</span><br><span class="line">&#125; <span class="keyword">catch</span> (org.bytedeco.javacv.FrameRecorder.Exception e) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"开启失败，关闭录制"</span>);</span><br><span class="line">recorder.stop();</span><br><span class="line"><span class="keyword">return</span> frame;</span><br><span class="line">&#125; <span class="keyword">catch</span> (org.bytedeco.javacv.FrameRecorder.Exception e1) &#123;</span><br><span class="line"><span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">// 音频捕获</span></span><br><span class="line"><span class="regexp">new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="regexp">@Override</span></span><br><span class="line"><span class="regexp">public void run() &#123;</span></span><br><span class="line"><span class="regexp">/**</span></span><br><span class="line"><span class="regexp"> * 设置音频编码器 最好是系统支持的格式，否则getLine() 会发生错误</span></span><br><span class="line"><span class="regexp"> * 采样率:44.1k;</span></span><br><span class="line"><span class="regexp"> * 采样率位数:16位;</span></span><br><span class="line"><span class="regexp"> * 立体声(stereo);</span></span><br><span class="line"><span class="regexp"> * 是否签名;true:</span></span><br><span class="line"><span class="regexp"> * big-endian字节顺序,false:little-endian字节顺序(详见:ByteOrder类)</span></span><br><span class="line"><span class="regexp"> */</span></span><br><span class="line"><span class="regexp">AudioFormat audioFormat = new AudioFormat(44100.0F, 16, 2, true, false);</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">//</span> 通过AudioSystem获取本地音频混合器信息</span><br><span class="line">Mixer.Info[] minfoSet = AudioSystem.getMixerInfo();</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 通过AudioSystem获取本地音频混合器</span></span><br><span class="line"><span class="regexp">Mixer mixer = AudioSystem.getMixer(minfoSet[AUDIO_DEVICE_INDEX]);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 通过设置好的音频编解码器获取数据线信息</span><br><span class="line">DataLine.Info dataLineInfo = <span class="keyword">new</span> DataLine.Info(TargetDataLine<span class="class">.<span class="keyword">class</span>, <span class="title">audioFormat</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 打开并开始捕获音频</span></span><br><span class="line"><span class="regexp">//</span> 通过line可以获得更多控制权</span><br><span class="line"><span class="regexp">// 获取设备：TargetDataLine line</span></span><br><span class="line"><span class="regexp">//</span> =(TargetDataLine)mixer.getLine(dataLineInfo);</span><br><span class="line">final TargetDataLine line = (TargetDataLine) AudioSystem.getLine(dataLineInfo);</span><br><span class="line"></span><br><span class="line">line.open(audioFormat);</span><br><span class="line"></span><br><span class="line">line.start();</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 获得当前音频采样率</span></span><br><span class="line"><span class="regexp">final int sampleRate = (int) audioFormat.getSampleRate();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 获取当前音频通道数量</span><br><span class="line">final int numChannels = audioFormat.getChannels();</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 初始化音频缓冲区(size是音频采样率*通道数)</span></span><br><span class="line"><span class="regexp">int audioBufferSize = sampleRate * numChannels;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">final byte[] audioBytes = new byte[audioBufferSize];</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">ScheduledThreadPoolExecutor exec = new ScheduledThreadPoolExecutor(1);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">exec.scheduleAtFixedRate(new Runnable() &#123;</span></span><br><span class="line"><span class="regexp">@Override</span></span><br><span class="line"><span class="regexp">public void run() &#123;</span></span><br><span class="line"><span class="regexp">try &#123;</span></span><br><span class="line"><span class="regexp">//</span> 非阻塞方式读取</span><br><span class="line">int nBytesRead = line.read(audioBytes, <span class="number">0</span>, line.available());</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 因为我们设置的是16位音频格式,所以需要将byte[]转成short[]</span></span><br><span class="line"><span class="regexp">int nSamplesRead = nBytesRead / 2;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">short[] samples = new short[nSamplesRead];</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/**</span></span><br><span class="line"><span class="regexp"> * ByteBuffer.wrap(audioBytes)-将byte[]数组包装到缓冲区</span></span><br><span class="line"><span class="regexp"> * ByteBuffer.order(ByteOrder)-按little-endian修改字节顺序，解码器定义的</span></span><br><span class="line"><span class="regexp"> * ByteBuffer.asShortBuffer()-创建一个新的short[]缓冲区</span></span><br><span class="line"><span class="regexp"> * ShortBuffer.get(samples)-将缓冲区里short数据传输到short[]</span></span><br><span class="line"><span class="regexp"> */</span></span><br><span class="line"><span class="regexp">ByteBuffer.wrap(audioBytes).order(ByteOrder.LITTLE_ENDIAN).asShortBuffer().get(samples);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 将short[]包装到ShortBuffer</span><br><span class="line">ShortBuffer sBuff = ShortBuffer.wrap(samples, <span class="number">0</span>, nSamplesRead);</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 按通道录制shortBuffer</span></span><br><span class="line"><span class="regexp"> ((FFmpegFrameRecorder) recorder).recordSamples(sampleRate, numChannels, sBuff);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125; catch (org.bytedeco.javacv.FrameRecorder.Exception e) &#123;</span></span><br><span class="line"><span class="regexp">e.printStackTrace();</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;, 0, (long) 1000 / FRAME_RATE, TimeUnit.MILLISECONDS);</span></span><br><span class="line"><span class="regexp">&#125; catch (LineUnavailableException e1) &#123;</span></span><br><span class="line"><span class="regexp">e1.printStackTrace();</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;).start();</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//</span></span><br><span class="line"><span class="regexp">//</span> 设置界面的默认关闭操作的方式，即界面退出的时候</span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 设置会让录制视频的窗体一直处于屏幕的最前端，即这个窗口永远会挡住别的窗口，所以录制到的内容也就是整个显示器的内容</span></span><br><span class="line"><span class="regexp">frame.setAlwaysOnTop(true);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 转换器通过进行转化 IplImage图片得到Frame,轮流[按顺序循环];</span><br><span class="line"><span class="regexp">//Frame rotatedFrame = converter.convert(grabbedImage);//</span> 不知道为什么这里不做转换就不能推到rtmp</span><br><span class="line">Frame rotatedFrame=converter.convert(toIplImage(robot.createScreenCapture(rectangle)));</span><br><span class="line"></span><br><span class="line"><span class="regexp">// //</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">///</span></span><br><span class="line"><span class="regexp">//</span> <span class="keyword">while</span>判断视频是否还在继续直播，如果继续的话，那么就显示图片</span><br><span class="line"><span class="keyword">while</span> (frame.isShowing() &amp;&amp; frame.isVisible() &amp;&amp; (grabbedImage = converter.convert(grabber.grab())) != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 从当前屏幕中读取的像素图像，该图像不包括鼠标光标</span></span><br><span class="line"><span class="regexp">BufferedImage image = robot.createScreenCapture(rectangle);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 该界面用以来显示图片</span><br><span class="line"><span class="regexp">//frame.showImage(image);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">///</span></span><br><span class="line"><span class="regexp">//</span> 转换器通过进行转化 IplImage图片得到Frame,轮流[按顺序循环];</span><br><span class="line">rotatedFrame = converter.convert(toIplImage(robot.createScreenCapture(rectangle)));</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 设置该Frame界面当中图为动态的图</span></span><br><span class="line"><span class="regexp">//</span> frame.showImage(rotatedFrame);</span><br><span class="line"><span class="regexp">// 如果开始时间为0，即让开始时间变为当前时间，初始化时间戳</span></span><br><span class="line"><span class="regexp">if (startTime == 0) &#123;</span></span><br><span class="line"><span class="regexp">startTime = System.currentTimeMillis();</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> ((当前时间-视频录制开始的时间)*<span class="number">1000</span>)=从开始到现在的时间差值</span><br><span class="line">videoTS = <span class="number">1000</span> * (System.currentTimeMillis() - startTime);</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 设置视频记录器的时间戳</span></span><br><span class="line"><span class="regexp">//</span>recorder.setTimestamp(videoTS);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//检查偏移量</span></span><br><span class="line"><span class="regexp">if (videoTS &gt; recorder.getTimestamp()) &#123;</span></span><br><span class="line"><span class="regexp">//</span>System.out.println(<span class="string">"Lip-flap correction: "</span> + videoTS + <span class="string">" : "</span> + recorder.getTimestamp() + <span class="string">" -&gt; "</span> + (videoTS - recorder.getTimestamp()));</span><br><span class="line"></span><br><span class="line"><span class="regexp">//告诉录制器写入这个timestamp</span></span><br><span class="line"><span class="regexp">recorder.setTimestamp(videoTS);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span> 设置视频的记录为 转化器通过进行转化IplImage图片得到的Frame，该Frame为轮流的</span><br><span class="line">recorder.record(rotatedFrame);</span><br><span class="line"></span><br><span class="line"><span class="regexp">// //</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>/</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="regexp">// 线程沉睡时间40</span></span><br><span class="line"><span class="regexp">Thread.sleep(40);</span></span><br><span class="line"><span class="regexp">&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="regexp">e.printStackTrace();</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/*//</span> javaCV提供了优化非常好的硬件加速组件来帮助显示我们抓取的摄像头视频</span><br><span class="line">CanvasFrame cFrame = <span class="keyword">new</span> CanvasFrame(<span class="string">"Capture Preview"</span>, CanvasFrame.getDefaultGamma() / grabber.getGamma());</span><br><span class="line">Frame capturedFrame = <span class="literal">null</span>;</span><br><span class="line"><span class="regexp">// 执行抓取（capture）过程</span></span><br><span class="line"><span class="regexp">while ((capturedFrame = grabber.grab()) != null) &#123;</span></span><br><span class="line"><span class="regexp">if (cFrame.isVisible()) &#123;</span></span><br><span class="line"><span class="regexp">//</span>本机预览要发送的帧</span><br><span class="line">cFrame.showImage(capturedFrame);</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//定义我们的开始时间，当开始时需要先初始化时间戳</span></span><br><span class="line"><span class="regexp">if (startTime == 0)</span></span><br><span class="line"><span class="regexp">startTime = System.currentTimeMillis();</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">//</span> 创建一个 timestamp用来写入帧中</span><br><span class="line">videoTS = <span class="number">1000</span> * (System.currentTimeMillis() - startTime);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//检查偏移量</span></span><br><span class="line"><span class="regexp">if (videoTS &gt; recorder.getTimestamp()) &#123;</span></span><br><span class="line"><span class="regexp">System.out.println("Lip-flap correction: " + videoTS + " : " + recorder.getTimestamp() + " -&gt; "</span></span><br><span class="line"><span class="regexp">+ (videoTS - recorder.getTimestamp()));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">//</span>告诉录制器写入这个timestamp</span><br><span class="line">recorder.setTimestamp(videoTS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">// 发送帧</span></span><br><span class="line"><span class="regexp">try &#123;</span></span><br><span class="line"><span class="regexp">recorder.record(capturedFrame);</span></span><br><span class="line"><span class="regexp">&#125; catch (org.bytedeco.javacv.FrameRecorder.Exception e) &#123;</span></span><br><span class="line"><span class="regexp">System.out.println("录制帧发生异常，什么都不做");</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">cFrame.dispose();*/</span></span><br><span class="line"><span class="regexp">try &#123;</span></span><br><span class="line"><span class="regexp">if (recorder != null) &#123;</span></span><br><span class="line"><span class="regexp">recorder.stop();</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125; catch (org.bytedeco.javacv.FrameRecorder.Exception e) &#123;</span></span><br><span class="line"><span class="regexp">System.out.println("关闭录制器失败");</span></span><br><span class="line"><span class="regexp">try &#123;</span></span><br><span class="line"><span class="regexp">if (recorder != null) &#123;</span></span><br><span class="line"><span class="regexp">grabber.stop();</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125; catch (org.bytedeco.javacv.FrameGrabber.Exception e1) &#123;</span></span><br><span class="line"><span class="regexp">System.out.println("关闭摄像头失败");</span></span><br><span class="line"><span class="regexp">return frame;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">try &#123;</span></span><br><span class="line"><span class="regexp">if (recorder != null) &#123;</span></span><br><span class="line"><span class="regexp">grabber.stop();</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125; catch (org.bytedeco.javacv.FrameGrabber.Exception e) &#123;</span></span><br><span class="line"><span class="regexp">System.out.println("关闭摄像头失败");</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">frame.dispose();</span></span><br><span class="line"><span class="regexp">recorder.stop();</span></span><br><span class="line"><span class="regexp">recorder.release();</span></span><br><span class="line"><span class="regexp">grabber.stop();</span></span><br><span class="line"><span class="regexp">return frame;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">public static void main(String[] args) throws Exception, org.bytedeco.javacv.FrameRecorder.Exception, ParseException &#123;</span></span><br><span class="line"><span class="regexp">VideoService videoService = new VideoService();</span></span><br><span class="line"><span class="regexp">String jsonStr = videoService.getPushAddress("Fsn");</span></span><br><span class="line"><span class="regexp">JSONObject json = JSONObject.parseObject(jsonStr);</span></span><br><span class="line"><span class="regexp">recordWebcamAndMicrophone(0, 4, json.getString("PUSH_URL"), 800, 600, 25);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在这当中协助我完成直播功能的博客：&lt;a href=&quot;https://me.csdn.net/eguid_1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://me.csdn.net/eguid_1&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;前期使用了有Red5
      
    
    </summary>
    
    
      <category term="直播" scheme="https://fengshana.github.io/categories/%E7%9B%B4%E6%92%AD/"/>
    
    
      <category term="直播" scheme="https://fengshana.github.io/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
</feed>
