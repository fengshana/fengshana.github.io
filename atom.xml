<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fsn</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fengshana.github.io/"/>
  <updated>2020-04-07T01:16:23.278Z</updated>
  <id>https://fengshana.github.io/</id>
  
  <author>
    <name>Fsn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>串</title>
    <link href="https://fengshana.github.io/2020/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2-05/"/>
    <id>https://fengshana.github.io/2020/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2-05/</id>
    <published>2020-04-07T04:52:56.000Z</published>
    <updated>2020-04-07T01:16:23.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><p><img src="/2020/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2-05/%E4%B8%B2-05.png" alt="串-05"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="串" scheme="https://fengshana.github.io/tags/%E4%B8%B2/"/>
    
      <category term="数据结构" scheme="https://fengshana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列</title>
    <link href="https://fengshana.github.io/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/"/>
    <id>https://fengshana.github.io/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/</id>
    <published>2020-04-05T04:52:56.000Z</published>
    <updated>2020-04-07T01:17:47.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04.png" alt="栈与队列-04"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E5%BC%80%E5%9C%BA%E7%99%BD.png" alt="开场白"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="栈的定义"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="栈的抽象数据类型"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0.png" alt="栈的顺序存储结构及实现"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E4%B8%A4%E6%A0%88%E7%9A%84%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4.png" alt="两栈的共享空间"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0.png" alt="栈的链式存储结构及实现"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E6%A0%88%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="栈的作用"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E9%80%92%E5%BD%92.png" alt="栈的应用-递归"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.png" alt="栈的应用-四则运算表达式求值"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="队列的定义"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E9%98%9F%E5%88%97%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="队列的抽象数据类型"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png" alt="循环队列"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0.png" alt="队列的链式存储结构及实现"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE.png" alt="总结回顾"></p><p><img src="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97-04/%E7%BB%93%E5%B0%BE%E8%AF%AD.png" alt="结尾语"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈与队列" scheme="https://fengshana.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>社会主义接班人</title>
    <link href="https://fengshana.github.io/2020/04/03/%E9%9A%8F%E7%AC%94/%E6%88%91%E6%98%AF%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%8E%A5%E7%8F%AD%E4%BA%BA/"/>
    <id>https://fengshana.github.io/2020/04/03/%E9%9A%8F%E7%AC%94/%E6%88%91%E6%98%AF%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%8E%A5%E7%8F%AD%E4%BA%BA/</id>
    <published>2020-04-03T11:52:56.000Z</published>
    <updated>2020-04-03T11:13:32.350Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>帮我妹改改作文。</p></blockquote><p>主题：灾害到来时我该怎么做</p><ol><li>身份：新时代的青年人，是社会建设和国家发展的接班人</li><li>态度：勇敢面对，承担使命</li><li>方向：针对新冠疫情；视角要宽；</li><li>人群：90,00代的突出表现和感人事迹</li></ol><p>面临黑暗，我向阳光</p><p>  汽车的鸣笛，街道的喧闹。<br>  在蓝天白云下，在灿阳照射下，看似和谐美好的生活，也有阳光穿不透的黑暗，<br>  他们在黑暗里肆意欢笑，趁人不注意，便将罪恶的双手伸向人们，<br>  他们在变态心理的引导下剥夺了人爱阳光照耀的机会，<br>  将人无情地拉进黑暗。</p><p>  黑暗就如病毒，如同冠状病毒，从天而降，肆意传播，于是将人们的天空浸染成了黑色，<br>  雨水冲刷着人们的双眼。但总会有阳光，哪怕只剩一缕，他也会穿过乌云照向大地。<br>  新闻中不断播的着“巨婴”的行为，可以说是个反面教材了，<br>  在面对危险时，他们慌乱了手脚，将内心底的自私播出来给人们看，<br>  像跳梁小丑，引人发笑。当医生带着阳光冲向黑暗，“巨婴”们手里拿着盾牌，却站反了方向。<br>  我们理应相信那一缕阳光，将我们内心的力量融合，为医生助力。</p><p>  黑暗也如同恐惧心理，覆压人的心灵，痛打着人们的躯体，凌辱了人的自尊，却仍在暗自偷笑。<br>  校园暴力给人带来的伤痛往往是比身体的疼痛更令人刻骨铭心。<br>  但总有强大心灵带着阳光，即使”身在井隅”，却仍然”心向璀璨”。<br>  冰冷的法律中出现裂痕，投进去了温暖，扫黑，禁止校园暴力的法律的颁布，<br>  在这个社会，让人们走在街道上，没有胆怯。我们主动站出来打击黑恶势力，将力量团结在一起。<br>  黑暗骑士也没有那么可怕。</p><p>  我想阳光的力量一定可以战胜黑暗，我想，抬头暖阳春草，用拥抱将黑暗消融。<br>  阳光会穿过茂密的树枝，穿过乱窜的树枝，知道最后，千缕阳光冲破黑来前来拥抱我。</p><p>  ======================================================================</p><h2 id="面临黑暗，我向阳光"><a href="#面临黑暗，我向阳光" class="headerlink" title="面临黑暗，我向阳光"></a>面临黑暗，我向阳光</h2><p>“等到黑夜翻面之后，会是新的白昼；<br>等到海啸退去之后，只是潮起潮落；<br>别到最后你才发觉，心里头的野兽，还没到最终就已经罢休；<br>心脏没有那么脆弱，总还会有执着；<br>人生不会只有收获，总难免有伤口；<br>不要害怕生命中，不完美的角落；<br>阳光在每个裂缝中散落，不如就勇敢打破生命中的裂缝，阳光就逐渐洒满了其中。”<br>——题记</p><p>2019的尾巴到2020的开端，甚至更甚。<br>爆发的新冠状病毒，在这场看不见硝烟的抗疫战争中告诉我们，<br>这不仅仅是一场我们巍巍中华人民需要迎接且不能退缩的挑战，这更是让我们泱泱华夏子孙心与心贴在了一起的连线。</p><p>在这场抗疫当中，有着数不清的前线抗疫战士为了这场战争前继后扑。<br>贵州省黔西南州兴义市人民医院的一位呼吸科医生张恩莉争分夺秒，只为更多患者康复；<br>吉林省援鄂医疗队的一位护士长高岚守护生命，坚持到最后胜利；<br>武汉大学人民医院东院区山东医疗队的主治医生郭海鹏用仁心仁术守护生命…</p><p>不仅仅是前线的抗疫战士，就连普普通通老百姓也送上了来自他们的绵薄之力。<br>山东日照一个环卫工人捐了一万二,钱虽然不是很多，但对于他来说却是一个大数目；<br>1月28日，寿光免费赠送了300吨新鲜蔬菜。并且29日起，每天给武汉送600吨平价新鲜蔬菜，持续供应10到15天。截止到2月3日共捐赠1120吨；<br>1月29日，临沂兰陵县捐赠200吨大蒜;<br>1月31日，临沂蔬菜公司原计划捐赠100吨蔬菜，结果这个消息传到了菜农耳朵里又自愿增加60吨，共计160吨;<br>1月31日，金乡捐赠300吨大蒜;<br>2月1日，滕州捐赠66吨马铃薯;<br>2月4日，菏泽8节车厢满载着275吨优质农产品驰援武汉…</p><p>给出力量的不仅仅来自于前线、百姓、企业…<br>也有来自00后，90后那些一度被认为仍处在温室的花朵，也给予了来自他们微弱的力量。</p><p>“阿姨，您的处方单是以前的，药店说需要新的处方单才能开药，请您让主治医师再开一张过来吧”，“叔叔，您要的药没有了，看看这种行不行”，……<br>在武汉市汉阳区晴川街的一家药店，19岁的张玉欣一边跟店主报需求，一边联系居民询问购药的细节，忙的不可开交。<br>张玉欣是武汉本地的“00”后大学生，疫情发生后，她主动到社区报名，成为一名志愿者，主要负责给居民买药送药。<br>“之前有过志愿服务经验，现在我们的城市遇到困难了，我想为家乡人民出一份力。”张玉欣说。<br>张玉欣工作的汉阳晴川街龙灯社区龙灯里小区是一个老旧小区，居民大多是老年人。<br>为了满足居民多样化的用药需求，张玉欣和同事们经常从早跑到晚，遇到一些难买到的药，还得一家家药店去询问，经常饭都来不及吃。<br>“虽然只是跑腿的工作，但有些药对居民来说是‘救命药’，我们必须争分夺秒去买。”张玉欣说。<br>小区居民买高血压、糖尿病等慢性病的药物比较多，有的隔几天就需要再买一次。最多的时候，她一天要买五六十种药品，光排队就要好几个小时。<br>让张玉欣印象最深的是，一天下午，她接到居民求助：一名70多岁的危重症者急需球蛋白。她和同事立即开车外出找药，一家家药店去询问，从汉阳一路搜到汉口，辗转10多家药店，终于在快要天黑时，在一家即将打烊的药店买到了药。<br>当他们把药送到求助居民手中时，对方感动的热泪盈眶。志愿者的辛苦付出，居民都看在眼里。<br>“开始时一些居民不放心，但看到那些买药的居民不仅拿到了急需的药，零钱也一份不少，现在他们都提前写下医保卡密码，放心地交给我们购药”张玉欣欣慰地说。</p><p>“身在无间，心在桃源”。<br>前有武汉汉阳区“00”后志愿者张玉欣为居民买药送药争分夺秒，后有“90”后一线抗疫英雄谢小玉的12小时无私奉献。</p><p>过去有人说他们是娇滴滴的一代，但现在看，他们成了抗疫一线的主力军，不怕苦、不怕牺牲。抗疫一线比其他地方更能考验人。”<br>3月10日，习近平总书记来到武汉市东湖新城社区考察。听完社区志愿者代表、中国矿业大学(北京)大二学生谢小玉的工作汇报后，总书记深有感触地说。<br>　　受到总书记的肯定和鼓励，谢小玉工作起来更有干劲了。这名社区第一批参加志愿服务、唯一的大学生志愿者，已经在30栋楼值守一个多月。日前，记者来到东湖新城社区，感受了谢小玉忙碌的一天。<br>　　上午9点——主动上门问需求。<br>　　趁着上午9点物资尚未送达的待命时刻，谢小玉看望了住在30栋楼15层的80多岁的周奶奶。<br>　　“奶奶，降压药够吗?燃气卡要充值吗?”“小玉来啦，放心，都够用。”周奶奶感动地说，有一次为了帮她买降压药，谢小玉连跑了3家药店。<br>　　因为老人家不会用手机、腿脚又不方便，谢小玉就特别关心周奶奶。“周奶奶第一次接电话时，看到是陌生的手机号码，以为遇到了骗子，熟悉了以后，周奶奶经常主动打电话找我谈心。”她说，以前连对门邻居都不熟悉，这段时间却认识了很多社区邻居，有些人还给她送防护物资。<br>　　服务200多户居民不是简单事。单从买药来说，居民对生产厂家、品牌型号都有特殊要求。有时候她和其他志愿者连“逛”几天药店，才能买到某种指定的药。<br>　　上午10点——大箱小箱送快递。<br>　　“我的顺丰快递到南门了。”上午10点，30栋楼1单元一位居民在群里求助志愿者，谢小玉看到后立刻起身。<br>　　取快递是志愿者的日常工作，30栋楼离社区南门最远，来回一趟要十几分钟。一上午谢小玉就帮居民取了4次快递，看到她气喘吁吁地抱着大箱小箱，其他志愿者连忙帮她找推车。“没事，这几天，我的力气都锻炼大了。”谢小玉说。<br>　　“快递业务是从2月下旬开始逐渐增多的，最忙时一天要跑十几趟，一批快递在南门，一批在社区服务站前，收到居民通知就得赶紧取走、避免堆积。”谢小玉介绍说，居民个性化需求比较多，经常会有退换货的情况。<br>　　几天前，谢小玉向一位社区居民借了辆电瓶车。“最近取快递、取货方便多了，但小玉总是把电瓶车给我们用。”一起负责30栋楼的下沉干部毕彪说，谢小玉年纪虽小却很爱照顾人。<br>　　当然，工作中也有不顺心的时候。有一次分快递时，有居民冲她发了火，她哭了。“不只是感到委屈，更多的是觉得自己没做好。”谢小玉不好意思地说，社区工作人员和家人都在鼓励她，她也慢慢学会了调整心态。<br>　　下午5点半——挨家挨户发活鱼。<br>　　“团购活鱼到楼下了。”下午5点半，近10份活鱼在灌满清水的塑料袋里活蹦乱跳。谢小玉在群里发出通知，担心有居民没及时看到，她又一家家打电话通知。“谢谢小玉!”不到20分钟，鱼分发完了。随后，她仔细查阅笔记本上的记录，再次确认当天的物资和生活用品是否全部送到，然后继续值班。<br>　　脚踩一双粉色球鞋，外面套着一件红马甲，扎着利落的马尾辫，未满20岁的谢小玉浑身洋溢着青春的活力。她原本计划今年寒假和家人出去旅游过年，“虽然旅游没成行，但当社区志愿者也挺有意义的。”<br>　　搭档万小强说，小玉上岗时正值2月中旬寒潮来袭，爱心物资大部分是米面油，都特别沉，一周要发三四次。小玉挨家挨户敲门送货，好几次一直从傍晚忙到晚上11点。“这个‘00后’小姑娘一点也不娇气，很坚强，很有责任感。”万小强佩服地说。<br>　　“抗疫一线也是大学，志愿服务就是课堂。社区工作的经历和体验，是我课堂上学不到的。现在，我的承受能力、沟通能力、信息整合能力都增强了。”谢小玉自豪地说。</p><p>阳光会穿过茂密的树枝，投下的那些光影将斑驳这段可歌可泣的岁月，成为这程征途上熠熠生辉的勋章。<br>我知道最后，千万缕阳光会冲破黑暗前来拥抱那些需要握住阳光的人。<br>我想，其实勇敢一点，我们也能手握阳光，给予他人。</p><p>那是一个即将下着雨的午后，<br>早些时候火辣的太阳瞧得人都睁不开眼睛，<br>烤的地铁车厢的壳都想生烟，车窗外的樟树叶子被晒的都好像要反光似的，卟呤卟呤的。<br>得亏地铁中有穿堂风倒是凉快。<br>不过本来身上就发了汗，黏黏糊糊的。<br>风一吹，贴在身上的衣服与皮肉之间倒是分开了，反倒生出一股子燥意。<br>就是一冷一热夹杂搞得人有点头昏脑涨，有点崩溃。<br>说白了，就是有点晕地铁。<br>车上人多的很，一个小小的车厢挤得好像已经腾不出地儿再去容纳更多的人了。<br>周遭放眼望去就是人。<br>戴着耳机听歌看电视的，看新闻的，低头玩手机的，逗孩子乐呵的，打电话的，望向车窗外放空的，喊着借过让道的，也有些观察着别人的人。<br>总之就是人挤人，挨着站一块儿。挤一挤，位置总会有的。<br>充斥在耳旁的声音还有地铁上穿堂而过的风声，那响声绝了，感觉就像是坐在过山车上尖叫声。<br>六月的天说变就变，不过一会儿，车窗外的天空就被就大块黑漆漆的乌云给占地为王了。<br>阴沉沉的，就像考试没考好爸妈的脸色似的，跟锅底有的一拼。跟要下暴雨似的，确是有黑云压城城欲摧的气势。<br>“哕！”<br>天！我一听声音就知道离我不远。我就杵在地铁门口的地儿，估算一下离我也就两个人的距离吧，听着声音倒不像是好事。<br>看向车窗外的视线立马掉转了180度，看向了声源地，准备凑凑热闹。<br>那是一个小男孩，得到我鼻子这么高了。<br>一手捂着口，脸通红着，冒着热汗，又止不住的想要吐。<br>不是想要吐，是止不住的吐，到后面吐到没东西吐了在那里干呕。<br>中午应该是吃了带有火腿肠热狗面包一类的快餐，<br>呕出的酸臭粘液从他指缝中滑过，连着口水丝都掺有一股浓浓的感觉没有消化完全的那股味道，<br>淌了一地的污秽物，红的白的黄的浑浊搅在一起，胆汁都要给吐出来了。<br>真真是惨不忍睹，人间惨剧。<br>旁边站着一位中年女士也是急了眼，手抓着小男孩的衣领骂，伸手拍打了小男孩背部几下，像是在训斥他怎么没有忍住在公共场合给吐了，<br>那小男孩有些不满，有些抵触，又做不得声。<br>该是他的妈妈。<br>那母亲也红了脸，隔着人我都能感觉得到她满脸的尴尬之情，无以言表。<br>她忙的翻了翻挎包，挎包夹层，里里外外找了一通，都没来得及扣好挎包的扣子，又从衣服口袋里翻了翻，没翻出什么东西，又从裤口袋里翻了翻，还是没找着什么。<br>她大概是在找能够清理那些污秽物的东西。<br>我突然发现，整一我在的这节车厢，不，是这小男孩和他母亲所在的这一车厢都安静了很多。<br>地铁上的穿堂风依然呼呼疾行而过，顺路将这节车厢的酸臭味稍稍带去了些许。<br>并且最最最古怪的事是，明明之前还挤得不可开交，现在倒是成了距离那对母子所在范围一两米都没有什么人。<br>他们都捂着口鼻，神色异样，仍在惊异怎么吐了，怎么偏偏在这节车厢吐了，今天可真是倒霉。<br>呕吐物带来的酸臭味让人退避三尺。<br>那对母子希望能有人帮助他们一点点，就一节纸巾或者是一个塑料袋的善意，那一点微末的雪中送炭，却都无人问津。<br>离那对母子最近的一位农民老奶奶颤巍巍的从自己挑的篮子当中找出了个卖菜的那种塑料袋，短小粗糙泛黄的手中递出了她的一点零星善意。<br>“你拿塑料袋盛着”。<br>那母亲连声道谢，一边鞠躬一边道谢，赶紧让那小男孩拿着那塑料袋以免再吐。<br>有了老奶奶递出的那个塑料袋，旁边一些近身旁的人也纷纷从口袋里拿出一包包的纸巾。<br>那母亲一边道谢一边拿着不多的纸巾去擦地铁上小男孩吐的一片狼藉，将那一张张纸一点点包住污秽，然后放到塑料袋里面。<br>但是纸巾依然不够。<br>我知道我今天出门前特意带了卷纸出来了。但我不太好意思拿出来给那母亲用。<br>于是我从包里将卷纸扯了一大长节，再在包里尴尬的折好紧张的递了过去。<br>我朝她笑了笑，她脸仍然是红着，但是已经好些了，也朝我笑了笑，拿过纸巾，怀着歉意拘谨的道谢。<br>狼藉已经被那母亲擦拭得差不多了，小男孩也吐的差不多了，看上去脸色要舒服点了。<br>我又扯了节纸巾折好了递了过去给那小男孩。<br>“可以拿着擦手”。<br>那小男孩摇了摇手，连声道谢说不用。<br>于是我拿着那节纸巾又把手给缩了回来。<br>“要下车的乘客，请您提前做好准备”。<br>地铁停下来的时候，那对母子从我身旁经过，我将那节纸巾准备递给那母亲。<br>“可以拿着擦手”。<br>那母亲提着污秽物的塑料袋，笑笑温婉答道：“不用了，谢谢你”。<br>直到他们下了地铁后，我手里仍有些紧张的拿着那节纸巾，心底突然放松了些，畅快了许多。<br>好像突然晓得”初极狭，才通人，复行数十步，豁然开朗”是个什么滋味儿。<br>地铁上又涌上来了许多人。人依然很挤。<br>嘈杂的声音依然存在着，穿堂风也依然在疾声作响，只是忽然从耳畔淡了下去。<br>车窗外的云好像也没有那么黑了。压的人透不过气的那股子气好像也泄了了下去。<br>而最终，这场疑似暴雨的天气也没有来临。</p><p>我想，其实勇敢一点，他人不仅能获取阳光，或许还能将阳光撒的更远。</p><p>即便是一脚踏空，我也会相信会有人将你扶起；<br>我向上不再会是迷茫，也不再会是抹掉的慌张，而是抬头便是暖阳春草；<br>我向下听见你说这世界不再是空荡荡，而是看见你会伸开双手将我搂住给我拥抱。<br>踩碎了冰冷走过时光，睁开眼你就会听到人间四月芳菲始盛开的声音。</p><p>微笑向暖，清风自来；而面临黑暗，我心向阳光。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;帮我妹改改作文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主题：灾害到来时我该怎么做&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;身份：新时代的青年人，是社会建设和国家发展的接班人&lt;/li&gt;
&lt;li&gt;态度：勇敢面对，承担使命&lt;/li&gt;
&lt;li&gt;方向：针对新冠疫情；
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://fengshana.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="社会主义接班人" scheme="https://fengshana.github.io/tags/%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%8E%A5%E7%8F%AD%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>线性表</title>
    <link href="https://fengshana.github.io/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/"/>
    <id>https://fengshana.github.io/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/</id>
    <published>2020-04-03T10:52:56.000Z</published>
    <updated>2020-04-07T01:17:39.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E7%BA%BF%E6%80%A7%E8%A1%A8-03.png" alt="线性表-03"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AE%9A%E4%B9%89.png" alt="线性表定义"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="线性表的抽象数据类型"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="线性表的顺序存储结构"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4.png" alt="顺序存储结构的插入与删除"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="线性表的链式存储结构"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96.png" alt="单链表的读取"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4.png" alt="单链表的插入与删除"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%9B%E5%BB%BA.png" alt="单链表的整表创建"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4.png" alt="单链表的整表删除"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BC%98%E7%BC%BA%E7%82%B9.png" alt="单链表结构与顺序存储结构优缺点"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8.png" alt="静态链表"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E7%BB%93%E5%B0%BE%E8%AF%AD.png" alt="结尾语"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="循环链表"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表"></p><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8-03/%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE.png" alt="总结回顾"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表" scheme="https://fengshana.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>查找</title>
    <link href="https://fengshana.github.io/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE-08/"/>
    <id>https://fengshana.github.io/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE-08/</id>
    <published>2020-04-03T04:52:56.000Z</published>
    <updated>2020-04-07T01:16:35.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE-08/%E6%9F%A5%E6%89%BE-08.png" alt="查找-08"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="查找" scheme="https://fengshana.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://fengshana.github.io/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F-09/"/>
    <id>https://fengshana.github.io/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F-09/</id>
    <published>2020-04-03T04:52:56.000Z</published>
    <updated>2020-04-07T01:16:45.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F-09/%E6%8E%92%E5%BA%8F-09.png" alt="排序-09"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="https://fengshana.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://fengshana.github.io/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE-07/"/>
    <id>https://fengshana.github.io/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE-07/</id>
    <published>2020-04-03T04:52:56.000Z</published>
    <updated>2020-04-07T01:17:23.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE-07/%E5%9B%BE-07.png" alt="图-07"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图" scheme="https://fengshana.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="https://fengshana.github.io/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91-06/"/>
    <id>https://fengshana.github.io/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91-06/</id>
    <published>2020-04-03T04:52:56.000Z</published>
    <updated>2020-04-07T01:16:54.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><p><img src="/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91-06/%E6%A0%91-06.png" alt="树-06"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://fengshana.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://fengshana.github.io/2020/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95-02/"/>
    <id>https://fengshana.github.io/2020/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95-02/</id>
    <published>2020-04-01T04:52:56.000Z</published>
    <updated>2020-04-07T01:17:27.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><p><img src="/2020/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95-02/%E7%AE%97%E6%B3%95-02.png" alt="算法-02"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://fengshana.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构绪论</title>
    <link href="https://fengshana.github.io/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA-01/"/>
    <id>https://fengshana.github.io/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA-01/</id>
    <published>2020-03-30T04:52:56.000Z</published>
    <updated>2020-04-07T01:17:02.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h2><p><img src="/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA-01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA-01.png" alt="数据结构绪论-01"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构绪论 - 数据结构" scheme="https://fengshana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>面试总结</title>
    <link href="https://fengshana.github.io/2020/03/29/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BB%8A%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://fengshana.github.io/2020/03/29/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BB%8A%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2020-03-29T13:33:56.000Z</published>
    <updated>2020-03-31T15:00:10.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li>自我介绍</li><li>最熟悉的一个项目进行介绍</li><li>多线程（Thread与Runnable的不同）</li><li>重构从哪些地方入手</li><li>索引优化</li><li>为什么红黑树快，二进制为什么快（底层操作系统）</li><li>描述下计算机的底层原理</li><li>SpringBoot统一异常处理机制</li><li>SpringBoot的AOP、IOC流程，以及简单实现</li><li>SpringBoot的注解@Autowired,@Resource实现原理</li><li>Spring当中Bean的实现流程</li><li>HashMap当中红黑树为什么需要左旋右旋</li><li>Redis缓存击穿，缓存穿透，雪崩</li><li>分布式相关知识点</li><li>时间空间复杂度，O(n),二叉搜索树O(logn)</li><li>如何看待加班</li><li>SpringBoot当中事务实现</li><li>Redis底层进制实现，为什么Redis性能高</li><li>使用过哪些锁机制，有哪些锁</li><li>邮件服务，通过多线程，邮件没有发送成功如何处理</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;自我介绍&lt;/li&gt;
&lt;li&gt;最熟悉的一个项目进行介绍&lt;/li&gt;
&lt;li&gt;多线程（Thread与Runnable的不同）&lt;
      
    
    </summary>
    
    
      <category term="面试总结" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="面试总结" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>时序图测试</title>
    <link href="https://fengshana.github.io/2020/03/26/%E9%9D%A2%E8%AF%95%E9%A2%98/testMd/"/>
    <id>https://fengshana.github.io/2020/03/26/%E9%9D%A2%E8%AF%95%E9%A2%98/testMd/</id>
    <published>2020-03-26T06:21:56.000Z</published>
    <updated>2020-03-25T18:40:13.004Z</updated>
    
    <content type="html"><![CDATA[<p>测试时序图，想看下他转成html之后会不会，也是是这个样子还是只是单纯的只出现code.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 页面加载</span><br><span class="line">e&#x3D;&gt;end: End:&gt;http:&#x2F;&#x2F;www.google.com</span><br><span class="line">op1&#x3D;&gt;operation: get_hotel_ids|past</span><br><span class="line">op2&#x3D;&gt;operation: get_proxy|current</span><br><span class="line">sub1&#x3D;&gt;subroutine: get_proxy|current</span><br><span class="line">op3&#x3D;&gt;operation: save_comment|current</span><br><span class="line">op4&#x3D;&gt;operation: set_sentiment|current</span><br><span class="line">op5&#x3D;&gt;operation: set_record|current</span><br><span class="line"></span><br><span class="line">cond1&#x3D;&gt;condition: ids_remain空?</span><br><span class="line">cond2&#x3D;&gt;condition: proxy_list空?</span><br><span class="line">cond3&#x3D;&gt;condition: ids_got空?</span><br><span class="line">cond4&#x3D;&gt;condition: 爬取成功??</span><br><span class="line">cond5&#x3D;&gt;condition: ids_remain空?</span><br><span class="line"></span><br><span class="line">io1&#x3D;&gt;inputoutput: ids-remain</span><br><span class="line">io2&#x3D;&gt;inputoutput: proxy_list</span><br><span class="line">io3&#x3D;&gt;inputoutput: ids-got</span><br><span class="line"></span><br><span class="line">st-&gt;op1(right)-&gt;io1-&gt;cond1</span><br><span class="line">cond1(yes)-&gt;sub1-&gt;io2-&gt;cond2</span><br><span class="line">cond2(no)-&gt;op3</span><br><span class="line">cond2(yes)-&gt;sub1</span><br><span class="line">cond1(no)-&gt;op3-&gt;cond4</span><br><span class="line">cond4(yes)-&gt;io3-&gt;cond3</span><br><span class="line">cond4(no)-&gt;io1</span><br><span class="line">cond3(no)-&gt;op4</span><br><span class="line">cond3(yes, right)-&gt;cond5</span><br><span class="line">cond5(yes)-&gt;op5</span><br><span class="line">cond5(no)-&gt;cond3</span><br><span class="line">op5-&gt;e</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;测试时序图，想看下他转成html之后会不会，也是是这个样子还是只是单纯的只出现code.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
    
      <category term="时序图" scheme="https://fengshana.github.io/categories/%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
    
    
      <category term="时序图" scheme="https://fengshana.github.io/tags/%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://fengshana.github.io/2020/03/26/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://fengshana.github.io/2020/03/26/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2020-03-25T18:14:56.000Z</published>
    <updated>2020-03-26T02:45:35.292Z</updated>
    
    <content type="html"><![CDATA[<p>最近两天看到了HashMap比较多，包括一致性Hash等。<br>基本的了解了。<br>就是不太晓得红黑树。  </p><p>要是觉得看文档实在觉得不适的话，可以建议先去b站看个视频：<a href="https://www.bilibili.com/video/BV1tE411f7tP?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1tE411f7tP?p=1</a>  </p><p>HashMap源码阅读参考：</p><ul><li><a href="https://ke.qq.com/webcourse/index.html#cid=459141&amp;term_id=100549477&amp;taid=4078067153043845&amp;vid=5285890795538344618" target="_blank" rel="noopener">https://ke.qq.com/webcourse/index.html#cid=459141&amp;term_id=100549477&amp;taid=4078067153043845&amp;vid=5285890795538344618</a>  </li></ul><p>一致性Hash:  </p><ul><li><a href="https://www.bilibili.com/video/av25184175" target="_blank" rel="noopener">https://www.bilibili.com/video/av25184175</a>  </li><li><a href="https://www.cnblogs.com/lpfuture/p/5796398.html" target="_blank" rel="noopener">https://www.cnblogs.com/lpfuture/p/5796398.html</a></li><li>Redis哈希槽：<a href="https://blog.csdn.net/z15732621582/article/details/79121213" target="_blank" rel="noopener">https://blog.csdn.net/z15732621582/article/details/79121213</a></li></ul><p>blog:</p><ul><li><a href="https://www.cnblogs.com/mfrank/p/9227097.html" target="_blank" rel="noopener">https://www.cnblogs.com/mfrank/p/9227097.html</a></li><li><a href="https://blog.csdn.net/carson_ho/article/details/79373026" target="_blank" rel="noopener">https://blog.csdn.net/carson_ho/article/details/79373026</a></li><li><a href="https://blog.csdn.net/carson_ho/article/details/79373134" target="_blank" rel="noopener">https://blog.csdn.net/carson_ho/article/details/79373134</a></li><li><a href="https://www.cnblogs.com/FCWORLD/articles/8504383.html" target="_blank" rel="noopener">https://www.cnblogs.com/FCWORLD/articles/8504383.html</a></li><li><a href="https://www.cnblogs.com/leesf456/p/5242233.html" target="_blank" rel="noopener">https://www.cnblogs.com/leesf456/p/5242233.html</a></li><li><a href="https://www.jianshu.com/p/400f3c019557" target="_blank" rel="noopener">https://www.jianshu.com/p/400f3c019557</a></li></ul><p>打算看完再睡觉。对自己蜜汁自信。  </p><p>Node是TreeNode的爷爷，而且普通节点一般来说也比TreeNode要多。  </p><ul><li>红黑树介绍</li><li>TreeNode结构</li><li>树化的过程</li><li>红黑树的左旋和右旋</li><li>TreeNode的左旋和右旋</li><li>红黑树的插入</li><li>TreeNode的插入</li><li>红黑树的删除</li><li>TreeNode的删除</li></ul><p>理论部分：红黑树部分<br>代码实践部分：TreeNode部分  </p><p>好饿啊。  </p><h2 id="红黑树介绍"><a href="#红黑树介绍" class="headerlink" title="红黑树介绍"></a>红黑树介绍</h2><blockquote><p>什么是树？  </p></blockquote><p> <img src="https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180625235951335-1438523857.jpg" alt="image"></p><ul><li>A~H 都是树的节点，每个节点有零个或者多个子节点，或者说多个孩子。</li><li>但是除根节点以外，每个节点都只有一个父节点，也称只要一个父亲。</li><li>最上面的A是根节点，最下面的D、H、F、G是叶子节点。</li><li>每一个非根节点【有且只有】一个父节点；</li><li>树是具有【一层一层】的【层次】结构；</li><li>这里A位于第一层，B、C位于第二层，D、E、F、G位于第三层，H位于第四层。以此类推。</li><li>将左边的B节点部分（包括BDEH）拿出来，则又是一棵树，称为树的子树。</li></ul><blockquote><p>什么是二叉搜索树？</p></blockquote><p> <img src="https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180626005359234-143383116.jpg" alt="image"></p><ul><li>二叉代表他的节点最多有两个子节点; 而且左右有顺序，不能颠倒，分别叫左孩子和右孩子；这两个节点互成为兄弟节点。</li><li>4、9互为兄弟，7是他们的父亲，9是2的叔叔，8是2的堂兄弟。</li><li>既然叫做搜索树，表示它的用途是为了【更快的搜索和查找】而设计的，所以这棵树本身满足【一定的排序规则】，即数组的【任何节点的值大于它的左孩子，且小于它的右孩子】。</li><li>任意节点的左、右子树也分别为二叉查找树。</li></ul><blockquote><p>什么是红黑树？  </p></blockquote><p> <img src="https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180626004222951-1996840383.jpg" alt="image"></p><ul><li>红黑树，本质上来说是一棵二叉搜索树。</li><li>红黑树，就跟他的名字一样，又红又黑，红黑并进，理实交融，【节点是非红即黑的】。</li></ul><h3 id="红黑树的主要特性"><a href="#红黑树的主要特性" class="headerlink" title="红黑树的主要特性"></a>红黑树的主要特性</h3><ol><li>每个节点要么是黑色，要么是红色。（节点非黑继红）</li><li>根节点是黑色的。</li><li>每个叶子节点（NIL）是黑色。</li><li>如果一个节点是红色的，则它的子节点必须是黑色的。（也就是说父子节点不能同时为红色）</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（这一点是平衡的关键）</li></ol><p>其实就是一棵比较平衡的又红又黑的二叉树。  </p><h4 id="TreeNode结构"><a href="#TreeNode结构" class="headerlink" title="TreeNode结构"></a>TreeNode结构</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">用于Tree bins的Entry.</span></span><br><span class="line"><span class="comment">扩展LinkedHashMap.Entry(进而扩展Node)，</span></span><br><span class="line"><span class="comment">因此可以用作常规节点或链接节点的扩展</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span></span>&#123;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;<span class="comment">//红黑树父节点</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;<span class="comment">//红黑树左节点？</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;<span class="comment">//红黑树右节点？</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;<span class="comment">//红黑树前一节点，删除后需要取消链接</span></span><br><span class="line">    boolean red;<span class="comment">//是否为红色，是否为红节点</span></span><br><span class="line">    <span class="comment">//构建TreeNode所需参数</span></span><br><span class="line">    <span class="type">TreeNode</span>(int hash,<span class="type">K</span> key,<span class="type">V</span> <span class="keyword">val</span>,<span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next)&#123;</span><br><span class="line">      <span class="keyword">super</span>(hash,key,<span class="keyword">val</span>,next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//省略后续代码</span></span><br></pre></td></tr></table></figure><p>TreeNode继承自LinkedHashMap中的内部类——-LinkedHashMap.Entry.<br>而这个内部类又继承自Node，所以算是Node的孙子辈了。  </p><p>属性：</p><ul><li>parent 用来指向他的父节点。</li><li>left 指向左孩子。</li><li>right 指向右孩子。</li><li>prev 则指向前一节点（原链表中的前一个节点）</li></ul><p>注意，这些字段跟Entry，Node中的字段是一样的，是使用默认访问权限的，所以子类可以直接使用父类的属性。</p><h4 id="树化的过程"><a href="#树化的过程" class="headerlink" title="树化的过程"></a>树化的过程</h4><p>当HashMap桶中的元素个数超过一定数量时，就会树化，也就是将链表转化为红黑树的结构。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法===》调用putVal方法</span></span><br><span class="line"> <span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(<span class="built_in">key</span>), <span class="built_in">key</span>, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现hashMap的put操作</span></span><br><span class="line">    <span class="keyword">final</span> V putVal(<span class="built_in">int</span> hash, K <span class="built_in">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent,</span><br><span class="line">                   <span class="built_in">boolean</span> evict) &#123;</span><br><span class="line">        ...省略部分代码...</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//当桶中元素个数超过阈值（8）时就进行树化</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">         ...省略部分代码...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树的具体实现方式（重点）"><a href="#红黑树的具体实现方式（重点）" class="headerlink" title="红黑树的具体实现方式（重点）"></a>红黑树的具体实现方式（重点）</h2><p>在JDK1.8 HashMap中，转换为红黑树大致分为三个步骤  </p><ol><li>第一阶段：将链表转化为二叉树</li><li>第二节点：验证是否满足红黑树的五大特征</li><li>第三阶段：对二叉树进行左右旋转操作</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将链表转化为二叉树；即tab为链表</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> treeifyBin(Node&lt;K,V&gt;[] tab, <span class="built_in">int</span> hash) &#123;</span><br><span class="line">        <span class="built_in">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">        如果node节点数组为空或者node节点数组的长度小于最小树化容量则进入判断进行初始化该节点数组吧应该是。或者扩容?</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">        对n进行赋值为链表的长度</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">        */</span></span></span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">        key根据算法算出得到hash,</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">        然后通过(n - 1) &amp; hash进行得到下标index位置，</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">        这里根据(n - 1) &amp; hash得到下标位置index也有一段说辞，</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">        请看视频：https://ke.qq.com/webcourse/index.html#cid=459141&amp;term_id=100549477&amp;taid=4078067153043845&amp;vid=5285890795538344618</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">        此处判断Node节点数组当中的该index下标位置上的Node是否为空</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">        如果不为空则进入判断</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">        */</span></span></span></span><br><span class="line">        <span class="comment">//重新计算hash段位，以及table节点数组的索引位，第一个节点</span></span><br><span class="line">        <span class="comment">//链表长度-1&amp;hash得到index下标取值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">*双向链表 strat*</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span>/</span></span></span><br><span class="line">          <span class="comment">//定义树节点hd为空； 树节点tl为空</span></span><br><span class="line">          <span class="comment">//hd：头节点head；tl: 为节点tail</span></span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                将节点替换为TreeNode</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                循环所有节点；即tab当中的所有Node(Node&lt;K,V&gt; e)</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                获取相对应的树节点p</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                */</span></span></span></span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前尾节点为空则将当前循环的p节点赋值给头结点</span></span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">　　　　　　　　　　　<span class="comment">//hd指向头结点</span></span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                    这里其实是将单链表转化成了双向链表，</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                    tl是p的前驱，</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                    每次循环更新指向双链表的最后一个元素，</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                    用来和p相连，</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                    p是当前节点</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                    */</span></span></span></span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//对尾节点进行赋值为当前树节点</span></span><br><span class="line">                tl = p;</span><br><span class="line"></span><br><span class="line">                <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                如果当前执行完do后执行while,首先进行重新赋值，</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                将e.next下一节点赋值给当前节点e，</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                并判断该节点是否为空;</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                不为空的情况下继续执行否则结束循环；</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">                */</span></span></span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">*双向链表 end*</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span>/</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">            前面仅仅转换为双向链表，treeify才是转换红黑树的处理方法入口;</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">            第一个节点赋值为头结点，也就是根节点</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">            查询链表当中是否存在头结点hd，如果不为空存在的话即验证</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">            */</span></span></span></span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//将链表进行树化；将二叉树转换为红黑树；</span></span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在treeifyBin函数中，先将所有节点替换为TreeNode，然后再将单链表转为双链表，方便之后的遍历和移动操作。<br>而最终的操作，实际上是调用了TreeNode的方法treeify进行的</p><p>看这些代码让我看得怀疑人生。仿佛又回到了当年的数学课。  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//树化</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">调用这个方法之前，也就是一个双向链表</span></span><br><span class="line"><span class="comment">初始进入值为 this头结点</span></span><br><span class="line"><span class="comment">将双向链表转换为红黑树</span></span><br><span class="line"><span class="comment">目标：查询root节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">验证是否满足红黑树的五大特征</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">final void treeify(Node&lt;K,V&gt;<span class="literal">[]</span> tab) &#123;</span><br><span class="line">            <span class="comment">//树的根节点；初始化为空；root节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; root = null;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//x是当前节点，next是后继</span></span><br><span class="line">            <span class="comment">//这里的this是树转换数组索引处的第一个链表元素</span></span><br><span class="line">            for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//next 当前节点的下一个节点，对next节点进行重新赋值</span></span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置左右节点为空</span></span><br><span class="line">                x.left = x.right = null;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果根节点为null，把当前节点设置为根节点</span></span><br><span class="line">                <span class="comment">//首次循环root根节点==null，设置当前循环的x节点为根节点</span></span><br><span class="line">                <span class="comment">//设置根节点特征</span></span><br><span class="line">                <span class="keyword">if</span> (root<span class="operator"> == </span>null) &#123;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//将根节点的父节点位置设置为空；根节点没有父节点</span></span><br><span class="line">                    x.parent = null;</span><br><span class="line">                  <span class="comment">//将根节点设置为black黑色；根节点是黑色的</span></span><br><span class="line">                    x.red = <span class="literal">false</span>;</span><br><span class="line">                  <span class="comment">//将当前节点设置为根节点，根节点重新赋值</span></span><br><span class="line">                    root = x;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果根节点现在不为空则当前的x节点，非根节点</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//当前节点x的键进行赋值给k</span></span><br><span class="line">                  <span class="comment">//获取当前循环节点x的Key</span></span><br><span class="line">                    K k = x.key;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//得到当前该节点x的hash进行赋值给h</span></span><br><span class="line">                    <span class="comment">//获取当前节点x的Hash</span></span><br><span class="line">                    <span class="built_in">int</span> h = x.hash;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//定义key所属于的class</span></span><br><span class="line">                    Class&lt;?&gt; kc = null;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//这里循环遍历，进行二叉搜索树的插入</span></span><br><span class="line">                    <span class="comment">//从根节点开始验证</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    循环这个红黑树，从根节点开始，也就是从上到下进行遍历</span></span><br><span class="line"><span class="comment">                    外层循环树节点也就相当于是Entry[]循环，内部是新建的，</span></span><br><span class="line"><span class="comment">                    外层循环到的当前该节点x也就相当于Entry,与构建的红黑树当中的根节点是否为空进行比较，</span></span><br><span class="line"><span class="comment">                    如果根节点不为空则说明当前遍历的x节点为非根节点，也就是左节点或者右节点，子节点</span></span><br><span class="line"><span class="comment">                    如果根节点为空则使之当前循环遍历到的x节点为根节点</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    for (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        p指向遍历中的当前节点，</span></span><br><span class="line"><span class="comment">                        x为待插入节点，</span></span><br><span class="line"><span class="comment">                        k是x的key，</span></span><br><span class="line"><span class="comment">                        h是x的hash值，</span></span><br><span class="line"><span class="comment">                        ph是p的hash值，</span></span><br><span class="line"><span class="comment">                        dir用来指示x节点与p的比较，</span></span><br><span class="line"><span class="comment">                        -1表示比p小，</span></span><br><span class="line"><span class="comment">                        1表示比p大，</span></span><br><span class="line"><span class="comment">                        不存在相等情况，</span></span><br><span class="line"><span class="comment">                        因为HashMap中是不存在两个key完全一致的情况。</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="built_in">int</span> dir, ph;</span><br><span class="line">                        K pk = p.key;<span class="comment">//每一个节点的key</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        每个节点的hash与外层的x.hash作比较</span></span><br><span class="line"><span class="comment">                        这里做了一个赋值的操作，即当前内部循环当中循环的节点p的hash赋值给了ph;</span></span><br><span class="line"><span class="comment">                        如果当前内部循环的字节点的hash大于外层循环当中x的hash值时，则进行判断其hash大小，</span></span><br><span class="line"><span class="comment">                        通过判断hash大小，</span></span><br><span class="line"><span class="comment">                        从而可以知道节点大致位置，比如在左边还是右边</span></span><br><span class="line"><span class="comment">                        因为(n-1) &amp; hash得到index下标位置</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        dir用来指示x节点与当前内部的p节点的比较，</span></span><br><span class="line"><span class="comment">                        如果dir小于0，沿左路径查找；</span></span><br><span class="line"><span class="comment">                        二叉查找树特征即为：任意节点大于左节点值，小于右节点值；</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                            dir = -<span class="number">1</span>;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        如果dir大于0，则沿右路径查找</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                            dir = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        如果hash值相等，</span></span><br><span class="line"><span class="comment">                        那么判断k是否实现了comparable接口，</span></span><br><span class="line"><span class="comment">                        如果实现了comparable接口就使用compareTo进行进行比较，</span></span><br><span class="line"><span class="comment">                        如果仍旧相等或者没有实现comparable接口，则在tieBreakOrder中比较</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ((kc<span class="operator"> == </span>null &amp;&amp;</span><br><span class="line">                                  (kc = comparable<span class="constructor">ClassFor(<span class="params">k</span>)</span>)<span class="operator"> == </span>null) <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">                                 (dir = compare<span class="constructor">Comparables(<span class="params">kc</span>, <span class="params">k</span>, <span class="params">pk</span>)</span>) <span class="operator">==</span> 0)</span></span><br><span class="line"><span class="pattern-match">                            dir = tie<span class="constructor">BreakOrder(<span class="params">k</span>, <span class="params">pk</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">                        <span class="operator">/</span><span class="operator">/</span>xp节点为内部循环遍历的节点p</span></span><br><span class="line"><span class="pattern-match">                        <span class="operator">/</span><span class="operator">/</span>p设置为x的父节点 xp</span></span><br><span class="line"><span class="pattern-match">                        <span class="constructor">TreeNode</span>&lt;<span class="constructor">K</span>,<span class="constructor">V</span>&gt; xp = p;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">                        <span class="operator">/</span><span class="operator">**</span></span></span><br><span class="line"><span class="pattern-match">                        dir默认为0；</span></span><br><span class="line"><span class="pattern-match">                        所以此处如果dir小于等于0即定义为向左</span></span><br><span class="line"><span class="pattern-match">                        沿左路径查找;</span></span><br><span class="line"><span class="pattern-match">                        如果dir小于等于0取值为内部循环节点p的左节点否则为右节点;</span></span><br><span class="line"><span class="pattern-match">                        对获取得到的该节点进行判空;</span></span><br><span class="line"><span class="pattern-match">                        内部循环也是从上往下循环节点的；</span></span><br><span class="line"><span class="pattern-match">                        所以如果当前内部循环的p节点的左节点或者右节点为空，即进行插入操作</span></span><br><span class="line"><span class="pattern-match">                        <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">                        <span class="keyword">if</span> ((p = (dir &lt;= 0) ? p.left : p.right) <span class="operator">==</span> null) &#123;</span></span><br><span class="line"><span class="pattern-match">                          <span class="operator">/</span><span class="operator">/</span>将xp设置为x的父节点</span></span><br><span class="line"><span class="pattern-match">                            x.parent = xp;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">                            <span class="keyword">if</span> (dir &lt;= 0)</span></span><br><span class="line"><span class="pattern-match">                                xp.left = x;</span></span><br><span class="line"><span class="pattern-match">                            <span class="keyword">else</span></span></span><br><span class="line"><span class="pattern-match">                                xp.right = x;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">　　　　　　　　　　　　　　　　 <span class="operator">/</span><span class="operator">/</span>进行插入平衡处理</span></span><br><span class="line"><span class="pattern-match">                              <span class="operator">/</span><span class="operator">/</span>将二叉树转换为红黑树-正式转换红黑树</span></span><br><span class="line"><span class="pattern-match">                            root = balance<span class="constructor">Insertion(<span class="params">root</span>, <span class="params">x</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">                            break;</span></span><br><span class="line"><span class="pattern-match">                        &#125;</span></span><br><span class="line"><span class="pattern-match">                    &#125;</span></span><br><span class="line"><span class="pattern-match">                &#125;</span></span><br><span class="line"><span class="pattern-match">            &#125;</span></span><br><span class="line"><span class="pattern-match">　　　　　　　<span class="operator">/</span><span class="operator">/</span>确保给定节点是桶中的第一个元素</span></span><br><span class="line"><span class="pattern-match">            move<span class="constructor">RootToFront(<span class="params">tab</span>, <span class="params">root</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">     <span class="operator">/</span><span class="operator">/</span>这里不是为了整体排序，而是为了在插入中保持一致的顺序</span></span><br><span class="line"><span class="pattern-match">     static <span class="built_in">int</span> tie<span class="constructor">BreakOrder(Object <span class="params">a</span>, Object <span class="params">b</span>)</span> &#123;</span></span><br><span class="line"><span class="pattern-match">            <span class="built_in">int</span> d;</span></span><br><span class="line"><span class="pattern-match">            <span class="operator">/</span><span class="operator">/</span>用两者的类名进行比较，如果相同则使用对象默认的hashcode进行比较</span></span><br><span class="line"><span class="pattern-match">            <span class="keyword">if</span> (a <span class="operator">==</span> null <span class="operator">||</span> b <span class="operator">==</span> null <span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">                (d = a.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>.</span></span><br><span class="line"><span class="pattern-match">                 compare<span class="constructor">To(<span class="params">b</span>.<span class="params">getClass</span>()</span>.get<span class="constructor">Name()</span>)) <span class="operator">==</span> 0)</span></span><br><span class="line"><span class="pattern-match">                d = (<span class="constructor">System</span>.identity<span class="constructor">HashCode(<span class="params">a</span>)</span> &lt;= <span class="constructor">System</span>.identity<span class="constructor">HashCode(<span class="params">b</span>)</span> ?</span></span><br><span class="line"><span class="pattern-match">                     -1 : 1);</span></span><br><span class="line"><span class="pattern-match">            return d;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br></pre></td></tr></table></figure><p>这里的逻辑其实并不复杂，仅仅是循环遍历当前树，然后找到可以该节点可以插入的位置，依次和遍历节点比较，比他大则跟其右孩子比较，小则与其左孩子比较，依次遍历，直到找到左孩子或者右孩子为null的位置进行插入。  </p><p>真正复杂一点的地方在于balanceInsertion函数，这个函数，后欧诺个黑叔进行插入平衡处理，保证插入节点后仍保持红黑树性质。  </p><p>这个函数稍后在TreeNode的插入中进行介绍，这里先看moveRootToFront,这个函数是将root节点移动到同种的第一个元素，也就是链表的首节点，这样做是因为在判断同种元素类型的时候会对链表进行遍历，将根节点移动到链表前端可以确保类型判断时不会出现错误。</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 把给定节点设为桶中的第一个元素</span><br><span class="line"> */        </span><br><span class="line">    static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果根节点不为空以及树节点数组不为空以及树节点数组长度大于0</span></span><br><span class="line">            if (root != <span class="built_in">null</span> &amp;&amp; tab != <span class="built_in">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//得到该根节点在该树节点数组当中的位置下标index</span></span><br><span class="line">                <span class="type">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//first指向链表第一个节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; <span class="built_in">first</span> = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断如果根节点与index查找出来的根节点不一致则</span></span><br><span class="line">                if (root != <span class="built_in">first</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果root不是第一个节点，则将root放到第一个首节点位置</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//定义next节点应该是</span></span><br><span class="line">                    Node&lt;K,V&gt; rn;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//对index位置的节点，树节点数组进行重新赋值为指定的根节点</span></span><br><span class="line">                    tab[index] = root;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//root节点的上一个节点进行赋值给rp</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; rp = root.<span class="built_in">prev</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//对rn进行重新赋值为根节点的下一节点，判空</span></span><br><span class="line">                    if ((rn = root.<span class="built_in">next</span>) != <span class="built_in">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)rn).<span class="built_in">prev</span> = rp;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//对rp进行判空，即根节点的上一节点判空</span></span><br><span class="line">                    if (rp != <span class="built_in">null</span>)</span><br><span class="line">                        rp.<span class="built_in">next</span> = rn;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    if (<span class="built_in">first</span> != <span class="built_in">null</span>)</span><br><span class="line">                        <span class="built_in">first</span>.<span class="built_in">prev</span> = root;</span><br><span class="line">                    root.<span class="built_in">next</span> = <span class="built_in">first</span>;</span><br><span class="line">                    root.<span class="built_in">prev</span> = <span class="built_in">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这里是防御性编程，校验更改后的结构是否满足红黑树和双链表的特性</span></span><br><span class="line">                <span class="comment">//因为HashMap并没有做并发安全处理，可能在并发场景中意外破坏了结构</span></span><br><span class="line">                assert checkInvariants(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树的左旋和右旋"><a href="#红黑树的左旋和右旋" class="headerlink" title="红黑树的左旋和右旋"></a>红黑树的左旋和右旋</h3><blockquote><p>左旋和右旋，顾名思义，就是将节点以某个节点向左或者向右进行旋转操作以保持二叉树的平衡</p></blockquote><h3 id="二叉树的左旋"><a href="#二叉树的左旋" class="headerlink" title="二叉树的左旋"></a>二叉树的左旋</h3><p>左旋：相当于以要旋转的节点为中心，将子树整体向左旋转，该节点变成子树的根节点，原来的父节点A变成了左孩子，如果右孩子C有左孩子D，则将其便成为A的右孩子  </p><p>当节点A向左旋转之后，C的左孩子D可以理解为因为重力问题掉到A的右孩子的位置。  </p><p> <img src="https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180717135149338-1921395779.png" alt="image"></p><h3 id="二叉树的右旋"><a href="#二叉树的右旋" class="headerlink" title="二叉树的右旋"></a>二叉树的右旋</h3><p> <img src="https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180717135200454-1697647783.png" alt="image"></p><h3 id="TreeNode的左旋和右旋"><a href="#TreeNode的左旋和右旋" class="headerlink" title="TreeNode的左旋和右旋"></a>TreeNode的左旋和右旋</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 左旋</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                              TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            这里的p即上图的A节点，</span></span><br><span class="line"><span class="comment">            r指向右孩子即C，</span></span><br><span class="line"><span class="comment">            rl指向右孩子的左孩子即D，</span></span><br><span class="line"><span class="comment">            pp为p的父节点</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断A节点是否为空以及A的右节点C节点r是否不为空,满足判断即左旋</span></span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">              如果A的右节点C，</span></span><br><span class="line"><span class="comment">              C的左节点D赋值给A节点的右节点；</span></span><br><span class="line"><span class="comment">              且将A节点的右节点赋值给r1树节点</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">                <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//将D的父节点重新赋值为A节点</span></span><br><span class="line">                    rl.<span class="keyword">parent</span> = p;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将p的父节点的孩子节点指向r</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                A的父节点重新赋值给，A节点的右节点即C节点</span></span><br><span class="line"><span class="comment">                C节点的父节点重新赋值给pp节点，进行判空</span></span><br><span class="line"><span class="comment">                如果为空则C节点重新赋值给root根节点指向，</span></span><br><span class="line"><span class="comment">                将从C节点的是否标红改为false，即根节点的颜色都是黑色的</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> ((pp = r.<span class="keyword">parent</span> = p.<span class="keyword">parent</span>) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = r).red = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                如果A的父节点赋值给C的父节点，C的父节点赋值给pp节点</span></span><br><span class="line"><span class="comment">                如果pp节点的左节点为为A节点；</span></span><br><span class="line"><span class="comment">                则pp节点的左节点进行重新赋值为C节点</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                    pp.left = r;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                最后如果不满足以上条件则进入else判断</span></span><br><span class="line"><span class="comment">                A节点的父节点C节点的父节点pp节点的右节点改为C节点</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = r;</span><br><span class="line">                <span class="comment">//将p置为r的左节点</span></span><br><span class="line">                r.left = p;</span><br><span class="line">                p.<span class="keyword">parent</span> = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 右旋</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                               TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">             <span class="comment">//这里的p即上图的A节点，l指向左孩子即C，lr指向左孩子的右孩子即E，pp为p的父节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">                    lr.<span class="keyword">parent</span> = p;</span><br><span class="line">                <span class="keyword">if</span> ((pp = l.<span class="keyword">parent</span> = p.<span class="keyword">parent</span>) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">                    pp.right = l;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.left = l;</span><br><span class="line">                l.right = p;</span><br><span class="line">                p.<span class="keyword">parent</span> = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><p>红黑树的插入，首先找到这个节点要插入的位置。<br>即一层一层比较，大的放右边，小的放左边，直到找到为null的节点放入即可。<br>可是如何在插入的过程中保持红黑树的特性呢，其实又这么几种情况：</p><ol><li>插入的为根节点，则直接把颜色改成黑色即可。</li><li>插入的节点的父节点是黑色节点，则不需要调整，因为插入的节点会初始化为红色节点，红色节点是不会影响树的平衡的。</li><li>插入的节点的祖父节点为null，即插入的节点的父节点是根节点，直接插入即可（因为根节点肯定是黑色）。</li><li>插入的节点父节点和祖父节点都存在，并且其父节点是祖父节点的左节点。这种情况稍微麻烦一点，又分两种子情况：</li></ol><ul><li>插入节点的叔叔节点是红色，则将父亲节点和叔叔节点都改成黑色，然后祖父节点改成红色即可。</li><li>插入节点的叔叔节点是黑色或不存在：<ul><li>若插入节点是其父节点的孩子，则将其父节点左旋</li><li>若为左孩子，则将其父节点变成黑色节点，将其祖父节点变成红色节点，然后将其祖父节点右旋。</li></ul></li></ul><ol start="5"><li>插入的节点父节点和祖父节点都存在，并且其父节点是祖父节点的右节点。这种情况跟上面是类似的，分两种子情况：</li></ol><ul><li>插入节点的叔叔节点是红色，则将父亲节点和叔叔节点都改成黑色，然后祖父节点改成红色即可。</li><li>插入节点的叔叔节点是黑色或不存在：<ul><li>若插入节点是其父节点的左孩子，则将其父节点右旋。</li><li>若为右孩子，则将其父节点变成黑色节点，将其祖父节点变成红色节点，然后将其祖父节点左旋。</li></ul></li></ul><p>然后重复进行上述操作，直到变成1或2的情况时则结束变换。<br>构建一棵红黑树，假设插入的顺序为：10,5,9,3,6,7,19,32,24,17</p><p>先来插个10，为情境1，直接改成黑色即可；<br>再插入5，为情境2，比10小，放到10的左孩子位置；<br>插入9，比10小，但是比5大，放到5的右孩子位置，此时为情境4iia，左旋后变成了情境4iib，变色右旋即可完成转化；<br>插入3后为情境4i，将父节点和叔叔节点同时变色即可；<br>插入6不需要调整；<br>插入7后变为情境5i，变色即可。<br>插入19不需要调整；<br>插入32，变成了5iib，左旋变色即可；<br>插入24，变成5iia，右旋变成5i，变色即可；<br>最后插入17，完美</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                                    TreeNode&lt;K,V&gt; x) &#123;</span><br><span class="line">            x.<span class="attr">red</span> = <span class="literal">true</span>;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">                //情景<span class="number">1</span>：父节点为<span class="literal">null</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="attr">xp</span> = x.parent) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x.<span class="attr">red</span> = <span class="literal">false</span>;</span><br><span class="line">                    return x;</span><br><span class="line">                &#125;</span><br><span class="line">　　　　　　　　　 //情景<span class="number">2</span>，<span class="number">3</span>：父节点是黑色节点或者祖父节点为<span class="literal">null</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (<span class="attr">xpp</span> = xp.parent) == <span class="literal">null</span>)</span><br><span class="line">                    return root;</span><br><span class="line">　　　　　　　　　　//情景<span class="number">4</span>：插入的节点父节点和祖父节点都存在，并且其父节点是祖父节点的左节点</span><br><span class="line">                <span class="keyword">if</span> (<span class="attr">xp</span> == (<span class="attr">xppl</span> = xpp.left)) &#123;</span><br><span class="line">　　　　　　　　　　　　//情景<span class="number">4</span>i：插入节点的叔叔节点是红色</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="attr">xppr</span> = xpp.right) != <span class="literal">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                        xppr.<span class="attr">red</span> = <span class="literal">false</span>;</span><br><span class="line">                        xp.<span class="attr">red</span> = <span class="literal">false</span>;</span><br><span class="line">                        xpp.<span class="attr">red</span> = <span class="literal">true</span>;</span><br><span class="line">                        <span class="attr">x</span> = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">　　　　　　　　　　　　//情景<span class="number">4</span>ii：插入节点的叔叔节点是黑色或不存在</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　　　　　　　　　//情景<span class="number">4</span>iia：插入节点是其父节点的右孩子</span><br><span class="line">                        <span class="keyword">if</span> (<span class="attr">x</span> == xp.right) &#123;</span><br><span class="line">                            <span class="attr">root</span> = rotateLeft(root, <span class="attr">x</span> = xp);</span><br><span class="line">                            <span class="attr">xpp</span> = (<span class="attr">xp</span> = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">　　　　　　　　　　　　　　//情景<span class="number">4</span>iib：插入节点是其父节点的左孩子</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                            xp.<span class="attr">red</span> = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                                xpp.<span class="attr">red</span> = <span class="literal">true</span>;</span><br><span class="line">                                <span class="attr">root</span> = rotateRight(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">　　　　　　　　　 //情景<span class="number">5</span>：插入的节点父节点和祖父节点都存在，并且其父节点是祖父节点的右节点</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　　　　　　　//情景<span class="number">5</span>i：插入节点的叔叔节点是红色</span><br><span class="line">                    <span class="keyword">if</span> (xppl != <span class="literal">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                        xppl.<span class="attr">red</span> = <span class="literal">false</span>;</span><br><span class="line">                        xp.<span class="attr">red</span> = <span class="literal">false</span>;</span><br><span class="line">                        xpp.<span class="attr">red</span> = <span class="literal">true</span>;</span><br><span class="line">                        <span class="attr">x</span> = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">　　　　　　　　　　　　//情景<span class="number">5</span>ii：插入节点的叔叔节点是黑色或不存在</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">·　　　　　　　　　　　　　　//情景<span class="number">5</span>iia：插入节点是其父节点的左孩子　</span><br><span class="line">                        <span class="keyword">if</span> (<span class="attr">x</span> == xp.left) &#123;</span><br><span class="line">                            <span class="attr">root</span> = rotateRight(root, <span class="attr">x</span> = xp);</span><br><span class="line">                            <span class="attr">xpp</span> = (<span class="attr">xp</span> = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">　　　　　　　　　　　　　　//情景<span class="number">5</span>iib：插入节点是其父节点的右孩子</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                            xp.<span class="attr">red</span> = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                                xpp.<span class="attr">red</span> = <span class="literal">true</span>;</span><br><span class="line">                                <span class="attr">root</span> = rotateLeft(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3><p>红黑树是一颗特殊的二叉搜索树，所以进行删除操作时，其实是先进行二叉搜索树的删除，然后再进行整理。  </p><p>所以，其实这里分为两部分内容：</p><ul><li>二叉搜索树的删除</li><li>红黑树的删除调整</li></ul><p>二叉搜索树的删除主要有这么几种情境：<br>情境一：待删除的节点五左右孩子；<br>情景二：待删除的节点只有左孩子或者右孩子；<br>情境三：待删除的节点既有左孩子又有右孩子；</p><p>对于情景一，直接删除即可；<br>情景二，则直接把该节点的父节点指向他的左孩子或者右孩子即可；<br>情境三稍微复杂一点，需要先找到其右子树的最左孩子(或者左子树的最右孩子)，即左（右）子树中序遍历时的第一个节点，然后将其与待删除的节点互换，最后再删除该节点（如果有右子树，则右子树上位）。<br>总之，就是先找到他的替代者，找到之后替换这个要删除的节点，然后再把这个节点真正删除掉。  </p><p>其实二叉搜索树的删除总体来说还是比较简单的。<br>删除完之后，如果替代者是红色节点，则不需要调整；<br>如果是黑色节点，则会导致左子树和右子树路径中黑色节点数量不一致，需要进行红黑树的调整；<br>跟上面一样，替代节点为其父节点的左孩子与右孩子的情况类似，所以这里直说其为左孩子的情景（PS：上一步的寻找替换节点使用的是右子树的最左节点，所以该节点如果右孩子，只能是右孩子）；  </p><p>情景一：只有右孩子且为红色，直接用右孩子替换该节点然后变成黑色即可。  </p><p>（D代表替代节点，即要被删除的节点，之前在经过二叉搜索树的删除之后，D节点其实已经被删除了，这里为了方便理解这个变化过程，所以把这个节点也画出来了，所以当初的初始状态是待删除节点与其替换节点互换位置与颜色字后的状态）  </p><p>情景二：只有右孩子且为黑色，那么删除该节点会导致父节点的左子树路径上黑色节点减一，此时只能去借助右子树，从右子树中借一个红色节点过来即可，具体取决于右子树的情况，这里又要分成两种情况：  </p><ul><li><p>兄弟节点是红色，则此时父节点是黑色，且兄弟节点肯定有两个孩子，且兄弟节点的左右子树路径上均有两个黑色节点，此时只需将兄弟节点与父节点颜色互换，然后将父节点左旋，左旋后，兄弟节点的左子树SL挂到了父节点p的右孩子位置，这时会导致p的右子树路径上的黑色节点比左子树多一，此时再SL置为红色即可。  </p></li><li><p>兄弟节点是黑色，那么就只能打他孩子的主意了。这里主要关注远侄子（兄弟节点的右孩子，即SR）的颜色情况，这里分成两种情况：</p><ul><li>远侄子SR是黑色，近侄子任意（白色代表颜色可以为任意颜色），现将S转为红色，然后右旋，再将SL换成P节点颜色，P土城黑色，S也涂成黑色，在进行左旋即可。<br>其实简单说就是SL上位，替换父节点位置。  </li><li>远侄子SR为红色，近侄子（该子树路径中有且有仅有一个黑色节点），则现将兄弟节点与父节点颜色互换，将SR涂成黑色，再将父节点左旋即可。  </li></ul></li></ul><h3 id="TreeNode的删除节点"><a href="#TreeNode的删除节点" class="headerlink" title="TreeNode的删除节点"></a>TreeNode的删除节点</h3><p>TreeNode删除节点其实也是两步走：  </p><ol><li>先进性二叉搜索树的删除，然后再进行红黑树的调整，跟之前的情况分析是一致的。  </li></ol><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">final void removeTreeNode(HashMap&lt;K,V&gt; <span class="built_in">map</span>, Node&lt;K,V&gt;[] tab, boolean movable) &#123;</span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     //p是待删除节点，replacement用于后续的红黑树调整，指向的是p或者p的继承者。</span><br><span class="line">     //如果p是叶子节点，<span class="attr">p==replacement，否则replacement为p的右子树中最左节点</span></span><br><span class="line">     <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        //若p不是叶子节点，则让replacement的父节点指向p的父节点</span><br><span class="line">        TreeNode&lt;K,V&gt; <span class="attr">pp</span> = replacement.<span class="attr">parent</span> = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (<span class="attr">pp</span> == <span class="literal">null</span>)</span><br><span class="line">            <span class="attr">root</span> = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">p</span> == pp.left)</span><br><span class="line">            pp.<span class="attr">left</span> = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.<span class="attr">right</span> = replacement;</span><br><span class="line">        p.<span class="attr">left</span> = p.<span class="attr">right</span> = p.<span class="attr">parent</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //若待删除的节点p时红色的，则树平衡未被破坏，无需进行调整。</span><br><span class="line">    //否则删除节点后需要进行调整</span><br><span class="line">    TreeNode&lt;K,V&gt; <span class="attr">r</span> = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    //p为叶子节点，则直接将p从树中清除</span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">replacement</span> == p) &#123;  // detach</span><br><span class="line">        TreeNode&lt;K,V&gt; <span class="attr">pp</span> = p.parent;</span><br><span class="line">        p.<span class="attr">parent</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="attr">p</span> == pp.left)</span><br><span class="line">                pp.<span class="attr">left</span> = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">p</span> == pp.right)</span><br><span class="line">                pp.<span class="attr">right</span> = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>麻烦的地方就在删除节点后的调整了，所有逻辑都在balanceDeletion函数里，两个参数分别表示根节点和删除节点的继承者，具体实现如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123;</span><br><span class="line">    for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">        //x为空或x为根节点，直接返回</span><br><span class="line">        <span class="keyword">if</span> (<span class="attr">x</span> == <span class="literal">null</span> || <span class="attr">x</span> == root)</span><br><span class="line">            return root; </span><br><span class="line">        //x为根节点，染成黑色，直接返回（因为调整过后，root并不一定指向删除操作过后的根节点，如果之前删除的是root节点，则x将成为新的根节点）</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="attr">xp</span> = x.parent) == <span class="literal">null</span>) &#123;</span><br><span class="line">            x.<span class="attr">red</span> = <span class="literal">false</span>; </span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果x为红色，则无需调整，返回</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">            x.<span class="attr">red</span> = <span class="literal">false</span>;</span><br><span class="line">            return root; </span><br><span class="line">        &#125;</span><br><span class="line">        //x为其父节点的左孩子</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="attr">xpl</span> = xp.left) == x) &#123;</span><br><span class="line">            //如果它有红色的兄弟节点xpr，那么它的父亲节点xp一定是黑色节点</span><br><span class="line">            <span class="keyword">if</span> ((<span class="attr">xpr</span> = xp.right) != <span class="literal">null</span> &amp;&amp; xpr.red) &#123; </span><br><span class="line">                xpr.<span class="attr">red</span> = <span class="literal">false</span>;</span><br><span class="line">                xp.<span class="attr">red</span> = <span class="literal">true</span>; </span><br><span class="line">                //对父节点xp做左旋转</span><br><span class="line">                <span class="attr">root</span> = rotateLeft(root, xp); </span><br><span class="line">                //重新将xp指向x的父节点，xpr指向xp新的右孩子</span><br><span class="line">                <span class="attr">xpr</span> = (<span class="attr">xp</span> = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.right; </span><br><span class="line">            &#125;</span><br><span class="line">            //如果xpr为空，则向上继续调整，将x的父节点xp作为新的x继续循环</span><br><span class="line">            <span class="keyword">if</span> (<span class="attr">xpr</span> == <span class="literal">null</span>)</span><br><span class="line">                <span class="attr">x</span> = xp; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                //sl和sr分别为其近侄子和远侄子</span><br><span class="line">                TreeNode&lt;K,V&gt; <span class="attr">sl</span> = xpr.left, <span class="attr">sr</span> = xpr.right;</span><br><span class="line">　　　　　　　　　　　　</span><br><span class="line">                <span class="keyword">if</span> ((<span class="attr">sr</span> == <span class="literal">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                    (<span class="attr">sl</span> == <span class="literal">null</span> || !sl.red)) &#123;</span><br><span class="line">                    xpr.<span class="attr">red</span> = <span class="literal">true</span>; //若sl和sr都为黑色或者不存在，即xpr没有红色孩子，则将xpr染红</span><br><span class="line">                    <span class="attr">x</span> = xp; //本轮结束，继续向上循环</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    //否则的话，就需要进一步调整</span><br><span class="line">                    <span class="keyword">if</span> (<span class="attr">sr</span> == <span class="literal">null</span> || !sr.red) &#123; </span><br><span class="line">                        <span class="keyword">if</span> (sl != <span class="literal">null</span>) //若左孩子为红，右孩子不存在或为黑</span><br><span class="line">                            sl.<span class="attr">red</span> = <span class="literal">false</span>; //左孩子染黑</span><br><span class="line">                        xpr.<span class="attr">red</span> = <span class="literal">true</span>; //将xpr染红</span><br><span class="line">                        <span class="attr">root</span> = rotateRight(root, xpr); //右旋</span><br><span class="line">                        <span class="attr">xpr</span> = (<span class="attr">xp</span> = x.parent) == <span class="literal">null</span> ?</span><br><span class="line">                            <span class="literal">null</span> : xp.right;  //右旋后，xpr指向xp的新右孩子，即上一步中的sl</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpr != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xpr.<span class="attr">red</span> = (<span class="attr">xp</span> == <span class="literal">null</span>) ? <span class="literal">false</span> : xp.red; //xpr染成跟父节点一致的颜色，为后面父节点xp的左旋做准备</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="attr">sr</span> = xpr.right) != <span class="literal">null</span>)</span><br><span class="line">                            sr.<span class="attr">red</span> = <span class="literal">false</span>; //xpr新的右孩子染黑，防止出现两个红色相连</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xp.<span class="attr">red</span> = <span class="literal">false</span>; //将xp染黑，并对其左旋，这样就能保证被删除的X所在的路径又多了一个黑色节点，从而达到恢复平衡的目的</span><br><span class="line">                        <span class="attr">root</span> = rotateLeft(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //到此调整已经完毕，进入下一次循环后将直接退出</span><br><span class="line">                    <span class="attr">x</span> = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //x为其父节点的右孩子，跟上面类似</span><br><span class="line">        <span class="keyword">else</span> &#123; // symmetric</span><br><span class="line">            <span class="keyword">if</span> (xpl != <span class="literal">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                xpl.<span class="attr">red</span> = <span class="literal">false</span>;</span><br><span class="line">                xp.<span class="attr">red</span> = <span class="literal">true</span>;</span><br><span class="line">                <span class="attr">root</span> = rotateRight(root, xp);</span><br><span class="line">                <span class="attr">xpl</span> = (<span class="attr">xp</span> = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="attr">xpl</span> == <span class="literal">null</span>)</span><br><span class="line">                <span class="attr">x</span> = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; <span class="attr">sl</span> = xpl.left, <span class="attr">sr</span> = xpl.right;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="attr">sl</span> == <span class="literal">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                    (<span class="attr">sr</span> == <span class="literal">null</span> || !sr.red)) &#123;</span><br><span class="line">                    xpl.<span class="attr">red</span> = <span class="literal">true</span>;</span><br><span class="line">                    <span class="attr">x</span> = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="attr">sl</span> == <span class="literal">null</span> || !sl.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sr != <span class="literal">null</span>)</span><br><span class="line">                            sr.<span class="attr">red</span> = <span class="literal">false</span>;</span><br><span class="line">                        xpl.<span class="attr">red</span> = <span class="literal">true</span>;</span><br><span class="line">                        <span class="attr">root</span> = rotateLeft(root, xpl);</span><br><span class="line">                        <span class="attr">xpl</span> = (<span class="attr">xp</span> = x.parent) == <span class="literal">null</span> ?</span><br><span class="line">                            <span class="literal">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xpl.<span class="attr">red</span> = (<span class="attr">xp</span> == <span class="literal">null</span>) ? <span class="literal">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="attr">sl</span> = xpl.left) != <span class="literal">null</span>)</span><br><span class="line">                            sl.<span class="attr">red</span> = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xp.<span class="attr">red</span> = <span class="literal">false</span>;</span><br><span class="line">                        <span class="attr">root</span> = rotateRight(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="attr">x</span> = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://r.photo.store.qq.com/psc?/V11rBmNJ3kviLN/hsnfJ.a5yg7.BhItQyNwPS8WgpyOY*TnhQ6ra5OBonOaSJRRjYa.EwaeDcHd5u0Z2wMIczAx0nk6IHzpV2SuW5ZkbqYqWpEyQuGfndQv*mU!/r" alt="image"></p><p><img src="https://r.photo.store.qq.com/psc?/V11rBmNJ3kviLN/hsnfJ.a5yg7.BhItQyNwPZ0TVvbWf.6wlQibDDEU9nwepElsriUycANIyLMCH972q4*18zAQ2JnfajC3UcA3FOOYO1pY.VPGyy9Yhc5qm0U!/r" alt="image"></p><p><img src="https://r.photo.store.qq.com/psc?/V11rBmNJ3kviLN/hsnfJ.a5yg7.BhItQyNwPVrsS.2eQykh7ln*jpalRaYOuC840EjilEUf*3l1I4Uj5vN8oKglrkZSTgN9O7NMea.f2q30d9hZwhBgLkZ2pjc!/r" alt="image"></p><p><img src="https://r.photo.store.qq.com/psc?/V11rBmNJ3kviLN/hsnfJ.a5yg7.BhItQyNwPaZRzqjFpkGRmkeFlPQdsF3YnWtpVuzAnvhHE3LZZLP.CEPsRNlRt0U.WFtozxfBS3bCEjSVmbIFygRtlzEuDYY!/r" alt="image"></p><p><img src="https://r.photo.store.qq.com/psc?/V11rBmNJ3kviLN/hsnfJ.a5yg7.BhItQyNwPXdSPInQ3l8qS*.LcdHVIU3s1Gt6GVBtTa9yvpW2nENYOBAu4lPqx2**2LleuReBcgcvRMJXIU9kfBqvzwfvC1A!/r" alt="image"></p><p><img src="https://r.photo.store.qq.com/psc?/V11rBmNJ3kviLN/hsnfJ.a5yg7.BhItQyNwPek1*OE0FbhH1wkxqG3uJo4a90xtMKMRqDZROfloDawycjwz7yjR*VrmgnpyK1.DoWB9aksaXcF2svMMndLJNUU!/r" alt="image"></p><p><img src="https://r.photo.store.qq.com/psc?/V11rBmNJ3kviLN/hsnfJ.a5yg7.BhItQyNwPfeCIgjNMUSfKD8lKPVMn13P9lKi7RRo3e8RSqlAT5LwIXSns.TckldPKVuWYuAh17R7wiB9FFZTtwfrabXsmY8!/r" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近两天看到了HashMap比较多，包括一致性Hash等。&lt;br&gt;基本的了解了。&lt;br&gt;就是不太晓得红黑树。  &lt;/p&gt;
&lt;p&gt;要是觉得看文档实在觉得不适的话，可以建议先去b站看个视频：&lt;a href=&quot;https://www.bilibili.com/video/BV1t
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://fengshana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="红黑树" scheme="https://fengshana.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="HashMap" scheme="https://fengshana.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>BAT大厂千万级并发Redis缓存架构实战笔记</title>
    <link href="https://fengshana.github.io/2020/03/26/%E9%9D%A2%E8%AF%95%E9%A2%98/Redis%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://fengshana.github.io/2020/03/26/%E9%9D%A2%E8%AF%95%E9%A2%98/Redis%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-03-25T16:37:56.000Z</published>
    <updated>2020-03-28T10:23:58.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存的三大问题"><a href="#缓存的三大问题" class="headerlink" title="缓存的三大问题"></a>缓存的三大问题</h2><p>是使用了缓存之后才会出现的问题。  </p><p>为什么要使用缓存？怎么使用缓存？ 再来讲缓存的问题。  </p><p>使用Redis做缓存；跟Redis相关。  </p><p>使用缓存的基本思路：  </p><p>烂方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public R select<span class="constructor">OrderById(Integer <span class="params">id</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查询缓存；valuOperations专门操作Redis当中字符串类型的对象。</span></span><br><span class="line">  Object redisObj=valuOperations.get(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//命中缓存;在缓存当中查到了称之为缓存命中</span></span><br><span class="line">  <span class="keyword">if</span>(redisObj!=null)&#123;</span><br><span class="line">    <span class="comment">//正常返回数据</span></span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(200)</span>.set<span class="constructor">Data(<span class="params">redisObj</span>)</span>.set<span class="constructor">Msg(<span class="string">"OK"</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//如果缓存当中没有的话则查询数据库</span></span><br><span class="line">    Order order=orderMapper.select<span class="constructor">OrderById(<span class="params">id</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span>(order==null)&#123;</span><br><span class="line">      valueOperations.set(id,order,<span class="number">30</span>,TimeUnit,SECONDS);<span class="comment">//加入缓存</span></span><br><span class="line">      return <span class="constructor">R()</span>.set<span class="constructor">Code(200)</span>.set<span class="constructor">Data(<span class="params">order</span>)</span>.set<span class="constructor">Msg(<span class="string">"OK"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;finally&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="keyword">new</span> <span class="constructor">R()</span>.set<span class="constructor">Code(500)</span>.set<span class="constructor">Data(<span class="params">new</span> NullValueResultDO()</span>).set<span class="constructor">Msg(<span class="string">"查询无果"</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：  </p><h3 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h3><ul><li>第一个是为了保护数据库；为什么使用了缓存能够达到一个保护数据库的一个作用？很多请求假设在没有使用缓存的情况下，将会直接查询数据库；而如果使用了缓存，则大部分情况将会第一次都会经过缓存，而缓存当中没有，则去数据库当中进行查询一次，然后加入到缓存当中，之后的请求相同的资源的话那么就会直接请求缓存，而此时的缓存当中则不为空了，降低了数据库的访问压力。  </li><li>第二个是为了提高性能。Redis的性能是非常快的。查询缓存是比查询数据库的效率要高的。  </li></ul><h3 id="第一个问题：缓存穿透问题"><a href="#第一个问题：缓存穿透问题" class="headerlink" title="第一个问题：缓存穿透问题"></a>第一个问题：缓存穿透问题</h3><p>缓存穿透：缓存当中没有，数据库当中没有数据，一直查询数据库（恶意）；</p><p>解决方案：1. 缓存空对象；2.布隆过滤器  </p><p>两种方案各有优缺点：<br>缓存空对象的缺点：会占用Redis当中大量的一个内存</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存的三大问题&quot;&gt;&lt;a href=&quot;#缓存的三大问题&quot; class=&quot;headerlink&quot; title=&quot;缓存的三大问题&quot;&gt;&lt;/a&gt;缓存的三大问题&lt;/h2&gt;&lt;p&gt;是使用了缓存之后才会出现的问题。  &lt;/p&gt;
&lt;p&gt;为什么要使用缓存？怎么使用缓存？ 再来讲缓存的问
      
    
    </summary>
    
    
      <category term="面试题" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Redis" scheme="https://fengshana.github.io/tags/Redis/"/>
    
      <category term="缓存" scheme="https://fengshana.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="面试" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="https://fengshana.github.io/2020/03/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://fengshana.github.io/2020/03/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-03-23T13:33:56.000Z</published>
    <updated>2020-03-24T10:56:04.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><p>Spring是一个开源的Java EE开发框架。<br>Spring框架的核心功能可以应用在任何java应用程序中，但对Java EE平台上的Web应用程序有更好的扩展性。<br>Spring框架的目标是使得Java EE应用程序的开发更加简捷，通过使用POJO为基础的变成模型促进良好的变成风格。  </p><h2 id="Spring有哪些优点"><a href="#Spring有哪些优点" class="headerlink" title="Spring有哪些优点"></a>Spring有哪些优点</h2><ul><li>轻量级： Spring在大小和透明性方面觉得属于轻量级的，基础版本的Spring框架大约只有2MB。</li><li>控制反转（IOC）： SPring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或者寻找依赖对象。</li><li>面向切面编程（AOP）: Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。</li><li>容器： Spring包含并管理应用程序对象的配置以及生命周期。</li><li>MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。</li><li>事务管理： Spring对下至本地业务上至全局业务（JAT）提供了统一的事务管理接口。</li><li>异常处理： Spring提供一个方便的API将特定技术的异常（由JDBC，Hibernate，或者JDO抛出）转化为一致的、Unchecked异常。</li></ul><h2 id="Spring事务实现方式"><a href="#Spring事务实现方式" class="headerlink" title="Spring事务实现方式"></a>Spring事务实现方式</h2><ul><li>编程式事务管理： 这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但是很难维护。</li><li>声明式事务管理： 这种方式意味着你可以将事务和业务代码分离。你只需要通过注解或者XML配置管理事务。</li></ul><h2 id="Spring框架的事务管理有哪些优点"><a href="#Spring框架的事务管理有哪些优点" class="headerlink" title="Spring框架的事务管理有哪些优点"></a>Spring框架的事务管理有哪些优点</h2><ul><li>它为不同的事务API（如JTA,JDBC,Hibernate,JPA,和JDO）提供了统一的编程模型。</li><li>它为编程式事务管理提供了一个简单的API而非一系列复杂的事务API（如JTA）</li><li>它支持声明式事务管理。</li><li>它可以和Spring的多种数据访问技术很好的融合。</li></ul><h2 id="Spring事务定义的传播规则"><a href="#Spring事务定义的传播规则" class="headerlink" title="Spring事务定义的传播规则"></a>Spring事务定义的传播规则</h2><ul><li>propagation_required: 支持当前事务，如果当前没有事务，就建一个事务。这是最常见的选择。</li><li>propagation_supports: 支持当前事务，如果当前没有事务，就以非事务方式执行。</li><li>propagation_mandatory: 支持当前事务，如果当前没有事务，就抛出异常。</li><li>propagation_requires_new: 新建事务，如果当前存在事务，把当前事务挂起。</li><li>propagation_not_supported: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>propagation_never: 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>propagation_nested: 如果当前存在事务，则在嵌套式事务内执行。如果当前没有事务，则进行与propagation_required类似的操作，即支持当前事务，如果当前没有事务，就建一个事务。这是最常见的选择。</li></ul><h2 id="Spring事务底层原理"><a href="#Spring事务底层原理" class="headerlink" title="Spring事务底层原理"></a>Spring事务底层原理</h2><h3 id="划分处理单元—-ioc"><a href="#划分处理单元—-ioc" class="headerlink" title="划分处理单元—-ioc"></a>划分处理单元—-ioc</h3><p>由于Spring解决的问题是对【单个数据库】进行【局部事务】处理的。<br>具体的实现首先用Spring的IOC划分了【事务处理单元】。<br>并且将对事务的各种配置放到了ioc容器中。<br>（设置事务管理器，设置事务的传播特性以及隔离机制）。  </p><h3 id="AOP拦截需要进行事务处理的类"><a href="#AOP拦截需要进行事务处理的类" class="headerlink" title="AOP拦截需要进行事务处理的类"></a>AOP拦截需要进行事务处理的类</h3><p>【Spring事务处理模块】是通过【AOP】功能来实现【声明式事务】处理的，<br>具体操作（比如事务实行的配置和读取，事务对象的抽象），用TransactionProxyFactoryBean接口来使用AOP功能，生成proxy代理对象，通过TransactionInterceptor完成对代理方法的拦截，将事务处理的功能编织到拦截的方法中。读取ioc容器事务配置属性，转化为Spring事务处理需要的内部数据结构（TransactionAttributeSourceAdvisor），转化为TransactionAttribute表示的数据对象。</p><h2 id="对事务处理实现（事务的生成、提交、回滚、挂起）"><a href="#对事务处理实现（事务的生成、提交、回滚、挂起）" class="headerlink" title="对事务处理实现（事务的生成、提交、回滚、挂起）"></a>对事务处理实现（事务的生成、提交、回滚、挂起）</h2><p>Spring委托给具体的事务处理器实现。<br>实现了一个抽象和适配。<br>适配的具体事务处理器：DataSource数据源支持、Hibernate数据源事务处理支持、JDO数据源事务处理支持、JPA、JTA数据源事务处理支持。<br>这些支持都是通过设计PlatformTransactionManager、AbstractPlatformTransaction一些列事务处理的支持。<br>为常用数据源支持提供了一系列TransactionManager。</p><ul><li>结合<br>PlatformTransactionManager实现了TransactionInterception接口，让其与TransactionProxyFactoryBean结合起来，形成一个Spring声明式事务处理的设计体系。</li></ul><h2 id="Spring-MVC运行流程"><a href="#Spring-MVC运行流程" class="headerlink" title="Spring MVC运行流程"></a>Spring MVC运行流程</h2><ol><li>第一步：发起请求到前端控制器（DispatcherServlet）</li><li>第二步：前端控制器请求HandlerMapping查找Handler（可以根据XML配置、注解进行查找）</li><li>第三步：处理器映射器HandlerMapping向前端控制器返回Handler</li><li>第四步：前端控制器调用处理器适配器去执行Handler</li><li>第五步：处理器适配器去执行Handler</li><li>第六步：Handler执行完成给适配器返回ModelAndView</li><li>第七步：处理器适配器向前端控制器返回ModelAndView（ModelAndView是SpringMVC框架的一个底层对象，包括Model和View）</li><li>第八步：前端控制器请求视图解析器去进行视图解析（根据逻辑视图名解析成真正的视图（jsp））</li><li>第九步：视图解析器向前端控制器返回View</li><li>前端控制器进行视图渲染（视图渲染将模型数据（在ModelAndView对象中）填充到Request域）</li><li>前端控制器向用户响应结果</li></ol><h2 id="BeanFactory和ApplicationContext有什么区别"><a href="#BeanFactory和ApplicationContext有什么区别" class="headerlink" title="BeanFactory和ApplicationContext有什么区别"></a>BeanFactory和ApplicationContext有什么区别</h2><p>ApplicationContext提供了一种解决文档信息的方法，一种加载文件资源的方式（如图片），他们可以向监听他们的Beans发送消息。<br>另外，容器或者容器中的Beans的操作，这些必须以Bean工厂的编程方式处理的操作可以在应用上下文中以声明的方式处理。<br>应用上下文实现了MessageSource，该接口用于获取本地消息，实际的实现是可选的。  </p><ul><li>相同点：两者都是通过xml配置文件加载Bean，ApplicationContext和BeanFactory相比，提供了更多的扩展功能。</li><li>不同点：BeanFactory是延迟加载，如果Bean的某一个属性没有注入，BeanFactory加载后，直至第一次使用调用getBean方法才会报异常；而ApplicationContext则在初始化自身是检验，这样有利于检查所依赖属性是否注入；通常情况狂下我们选择使用ApplicationContext。</li></ul><h2 id="什么是Spring-Beans"><a href="#什么是Spring-Beans" class="headerlink" title="什么是Spring Beans"></a>什么是Spring Beans</h2><p>Spring Beans是构成Spring应用核心的Java对象。<br>这些对象由Spring IOC容器实例化、组装、管理。<br>这些对象通过容器中配置的元数据创建。<br>例如，使用XML文件中的定义的创建。  </p><p>在Spring中创建的beans都是单例的beans。<br>在bean标签中国有一个属性为”singleton”<br>如果设为true,则该bean是单例的；如果设置为false，则该bean是原型bean。<br>Singleton属性默认设置为true。<br>因此，Spring框架中所有的bean都默认是单例bean。  </p><h2 id="说一下Spring中支持的bean作用域"><a href="#说一下Spring中支持的bean作用域" class="headerlink" title="说一下Spring中支持的bean作用域"></a>说一下Spring中支持的bean作用域</h2><p>Spring框架支持如下五种不同的作用域：</p><ul><li><p>singleton: 在Spring IOC容器中仅存在一个Bean实例，Bean以单实例的方式存在。</p></li><li><p>prototype：一个Bean可以定义多个实例。</p></li><li><p>request：每次Http请求都会创建一个新的Bean。该作用域仅适用于WebApplicationContext环境。</p></li><li><p>session：一个Http Session定义一个Bean。该作用于仅适用于WebApplicationContext环境。</p></li><li><p>globalSession：同一个全局Http Session定义一个Bean。该作用于同样仅适用于WebApplicationContext环境。</p></li><li><p>bean默认的scope属性是”singleton”</p></li></ul><h2 id="Spring-的单例实现原理"><a href="#Spring-的单例实现原理" class="headerlink" title="Spring 的单例实现原理"></a>Spring 的单例实现原理</h2><p>Spring框架对单例的支持是采用单例注册表的方式进行实现的，而这个注册表的缓存是HashMap对象，如果配置文件中的配置信息不要求使用单例Spring会采用新建实例的方式返回对象实例。</p><h2 id="解释Spring框架中Bean的生命周期"><a href="#解释Spring框架中Bean的生命周期" class="headerlink" title="解释Spring框架中Bean的生命周期"></a>解释Spring框架中Bean的生命周期</h2><ol><li>容器启动</li><li>实例化Bean对象</li><li>设置对象属性</li><li>调用BeanNameAware的setBeanName()方法</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Spring&quot;&gt;&lt;a href=&quot;#什么是Spring&quot; class=&quot;headerlink&quot; title=&quot;什么是Spring&quot;&gt;&lt;/a&gt;什么是Spring&lt;/h2&gt;&lt;p&gt;Spring是一个开源的Java EE开发框架。&lt;br&gt;Spring框架的核心功能可
      
    
    </summary>
    
    
      <category term="面试题" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="https://fengshana.github.io/2020/03/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%B8%80%E7%82%B9%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
    <id>https://fengshana.github.io/2020/03/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%B8%80%E7%82%B9%E7%82%B9%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-03-23T13:33:56.000Z</published>
    <updated>2020-03-24T10:56:04.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h2 id="理解常用的设计模式"><a href="#理解常用的设计模式" class="headerlink" title="理解常用的设计模式"></a>理解常用的设计模式</h2><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h2 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h2><h2 id="微服务架构设计原理"><a href="#微服务架构设计原理" class="headerlink" title="微服务架构设计原理"></a>微服务架构设计原理</h2><h2 id="Linux操作系统，shell编程，Linux操作命令"><a href="#Linux操作系统，shell编程，Linux操作命令" class="headerlink" title="Linux操作系统，shell编程，Linux操作命令"></a>Linux操作系统，shell编程，Linux操作命令</h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis 是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API的非关系型数据库。  </p><p>传统数据库遵循ACID规则。而NoSql(Not Only Sql的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称)一般为分布式，而分布式一般遵循CAP定理。</p><h3 id="Redis支持的数据类型"><a href="#Redis支持的数据类型" class="headerlink" title="Redis支持的数据类型"></a>Redis支持的数据类型</h3><ul><li>String<ul><li>字符串类型</li><li>格式：set key value</li><li>String 类型是二进制安全的。意思是Redis的String可以包含任何数据。比如jpg图片或者序列化的对象。</li><li>String类型是Redis最基本的数据类型。一个键最大能存储512MB。</li></ul></li><li>Hash<ul><li>哈希</li><li>格式：hmset name key1 value1 key2 value2</li><li>Redis Hash 是一个键值（key=&gt;value）对集合</li><li>Redis Hash 是一个String类型的field和value的映射表，hash特别适合用于存储对象。</li></ul></li><li>List<ul><li>列表</li><li>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</li><li>格式：lpush name value</li><li>在key对应list的头部添加字符串元素</li><li>格式：rpush name value</li><li>在key对应list的尾部添加字符串元素</li><li>格式：lrem name index</li><li>key对应list中删除count个和value相同的元素</li><li>格式： llen name</li><li>返回key对应list的长度</li></ul></li><li>Set<ul><li>集合</li><li>格式：sadd name value</li><li>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1).</li></ul></li><li>Zset<ul><li>sorted set:有序集合</li><li>格式：zadd name score value</li><li>Redis zset和set一样也是String类型元素的集合，且不允许重复的成员</li><li>不同的是每个元素都会关联一个double类型的分数。Redis正式通过分数来为集合中的成员从小到大的排序。</li><li>zset的成员是唯一的，但是分数（score）却可以重复。</li></ul></li></ul><h3 id="什么是Redis持久化，Rredis有哪几种持久化方式，优缺点是什么"><a href="#什么是Redis持久化，Rredis有哪几种持久化方式，优缺点是什么" class="headerlink" title="什么是Redis持久化，Rredis有哪几种持久化方式，优缺点是什么"></a>什么是Redis持久化，Rredis有哪几种持久化方式，优缺点是什么</h3><ul><li>持久化就是把内存的数据写到磁盘中去，防止服务宕机内存数据丢失。</li><li>Redis提供了两种持久化方式：RDB（默认）和AOF </li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>rdb是Redis DataBase的缩写。<br>核心功能函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数<br>内存中的数据对象—–rdbSave—–&gt;磁盘中的RDB文件<br>内存中的数据对象&lt;—-rdbLoad——磁盘中的RDB文件  </p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>Aof是Append-only file缩写<br>服务端——–flush Append Only File——-&gt;磁盘中的AOF文件</p><p>每当执行服务器（定时）任务或者函数时flushAppendOnlyFile函数都会被调用，这个函数执行以下两个工作  </p><p>aof写入保存：<br>WRITE: 根据条件，将aof_buf中的缓存写入到AOF文件<br>SAVE：根据条件，调用fsync或者fdatasync函数，将AOF文件保存到磁盘中。</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>内容是Redis通讯协议（RESP）格式的命令文本存储</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ol><li>aof文件比rdb更新频率高，有限使用aof还原数据。</li><li>aof比rdb更安全也更大</li><li>rdb性能比aof好</li><li>如果两个都进行了配置优先加载AOF</li></ol><h3 id="其实上面你有提到Redis通讯协议（RESP），能解释下什么是RESP-有什么特点"><a href="#其实上面你有提到Redis通讯协议（RESP），能解释下什么是RESP-有什么特点" class="headerlink" title="其实上面你有提到Redis通讯协议（RESP），能解释下什么是RESP,有什么特点"></a>其实上面你有提到Redis通讯协议（RESP），能解释下什么是RESP,有什么特点</h3><ul><li>RESP 是Redis客户端和服务端之间使用的一种通讯协议</li><li>RESP的特点是：实现简单、快速解析、可读性好</li></ul><h3 id="REdis有哪些架构模式，讲讲各自的特点"><a href="#REdis有哪些架构模式，讲讲各自的特点" class="headerlink" title="REdis有哪些架构模式，讲讲各自的特点"></a>REdis有哪些架构模式，讲讲各自的特点</h3><ul><li><p>单机版</p><ul><li>特点：简单</li><li>问题：<ul><li>1.内存容量有限</li><li>2.处理能力有限</li><li>3.无法高可用</li></ul></li></ul></li><li><p>主从复制</p><ul><li>Redis的复制（replication）功能允许用户根据一个REdis服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。</li><li>只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据库，，主服务器就会一直讲发生在自己身上的数据更新同步给从服务器，从而抑制保证主从服务器的数据相同。</li><li>特点：<ul><li>1.master/slave角色</li><li>2.master/slave数据相同</li><li>3.降低master读压力在转交从库</li></ul></li><li>问题： 无法保证高可用，没有解决master写的压力</li></ul></li><li><p>哨兵</p><ul><li>Redis sentinel 是一个分布式系统中监控redis主从服务器，并在主服务器下线时自动进行故障转移。</li><li>其中三个特性：<ul><li>监控（Monitoring）：Sentinel会不断的检查你的主服务器和从服务器是否运作正常；</li><li>提醒（Notification）：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知</li><li>自动故障迁移（Automatic failover）:当一个主服务器不能正常工作时，Sentinel会开始一次自动故障迁移操作。</li></ul></li><li>特点：<ul><li>1.保证高可用</li><li>2.监控各个节点</li><li>3.自动故障迁移</li></ul></li><li>缺点： 主从模式，切换需要时间丢数据；没有解决master写的压力</li></ul></li><li><p>集群（Proxy）型</p><ul><li>Twemproxy是一个Twitter开源的一个Redis和memcache快速、轻量级代理服务器；</li><li>Twemproxy是一个快速的单线程代理程序，支持Memcached ASCII协议和Redis协议</li><li>特点：<ul><li>1.多种hash算法：MD 5、CRC16、CRC32、CRC32a、hsieh、nurmur、Jenkins </li><li>2.支持失败节点自动删除 </li><li>3.后端Sharding分片逻辑对业务透明，业务放的读写方式和操作单个Redis一致</li></ul></li><li>缺点：增加了新的proxy，需要维护其高可用</li></ul></li><li><p>集群（直连型）</p><ul><li>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接</li><li>特点：<ul><li>无中心架构（不存在哪个节点影响性能瓶颈），少了proxy层</li><li>数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分步</li><li>可扩展性，可先行扩展到1000个节点，节点可动态添加或者删除</li><li>高可用性，部分节点不可用时，集群仍然可用。通过增加Slave做备份数据副本。</li><li>实现谷中自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提升。</li></ul></li><li>缺点<ul><li>1.资源隔离性较差，容易出现相互影响的情况</li><li>2.数据通过异步复制，不保证数据的强一致性</li></ul></li></ul></li></ul><h3 id="什么是一致性哈希算法，什么是哈希槽"><a href="#什么是一致性哈希算法，什么是哈希槽" class="headerlink" title="什么是一致性哈希算法，什么是哈希槽"></a>什么是一致性哈希算法，什么是哈希槽</h3><h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="使用RabbitMQ有什么好处"><a href="#使用RabbitMQ有什么好处" class="headerlink" title="使用RabbitMQ有什么好处"></a>使用RabbitMQ有什么好处</h3><ol><li>解耦：系统A在代码中国直接调用系统B和系统C的代码，如果将来D系统接入，系统A还不需要修改代码，过于麻烦</li><li>异步：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度。</li><li>削峰：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常。</li></ol><h3 id="RabbitMQ中的broker是指的什么，cluster又是指的什么"><a href="#RabbitMQ中的broker是指的什么，cluster又是指的什么" class="headerlink" title="RabbitMQ中的broker是指的什么，cluster又是指的什么"></a>RabbitMQ中的broker是指的什么，cluster又是指的什么</h3><ul><li>broker是指一个或者多个erlang node 的逻辑分组，且node上运行着rabbitMQ的应用程序。</li><li>cluster是指在broker的基础之上，增加了node之间共享元数据的约束。</li></ul><h3 id="RabbitMQ概念里的Channel、exchange和queue是逻辑概念还是对应着进程实体，分别起着什么作用"><a href="#RabbitMQ概念里的Channel、exchange和queue是逻辑概念还是对应着进程实体，分别起着什么作用" class="headerlink" title="RabbitMQ概念里的Channel、exchange和queue是逻辑概念还是对应着进程实体，分别起着什么作用"></a>RabbitMQ概念里的Channel、exchange和queue是逻辑概念还是对应着进程实体，分别起着什么作用</h3><ul><li>queue具有自己的erlang进程；</li><li>exchange内部实现为保存binding关系的查找表；</li><li>channel是实际进行路由工作的实体，即负责按照routing_key将message投递给queue；</li><li>由AMQP协议描述可知，channel是真实TCP连接之上的虚拟连接，所有AMQP命令都是通过channel发送的，且每一个channel都有一个唯一的ID。一个channel只能被单独一个操作系统线程使用，故投递到特定channel上的message是有顺序的。单一个操作系统还是那个允许使用多个channel。</li></ul><h3 id="vhost是什么，起什么作用"><a href="#vhost是什么，起什么作用" class="headerlink" title="vhost是什么，起什么作用"></a>vhost是什么，起什么作用</h3><ul><li>vhost可以理解为虚拟broker，即mini-RabbitMQ server。</li><li>其内部均含有独立的queue、exchange和binding等。</li><li>但最最最重要的是，其拥有独立的权限系统。可以做到vhost范围的用户控制。</li><li>当然，从RabbitMQ的全局角度，vhost可以作为不同权限隔离的手段（一个典型的例子就是不同应用可以跑在不同的vhost中）。</li></ul><h3 id="消息基于什么传输"><a href="#消息基于什么传输" class="headerlink" title="消息基于什么传输"></a>消息基于什么传输</h3><ul><li>由于TCP连接的擦行间和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。</li><li>RabbitMQ使用【信道】的方式来传输数据。</li><li>信道是建立在真是的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。</li></ul><h3 id="消息如何分发"><a href="#消息如何分发" class="headerlink" title="消息如何分发"></a>消息如何分发</h3><ul><li>若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。</li><li>每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。</li></ul><h3 id="消息怎么路由"><a href="#消息怎么路由" class="headerlink" title="消息怎么路由"></a>消息怎么路由</h3><p>从概念上来说，消息路由必须有三部分：交换器exchange、路由routing_key、绑定binding。  </p><p>生产者把消息发布到交换器上；绑定决定消息如何从路由器路由到特定的队列；消息最终到达队列，并被消费者接收。</p><ol><li>消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定；</li><li>通过队列路由键，可以吧队列绑定到交换器上。</li><li>消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）；如果能够匹配到队列，则消息会投递到相应的队列当中；如果不能匹配到任何队列，消息将进入”黑洞”；</li></ol><h4 id="常用的交换器主要分为以下三种"><a href="#常用的交换器主要分为以下三种" class="headerlink" title="常用的交换器主要分为以下三种"></a>常用的交换器主要分为以下三种</h4><ul><li>direct: 如果路由键完全匹配，消息就被投递到相应的队列</li><li>fanout: 如果交换器收到消息，将会广播到所有绑定的队列上</li><li>topic：可以使来自不同源头的消息能够到达同一个队列。使用topic交换器时，可以使用通配符；比如：”*”匹配特定位置的任意文本。”.”把路由键分为了几个部分。”#”匹配所有规则等。</li><li>特别注意：发往topic交换器的消息不能随意的设置选择键（routing_key）,必须是由”.”隔开的一系列的标识符组成。</li></ul><h3 id="什么是元数据，元数据分为哪些类型，包括哪些内容，与cluster相关的元数据有哪些，元数据是如何保存的，元数据在cluster中是如何分布的"><a href="#什么是元数据，元数据分为哪些类型，包括哪些内容，与cluster相关的元数据有哪些，元数据是如何保存的，元数据在cluster中是如何分布的" class="headerlink" title="什么是元数据，元数据分为哪些类型，包括哪些内容，与cluster相关的元数据有哪些，元数据是如何保存的，元数据在cluster中是如何分布的"></a>什么是元数据，元数据分为哪些类型，包括哪些内容，与cluster相关的元数据有哪些，元数据是如何保存的，元数据在cluster中是如何分布的</h3><ul><li>在非cluster模式下，元数据主要分为：<ul><li>Queue元数据（queue名字和属性等）；</li><li>Exchange元数据（exchange名字、类型、属性等）</li><li>Binding元数据（存放路由关系的查找表）</li><li>Vhost元数据（Vhost范围内针对前三者的名字空间约束和安全属性设置）</li></ul></li><li>在cluster模式下，元数据还包括：<ul><li>cluster中node位置信息和node关系信息</li></ul></li><li>元数据按照erlang node的类型确定是仅保存于RAM中，还是同时保存在RAM和disk上。</li><li>元数据在cluster中是全node分步的。</li></ul><h3 id="在单node系统和多node构成的cluster系统中声明queue、exchange、以及进行binding会有什么不同"><a href="#在单node系统和多node构成的cluster系统中声明queue、exchange、以及进行binding会有什么不同" class="headerlink" title="在单node系统和多node构成的cluster系统中声明queue、exchange、以及进行binding会有什么不同"></a>在单node系统和多node构成的cluster系统中声明queue、exchange、以及进行binding会有什么不同</h3><ul><li><p>当你在单node上声明queue时，只要该node上相关元数据进行了变更，你就会得到Queue.Declare-ok回应。</p></li><li><p>而在cluster上声明queue，则要求cluster上的全部node都要进行元数据成功更新，才会得到Queue.Declare-ok回应。</p></li><li><p>另外，若node类型为RAM node则变更的数据仅保存在内存中；若类型为disk node 则还要变更保存在磁盘上的数据。</p></li><li><p>死信队列&amp;死信交换器：DLX全称（Dead-Letter-Exchange），称之为死信交换器，当消息变成一个死信之后，如果这个消息所在的队列存在x-dead-letter-exchange参数，那它会被发送到x-dead-letter-exchange对应值的交换器上，这个交换器就称之为死信交换器，与这个死信交换器绑定的队列就是死信队列。</p></li></ul><h3 id="如何确保消息正确的发送至RabbitMQ"><a href="#如何确保消息正确的发送至RabbitMQ" class="headerlink" title="如何确保消息正确的发送至RabbitMQ"></a>如何确保消息正确的发送至RabbitMQ</h3><ul><li>RabbitMQ使用发送方确认模式，确保消息正确地发送到RabbitMQ。</li><li>发送方确认模式：将信道设置confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的id。一旦消息被投递到目的地队列之后，或者消息被写入磁盘之后（可持久化消息），信道会发送一个确认和生产者（包含消息唯一id）。</li><li>如果RabbitMQ发送内部错误而导致消息丢失，会发送一条nack(not acknowledged,未确认)消息。</li><li>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。</li><li>当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</li></ul><h3 id="如何确保消费接收方消费了消息"><a href="#如何确保消费接收方消费了消息" class="headerlink" title="如何确保消费接收方消费了消息"></a>如何确保消费接收方消费了消息</h3><ul><li>接收方消息确认机制： 消费者接受每一条消息后都必须进行确认（消息接受和消息确认时两个不同的操作）。</li><li>只有消费者确认了消息，RabbitMQ才能安全的把消息从队列中删除。</li><li>这里并没有用到超时机制，RabbitMQ仅通过COnsumer的连接中断来确认是否需要重新发送消息。</li><li>也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息。</li></ul><p>下面罗列几种特殊情况；</p><ul><li>如果消费者接收到消息，在确认之前断开了连接或者取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者（可能存在消息重复消费的隐患，需要根据bizId去重）</li><li>如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。</li></ul><h3 id="如何避免消息重复投递或者重复消费"><a href="#如何避免消息重复投递或者重复消费" class="headerlink" title="如何避免消息重复投递或者重复消费"></a>如何避免消息重复投递或者重复消费</h3><ul><li>在消息生产时，MQ内部针对每条生产者发送的消息生成了一个inner-msg-id，作为去重和幂等性的依据（消息投递失败并重传）避免重复的消息进入队列；</li><li>在消息消费时，要求消息体重必须要有一个bizId（对于同一个业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。</li></ul><p>这个问题针对业务场景来答，分以下几点：</p><ol><li>比如，你拿到这个消息做数据库的insert操作，那就容易了。给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。</li><li>再比如，你拿到这个消息做redis的set操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。</li><li>如果上面两种情况还不行，上大招，准备一个第三方介质，来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt; id, message&gt; 以key-value形式写入redis。那消费者开始消费前，先去redis中查询有没有消费记录即可。</li></ol><h3 id="如何结局丢数据的问题"><a href="#如何结局丢数据的问题" class="headerlink" title="如何结局丢数据的问题"></a>如何结局丢数据的问题</h3><ol><li>生产者丢数据</li></ol><p>生产者的消息如果没有投递到MQ中怎么办？<br>从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。  </p><p>transaction机制就是说，发送消息前，开启事务（channel.txSelect()）,然后放消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。  </p><p>然后缺点就是吞吐量下降了。因此，生产商用confirm模式居多。<br>一旦channel进入confirm模式，所有在该信道上面发布的消息都将会呗指派一个唯一的ID（从1开始），一旦消息被投递到素有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者（包含消息的唯一ID），这就使得生产知道消息已经正确到达目的地队列了。<br>如果RabbitMQ没能处理该消息，则会发送一个nack消息给你，你可以进行重试操作。</p><ol start="2"><li>消息队列丢失数据</li></ol><p>处理消息队列丢失数据的情况，一般是开启持久化磁盘的配置。<br>这个持久化配置可以和confirm机制配合使用。<br>你可以在消息持久化磁盘之后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，RabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。  </p><p>那么如何持久化呢，这里顺便说一下，其实也很容易，就下面两步骤：  </p><ul><li>将queue的持久化标示durable设置为true，则代表是一个持久的队列</li><li>发送消息的时候将deliveryMode=2</li></ul><p>这样设置以后，RabbitMQ就算挂了，重启后也能恢复数据，在消息还没哟持久化到硬盘时，可能服务已经死掉，这种那个情况可以通过引入mirrored-queue即镜像队列，但是也不能保证消息百分百不丢失（整个集群都挂掉）</p><ol start="3"><li>消费者丢失数据</li></ol><p>启用手动确认模式可以解决这个问题  </p><ul><li>自动确认模式：消费者挂掉，等待ack的消息回归到队列中。消费者抛出异常，消息会不断地被重发，知道处理成功。不会丢失消息，即便服务挂掉，没有处理完成的消息会重回队列，但是异常回访消息不断重试。</li><li>手动确认模式：如果消费者来不及处理就死掉时，没有响应ack时会重复发送一条消息给其他消费者；如果监听程序处理异常了，且未对异常进行捕获，会一直重复接收消息，然后一直抛出异常；如果对异常进行了捕获，但是没有在finally里ack，也会一直重复发送消息（重试机制）；</li><li>不确认模式，acknowledge=”none”,不使用确认机制，只要消息发送完成会立即在队列移除，无论客户端异常还是断开，只要发送完就移除，不会重发。</li></ul><h3 id="死信队列和延迟队列的使用"><a href="#死信队列和延迟队列的使用" class="headerlink" title="死信队列和延迟队列的使用"></a>死信队列和延迟队列的使用</h3><p>死信消息：</p><ol><li>消息被拒绝（Basic.Reject或者Basic.Nack）并且设置requeue参数的值为false</li><li>消息过期了</li><li>队列达到最大的长度</li></ol><p>过期消息：</p><p>在RabbitMQ中存在两种方式方可设置消息的过期时间：</p><ul><li>第一种通过对队列进行设置，这猴子那个设置后，该队列中所有消息都存在相同的过期时间；</li><li>第二种通过对消息本身进行设置，那么每条消息的过期时间都不一样。</li><li>如果同时使用这两种方法，那么以过期时间小的那个数值为准。</li><li>当消息达到过期时间还没有被消费，那么这个消息就成为了一个死信消息.</li></ul><p>队列设置: 在队列申明的时候使用x-message-ttl参数，单位为毫秒</p><p>单个消息设置：是设置消息属性的expiration参数的值，单位为毫秒</p><p>延时队列：在RabbitMQ中不存在延时队列。但是我们可以通过设置消息的过期时间和死信队列来模拟出延时队列。消费者监听死信交换器绑定的队列，而不要监听消息发送的队列。</p><p>需求：用户在系统中创建了一个订单，如果超过时间用户没有进行支付，那么自动取消订单。<br>分析：</p><ol><li>上面这个情况，我们就适合使用延时队列来实现，那么延时队列如何创建</li><li>延时队列可以由 过期消息+死信队列 来实现</li><li>过期消息通过队列中设置x-message-ttl 参数实现</li><li>死信队列通过在队列申明时，给队列设置x-dead-letter-exchange参数，然后另外申明一个队列绑定x-dead-letter-exchange对应的交换器。</li></ol><h3 id="使用消息队列会有什么缺点"><a href="#使用消息队列会有什么缺点" class="headerlink" title="使用消息队列会有什么缺点"></a>使用消息队列会有什么缺点</h3><ol><li>系统可用性降低</li><li>系统复杂性增加，需要考虑的东西更多，系统复杂性增大。</li><li>一致性问题</li></ol><h2 id="SQL数据库索引优化"><a href="#SQL数据库索引优化" class="headerlink" title="SQL数据库索引优化"></a>SQL数据库索引优化</h2><ul><li>索引不会包含有NULLL的值</li><li>使用短索引</li><li>不要在列上进行运算</li><li>不适用not in 和in操作</li></ul><h2 id="SQL数据库查询优化"><a href="#SQL数据库查询优化" class="headerlink" title="SQL数据库查询优化"></a>SQL数据库查询优化</h2><h4 id="SQL优化的具体操作"><a href="#SQL优化的具体操作" class="headerlink" title="SQL优化的具体操作"></a>SQL优化的具体操作</h4><ol><li>在表中建立索引，优先考虑where、group by 使用到的字段；<br>【优化方式】：在表中建立索引，优先考虑where、group by使用到的字段。</li><li>尽量避免使用select * ,<br>返回无用的字段会降低查询效率。<br>如下：select * from t.<br>【优化方式】：使用具体的字段代替*，只返回使用到的字段。</li><li>尽量避免使用in 和not in,会导致数据库引擎放弃索引进行全表扫描。如下:<br>select * from t where id in (2,3);<br>select * from t1 where username in (select username from t2);<br>【优化方式】：如果是连续数值，可以用between and代替。如下：<br>select * from t where id between 2 and 3;<br>如果是子查询，可以用exists代替，如下：<br>select * from t1 where exists (select * from t2 where t1.username=t2.username);</li><li>尽量避免使用or，会导致数据库引擎放弃索引进行全表扫描。如下:<br>select * from t where id=1 or id=3;<br>【优化方式】：可以用union代替or，如下：<br>select * from t where id=1 union select * from t where id=3;<br>(ps:如果or两边的字段是同一个，如例子中这样，貌似两种方式效率差不多，及时union扫描的是索引，or扫描的是全表)。</li><li>尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。如下：<br>select * from t where username like ‘%li%’;<br>【优化方式】：尽量在字段后面使用模糊查询。如下：<br>select * from t where username like ‘li%’;</li><li>尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下：<br>select * from t where score is null;<br>【优化方式】：可以给字段添加默认值为0，对0值进行判断，如下：<br>selext * from t where score =0;</li><li>尽量避免在where条件中等号的左边进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。如下：<br>select * from t2 where score/10=9;<br>select * from t2 where substr(username,1,2)=’li’;<br>【优化方式】：可以将表达式、函数操作移动到灯油右侧，如下：<br>select * from t2 where socre=10*9;<br>select * from t2 where username like ‘li%’;</li><li>当数据量较大时，避免使用where 1=1的条件。通常是为了方便拼装插叙条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：<br>select * from t where 1=1;<br>【优化方式】：用代码拼装sql时进行判断，没有where加where,有where加and.</li><li>对查询进行优化，应尽量避免全表扫描，首先应该考虑在where以及order by涉及的列上建立索引，一个表的索引不能过多，过多则不利于删除、插入等操作。</li><li>避免频繁创建和删除临时表，以减少系统表资源的消耗。</li><li>尽可能的使用varchar代替char，因为首选变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</li><li>尽量使用数字型字段，若只含有数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，炳辉增加存储的开销。这是因为引擎在处理查询和连接是会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</li><li>索引并不是越多越好，索引固然可以提高相应的select的效率，但同时也降低了insert和update的效率，因为insert或者是update时有可能重建索引，所以怎样建立索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，弱太多则应该考虑一些不常使用到的列上键的索引是否有必要。</li><li>并不是所有索引对查询都要效。SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一张表中有字段sex，male、female各占了一半，那么即使在sex上建立了索引也对查询效率起不了作用。</li></ol><h2 id="SQL数据库存储过程优化"><a href="#SQL数据库存储过程优化" class="headerlink" title="SQL数据库存储过程优化"></a>SQL数据库存储过程优化</h2><p>SQL语句需要【先编译然后执行】。<br>而存储过程（Stored Procedure）则是一组为了完成特定功能的【SQL语句集】，经过【编译】之后【存储】在数据库中，用户通过指定存储过程的【名字】并传给定【参数】（如果该存储过程带有参数的话）来调用执行它。  </p><p>存储过程是可编程的函数，在数据库中创建并保存，可以由【SQL语句】和【控制结构】组成。<br>当想要在【不同的应用程序或着平台】上执行【相同的函数】，或者【封装特定功能】时，存储过程是非常有用的。<br>数据库中的存储过程可以看做是对编程中【面向对象方法的模拟】，它【允许控制数据的访问方式】。  </p><p>存储过程的优点：</p><ol><li>【增强SQL语言的功能和灵活性】：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和比较复杂的运算。</li><li>【标准组件式编程】：存储过程被创建之后，可以在程序中被调用多次，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。</li><li>【较快的执行速度】：如果某已操作包含大量的Transaction-SQL代码或者分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句则在每次运行时都要进行编译和优化，速度相对要慢一些。</li><li>【减少网络流量】：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程的时候，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。</li><li>【作为一种安全机制来充分利用】：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全性。</li></ol><h3 id="MySQL的存储过程"><a href="#MySQL的存储过程" class="headerlink" title="MySQL的存储过程"></a>MySQL的存储过程</h3><p>存储过程是数据库的一个重要的功能，【MySQL5.0】 以前并不支持存储过程这使得MySQL在应用上大打折扣。好在MySQL5.0开始支持存储过程，这样既可以大大提高数据库的【处理速度】，同时也可以提供数据库【编程的灵活性】。</p><h3 id="存储过程编写经验和优化措施"><a href="#存储过程编写经验和优化措施" class="headerlink" title="存储过程编写经验和优化措施"></a>存储过程编写经验和优化措施</h3><ol><li>开发人员如果用到其他库的Table或者View，务必在当前库中简历View来实现跨库操作，最好不要直接使用”database.dbo.table_name”，因为sp_depends不能显示出该SP所使用的的跨库table或者view，不方便校验。</li><li>开发人员在提交SP前，必须已经使用set showplan on 分析过查询计划，做过自身的查询优化检查。</li><li>高程序运行效率，优化应用程序，在SP编写过程中应该注意以下几点：</li></ol><ul><li>SQL的使用规范：<ul><li>尽量避免大量事务操作，慎用holdlock子句，提高系统并发能力。</li><li>尽量避免反复访问同一张或者几张表，尤其是数据量较大的二标，可以考虑先根据条件提取数据到临时表中，然后再做连接。</li><li>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过一万行，那么就应该改写；如果使用了游标，就要尽量避免在游标循环中在进行表连接的操作。</li><li>注意where 子句写法，必须考虑语句顺序，应该根据索引顺序，范围大小来确定条件子句的前后顺序，尽可能的让字段顺序与所以顺序相一致，范围从大到小。</li><li>不要在where子句中的”=”左边进行函数、算数运算或者其他表达式运算，否则系统将可能无法正确使用索引。</li><li>尽量使用exists代替select count(1)来判断是否存在记录，count函数只有在统计表中所有行数时使用，而且count(1)比count(*)更有效率。</li><li>尽量使用”&gt;=”，不要使用”&gt;”</li><li>注意一些or子句和union子句之间的替换</li><li>注意表之间的数据类型，避免不同类型数据之间的链接。</li><li>注意存储过程中国参数和数据类型的关系。</li><li>注意insert、update操作的数据量，防止与其他应用冲突。如果数据量超过200个数据页面（400k），那么系统将会进行锁升级，页级锁会升级成表级锁。</li></ul></li><li>索引的使用规范：<ul><li>所以的创建要与应用结合考虑，建议大的OLTP表不要超过6个索引</li><li>尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index_name来强制指定索引</li><li>避免对大表查询时进行table scan,必要时考虑新建索引</li><li>在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用。</li><li>要注意索引的维护，周期性重建索引，重新编译存储过程。</li></ul></li><li>tempdb的使用规范<ul><li>尽量避免使用distinct、order by、group by、having、join、***pute，因为这些语句会加重tempdb的负担。</li><li>避免频繁创建和删除临时表，减少系统表资源的消耗。</li><li>在新建临时表时，如果一次性插入数据量很大，那么可以使用select into 代替create table,避免log,提高速度；如果数据量不大，为了缓和系统表的资源，建议先create table,然后insert</li><li>如果临时表的数据量较大，需要建立索引，那么应该将创建临时表和建立索引的过后才能放在单独一个自存储过程中，这样才能保证系统能够很好的使用到该临时表的索引。</li><li>如果使用到了临时表，在存储过程的最后务必将所有临时表显示删除，先truncate table然后drop table,这样可以便面系统表的较长时间锁定。</li><li>慎用大的临时表与其他大表的链接查询和修改，减低系统表的负担，因为这种操作会在一条语句中多次使用tempdb的系统表。</li></ul></li><li>合理的算法使用<ul><li>根据上面已经提到的SQL优化技术和ASE Tuning手册中的SQL优化内容，结合实际内容，采用多种算法进行比较，以获得消耗资源最少，效率最高的方法。具体可以使用ASE调优命令：set statistics io on,set statistics time on,set showplan on 等。</li></ul></li></ul><h3 id="存储过程执行速度优化"><a href="#存储过程执行速度优化" class="headerlink" title="存储过程执行速度优化"></a>存储过程执行速度优化</h3><ol><li>首先查看存储过程中是否有很多重复的实体表（一般给报表写存储过程，第一步就是使用临时表）</li><li>如果反复使用的实体表很多，就要考虑将这个实体表最小范围的数据放到临时表，这样就可以大大提高查询效率。</li><li>如果前两条都做到了还是很慢，就分步骤执行你的存储过程，看看慢在哪个SQL</li><li>如果临时表做到了，问题基本就是在临时表提取数据的时候慢，那就专门对这个临时表提取数据的sql看看有没有走索引，需要的情况下拆分SQL，分步提取数据。</li><li>分步执行你的存储过程，看看慢在哪一个SQL上。一般给报表写存储过程，要在第一步提取出最小范围的数据放到临时表，之后全部的处理过程都对该临时表操作，不再涉及任何实体表，先看看这一点你做大了没有。</li></ol><h3 id="存储过程编写与优化"><a href="#存储过程编写与优化" class="headerlink" title="存储过程编写与优化"></a>存储过程编写与优化</h3><h4 id="编写存储过程有如下好处"><a href="#编写存储过程有如下好处" class="headerlink" title="编写存储过程有如下好处"></a>编写存储过程有如下好处</h4><ol><li>使用存储过程可以对所执行的SQL语句进行封装，在接口保持不变的情况下不影响调用程序。</li><li>最大限度的重用已缓存的执行计划。</li><li>减少网络流量。</li><li>提供更好的数据库安全控制，防止直接对表操作。</li></ol><p>存储过程的编译占用CPU，因此我们应该发那个孩子存储过程不必要的重新编译。  </p><p>防止存储过程不必要的重新编译，达到优化存储过程的目的。  </p><h4 id="存储过程编写经验和优化措施-1"><a href="#存储过程编写经验和优化措施-1" class="headerlink" title="存储过程编写经验和优化措施"></a>存储过程编写经验和优化措施</h4><ul><li><p>存储过程正确的编译发生于</p><ul><li>1.所引用的表中大部分的数据发生了的更改，导致统计信息变化过大</li><li>2.所引用的表的架构被修改，包括添加或者取消约束，默认值或者规则</li><li>3.明确使用WITH RECOMPILE强制每次执行过程时重新编译或者sp_recompile使用过程缓存无效。</li><li>4.由于服务器内存不足或者长期不使用，使缓存过程被清除。</li></ul></li><li><p>在以下情况下编写的存储过程会被不必要的重新编译</p><ul><li>1.在调用过程时，不指定架构所有者。</li><li>2.存储过程在临时表上执行了特定操作。</li><li>3.过程定义中出现DDL和DML的交错。</li><li>4.不应该使用sp_作为自定义存储过程的前缀。这是微软用作系统存储的前缘；在调用以sp_开头的过程中，会首先在master数据库中进行查找，如果找不到才会在用户数据库中查找。</li><li>5.存储过程编写的安全方面，因为传入的参数可能会引起脚本注入的危险，因此应该对每个参数进行一些判断。</li></ul></li></ul><h2 id="Docker服务"><a href="#Docker服务" class="headerlink" title="Docker服务"></a>Docker服务</h2><h3 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h3><p>Docker是一个【容器化】平台。<br>它以【容器】的形式将您的【应用程序】及其所有【依赖项】打包在一起，以确保您的应用程序在【任何环境】中无缝运行。</p><h3 id="CI-持续集成-服务器的功能是什么"><a href="#CI-持续集成-服务器的功能是什么" class="headerlink" title="CI (持续集成)服务器的功能是什么"></a>CI (持续集成)服务器的功能是什么</h3><p>CI功能就是在每次提交之后不断地集成所有提交到存储库的代码，并编译检查错误。</p><h3 id="什么是Docker镜像"><a href="#什么是Docker镜像" class="headerlink" title="什么是Docker镜像"></a>什么是Docker镜像</h3><p>Docker镜像是Docker容器的源代码，Docker镜像用于创建容器，使用build命令创建镜像。</p><h3 id="什么是Docker容器"><a href="#什么是Docker容器" class="headerlink" title="什么是Docker容器"></a>什么是Docker容器</h3><p>Docker容器包括应用程序以及其所有依赖项，作为操作系统的独立进程运行</p><h3 id="Docker容器有几种状态"><a href="#Docker容器有几种状态" class="headerlink" title="Docker容器有几种状态"></a>Docker容器有几种状态</h3><p>Docker容器可以有四种状态</p><ul><li>运行状态</li><li>已暂停状态</li><li>重新启动状态</li><li>已退出状态</li></ul><h3 id="Docker使用流程"><a href="#Docker使用流程" class="headerlink" title="Docker使用流程"></a>Docker使用流程</h3><ol><li>创建Dockerfile之后，您可以构建它已创建容器的镜像。</li><li>推送或拉取镜像。</li></ol><h3 id="Dockerfile中最常见的命令是什么"><a href="#Dockerfile中最常见的命令是什么" class="headerlink" title="Dockerfile中最常见的命令是什么"></a>Dockerfile中最常见的命令是什么</h3><p>Dockerfile中的一些常用指令如下：</p><ul><li>FROM: 指定基础镜像</li><li>LABEL：功能是为镜像指定标签</li><li>RUN：运行指定的命令</li><li>CMD：容器启动时要运行的命令</li></ul><h3 id="Dockerfile中的命令COPY和ADD命令有什么区别"><a href="#Dockerfile中的命令COPY和ADD命令有什么区别" class="headerlink" title="Dockerfile中的命令COPY和ADD命令有什么区别"></a>Dockerfile中的命令COPY和ADD命令有什么区别</h3><p>COPY与ADD的区别在于：COPY的&lt; src &gt;只能是本地文件，其他的用法一致</p><h3 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h3><ul><li>docker pull 拉取或者更新指定镜像</li><li>docker pusl 将镜像推送至远程仓库</li><li>docker rm 删除容器</li><li>docker rmi 删除镜像</li><li>docker images 列出所有镜像</li><li>docker ps 列出所有容器</li></ul><h3 id="DevOps有哪些优势"><a href="#DevOps有哪些优势" class="headerlink" title="DevOps有哪些优势"></a>DevOps有哪些优势</h3><ol><li>技术优势</li></ol><ul><li>持续的软件交付</li><li>修复不太复杂的问题</li><li>更快地解决问题</li></ul><ol start="2"><li>商业利益：</li></ol><ul><li>更快速的传递功能</li><li>更稳定的操作环境</li><li>有更多时间可以增加价值（而不是修复/维护）</li></ul><h3 id="CI（持续集成）服务器的功能是什么"><a href="#CI（持续集成）服务器的功能是什么" class="headerlink" title="CI（持续集成）服务器的功能是什么"></a>CI（持续集成）服务器的功能是什么</h3><p>CI服务器功能是：不断地集成所有正在进行的更改并由不同的开发人员提交到存储库，并检查编译错误。<br>他需要每天多次构建代码，最好是在每次提交之后，以便他可以检测在问题发生时是哪个提交bug了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java基础&quot;&gt;&lt;a href=&quot;#java基础&quot; class=&quot;headerlink&quot; title=&quot;java基础&quot;&gt;&lt;/a&gt;java基础&lt;/h2&gt;&lt;h2 id=&quot;理解常用的设计模式&quot;&gt;&lt;a href=&quot;#理解常用的设计模式&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="面试题" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="https://fengshana.github.io/2020/03/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%A8%A1%E5%9D%97/"/>
    <id>https://fengshana.github.io/2020/03/23/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%A8%A1%E5%9D%97/</id>
    <published>2020-03-23T13:33:56.000Z</published>
    <updated>2020-03-25T18:40:13.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>借鉴自博客：<a href="https://blog.csdn.net/fangchao2011/article/details/89184058" target="_blank" rel="noopener">https://blog.csdn.net/fangchao2011/article/details/89184058</a></p></blockquote><h2 id="面试题模块"><a href="#面试题模块" class="headerlink" title="面试题模块"></a>面试题模块</h2><ul><li>Java基础</li><li>容器</li><li>多线程</li><li>反射</li><li>对象拷贝</li><li>Java Web模块</li><li>异常</li><li>网络</li><li>设计模式</li><li>Spring/Spring MVC</li><li>SpringBoot/Spring Cloud</li><li>Hibernate</li><li>Mybatis</li><li>RabbitMQ</li><li>Kafka</li><li>Zookeeper</li><li>Mysql</li><li>Redis</li><li>JVM</li></ul><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><ul><li>Java基础</li><li>容器</li><li>多线程</li><li>对象拷贝</li><li>Java Web模块</li><li>异常模块</li><li>网络模块</li><li>设计模块</li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ul><li>Spring<ul><li>Spring MVC</li><li>Spring Boot</li><li>Spring Cloud</li></ul></li><li>Hibernate</li><li>Mybatis</li><li>中间件<ul><li>RabbitMQ</li><li>Kafka</li><li>Zookeeper</li></ul></li><li>数据<ul><li>Mysql</li><li>Redis</li></ul></li><li>JVM</li></ul><h2 id="基础模块"><a href="#基础模块" class="headerlink" title="基础模块"></a>基础模块</h2><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><h4 id="1-JDK和JRE有什么区别"><a href="#1-JDK和JRE有什么区别" class="headerlink" title="1.JDK和JRE有什么区别"></a>1.JDK和JRE有什么区别</h4><ul><li>JDK: Java Development Kit的简称，Java开发工具包，提供了Java的开发环境和运行环境。</li><li>JRE：Java Runtime Environment的简称，Java运行环境，为Java的运行提供了所需环境。</li></ul><p>具体分析来说，【JDK其实包含了JRE，同时还包含了编译Java源码的编译器Javac，还包含了很多Java程序调试和分析的工具。】<br>简单来说，如果你需要运行Java程序，只需要安装JRE就可以了；如果你需要编写Java程序，那么需要安装JDK。  </p><h4 id="2-和equals的区别是什么"><a href="#2-和equals的区别是什么" class="headerlink" title="2.==和equals的区别是什么"></a>2.==和equals的区别是什么</h4><h5 id="解读"><a href="#解读" class="headerlink" title="==解读"></a>==解读</h5><p>对于【基本类型】和【引用类型】，==的作用效果是不同的，如下所示：  </p><ul><li>基本类型：比较的是值是否相同；</li><li>引用类型：比较的是引用是否相同；</li></ul><p>代码示例：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String x=<span class="string">"string"</span>;</span><br><span class="line">String y=<span class="string">"string"</span>;</span><br><span class="line"></span><br><span class="line">String z=<span class="keyword">new</span> <span class="constructor">String(<span class="string">"string"</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x==y);<span class="comment">//true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x==z);<span class="comment">//false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x.equals(y));<span class="comment">//true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x.equals(z));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>代码解读：<br>因为x和y指向的是同一个引用，所以==也是true；<br>而new String()方法则是重写开辟了内存空间，所以==结果为false，而equals比较的一直是值，所以结果都为true。  </p><h5 id="equals解读"><a href="#equals解读" class="headerlink" title="equals解读"></a>equals解读</h5><p>equals本质上就是==，只不过String和Integer等重写了equals方法，把它变成了值比较。  </p><p>看下面的代码就明白了。  </p><p>首先来看默认情况下equals比较一个有相同值的对象，代码如下：  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">String</span> name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Cat c1=<span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line">  Cat c2=<span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line">  System.out.<span class="built_in">println</span>(c1.equals(c2));<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果出乎我们的意料，竟然是false? 这是怎么回事，看了equals源码就知道了，源码如下：  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>==obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来equals本质上就是==  </p><p>那么问题来了，两个相同值的String对象，为什么返回的是true？代码如下:  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> s1=<span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"老王"</span>);</span><br><span class="line"><span class="keyword">String</span> s2=<span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"老王"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(s1.equals(s2));</span><br></pre></td></tr></table></figure><p>同样的，当我们进入String的equals方法，找到了答案，代码如下：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">boolean</span> equals(<span class="keyword">Object</span> anObject)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(this==anObject)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(anObject instanceOf String)&#123;</span><br><span class="line">      String anotherString=(String)anObject;</span><br><span class="line">      <span class="type">int</span> n=<span class="keyword">value</span>.length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(n==anotherString.<span class="keyword">value</span>.length)&#123;</span><br><span class="line">          <span class="type">char</span> v1[]=<span class="keyword">value</span>;</span><br><span class="line">          <span class="type">char</span> v2[]=anotherString.<span class="keyword">value</span>;</span><br><span class="line">          <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span>(n<span class="comment">-- !=0)&#123;</span></span><br><span class="line">            <span class="keyword">if</span>(v1[i] != v2[i])&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是String重写了Object的equals方法，把引用比较改成了值比较。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>==对于基本类型来说是值比较；<br>==对于引用类型来说是比较的引用；<br>而equals默认情况下是引用比较，只是很多类重写了equals方法，比如String、Integer等把他变成了值比较，所以一般情况下equals比较的是值是否相等。  </p><h4 id="3-两个对象的hashCode-相同，则equals-也一定为true，对吗"><a href="#3-两个对象的hashCode-相同，则equals-也一定为true，对吗" class="headerlink" title="3.两个对象的hashCode()相同，则equals()也一定为true，对吗"></a>3.两个对象的hashCode()相同，则equals()也一定为true，对吗</h4><p>不对，两个对象的hashCode()相同，equals()不一定true  </p><p>代码示例：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="string">"通话"</span>;</span><br><span class="line">String str2=<span class="string">"重地"</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println( <span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">"str1: %d | str2: %d"</span>, str1.hash<span class="constructor">Code()</span>, str2.hash<span class="constructor">Code()</span> ) );</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(str1.equals(str2));</span><br></pre></td></tr></table></figure><p>执行的结果：<br>str1: 1179395 | str2: 1179395<br>false  </p><p>代码解读：很显然”通话”和”重地”的hashCode()相同,然而equals()则为false；<br>因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。  </p><h4 id="4-final在Java中有什么作用"><a href="#4-final在Java中有什么作用" class="headerlink" title="4.final在Java中有什么作用"></a>4.final在Java中有什么作用</h4><ul><li>final修饰的类叫做最终类，该类不能被继承</li><li>final修饰的方法不能被重写</li><li>final修饰的变量叫做常量，常量必须初始化，初始化之后值就不能被修改</li></ul><h4 id="5-Java中的Math-round-1-5-等于多少"><a href="#5-Java中的Math-round-1-5-等于多少" class="headerlink" title="5.Java中的Math.round(-1.5)等于多少"></a>5.Java中的Math.round(-1.5)等于多少</h4><p>等于-1。</p><h4 id="6-String属于基础的数据类型吗"><a href="#6-String属于基础的数据类型吗" class="headerlink" title="6.String属于基础的数据类型吗"></a>6.String属于基础的数据类型吗</h4><p>String不属于基础的数据类型；<br>基础类型有8种：byte、short、char、int、long、float、double、boolean;<br>而String属于对象。</p><h4 id="7-Java-中操作字符串的类都有哪些类？他们之间有什么区别"><a href="#7-Java-中操作字符串的类都有哪些类？他们之间有什么区别" class="headerlink" title="7.Java 中操作字符串的类都有哪些类？他们之间有什么区别"></a>7.Java 中操作字符串的类都有哪些类？他们之间有什么区别</h4><p>操作字符串的类有：String、StringBuffer、StringBuilder  </p><p>String和StringBuffer、StringBuilder的区别在于：  </p><p>String声明的是不可变的对象，每次操作都会生成新的String对象，然后将指针指向新的String对象；<br>而StringBuffer、StringBuilder可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用String。  </p><p>StringBuffer和StringBuilder最大的区别在于，StringBuffer是线程安全的，而StringBuilder是非线程安全的。<br>但是StringBuilder的性能却高于StringBuffer，所以单线程环境推荐使用StringBuilder，多线程环境下推荐使用StringBuffer。</p><h4 id="8-String-str-”i”与String-str-new-String-“i”-一样吗"><a href="#8-String-str-”i”与String-str-new-String-“i”-一样吗" class="headerlink" title="8.String str=”i”与String str=new String(“i”)一样吗"></a>8.String str=”i”与String str=new String(“i”)一样吗</h4><p>不一样，因为内存的分配方式不一样。<br>String str=”i”的方式，Java虚拟机会将其分配到常量池当中；而String str=new String(“i”)则会被分配到堆内存中。</p><h4 id="9-如何将字符串反装"><a href="#9-如何将字符串反装" class="headerlink" title="9.如何将字符串反装"></a>9.如何将字符串反装</h4><p>使用StringBuilder 或者StringBuffer的reverse()  </p><p>示例代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer.<span class="keyword">append</span>(<span class="string">"abcdefg"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(stringBuffer.<span class="keyword">reverse</span>());<span class="comment">//gfedcba</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder.<span class="keyword">append</span>(<span class="string">"abcdefg"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(stringBuilder.<span class="keyword">reverse</span>());<span class="comment">//gfedcba</span></span><br></pre></td></tr></table></figure><h4 id="10-String类的常用方法都有哪些"><a href="#10-String类的常用方法都有哪些" class="headerlink" title="10.String类的常用方法都有哪些"></a>10.String类的常用方法都有哪些</h4><p>好饿啊</p><ul><li>indexOf(): 返回指定字符的索引</li><li>chatAt(): 返回指定索引出的字符</li><li>replace(): 字符串替换</li><li>trim(): 取出字符串两端空白</li><li>split(): 分隔字符串，返回一个分隔后的字符串数组</li><li>getBytes(): 返回字符串的byte类型数组</li><li>length(): 返回字符串的长度</li><li>toLowerCase(): 将字符串转成小写字母</li><li>toUpperCase(): 将字符串转成大写字母</li><li>substring(): 截取字符串</li><li>equals(): 字符串比较</li></ul><h4 id="11-抽象类必须要有抽象方法吗"><a href="#11-抽象类必须要有抽象方法吗" class="headerlink" title="11.抽象类必须要有抽象方法吗"></a>11.抽象类必须要有抽象方法吗</h4><p>不需要，抽象类不一定非要有抽象方法。  </p><p>示例代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Cat</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"hi~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，抽象类并没有抽象方法但完全可以正常运行</p><h4 id="12-普通类和抽象类的区别"><a href="#12-普通类和抽象类的区别" class="headerlink" title="12.普通类和抽象类的区别"></a>12.普通类和抽象类的区别</h4><ul><li>普通类不能够包含抽象方法，抽象类可以包含抽象方法；</li><li>抽象类不能够直接实例化，普通类可以直接实例化；</li></ul><h4 id="13-抽象类能够使用final修饰吗"><a href="#13-抽象类能够使用final修饰吗" class="headerlink" title="13.抽象类能够使用final修饰吗"></a>13.抽象类能够使用final修饰吗</h4><p>不能。<br>定义抽象类就是让其他类继承的；<br>如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类。<br>编辑器也会提示错误信息。  </p><h4 id="14-接口和抽象类有什么区别"><a href="#14-接口和抽象类有什么区别" class="headerlink" title="14.接口和抽象类有什么区别"></a>14.接口和抽象类有什么区别</h4><ul><li>实现：抽象类的子类使用extend是来进行继承；接口必须使用implements来实现接口。</li><li>构造函数：抽象类可以有构造函数，但是接口不能有。</li><li>main方法：抽象类可以有main方法，并且我们能够运行他；但是接口不能有main方法。</li><li>实现数量：类可以是实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用public修饰；抽象类中的方法可以使任意访问修饰符。</li></ul><h4 id="15-Java中IO流分几种"><a href="#15-Java中IO流分几种" class="headerlink" title="15.Java中IO流分几种"></a>15.Java中IO流分几种</h4><p>按照功能来分：  </p><ul><li>输入流</li><li>输出流</li></ul><p>按照类型来分：</p><ul><li>字节流</li><li>字符流</li></ul><p>字节流和字符流的区别是： 字节流按照8位传输，以字节为单位，输入输出数据；字符流按照16位传输，以字符为单位；</p><h4 id="16-BIO、NIO、AIO有什么区别"><a href="#16-BIO、NIO、AIO有什么区别" class="headerlink" title="16.BIO、NIO、AIO有什么区别"></a>16.BIO、NIO、AIO有什么区别</h4><ul><li>BIO：Block IO同步阻塞式IO，就是我们平常使用的传统IO，他的特点是模式简单，使用方便，并发处理能力低。</li><li>NIO：New IO同步非阻塞式IO，是传统IO的升级，客户端和服务器通过Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是NIO的升级，也叫NIO2，实现了异步非堵塞IO，异步IO的操作基于事件和回调机制。</li></ul><h4 id="17-Files的常用方法都有哪些"><a href="#17-Files的常用方法都有哪些" class="headerlink" title="17.Files的常用方法都有哪些"></a>17.Files的常用方法都有哪些</h4><ul><li>Files.exists(): 检测文件路径是否存在。</li><li>Files.createFile(): 创建文件。</li><li>Files.createDirectory(): 创建文件夹。</li><li>Files.delete(): 删除一个文件或者目录。</li><li>Files.copy(): 复制文件。</li><li>Files.move(): 移动文件。</li><li>Files.size(): 查看文件个数。</li><li>Files.read(): 读取文件。</li><li>Files.write(): 写入文件。</li></ul><h4 id="抽象类与接口的区别2"><a href="#抽象类与接口的区别2" class="headerlink" title="抽象类与接口的区别2"></a>抽象类与接口的区别2</h4><ol><li>修饰符不同。一个是abstract，一个是interface。</li><li>抽象类中可以有不是抽象的方法，接口当中必须全是抽象方法（jdk1.8之前成立）</li><li>接口中变量全部默认是public static final修饰的常量，抽象类当中不限制。</li><li>抽象类继承（extends），接口实现（implements）。</li><li>抽象类中只能被单继承，接口可以有多实现。</li></ol><h3 id="容器（二）"><a href="#容器（二）" class="headerlink" title="容器（二）"></a>容器（二）</h3><h4 id="18-Java容器都有哪些"><a href="#18-Java容器都有哪些" class="headerlink" title="18.Java容器都有哪些"></a>18.Java容器都有哪些</h4><ul><li>Collection<ul><li>List<ul><li>Vector<ul><li>Stack</li></ul></li><li>ArrayList</li><li>LinkedLIst</li></ul></li><li>Queue<ul><li>LinkedList</li><li>PriorityQueue</li></ul></li><li>Set<ul><li>HashSet<ul><li>LinkHashSet</li></ul></li><li>TreeSet</li></ul></li></ul></li><li>Map<ul><li>HashMap</li><li>TreeMap</li></ul></li></ul><h4 id="19-Collection和Collections有什么区别"><a href="#19-Collection和Collections有什么区别" class="headerlink" title="19.Collection和Collections有什么区别"></a>19.Collection和Collections有什么区别</h4><ul><li>java.util.Collection是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用方法。Collection接口再Java类库当中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方法，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类、帮助类，其中提供了一系列静态方法，用于集合元素进行排序、搜索以及线程安全等各种操作。</li></ul><h4 id="20-List、Set、Map之间的区别是什么"><a href="#20-List、Set、Map之间的区别是什么" class="headerlink" title="20.List、Set、Map之间的区别是什么"></a>20.List、Set、Map之间的区别是什么</h4><table>  <thead>   <tr>      <th>比较</th>      <th>List</th>      <th>Set</th>      <th>Map</th>   </tr>  </thead>  <tbody>    <tr>      <th>继承接口</th>      <td>Collection</td>      <td>Collection</td>      <td></td>    </tr>    <tr>      <th>常见实现类</th>      <td>AbstractList(其常用子类有ArrayList、LinkedList、Vector)</td>      <td>AbstractSet（其常用子类有HashSet、LinkedHashSet、TreeSet）</td>      <td>HashMap、HashTable</td>    </tr>    <tr>      <th>常用方法</th>      <td>add()、remove()、clear()、get()、contains()、size()</td>      <td>add()、remove()、clear()、contains()、size()</td>      <td>put()、get()、remove()、clear()、containsKey()、containsValue()、keySet()、values()、size()</td>    </tr>    <tr>      <th>元素</th>      <td>可重复</td>      <td>不可重复（用equals判断）</td>      <td>不可重复</td>    </tr>    <tr>      <th>顺序</th>      <td>有序</td>      <td>无需（实际上用HashCode决定）</td>      <td></td>    </tr>    <tr>      <th>线程安全</th>      <td>Vector线程安全</td>      <td></td>      <td>HashTable线程安全</td>    </tr>  </tbody></table><h4 id="21-HashMap和HashTable有什么区别"><a href="#21-HashMap和HashTable有什么区别" class="headerlink" title="21.HashMap和HashTable有什么区别"></a>21.HashMap和HashTable有什么区别</h4><ul><li>HashMap去掉了HashTable的contains方法，但是加上了containsValue()和containsKey()方法。</li><li>HashTable是同步的，而hashMap是非同步的，效率上要比HashTable要高</li><li>hashMap允许空键值，而HashTable不允许。</li></ul><h4 id="22-如何决定使用HashMap还是TreeMap"><a href="#22-如何决定使用HashMap还是TreeMap" class="headerlink" title="22.如何决定使用HashMap还是TreeMap"></a>22.如何决定使用HashMap还是TreeMap</h4><p>对于在Map中插入、删除和定位这类操作，HashMap是最好的选择。<br>然后，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。<br>基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p><h4 id="23-说一下HashMap的实现原理"><a href="#23-说一下HashMap的实现原理" class="headerlink" title="23.说一下HashMap的实现原理"></a>23.说一下HashMap的实现原理</h4><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是他不保证该顺序恒久不变。  </p><p>HashMap的数据结构：在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用）。所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个”链表散列”的数据结构，即数组和链表的结合体。  </p><p>当我们往HashMap当中put元素时，<br>首先根据key的hashCode重新计算Hash值，<br>根据Hash值得到这个元素在数组当中的位置（下标），<br>如果该数组在该位置上已经存放了其他元素，那么在这个位置上的元素将以链表的形式存放，新加入的放在链表头部，最先加入的放在链表尾部，如果数组该位置没有元素，那么就直接将该元素放到该数组的该位置上。  </p><p>需要注意Jdk1.8中对HashMap的实现做了优化，当链表当中的节点数据超过了八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn).</p><h4 id="24-说一下HashSet的实现原理"><a href="#24-说一下HashSet的实现原理" class="headerlink" title="24.说一下HashSet的实现原理"></a>24.说一下HashSet的实现原理</h4><ul><li>HashSet底层由HashMap实现</li><li>HashSet的值存放在HashMap的key上</li><li>HashMap的value统一为PRESENT present</li></ul><h4 id="25-ArrayList和LinkedList的区别是什么"><a href="#25-ArrayList和LinkedList的区别是什么" class="headerlink" title="25.ArrayList和LinkedList的区别是什么"></a>25.ArrayList和LinkedList的区别是什么</h4><p>最明显的区别是ArrayList底层的数据结构是数组，支持随机访问。<br>而LinkedList的底层数据结构是双向循环链表，不支持随机访问。<br>使用下标访问下一个元素，ArrayList的时间复杂度是O(1)，而LinkedList的时间复杂度是O(n)。</p><h4 id="26-如何实现数组和List之间的转换"><a href="#26-如何实现数组和List之间的转换" class="headerlink" title="26.如何实现数组和List之间的转换"></a>26.如何实现数组和List之间的转换</h4><ul><li>List转换成为数组：调用ArrayList的toArray()方法</li><li>数组转换成为List：调用Arrays的asList方法</li></ul><h4 id="27-ArrayList和Vector的区别是什么"><a href="#27-ArrayList和Vector的区别是什么" class="headerlink" title="27.ArrayList和Vector的区别是什么"></a>27.ArrayList和Vector的区别是什么</h4><ul><li>Vector是同步的，而ArrayList不是。然后，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</li><li>ArrayList比Vector快，Vector因为有同步，不会过载。</li><li>ArrayList更加通用，因为我们可以使用Collections工具类轻易的获取同步列表和只读列表。</li></ul><h4 id="28-Array和ArrayList有何区别"><a href="#28-Array和ArrayList有何区别" class="headerlink" title="28.Array和ArrayList有何区别"></a>28.Array和ArrayList有何区别</h4><ul><li>Array可以容纳基本类型和对象，而ArrayList只能够容纳对象。</li><li>Array是指定大小后不可变的，而ArrayList是可变的。</li><li>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</li></ul><h4 id="29-在Queue中poll-和remove-有什么区别"><a href="#29-在Queue中poll-和remove-有什么区别" class="headerlink" title="29.在Queue中poll()和remove()有什么区别"></a>29.在Queue中poll()和remove()有什么区别</h4><p>poll()和remove()都是从队列当中取出一个元素，但是poll()在获取元素失败的时候会返回空，但是remove()在获取元素失败的时候会抛出异常。</p><h4 id="30-哪些集合类是线程安全的"><a href="#30-哪些集合类是线程安全的" class="headerlink" title="30.哪些集合类是线程安全的"></a>30.哪些集合类是线程安全的</h4><ul><li>Vector：就比ArrayList多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在Web应用中，特别是前端页面，往往效率（页面响应速度）是优先考虑的。</li><li>stack：堆栈类，先进后出。</li><li>HashTable：就比HashMap多了个线程安全。</li><li>enumeration：枚举，相当于迭代器。</li></ul><h4 id="31-迭代器iterator是什么"><a href="#31-迭代器iterator是什么" class="headerlink" title="31.迭代器iterator是什么"></a>31.迭代器iterator是什么</h4><p>迭代器是一种设计模式。<br>它是一个对象。<br>他可以遍历并选择序列中的对象，而开发人员不需要了解序列的底层结构，迭代器通常被称为”轻量级”对象，因为创建它的代价小。</p><h4 id="32-Iterator怎么使用，有什么特点"><a href="#32-Iterator怎么使用，有什么特点" class="headerlink" title="32.Iterator怎么使用，有什么特点"></a>32.Iterator怎么使用，有什么特点</h4><p>Java中的Iterator功能比较简单，并且只能单向移动。  </p><ol><li>使用方法Iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterator接口，被Collection继承。</li><li>使用next()获得序列中的下一个元素。</li><li>使用hasNext()检查序列中是否还有元素。</li><li>使用remove()将迭代器新返回的元素删除。</li></ol><p>iterator是Java迭代器最简单的实现，为List设计的LIstIterator具有更多的功能，他可以从两个方向遍历List，也可以从List中插入和删除元素。</p><h4 id="Iterator和ListIterator有什么区别"><a href="#Iterator和ListIterator有什么区别" class="headerlink" title="Iterator和ListIterator有什么区别"></a>Iterator和ListIterator有什么区别</h4><ul><li>Iterator可用来遍历Set和List集合，但是LIstIterator只能用来遍历List。</li><li>Iterator对集合只能是向前遍历，ListIterator既可以向前遍历也可以向后遍历。</li><li>LIstIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引等。</li></ul><h4 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h4><p>HashMap的原理：<br>众所周知，HashMap是用来存储Key-Value键值对的一种集合，这个键值对也叫做Entry，而每个Entry都是存储在数组当中，因此这个数组就是HashMap的主干。  </p><p>HashMap数组中的每一个元素的初始值都是NULL。  </p><ol><li>put()方法的实现原理  </li></ol><p>HashMap的一种重要的方法是put()方法，当我们调用put()方法时，比如hashMap.put(“java”,0); 此时要插入一个Key值为”java”的元素，这时首先需要一个Hash函数来确定这个Entry的插入位置，设为index，即index=hash(“java”),假设求出的index值为2，那么这个Entry就会插入到数组索引为2的位置。  </p><p>但是HashMap的长度肯定是有限的，当插入的Entry越来越多时，不同的Key值通过哈希函数算出来的index肯定会有冲突，此时就可以利用链表来解决。  </p><p>其实HashMap数组的每一个元素不只是一个Entry对象，也是一个链表的头结点，每一个Entry对象通过Next指针指向下一个Entry对象，这样，当新的Entry的哈市值与之前的存在冲突时，只需要插入到对应点链表即可。  </p><p>需要注意的是，新来的Entry节点采用的是“头插法”，而不是直接插入在链表的尾部，这时候因为HashMap的发明者认为，新插入的节点被查找出来的可能性更大。  </p><ol start="2"><li>get()方法的实现原理  </li></ol><p>get()方法用来根据key值来查找对应点的value，当调用get方法时，比如hashMap.get(“apple”)，这时同样要对key值做一次Hash映射，算出其对一样的index值，即index=hash(“apple”)。前面说到的可能存在hash冲突，同一个位置可能存在多个Entry，这时就要从对应链表的头结点开始，一个个向下查找，知道找到对应的Key值，这样就获得了索要查找的键值对。例如假设我们要找的Key值是”apple”：  </p><ul><li>第一步，算出key值”apple”的hash值，假设为2.</li><li>第二步，在数组中查找索引为2的位置，此时找到头结点为Entry6,Entry6的key值是banana，不是我们要找的值。</li><li>第三部，查找Entry6的Next节点，这里为Entry1,它的key值为apple,使我们要查找的值，这样就找到了对应的价值对，结束。  </li></ul><p>在jdk1.8之后，hashMap的链表数量如果超过8个，那么就会自动转成红黑树了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;借鉴自博客：&lt;a href=&quot;https://blog.csdn.net/fangchao2011/article/details/89184058&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn
      
    
    </summary>
    
    
      <category term="面试题" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>In the Supermarket</title>
    <link href="https://fengshana.github.io/2020/03/21/%E8%8B%B1%E8%AF%AD/lesson3/"/>
    <id>https://fengshana.github.io/2020/03/21/%E8%8B%B1%E8%AF%AD/lesson3/</id>
    <published>2020-03-21T12:13:40.000Z</published>
    <updated>2020-03-21T14:21:04.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Learn-amp-Talk-I"><a href="#Learn-amp-Talk-I" class="headerlink" title="Learn &amp; Talk I"></a>Learn &amp; Talk I</h2><h3 id="Chapter-1-Shopping"><a href="#Chapter-1-Shopping" class="headerlink" title="Chapter 1 Shopping"></a>Chapter 1 Shopping</h3><h4 id="Lesson-3-In-the-Supermarket"><a href="#Lesson-3-In-the-Supermarket" class="headerlink" title="Lesson 3 In the Supermarket"></a>Lesson 3 In the Supermarket</h4><blockquote><p>at the bottom of the following pages:T1=teaching instructions;T=teacher;S=student</p></blockquote><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ul><li><p>part <big>A</big>. Let’s Learn (12 mins)</p></li><li><p>part <big>B</big>. Let’s Talk (12 mins)</p></li><li><p>part <big>C</big>. Review (1 min)</p></li></ul><blockquote><p>Learning Objectives</p><blockquote><p>学习目标：</p><blockquote><p>4 words about “supermarket shopping” | 4个和”超市购物”相关的单词<br>Expressions for “supermarket” | “超市购物”常用表达<br>How to talk about topics related to “supermarket shopping” | 谈论和”超市购物”相关的话题</p></blockquote></blockquote></blockquote><h2 id="part-A-Let’s-Learn"><a href="#part-A-Let’s-Learn" class="headerlink" title="part A. Let’s Learn"></a>part A. Let’s Learn</h2><h3 id="Vocabulary-4-mins"><a href="#Vocabulary-4-mins" class="headerlink" title="Vocabulary (4 mins)"></a>Vocabulary (4 mins)</h3><table><thead><tr><th>vocabulary</th><th>means</th><th>sentense</th><th>etc</th><th>phrase</th></tr></thead><tbody><tr><td>toothbrush</td><td>a small brush with a long handle that you use to clean your teeth</td><td>e.g. How much is the <u><strong><em>toothbrush</em></strong></u> .</td><td>toothpaste 牙膏；mouthwash 漱口水</td><td></td></tr><tr><td>promote</td><td>to encourage people to like,buy,use,do,or support something 宣传，促销</td><td>e.g. The saleswoman is <u><strong><em>promoting</em></strong></u> cookies.</td><td>promotion n.促销（often on posters 常做海报标语）</td><td></td></tr><tr><td>include</td><td>to contain something as a part of something else,or to make something part of something else 包括</td><td>e.g. This gift pack(礼包) <u><strong><em>includes</em></strong></u> toothbrushes,toothpaste, and mouthwash.</td><td></td><td></td></tr><tr><td>aisle</td><td>a long,narrow space between the rows of shelves in a large shop （商店货架间的）通道</td><td>e.g. You’ll find toothbrushes in the fourth <u><strong><em>aisle</em></strong></u> .</td><td></td><td></td></tr></tbody></table><h3 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h3><h4 id="Role-play-the-dialog-with-your-teacher-twice-and-learn-the-highlighted-expressions-by-heart-和老师一起分角色朗读两遍一下对话。熟记标亮部分的短语和表达"><a href="#Role-play-the-dialog-with-your-teacher-twice-and-learn-the-highlighted-expressions-by-heart-和老师一起分角色朗读两遍一下对话。熟记标亮部分的短语和表达" class="headerlink" title="Role-play the dialog with your teacher twice,and learn the highlighted expressions by heart.和老师一起分角色朗读两遍一下对话。熟记标亮部分的短语和表达"></a>Role-play the dialog with your teacher twice,and learn the highlighted expressions by heart.和老师一起分角色朗读两遍一下对话。熟记标亮部分的短语和表达</h4><h5 id="（Mark-is-choosing-a-gift-for-His-girlfriend-in-a-jewelry-珠宝-store-）"><a href="#（Mark-is-choosing-a-gift-for-His-girlfriend-in-a-jewelry-珠宝-store-）" class="headerlink" title="（Mark is choosing a gift for His girlfriend in a jewelry(珠宝) store.）"></a>（Mark is choosing a gift for His girlfriend in a jewelry(珠宝) store.）</h5><ul><li><strong><em>Salesman:</em></strong> Have a look at these toothbrushes.They are being promoted in this gift pack now.</li><li><strong><em>Mark:</em></strong> What’s included in the gift pack ?</li><li><strong><em>Salesman:</em></strong> Toothbrushes,toothpaste,mouthwash and a cup .</li><li><strong><em>Mark:</em></strong> It’s good deal. Where can i find shower gel(沐浴露).</li><li><strong><em>Salesman:</em></strong> It’s in aisle 10.</li></ul><blockquote><p>It’s good deal. 直译：这是笔好交易./意译：这挺划算的.</p></blockquote><h2 id="part-B-Let’s-Talk"><a href="#part-B-Let’s-Talk" class="headerlink" title="part B. Let’s Talk"></a>part B. Let’s Talk</h2><h3 id="Conversation"><a href="#Conversation" class="headerlink" title="Conversation"></a>Conversation</h3><h4 id="Suppose-you’re-choosing-a-gift-in-a-jewelry-store-Use-th-vocabulary-and-expressions-you’ve-learned-in-part-A-to-complete-the-following-conversation-假设你在商店里挑礼物。运用在第一部分学到的词汇和表达将一下情境对话补充完整"><a href="#Suppose-you’re-choosing-a-gift-in-a-jewelry-store-Use-th-vocabulary-and-expressions-you’ve-learned-in-part-A-to-complete-the-following-conversation-假设你在商店里挑礼物。运用在第一部分学到的词汇和表达将一下情境对话补充完整" class="headerlink" title="Suppose you’re choosing a gift in a jewelry store. Use th vocabulary and expressions you’ve learned in part A to complete the following conversation. 假设你在商店里挑礼物。运用在第一部分学到的词汇和表达将一下情境对话补充完整"></a>Suppose you’re choosing a gift in a jewelry store. Use th vocabulary and expressions you’ve learned in part A to complete the following conversation. 假设你在商店里挑礼物。运用在第一部分学到的词汇和表达将一下情境对话补充完整</h4><blockquote><p>Hints<br><strong><em>aisle</em></strong><br><strong><em>It’s good deal</em></strong><br><strong><em>toothbrush</em></strong><br><strong><em>What’s included in the pack?</em></strong><br><strong><em>promote</em></strong></p></blockquote><ul><li><strong><em>A:</em></strong> Excuse me. Where can i find toothbrush ?</li><li><strong><em>B:</em></strong> In aisle 4. Follow me.</li><li><strong><em>A:</em></strong> Thanks.</li><li><strong><em>B:</em></strong> Have a look at this pack. It’s being promote and it is selling well.</li><li><strong><em>A:</em></strong> What’s included in the pack ?</li><li><strong><em>B:</em></strong> Toothbrushes,toothpaste and mouthwash. They’re only 25 yuan in total(合计).</li><li><strong><em>A:</em></strong> It’s good deal.</li></ul><h3 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h3><h4 id="Talk-with-your-teacher-about-the-following-question-Refer-to-the-hints-if-necessary-和老师一起讨论一下问题。可以参考方框中的提示。"><a href="#Talk-with-your-teacher-about-the-following-question-Refer-to-the-hints-if-necessary-和老师一起讨论一下问题。可以参考方框中的提示。" class="headerlink" title="Talk with your teacher about the following question. Refer to the hints if necessary.和老师一起讨论一下问题。可以参考方框中的提示。"></a>Talk with your teacher about the following question. Refer to the hints if necessary.和老师一起讨论一下问题。可以参考方框中的提示。</h4><ul><li>1.When are things in the supermarket promoted in your city? Will you by a lot when they’re being promoted? Why?</li></ul><blockquote><p>Hints:<br><strong><em>around hoildays like Christmas,Women’s Day…</em></strong><br><strong><em>will by a lot-&gt;cheap/It’s a good deal…</em></strong><br><strong><em>won’t buy a lot-&gt;waste</em></strong></p></blockquote><blockquote><p>Hints:<br><strong><em>toothbrushes</em></strong><br><strong><em>aisle</em></strong><br><strong><em>promoted</em></strong><br><strong><em>What’s included in the pack</em></strong><br><strong><em>It’s a good deal</em></strong></p></blockquote><ul><li>2.How often do you go to the supermarket? What do you usually buy in the supermarket?</li></ul><blockquote><p>Hints:<br><strong><em>every day/every week/when i need to buy</em></strong><br><strong><em>thins/once in a while(时不时，偶尔)…</em></strong><br><strong><em>bread/fruit/drinks/showr gel…</em></strong></p></blockquote><ul><li>Have you ever bought(buy的过去分词) things in an online supermarket? Do you like it? Why or Why not?</li></ul><blockquote><p>Hints:<br><strong><em>yes-&gt;anytime and anywhere / no need to carry the heavy shopping bags…</em></strong><br><strong><em>no-&gt;wait for days for things to come…</em></strong></p></blockquote><h2 id="part-c-Review"><a href="#part-c-Review" class="headerlink" title="part c. Review"></a>part c. Review</h2><p>In this lesson,you’ve learned</p><ul><li>4 words about “shopping in the supermarket”</li></ul><blockquote><p>toothbrush<br>promote<br>include<br>aisle</p></blockquote><ul><li>commonly used expressions for buying gifts</li></ul><blockquote><p>What’s included in the gift pack?<br>It’s good deal.</p></blockquote><ul><li>how to talk about topics related to “supermarket shopping”</li></ul><h2 id="Further-Study"><a href="#Further-Study" class="headerlink" title="Further Study"></a>Further Study</h2><h3 id="Listen-and-Learn"><a href="#Listen-and-Learn" class="headerlink" title="Listen and Learn"></a>Listen and Learn</h3><blockquote><p>save up to 40% 打六折<br>shopping list 购物清单<br>coupon 优惠券</p></blockquote><ul><li>There are lots of items on sale today.</li><li>That chair is for sale.</li></ul><p>(both highlighted phrases means “sold at a lower price”上述加粗词组均有“打特价”之意)</p><blockquote><p>closing down sale 结业大甩卖</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hello,teacher</span><br><span class="line">ok ,i <span class="keyword">am</span> introducing myself <span class="keyword">to</span> you.</span><br><span class="line"><span class="keyword">first</span>,my chinese name <span class="keyword">is</span> fengshana,i <span class="keyword">am</span> not have englishname,<span class="keyword">so</span>,you can <span class="keyword">call</span> <span class="keyword">me</span> shana.</span><br><span class="line">i <span class="keyword">am</span> twenty yeas old.</span><br></pre></td></tr></table></figure><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">like</span> <span class="built_in">Double</span> Twelve Festival,<span class="keyword">or</span> <span class="built_in">Double</span> Eleven Festival <span class="keyword">on</span> internet Shopping <span class="keyword">by</span> TaoBao apps.<span class="keyword">if</span> i have more money,i will buy a lot <span class="keyword">and</span> useful things <span class="keyword">for</span> <span class="keyword">me</span> <span class="keyword">and</span> my family <span class="keyword">when</span> they<span class="comment">'re being promoted. because something usually is expansive,but,if in the some festivals,these will be cheaper than usually. so, the time ,we are not go to the buy, when  we are going to wait.It's good deal.of course, in generally,if i need go to the trip or go to the outside working,  i will buy something to prepare.</span></span><br></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">when i need <span class="built_in">to</span> buy something,so i will go <span class="built_in">to</span> <span class="keyword">the</span> supermarket. </span><br><span class="line">i will <span class="keyword">with</span> my friend buy some vegetables <span class="keyword">and</span> some  fruits <span class="keyword">in</span> <span class="keyword">the</span> supermarket.</span><br><span class="line">usually, <span class="keyword">in</span> <span class="keyword">the</span> evening,<span class="keyword">at</span> <span class="keyword">the</span> <span class="number">8</span><span class="string">'clock,9'</span>clock. we go <span class="built_in">to</span> <span class="keyword">the</span> supermarket <span class="keyword">for</span> preparing our dinner.but ,today,i am <span class="keyword">not</span> go <span class="built_in">to</span> <span class="keyword">the</span> supermarket.because my friends need <span class="built_in">to</span> working <span class="keyword">in</span> her company. so ,today ,<span class="keyword">in</span> <span class="keyword">the</span> evening, i eat some noodles <span class="keyword">as</span> <span class="keyword">a</span> dinner.</span><br></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yes, i have. <span class="keyword">and</span> ,yes, i <span class="built_in">do</span>.</span><br><span class="line">because sometime <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">internet</span> shopping,online supermarket,i can compare <span class="keyword">the</span> store A<span class="string">',and store B,and c ,in these stores compare the same goods ,in price.and i think online supermarket'</span>s goods is cheaper than live supermarket. but have <span class="keyword">a</span> shortcoming,<span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">internet</span> shopping will be <span class="built_in">wait</span> <span class="keyword">for</span> days when you buy something <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">internet</span>.sometimes ,<span class="keyword">it</span><span class="string">'s slowly.sometimes,it'</span>s quickly.sure,when i received my something that i bought <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">internet</span>,i am very happy.looks like kids received sweet <span class="keyword">in</span> <span class="keyword">the</span> festival.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Learn-amp-Talk-I&quot;&gt;&lt;a href=&quot;#Learn-amp-Talk-I&quot; class=&quot;headerlink&quot; title=&quot;Learn &amp;amp; Talk I&quot;&gt;&lt;/a&gt;Learn &amp;amp; Talk I&lt;/h2&gt;&lt;h3 id=&quot;Chapt
      
    
    </summary>
    
    
      <category term="英语" scheme="https://fengshana.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="英语" scheme="https://fengshana.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Choosing a Gift</title>
    <link href="https://fengshana.github.io/2020/03/21/%E8%8B%B1%E8%AF%AD/lesson2/"/>
    <id>https://fengshana.github.io/2020/03/21/%E8%8B%B1%E8%AF%AD/lesson2/</id>
    <published>2020-03-21T06:13:40.000Z</published>
    <updated>2020-03-21T08:05:03.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Learn-amp-Talk-I"><a href="#Learn-amp-Talk-I" class="headerlink" title="Learn &amp; Talk I"></a>Learn &amp; Talk I</h2><h3 id="Chapter-1-Shopping"><a href="#Chapter-1-Shopping" class="headerlink" title="Chapter 1 Shopping"></a>Chapter 1 Shopping</h3><h4 id="Lesson-2-Choosing-a-Gift"><a href="#Lesson-2-Choosing-a-Gift" class="headerlink" title="Lesson 2 Choosing a Gift"></a>Lesson 2 Choosing a Gift</h4><blockquote><p>at the bottom of the following pages:T1=teaching instructions;T=teacher;S=student</p></blockquote><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ul><li><p>part <big>A</big>. Let’s Learn (12 mins)</p></li><li><p>part <big>B</big>. Let’s Talk (12 mins)</p></li><li><p>part <big>C</big>. Review (1 min)</p></li></ul><blockquote><p>Learning Objectives</p><blockquote><p>学习目标：</p><blockquote><p>4 words about “choosing a gift” | 4个和”挑礼物”相关的单词<br>Expressions for “choosing a gift” | “挑礼物”常用表达<br>How to talk about topics related to “choosing a gift” | 谈论和”挑礼物”相关的话题</p></blockquote></blockquote></blockquote><h2 id="part-A-Let’s-Learn"><a href="#part-A-Let’s-Learn" class="headerlink" title="part A. Let’s Learn"></a>part A. Let’s Learn</h2><h3 id="Vocabulary-4-mins"><a href="#Vocabulary-4-mins" class="headerlink" title="Vocabulary (4 mins)"></a>Vocabulary (4 mins)</h3><table><thead><tr><th>vocabulary</th><th>means</th><th>sentense</th><th>etc</th></tr></thead><tbody><tr><td>look for</td><td>to try to find something or someone 寻找（某物/某人）</td><td>e.g. They’re <u><strong>looking for</strong></u> insects in the field.</td><td></td></tr><tr><td>have something in mind</td><td>to think of (想起，有…想法)</td><td>e.g. What do you <u><strong>have in mind</strong></u> ?</td><td></td></tr><tr><td>how about (doing) something</td><td>used to introduce a new subject which you think is relevant to the conversation …怎么样</td><td>e.g. 1.<u><strong><em>How about</em></strong></u> a cup of coffee ? 2.<u><strong><em>How about</em></strong></u> going to the cinema ?</td><td></td></tr><tr><td>gift-wrap</td><td>to wrap as a gift,with decorative pape,ribbon,etc（used as verb）</td><td>e.g. She’s <u><strong><em>gift-wrapping</em></strong></u> the chocolate.</td><td>gift wrapping 礼品的包装（动名词） 、 wrapping paper 礼品包装纸</td></tr></tbody></table><h3 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h3><h4 id="Role-play-the-dialog-with-your-teacher-twice-and-learn-the-highlighted-expressions-by-heart-和老师一起分角色朗读两遍一下对话。熟记标亮部分的短语和表达"><a href="#Role-play-the-dialog-with-your-teacher-twice-and-learn-the-highlighted-expressions-by-heart-和老师一起分角色朗读两遍一下对话。熟记标亮部分的短语和表达" class="headerlink" title="Role-play the dialog with your teacher twice,and learn the highlighted expressions by heart.和老师一起分角色朗读两遍一下对话。熟记标亮部分的短语和表达"></a>Role-play the dialog with your teacher twice,and learn the highlighted expressions by heart.和老师一起分角色朗读两遍一下对话。熟记标亮部分的短语和表达</h4><h5 id="（Mark-is-choosing-a-gift-for-His-girlfriend-in-a-jewelry-珠宝-store-）"><a href="#（Mark-is-choosing-a-gift-for-His-girlfriend-in-a-jewelry-珠宝-store-）" class="headerlink" title="（Mark is choosing a gift for His girlfriend in a jewelry(珠宝) store.）"></a>（Mark is choosing a gift for His girlfriend in a jewelry(珠宝) store.）</h5><ul><li><strong><em>Salesman:</em></strong> Good evening, sir, can i help you ?</li><li><strong><em>Mark:</em></strong> Yeah! I’m looking for a gift for my girlfriend.</li><li><strong><em>Salesman:</em></strong> Do you have something in mind ?</li><li><strong><em>Mark:</em></strong> I think a necklace(项链) would be perfect.</li><li><strong><em>Salesman:</em></strong> How about this one ? It sells very well.</li><li><strong><em>Mark:</em></strong> Sounds good, but could you gift-wrap this,please ?</li><li><strong><em>Salesman:</em></strong> Sure.</li></ul><h2 id="part-B-Let’s-Talk"><a href="#part-B-Let’s-Talk" class="headerlink" title="part B. Let’s Talk"></a>part B. Let’s Talk</h2><h3 id="Conversation"><a href="#Conversation" class="headerlink" title="Conversation"></a>Conversation</h3><h4 id="Suppose-you’re-choosing-a-gift-in-a-jewelry-store-Use-th-vocabulary-and-expressions-you’ve-learned-in-part-A-to-complete-the-following-conversation-假设你在商店里挑礼物。运用在第一部分学到的词汇和表达将一下情境对话补充完整"><a href="#Suppose-you’re-choosing-a-gift-in-a-jewelry-store-Use-th-vocabulary-and-expressions-you’ve-learned-in-part-A-to-complete-the-following-conversation-假设你在商店里挑礼物。运用在第一部分学到的词汇和表达将一下情境对话补充完整" class="headerlink" title="Suppose you’re choosing a gift in a jewelry store. Use th vocabulary and expressions you’ve learned in part A to complete the following conversation. 假设你在商店里挑礼物。运用在第一部分学到的词汇和表达将一下情境对话补充完整"></a>Suppose you’re choosing a gift in a jewelry store. Use th vocabulary and expressions you’ve learned in part A to complete the following conversation. 假设你在商店里挑礼物。运用在第一部分学到的词汇和表达将一下情境对话补充完整</h4><blockquote><p>Hints<br><strong><em>Could you gift-wrap this?</em></strong><br><strong><em>How about this necklace?</em></strong><br><strong><em>look for</em></strong><br><strong><em>(not)have anything in mind</em></strong></p></blockquote><ul><li><strong><em>A:</em></strong> Can I help you, sir/madam?</li><li><strong><em>B:</em></strong> Yes,I’m look for a gift for my mother, but i don’t have anything in mind.</li><li><strong><em>A:</em></strong> How about this necklace? It;s beautiful and perfect as a gift.</li><li><strong><em>B:</em></strong> Could you gift-wrap this?</li><li><strong><em>A:</em></strong> Sure. We offer free gift wrapping.</li><li><strong><em>B:</em></strong> Fine. I’ll take it.</li></ul><h3 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h3><h4 id="Talk-with-your-teacher-about-the-following-question-Refer-to-the-hints-if-necessary-和老师一起讨论一下问题。可以参考方框中的提示。"><a href="#Talk-with-your-teacher-about-the-following-question-Refer-to-the-hints-if-necessary-和老师一起讨论一下问题。可以参考方框中的提示。" class="headerlink" title="Talk with your teacher about the following question. Refer to the hints if necessary.和老师一起讨论一下问题。可以参考方框中的提示。"></a>Talk with your teacher about the following question. Refer to the hints if necessary.和老师一起讨论一下问题。可以参考方框中的提示。</h4><ul><li>1.Describe a gift that you sent to someone recently(最近) or in the past.</li></ul><blockquote><p>Hints:<br><strong><em>What was the gift?</em></strong><br><strong><em>Who did you send th gift to?</em></strong><br><strong><em>When did you send th gift?</em></strong></p></blockquote><ul><li>2.Describe a gift that you ever received.</li></ul><blockquote><p>Hints:<br><strong><em>What was the gift?</em></strong><br><strong><em>Who gave it to you?</em></strong><br><strong><em>When did he/she send you the gift?</em></strong><br><strong><em>Do you like it? Why or why not?</em></strong></p></blockquote><ul><li>Do you think gifts should be wrapped? Why or why not?</li></ul><blockquote><p>Hints:<br><strong><em>yes-&gt;more beautiful / give somebody a surprice…</em></strong><br><strong><em>no-&gt;useless(没用的)/a waste of papre…</em></strong></p></blockquote><h2 id="part-c-Review"><a href="#part-c-Review" class="headerlink" title="part c. Review"></a>part c. Review</h2><p>In this lesson,you’ve learned</p><ul><li>5 phrases about “choosing a gift”</li></ul><blockquote><p>look for<br>have something in mind<br>how about(doing) something<br>gift-wrap</p></blockquote><ul><li>commonly used expressions for buying gifts</li></ul><blockquote><p>How about this one?<br>Could you gift-wrap this,please?</p></blockquote><ul><li>how to talk about topics related to “choosing a gift”</li></ul><h2 id="Further-Study"><a href="#Further-Study" class="headerlink" title="Further Study"></a>Further Study</h2><h3 id="Listen-and-Learn"><a href="#Listen-and-Learn" class="headerlink" title="Listen and Learn"></a>Listen and Learn</h3><blockquote><p>loacl handcrafts 当地的手工艺品<br>handmade candles 手工蜡烛<br>handmade pillow 手工枕头<br>jewelry box 珠宝盒<br>wood carving 木雕刻品</p></blockquote><ul><li>These words are all countable!</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hello,teacher</span><br><span class="line">ok ,i am introducing myself <span class="keyword">to</span> you.</span><br><span class="line"><span class="keyword">first</span>,<span class="keyword">my</span> chinese <span class="built_in">name</span> <span class="keyword">is</span> fengshana,i am <span class="keyword">not</span> have englishname,so,you can call <span class="keyword">me</span> shana.</span><br><span class="line">i am twenty yeas old.</span><br><span class="line">i am a girl. i like reading <span class="keyword">some</span> books.  </span><br><span class="line">now, i am working. i am occuping programing.</span><br><span class="line"><span class="keyword">but</span>,i am look <span class="keyword">for</span> a new job.beacuse ,this <span class="built_in">year</span>,<span class="keyword">in</span> february,i have leaved office. because, i think <span class="keyword">that</span> i am unhappy <span class="keyword">in</span> work <span class="built_in">time</span> ,i fear <span class="keyword">my</span> state <span class="keyword">that</span>  will impact others.so , i leave <span class="keyword">my</span> office.</span><br><span class="line">now, i live <span class="keyword">in</span> china - country,Guangdong province,shenzhen city,longgang distinguish,i <span class="keyword">with</span> <span class="keyword">my</span> friend,she names <span class="keyword">is</span> xielihong ,you can call her lihong,li <span class="keyword">is</span> beautiful mean,hong <span class="keyword">is</span> red. i think her <span class="built_in">name</span> like a beauty.lihong <span class="keyword">with</span> her boyfriend <span class="keyword">in</span> five floors,i like <span class="keyword">in</span> four floors. i live <span class="keyword">on</span> <span class="keyword">my</span> own <span class="keyword">in</span> a studio flat.<span class="keyword">my</span> room <span class="keyword">with</span> a balcony,<span class="keyword">and</span> <span class="keyword">the</span> balcony look out ,have red ,pink,orange colors flower,so beautiful,because ,now <span class="keyword">the</span> season <span class="keyword">is</span> spring.all grass <span class="keyword">is</span> green.<span class="keyword">the</span> wind blowing,sky <span class="keyword">is</span> bule,flowers <span class="keyword">and</span> grass,<span class="keyword">and</span> other grass <span class="keyword">that</span> i can't call these names.<span class="keyword">and</span> <span class="keyword">in</span> <span class="keyword">the</span> morning,<span class="keyword">or</span> now, outside <span class="keyword">of</span> a window,have <span class="keyword">some</span> birds <span class="keyword">that</span> are twittering,peeping. could you imagine <span class="keyword">the</span> picture <span class="keyword">in</span> your mind?</span><br><span class="line"></span><br><span class="line">long ago,<span class="keyword">in</span> <span class="keyword">last</span> <span class="built_in">year</span>, <span class="keyword">in</span> fact, i haved a <span class="built_in">class</span>.later,i haven't a <span class="built_in">class</span>, i think <span class="keyword">that</span> i have more reason,<span class="keyword">but</span>,all reasons <span class="keyword">is</span> used <span class="keyword">as</span> an excuse;so i feel so sorry. teacher.</span><br><span class="line">recently, i have seven  classes. there are classes <span class="keyword">about</span> self-confidence <span class="keyword">and</span>  feelings manager.<span class="keyword">that</span>'s sounds good. <span class="keyword">the</span> teacher <span class="keyword">is</span> chinese.i think these classes are good <span class="keyword">for</span> <span class="keyword">me</span>. i am thanks <span class="keyword">to</span> him.</span><br><span class="line">ok,introducing ,now <span class="keyword">is</span> ending.</span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recently,long long age, like <span class="keyword">last</span> <span class="built_in">year</span>.i send <span class="keyword">the</span> gift <span class="keyword">to</span> <span class="keyword">my</span> friend. <span class="keyword">my</span> friend, just,<span class="keyword">in</span> introducing, referred lihong. <span class="keyword">the</span> gift <span class="keyword">is</span> a cloth. <span class="keyword">the</span> cloth <span class="keyword">that</span> <span class="keyword">it</span>'s <span class="keyword">back</span> have <span class="keyword">some</span> flowers.these flowers <span class="keyword">is</span> pink, <span class="keyword">the</span> cloth <span class="keyword">is</span> a cappa ,similar <span class="keyword">to</span> a cloak,<span class="keyword">but</span> <span class="keyword">it</span> <span class="keyword">is</span> usually long <span class="keyword">and</span> too thin. just <span class="keyword">as</span> lihong' <span class="built_in">name</span>, <span class="keyword">the</span> cloth <span class="keyword">that</span> i think <span class="keyword">is</span> add a beautiful thing <span class="keyword">to</span> a contrasting beautiful girl .<span class="keyword">but</span> ,i hear <span class="keyword">that</span> her <span class="keyword">try</span> <span class="keyword">on</span> <span class="keyword">the</span> cloth looks like long. so ,advice her can take <span class="keyword">in</span> <span class="keyword">that</span> cloth.</span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">last</span> <span class="built_in">year</span>,i received a gift <span class="keyword">is</span> a bracelet. <span class="keyword">the</span> bracelet have a rabbit <span class="keyword">that</span> <span class="keyword">is</span> small <span class="keyword">and</span> white.<span class="keyword">it</span> <span class="keyword">is</span> very delicate.<span class="keyword">but</span> <span class="keyword">it</span> <span class="keyword">is</span> <span class="keyword">not</span> expensive.<span class="keyword">in</span> price field,<span class="keyword">it</span> <span class="keyword">is</span> just so so. <span class="keyword">the</span> bracelet <span class="keyword">with</span> <span class="keyword">some</span> flowers <span class="keyword">and</span> twining vines,branches <span class="keyword">and</span> green leaves. i think <span class="keyword">that</span> <span class="keyword">is</span> beautiful.</span><br><span class="line"></span><br><span class="line"><span class="keyword">isn't</span> someone gave <span class="keyword">it</span> <span class="keyword">to</span> <span class="keyword">me</span>.contrary,<span class="keyword">is</span> one ,two ,three ,four,group <span class="keyword">of</span> people <span class="keyword">that</span> <span class="keyword">is</span> <span class="keyword">my</span> sister <span class="keyword">and</span> her classmates.</span><br><span class="line"><span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">last</span> <span class="built_in">year</span> ,they send <span class="keyword">me</span> <span class="keyword">the</span> gift.i like <span class="keyword">it</span>.<span class="keyword">but</span> i don't like <span class="keyword">some</span> ,<span class="keyword">for</span> example,necklace,jewelry,ornaments.i don't like wearing jewelry. so ,<span class="keyword">the</span> gift was collected <span class="keyword">by</span> <span class="keyword">me</span>.</span><br><span class="line"><span class="keyword">the</span> gift,<span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">my</span> birthday send <span class="keyword">to</span> <span class="keyword">me</span>,neither <span class="keyword">in</span> <span class="keyword">some</span> festival send <span class="keyword">to</span> <span class="keyword">me</span>.</span><br><span class="line">because,<span class="keyword">my</span> sister <span class="keyword">and</span> her classmates <span class="keyword">in</span> senior <span class="keyword">middle</span> school have a dancing show.<span class="keyword">my</span> sister <span class="keyword">is</span> one <span class="keyword">of</span> them <span class="keyword">as</span> a leader dancer.she request <span class="keyword">me</span> <span class="keyword">that</span> whether <span class="keyword">or</span> <span class="keyword">not</span> have <span class="keyword">some</span> free <span class="built_in">time</span> help them make a background video.them shows <span class="keyword">that</span> <span class="keyword">the</span> dancing content <span class="keyword">is</span> ,<span class="keyword">in</span> english, <span class="keyword">is</span> beauty walk. <span class="keyword">in</span> chinese, call show's <span class="built_in">name</span> <span class="keyword">is</span> lirenxing. <span class="keyword">the</span> show model <span class="keyword">from</span> tang dynasty <span class="keyword">in</span> china. when i make <span class="keyword">the</span> video later,i  am very expect <span class="keyword">the</span> show. <span class="keyword">my</span> sister think <span class="keyword">that</span> her afraid audience will prefer <span class="keyword">the</span> video than  them shows. <span class="keyword">the</span> show, i also invite <span class="keyword">my</span> parents <span class="keyword">to</span> <span class="keyword">my</span> sister school <span class="keyword">as</span> audience.<span class="keyword">that</span> point <span class="keyword">of</span> <span class="built_in">time</span> <span class="keyword">is</span> <span class="keyword">my</span> sister school's art festival. <span class="keyword">the</span> show <span class="keyword">is</span> finished successfully.<span class="keyword">my</span> sister <span class="keyword">and</span> her classmates are very thankful <span class="keyword">to</span> <span class="keyword">me</span>,so ,them together discusses an idea <span class="keyword">that</span> send <span class="keyword">me</span> a bracelet.<span class="keyword">it</span> <span class="keyword">is</span> a surprise <span class="keyword">to</span> <span class="keyword">me</span>. <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">time</span>, i even feel <span class="keyword">that</span> i like <span class="keyword">the</span> gift far exceed <span class="keyword">my</span> twenty years birthday. i like <span class="keyword">the</span> gift ,<span class="keyword">but</span> <span class="keyword">not</span> just <span class="keyword">the</span> gift.contrary,i prefer <span class="keyword">to</span> them kindly feelings.<span class="keyword">the</span> point <span class="keyword">is</span> very important.</span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">the</span> <span class="keyword">above</span>-mentioned bracelet <span class="keyword">that</span> was wrapped.</span><br><span class="line">i think <span class="keyword">the</span> gifts whether <span class="keyword">or</span> <span class="keyword">not</span> should be wrapped need observe <span class="keyword">the</span> gift itself.because <span class="keyword">some</span> gift <span class="keyword">is</span> easy broken <span class="keyword">or</span> need <span class="keyword">to</span> take lightly.so, <span class="keyword">in</span> this  situation, <span class="keyword">the</span> gift should be wrapped. others, have <span class="keyword">some</span> big gift,itself haven been wrapped , <span class="keyword">in</span> this condition,so,we needn't <span class="keyword">to</span> wrap <span class="keyword">it</span>.</span><br><span class="line"><span class="keyword">last</span> <span class="keyword">but</span> <span class="keyword">not</span> least,i think <span class="keyword">the</span> gift should be wrapped ,this topic,<span class="keyword">it</span> would <span class="keyword">by</span> best <span class="keyword">not</span> wrapped. because this way <span class="keyword">that</span> i think <span class="keyword">is</span> protect <span class="keyword">the</span> environment. shouldn't wrapped <span class="keyword">the</span> gift <span class="keyword">not</span> <span class="keyword">is</span> useless,contrary,<span class="keyword">if</span> <span class="keyword">the</span> gift have been wrapped,<span class="keyword">it</span> <span class="keyword">is</span> will bring receiver a good impression.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Learn-amp-Talk-I&quot;&gt;&lt;a href=&quot;#Learn-amp-Talk-I&quot; class=&quot;headerlink&quot; title=&quot;Learn &amp;amp; Talk I&quot;&gt;&lt;/a&gt;Learn &amp;amp; Talk I&lt;/h2&gt;&lt;h3 id=&quot;Chapt
      
    
    </summary>
    
    
      <category term="英语" scheme="https://fengshana.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="英语" scheme="https://fengshana.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>第四节心态课</title>
    <link href="https://fengshana.github.io/2020/03/18/%E5%BF%83%E6%80%81%E8%AF%BE/%E7%AC%AC%E5%9B%9B%E8%8A%82%E8%AF%BE/"/>
    <id>https://fengshana.github.io/2020/03/18/%E5%BF%83%E6%80%81%E8%AF%BE/%E7%AC%AC%E5%9B%9B%E8%8A%82%E8%AF%BE/</id>
    <published>2020-03-18T06:33:50.000Z</published>
    <updated>2020-03-18T05:42:23.391Z</updated>
    
    <content type="html"><![CDATA[<p>朋友推荐我看的心态修炼课程：<a href="http://www.gulixueyuan.com/h5/index.html#/course/354" target="_blank" rel="noopener">http://www.gulixueyuan.com/h5/index.html#/course/354</a>   </p><p>第四堂课主题：很多人，一辈子就靠这两个字活着  </p><p>别人家孩子。  </p><p>你看看人家谁谁谁，你再看看你自己  </p><p>不能让孩子输在起跑线上  </p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h2 id="比较无处不在，比较学习"><a href="#比较无处不在，比较学习" class="headerlink" title="比较无处不在，比较学习"></a>比较无处不在，比较学习</h2><p>竞争的是全中国人民。  </p><h2 id="建议：把眼光放远一点，你未来的世界远比现在大"><a href="#建议：把眼光放远一点，你未来的世界远比现在大" class="headerlink" title="建议：把眼光放远一点，你未来的世界远比现在大"></a>建议：把眼光放远一点，你未来的世界远比现在大</h2><p>不要在需要埋头种地的时候，走错了别人家的花园，还以为自己收获了整个秋天，这才是最大的作死  </p><p>生活啊，从来都不会心平气和的和你招招手<br>生活只会一脚把你踢翻在地，然后说傻叉以后长点记性  </p><p>所以别因为比较而沾沾自喜或者郁郁寡欢  </p><p>如果要比，就和上个月的自己比，和以前的自己相比较  </p><h2 id="比较无处不在：比对象"><a href="#比较无处不在：比对象" class="headerlink" title="比较无处不在：比对象"></a>比较无处不在：比对象</h2><p>高不成低不就，难在了比较二字  </p><p>比较有时让人惶恐  </p><p>不要在千千万万的比较当中迷失自我。  </p><p>比较有时候就是用拉人下水的形式找认同感  </p><h2 id="比较无处不在：比较收入"><a href="#比较无处不在：比较收入" class="headerlink" title="比较无处不在：比较收入"></a>比较无处不在：比较收入</h2><p>比较是一种局限和狭隘，会让你变得不思进取  </p><p>人和人的差距，根源在于有的人总是喜欢通过比较降低自己的标准，然后躲在舒适圈，享安乐  </p><p>演好自己的角色，别成天盯着别人的剧本看，越是优秀的人越努力，越是富有的人越勤奋。</p><p>越是智慧的人越是谦卑学习。优秀的人总能看到比自己更好的。而平庸的人总能看到比自己更差的。<br>如果总是看到比自己优秀的人，说明自己可能在走上坡路，你总是看到和自己差不多的人，甚至更甚，说明自己正在混日子。<br>如果你是这个房间最聪明的人，那么自己一定是走错了房间。  </p><p>年龄越大越没有人会原谅你的穷。<br>现在的生活也许不是自己想要的，但是觉得是自己自找的。  </p><p>别成天在比较中安逸，生活里，不必要去苛求别人的理解和认同，因为别人也没有这些义务。  </p><h2 id="记住：今天所做的努力，不是为了让别人觉得自己了不起，而是为了能够让你打心里看得起自己。"><a href="#记住：今天所做的努力，不是为了让别人觉得自己了不起，而是为了能够让你打心里看得起自己。" class="headerlink" title="记住：今天所做的努力，不是为了让别人觉得自己了不起，而是为了能够让你打心里看得起自己。"></a>记住：今天所做的努力，不是为了让别人觉得自己了不起，而是为了能够让你打心里看得起自己。</h2><h2 id="最后：比较无处不在：比个屁"><a href="#最后：比较无处不在：比个屁" class="headerlink" title="最后：比较无处不在：比个屁"></a>最后：比较无处不在：比个屁</h2><p>比较让人愤愤不平。<br>世界上最好的安慰，并不是告诉对方一切都会好起来，而是愁眉苦脸的说，你哭个屁啊，你看我比你还惨  </p><h2 id="一起比惨-痛苦减半"><a href="#一起比惨-痛苦减半" class="headerlink" title="一起比惨 痛苦减半"></a>一起比惨 痛苦减半</h2><p>幸福是用来感觉不是用来比较  </p><p>知足是一种生活态度  </p><p>自己喜欢的东西就不要问别人好不好看，你的生活不会因为别人的话就变好了<br>自己的事情和别人没有关系  </p><p>石黑一雄：如果说有一件事是我鼓励你们大家去做的，那就是永远不要随波逐流，要超越我们周围那些低级和颓废的影响  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;朋友推荐我看的心态修炼课程：&lt;a href=&quot;http://www.gulixueyuan.com/h5/index.html#/course/354&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.gulixueyuan.com/h5
      
    
    </summary>
    
    
      <category term="心态" scheme="https://fengshana.github.io/categories/%E5%BF%83%E6%80%81/"/>
    
    
      <category term="心态课程" scheme="https://fengshana.github.io/tags/%E5%BF%83%E6%80%81%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
</feed>
