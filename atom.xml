<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>✨Fsn✨</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fengshana.github.io/"/>
  <updated>2020-06-26T19:16:34.972Z</updated>
  <id>https://fengshana.github.io/</id>
  
  <author>
    <name>Fsn✨🧙‍♀️✨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MQ消息中间件RabbitMQ 入门到进阶+(牧码人/老王/)+(架构师系列)</title>
    <link href="https://fengshana.github.io/2020/06/19/%E3%80%90RabbitMQ%E3%80%91/MQ%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ%20%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"/>
    <id>https://fengshana.github.io/2020/06/19/%E3%80%90RabbitMQ%E3%80%91/MQ%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ%20%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/</id>
    <published>2020-06-19T14:11:02.310Z</published>
    <updated>2020-06-26T19:16:34.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看链接：<code>https://www.bilibili.com/video/BV1gW411H7Az?from=search&amp;seid=4102616313278484943</code>。</p><h2 id="rabbitmq课程大纲-amp-使用场景"><a href="#rabbitmq课程大纲-amp-使用场景" class="headerlink" title="rabbitmq课程大纲&amp;使用场景"></a>rabbitmq课程大纲&amp;使用场景</h2><p>消息中间件有很多，比如说ActiveMQ、RocketMQ…<br>为什么要讲RabbitMQ呢？<br>一般中小企业都是使用的RabbitMQ，而且性能蛮高的，而且RabbitMQ支持的语言很多，比如说Java、PHP、.NET、GO、JS等；<br>在学习RabbitMQ之前先进行了解一下，</p><h2 id="rabbitmq安装简述"><a href="#rabbitmq安装简述" class="headerlink" title="rabbitmq安装简述"></a>rabbitmq安装简述</h2><h2 id="用户以及vhost配置"><a href="#用户以及vhost配置" class="headerlink" title="用户以及vhost配置"></a>用户以及vhost配置</h2><h2 id="simple简单队列"><a href="#simple简单队列" class="headerlink" title="simple简单队列"></a>simple简单队列</h2><h2 id="simple简单队列java新api"><a href="#simple简单队列java新api" class="headerlink" title="simple简单队列java新api"></a>simple简单队列java新api</h2><h2 id="工作队列之Round-robin轮询分发"><a href="#工作队列之Round-robin轮询分发" class="headerlink" title="工作队列之Round-robin轮询分发"></a>工作队列之Round-robin轮询分发</h2><h2 id="工作队列之Fair-dispatch公平分发"><a href="#工作队列之Fair-dispatch公平分发" class="headerlink" title="工作队列之Fair dispatch公平分发"></a>工作队列之Fair dispatch公平分发</h2><h2 id="消息应答与消息持久化"><a href="#消息应答与消息持久化" class="headerlink" title="消息应答与消息持久化"></a>消息应答与消息持久化</h2><h2 id="publish-subscribe订阅模式"><a href="#publish-subscribe订阅模式" class="headerlink" title="publish_subscribe订阅模式"></a>publish_subscribe订阅模式</h2><h2 id="routing路由模式"><a href="#routing路由模式" class="headerlink" title="routing路由模式"></a>routing路由模式</h2><h2 id="topic主题模式"><a href="#topic主题模式" class="headerlink" title="topic主题模式"></a>topic主题模式</h2><h2 id="rabbitmq消息确认机制之事务机制"><a href="#rabbitmq消息确认机制之事务机制" class="headerlink" title="rabbitmq消息确认机制之事务机制"></a>rabbitmq消息确认机制之事务机制</h2><h2 id="rabbitmq消息确认机制之confirm串行"><a href="#rabbitmq消息确认机制之confirm串行" class="headerlink" title="rabbitmq消息确认机制之confirm串行"></a>rabbitmq消息确认机制之confirm串行</h2><h2 id="rabbitmq消息确认机制之confirm异步"><a href="#rabbitmq消息确认机制之confirm异步" class="headerlink" title="rabbitmq消息确认机制之confirm异步"></a>rabbitmq消息确认机制之confirm异步</h2><h2 id="spring集成rabbitmq-client"><a href="#spring集成rabbitmq-client" class="headerlink" title="spring集成rabbitmq-client"></a>spring集成rabbitmq-client</h2><h2 id="大数据日志收集消息中间件应用场景"><a href="#大数据日志收集消息中间件应用场景" class="headerlink" title="大数据日志收集消息中间件应用场景"></a>大数据日志收集消息中间件应用场景</h2><h2 id="搜索系统DIH时时增量"><a href="#搜索系统DIH时时增量" class="headerlink" title="搜索系统DIH时时增量"></a>搜索系统DIH时时增量</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看链接：&lt;code&gt;https://www.bilibili.com/video/BV1gW411H7Az?from=search&amp;amp
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="RabbitMQ" scheme="https://fengshana.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Java面试内容精讲—并发编程volatile</title>
    <link href="https://fengshana.github.io/2020/06/18/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E5%86%85%E5%AE%B9%E7%B2%BE%E8%AE%B2%E2%80%94%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Bvolatile/"/>
    <id>https://fengshana.github.io/2020/06/18/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E5%86%85%E5%AE%B9%E7%B2%BE%E8%AE%B2%E2%80%94%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Bvolatile/</id>
    <published>2020-06-17T20:20:50.000Z</published>
    <updated>2020-07-03T13:37:25.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看链接：<code>https://www.bilibili.com/video/BV1RC4y1h7YU</code>。</p><h2 id="课程总体说明"><a href="#课程总体说明" class="headerlink" title="课程总体说明"></a>课程总体说明</h2><p>介绍的是有关于并发编程下的<code>volatile</code>关键字的使用；<br>并发编程一直是java实际开发当中一个非常重要的内容，同时也是一个难以理解的内容；<br>在实际开发中或者是在面试中经常被面试官问到关于并发编程的知识点；<code>volatile</code>就是其中一个比较热门的知识点，也是相对于来说比较难以理解的知识点；</p><p>在介绍<code>volatile</code>关键字之前，先来了解一下并发编程的背景；<br>并发编程是在互联网的背景下，当我们的系统开发出来以后，肯定会涉及到非常多的并发量；<br>那么在这么大的并发量的情况下，我们的业务以及共享数据都会出现一个并发安全性的问题。<br>所以并发编程会衍生出非常多的技术；<br>在介绍<code>volatile</code>模块之前，介绍下本次课程的总体介绍。</p><p><strong>并发编程-volatile使用精讲</strong></p><ul><li>第一章 volatile关键字概览（介绍<code>volatile</code>是干嘛用的）<ul><li>多线程下变量的不可见性<ul><li>概述<ul><li>在多线程并发执行下，多个线程修改共享的成员变量，会出现一个线程修改了共享变量的值后，另一个线程不能直接看到该线程修改后的变量的最新值。而通过<code>volatile</code>关键字就可以让共享变量值可见。</li></ul></li><li>案例演示</li><li>执行结果</li><li>小结</li></ul></li><li>变量不可见性内存语义<ul><li>概述</li><li>问题分析</li><li>小结</li></ul></li><li>变量不可见性解决方案<ul><li>概述</li><li>解决方案</li><li>小结</li></ul></li></ul></li><li>第二章 volatile的其他特性<ul><li>volatile特性概述<ul><li>volatile总体概述</li></ul></li><li>volatile不保证原子性<ul><li>问题案例演示</li><li>问题原理说明</li><li>volatile原子性测试</li><li>小结</li><li>问题解决<ul><li>使用锁机制</li><li>原子类<ul><li>AtomicInteger</li><li>案例改造</li></ul></li></ul></li></ul></li><li>禁止指令重排序<ul><li>概述</li><li>重排序的好处</li><li>重排序案例演示</li><li>volatile禁止重排序</li><li>小结</li></ul></li></ul></li><li>第三章 volatile内存语义<ul><li>volatile写读建立的happens-before关系<ul><li>概述</li><li>happens-before规则</li><li>volatile写读建立的happens-before关系</li><li>volatile重排序规则小结</li></ul></li></ul></li><li>第四章 volatile高频面试与总结<ul><li>long和double的原子性<ul><li>概述</li><li>案例演示</li><li>测试结果</li><li>小结</li></ul></li><li>volatile在双重检查加锁的单例中的应用<ul><li>单例概述</li><li>单例模式有8中</li><li>饿汉单例的2种写法<ul><li>饿汉式（静态常量）</li><li>饿汉式（静态代码块）</li></ul></li><li>懒汉式单例4中写法<ul><li>懒汉式（线程不安全）</li><li>懒汉式（线程安全）</li><li>懒汉式（线程不安全）</li><li>懒汉式（volatile双重检查模式 推荐）</li></ul></li><li>静态内部类单例模式</li><li>枚举实现单例</li></ul></li><li>volatile的使用场景<ul><li>纯赋值操作<ul><li>概述</li><li>案例代码</li><li>小结</li></ul></li><li>触发器</li></ul></li><li>volatile与synchronized<ul><li>区别</li></ul></li><li>volatile的总结<ul><li>总体总结</li></ul></li></ul></li></ul><h2 id="多线程下变量的不可见性现象"><a href="#多线程下变量的不可见性现象" class="headerlink" title="多线程下变量的不可见性现象"></a>多线程下变量的不可见性现象</h2><p>多线程下变量的不可见性</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在多线程并发执行下（多条线程执行的情况下），多个线程修改共享的成员变量（共享的成员变量：比如说实例成员变量、一个类中的静态成员变量，那么这些都是可以被多个线程所共享的成员变量），会出现一个线程修改了共享变量的值后，另一个线程不能直接看到该线程修改后的变量的最新值。</p><p>当使用多条线程来访问一个类当中的成员变量的时候，如果其中有一个线程将该成员变量的值给进行修改了则那么另外一个线程可能不能够马上看到这个变量的最新值。<br>这样就可能在并发编程的情况下，可能出现一个变量数据不同步的问题。</p><h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><p>当有一个成员变量的情况下，如果开了多条线程，其中某一个线程A修改了这个变量的取值以后，其他的线程B、C、D可能是无法观看得到线程A所针对这个变量所做的操作；<br>那么通过volatile关键字，就可以使得这个变量的取值在线程之间可见；</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">MyThread</span> <span class="symbol">extends</span> <span class="symbol">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义成员变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">bool</span>ean flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">bool</span>ean isFlag()&#123; <span class="keyword">return</span> flag; &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> run()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将flag的值更改为false</span></span><br><span class="line">    <span class="keyword">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"flag = "</span> + flag)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">VolatileThreadDemo</span>&#123;</span><br><span class="line">  <span class="comment">//测试类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.concurrent;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      目标：研究一下多线程下变量访问的不可见性现象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      准备内容：</span></span><br><span class="line"><span class="comment">        1. 准备两个线程</span></span><br><span class="line"><span class="comment">        2. 定义一个成员变量</span></span><br><span class="line"><span class="comment">        3. 开启两个线程，其中一个线程负责修改，另外一个负责读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisibilityDemo01</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// main()方法本身就是一个主线程，作为一个主线程</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. 开启一个子线程</span></span><br><span class="line">    MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">    <span class="comment">// 启动子线程；在子线程当中将成员变量flag修改为true</span></span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. 主线程执行；定义成一个死循环；</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        调用isFla取出MyThread类当中flag成员变量的值。</span></span><br><span class="line"><span class="comment">        创建好一个子线程t，MyThread当中的flag成员变量属于线程对象t；</span></span><br><span class="line"><span class="comment">        触发启动子线程之后，子线程执行完其run()方法之后，将flag的取值修改为了true；</span></span><br><span class="line"><span class="comment">        从而接着主线程执行判断t.isFlag()时应该取到的值为true；</span></span><br><span class="line"><span class="comment">        取到正确的值之后进入到if判断中来进行打印输出；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        将子线程启动的时候，应该要将flag变量修改为true；</span></span><br><span class="line"><span class="comment">        那么当主线程在执行的时候就会发现flag变量已经为true，</span></span><br><span class="line"><span class="comment">        那么就会进入到if块当中的代码进行打印输出</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span>(t.isFlag())&#123;</span><br><span class="line">        System.out.println(<span class="string">"主线程进入循环执行~~~~~~"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独定义一个类，子线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//重写run方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发修改共享成员变量</span></span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时已经在子线程当中将共享变量flag的取值修改为true；</span></span><br><span class="line">    System.out.println(<span class="string">"flag = "</span> + flag);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.flag=flag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------</span><br><span class="line">运行成功；将主线程当中打印内容<span class="keyword">while</span>(<span class="keyword">true</span>)循环输出；</span><br><span class="line">flag = <span class="keyword">true</span></span><br><span class="line">主线程进入循环执行~~~~~~</span><br><span class="line">主线程进入循环执行~~~~~~</span><br><span class="line">主线程进入循环执行~~~~~~</span><br><span class="line">主线程进入循环执行~~~~~~</span><br><span class="line">主线程进入循环执行~~~~~~</span><br><span class="line">主线程进入循环执行~~~~~~</span><br><span class="line">....</span><br><span class="line">------------------------------------------</span><br><span class="line">原因：</span><br><span class="line">原因在于子线程B很快的将线程MyThread当中的flag修改成了<span class="keyword">true</span>；</span><br><span class="line">所以当主线程再来进行执行的时候，flag的取值已经为<span class="keyword">true</span>了，所以主线程会进入到<span class="keyword">if</span>判断中执行代码块中的打印输出；</span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义成员变量（实例成员变量）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> flag; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将flag的值更改为false</span></span><br><span class="line">    <span class="keyword">this</span>.flag = <span class="keyword">true</span>;</span><br><span class="line">    System.out.println(<span class="string">"flag = "</span> + flag)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileThreadDemo</span></span>&#123;</span><br><span class="line">  <span class="comment">//测试类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      目标：研究一下多线程下变量访问的不可见性现象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      准备内容：</span></span><br><span class="line"><span class="comment">        1. 准备两个线程</span></span><br><span class="line"><span class="comment">        2. 定义一个成员变量</span></span><br><span class="line"><span class="comment">        3. 开启两个线程，其中一个线程负责修改，另外一个负责读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisibilityDemo01</span>&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// main()方法本身就是一个线,程</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. 开启一个子线程</span></span><br><span class="line">    MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. 主线程执行</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(t.isFlag())&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"主线程进入循环执行~~~~~~"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="title">extends</span> <span class="title">Thread</span>&#123;</span></span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    在实际开发过程中，假设更改flag变量取值为true修改得慢一点；</span></span><br><span class="line"><span class="comment">    即让子线程休眠一秒钟；</span></span><br><span class="line"><span class="comment">    而当中子线程在进行休眠的该过程当中主线程其实也是有机会优先执行while(true)循环体中的if判断层的；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发修改共享成员变量</span></span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"flag = "</span> + flag);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.flag=flag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------</span><br><span class="line">运行成功；将主线程当中打印内容<span class="keyword">while</span>(<span class="literal">true</span>)并没有进行循环输出；</span><br><span class="line">flag = <span class="literal">true</span></span><br><span class="line">------------------------------------------</span><br><span class="line">原因：当子线程执行<span class="built_in">run</span>()方法的时候，已经将flag变为了<span class="literal">true</span>；</span><br><span class="line">也就是说子线程已经修改了这个变量的取值；</span><br><span class="line">但是在主线程当中是没有访问得到这个变量的最新取值的；</span><br><span class="line">这样也就出现了多线程下变量访问的不可见性现象。</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><p>此时可以看到，子线程中已经将flag设置为true，<br>但是main()方法当中始终没有读取到修改后的最新值，<br>从而循环没有能进入到if语句中执行，所以没有任何打印。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>多线程下修改共享变量会出现变量修改值后的不可见性。</p><p>（当其中一个变量修改了，而其他线程是可能无法看到修改后的变量的新的取值的）</p><h2 id="多线程下变量不可见性内存语义"><a href="#多线程下变量不可见性内存语义" class="headerlink" title="多线程下变量不可见性内存语义"></a>多线程下变量不可见性内存语义</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>JMM内存模型不同于java基础当中学到的栈、堆，它是属于并发编程下的一个独有的内存模型。通过了解内存模型可以深入理解并发编程当中的底层运转机制。同时也可以更加深入理解volatile关键字，在并发编程当中的作用，以及它可以帮助我们在实际开发当中解决问题。</p><p>在连接多线程并发修改变量不可见现象前，我们需要了解回顾一下Java内存模型（和Java并发编程有关的模型）：JMM。</p><p>JMM（Java Memory Model）：Java内存模型是Java虚拟机规范中所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。</p><p>Java内存模型（Java Memory Model）描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。</p><p>JMM有以下规定：</p><ul><li>所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</li><li>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</li><li>线程对变量的所有操作（读、取）都必须在工作内存中完成，而不能直接读写主内存中的变量。</li><li>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存</li></ul><p>本地内存和主内存的关系：</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><h2 id="多线程下变量不可见性解决方案-加锁，volatile修饰"><a href="#多线程下变量不可见性解决方案-加锁，volatile修饰" class="headerlink" title="多线程下变量不可见性解决方案-加锁，volatile修饰"></a>多线程下变量不可见性解决方案-加锁，volatile修饰</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>如何实现在多线程下访问共享变量，实现一个线程修改变量后，对其他线程可见呢。<br>接下来为大家介绍两种方案：</p><p>第一种加锁；<br>第二种是使用volatile关键字；</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>加锁</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main方法</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  synchronized(t)&#123;</span><br><span class="line">    <span class="keyword">if</span>(t.is<span class="constructor">Flag()</span>)&#123;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"执行了=============="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某一个线程进入synchronized代码块前后，执行过程如下：</p><p>a. 线程获得锁<br>b. 清空工作内存<br>c. 从主内存拷贝共享变量最新的值到工作内存成为副本</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><h2 id="volatile不保证原子性"><a href="#volatile不保证原子性" class="headerlink" title="volatile不保证原子性"></a>volatile不保证原子性</h2><p>第二章 volatile的其他特性</p><h3 id="volatile特性概述"><a href="#volatile特性概述" class="headerlink" title="volatile特性概述"></a>volatile特性概述</h3><p>在上节中，已经研究完了 volatile可以实现并发下共享变量的可见性；<br>除了volatile可以保证可见性外，<br>volatile还具备如下一些突出的特性：<br>volatile的原子性问题：volatile不能保证原子性操作；<br>禁止指令重排序：volatile可以防止指令重排序操作；</p><h3 id="volatile不保证原子性2"><a href="#volatile不保证原子性2" class="headerlink" title="volatile不保证原子性2"></a>volatile不保证原子性2</h3><p>在保证线程安全的情况下，volatile是否可以做到保证原子性？<br>在之前是使用synchronized关键字进行加锁机制来进行保证变量修改的安全性；<br>而volatile无法保证线程安全性；</p><p>所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</p><h4 id="问题案例演示"><a href="#问题案例演示" class="headerlink" title="问题案例演示"></a>问题案例演示</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">VolatileAtomicThread</span> <span class="symbol">implements</span> <span class="symbol">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义一个int类型的遍历</span></span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> run()&#123;</span><br><span class="line">    <span class="comment">// 对该变量进行++操作，100次</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> i = x; x&lt;<span class="number">100</span>; x++)&#123;</span><br><span class="line">      count++;</span><br><span class="line">      System.<span class="keyword">out</span>.println(<span class="string">"count ==========&gt;&gt;&gt;&gt;&gt;&gt;&gt; "</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">VolatileAtomicThreadDemo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建VolatileAtomicThread对象</span></span><br><span class="line">    VolatileAtomicThread volatileAtomicThread = new VolatileAtomicThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启100个线程对count进行++操作</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span>; x&lt;<span class="number">100</span>; x++)&#123;</span><br><span class="line">      new Thread(volatileAtomicThread).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：不保证一定是10000</p><h4 id="问题原理说明"><a href="#问题原理说明" class="headerlink" title="问题原理说明"></a>问题原理说明</h4><h4 id="volatile原子性测试"><a href="#volatile原子性测试" class="headerlink" title="volatile原子性测试"></a>volatile原子性测试</h4><p>代码测试</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个<span class="built_in">int</span> 类型的变量</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="built_in">int</span> <span class="built_in">count</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>在多线程环境下，<code>volatile</code>关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性（在多线程环境下<code>volatile</code>修饰的变量也是线程不安全的）。</p><p>在多线程环境下，要保证数据的安全性，还需要使用锁机制。</p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><h5 id="使用锁机制"><a href="#使用锁机制" class="headerlink" title="使用锁机制"></a>使用锁机制</h5><p>可以给<code>count++</code>操作添加锁，<br>那么<code>count++</code>操作就是临界区的代码，<br>临界区只能有一个线程去执行，<br>所以<code>count++</code>就变成了原子操作。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> VolatileAtomicThread <span class="keyword">implements</span> Runnable&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//定义一个int类型的变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> run ()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对该变量进行++操作，100次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x&lt;<span class="number">100</span>; x++)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="keyword">count</span>++;</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"count ============&gt;&gt;&gt;&gt;&gt;&gt;&gt; "</span>+<span class="keyword">count</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h5><p>概述：java从JDK1.5开始提供了java.util.concurrent.atomic包（简称Atomic包），这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。</p><h6 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h6><p>原子性Integer，可以实现原子更新操作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="constructor">AtomicInteger()</span>:                   初始化一个默认值为<span class="number">0</span>的Integer</span><br><span class="line">public <span class="constructor">AtomicInteger(<span class="params">int</span> <span class="params">initialValue</span>)</span>：  初始化一个指定值的原子性Integer</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> get<span class="literal">()</span>:                                获取值</span><br><span class="line"><span class="built_in">int</span> get<span class="constructor">AndIncrement()</span>:                    以原子方式将当前值加<span class="number">1</span>，注意，这里返回的是自增前的值。</span><br><span class="line"><span class="built_in">int</span> increment<span class="constructor">AndGet()</span>:                    以原子方式将当前值加<span class="number">1</span>，注意，这里返回的是自增后的值。</span><br><span class="line"><span class="built_in">int</span> add<span class="constructor">AndGet(<span class="params">int</span> <span class="params">data</span>)</span>:                  以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</span><br><span class="line"><span class="built_in">int</span> get<span class="constructor">AndSet(<span class="params">int</span> <span class="params">value</span>)</span>:                 以原子方式设置为newValue的值，并返回旧值。</span><br></pre></td></tr></table></figure><p>演示基本使用</p><h6 id="案例改造"><a href="#案例改造" class="headerlink" title="案例改造"></a>案例改造</h6><p>使用AtomicInteger对案例进行改造</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">VolatileAtomicThread</span> <span class="symbol">implements</span> <span class="symbol">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="volatile原子性操作保障：加锁机制"><a href="#volatile原子性操作保障：加锁机制" class="headerlink" title="volatile原子性操作保障：加锁机制"></a>volatile原子性操作保障：加锁机制</h2><h2 id="volatile原子性操作保障：使用原子类"><a href="#volatile原子性操作保障：使用原子类" class="headerlink" title="volatile原子性操作保障：使用原子类"></a>volatile原子性操作保障：使用原子类</h2><h2 id="重排序的概述和好处"><a href="#重排序的概述和好处" class="headerlink" title="重排序的概述和好处"></a>重排序的概述和好处</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><strong>什么是重排序</strong>：为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。</p><p>一个好的内存模型 实际上会 放松对处理器和编译器规则的束缚，<br>也就是说 软件技术和硬件技术都为同一个目标而进行奋斗：<br>  在不改变程序执行结果的前提下，尽可能提高执行效率。</p><p>JMM对底层尽量减少约束，使其能够发挥自身优势。<br>因此，在执行程序时，为了提高性能，编译器和处理器常常会对指令重排序，一般重排序可以分为如下三种：</p><ol><li><p>编译器优化的重排序，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；</p></li><li><p>指令集并行的重排序。现代处理器采用了指令集并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li><li><p>内存系统的重排序，由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。</p></li></ol><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>     --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>      --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>     --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>     --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="comment">|</span> <span class="comment">源代码</span> <span class="comment">|</span> --<span class="literal">-</span><span class="comment">→</span> <span class="comment">|</span> <span class="comment">1：编译器优化重排序</span> <span class="comment">|</span>  --<span class="literal">-</span><span class="comment">→</span> <span class="comment">|</span> <span class="comment">2：指令集并行重排序</span> <span class="comment">|</span> --<span class="literal">-</span><span class="comment">→</span> <span class="comment">|</span> <span class="comment">3：内存系统重排序</span> <span class="comment">|</span> --<span class="literal">-</span><span class="comment">→</span> <span class="comment">|</span> <span class="comment">最终执行的指令序列</span> <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>     --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>      --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>     --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>     --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br></pre></td></tr></table></figure><h3 id="重排序的好处"><a href="#重排序的好处" class="headerlink" title="重排序的好处"></a>重排序的好处</h3><p>重排序可以提高处理的速度</p><h2 id="重排序带来的问题演示"><a href="#重排序带来的问题演示" class="headerlink" title="重排序带来的问题演示"></a>重排序带来的问题演示</h2><h3 id="重排序案例演示"><a href="#重排序案例演示" class="headerlink" title="重排序案例演示"></a>重排序案例演示</h3><p><strong>引入</strong>：重排序虽然可以提高执行的效率，但是在并发执行下，JVM虚拟机底层并不能保证重排序下带来的安全性等问题，请看如下案例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">OutOfOrderExecution</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> static <span class="built_in">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> static <span class="built_in">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) throws InterruptedException&#123;</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;<span class="comment">// 计数</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="volatile禁止指令重排序"><a href="#volatile禁止指令重排序" class="headerlink" title="volatile禁止指令重排序"></a>volatile禁止指令重排序</h2><p>volatile修饰变量后可以实现禁止指令重排序！<br>volatile禁止重排序案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfOrderException</span></span>&#123;</span><br><span class="line">  <span class="comment">//使用volatile修饰变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span>  i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span>  a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">// 计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      count++;</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line">      j = <span class="number">0</span>;</span><br><span class="line">      a = <span class="number">0</span>;</span><br><span class="line">      b = <span class="number">0</span>;</span><br><span class="line">      Thread one  = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">          a = <span class="number">1</span>;</span><br><span class="line">          i = b;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      Thread two =  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><ul><li>使用volatile可以禁止指令重排序，从而修正重排序可能带来的并发安全问题。</li></ul><h2 id="happens-before的概述和常见规则"><a href="#happens-before的概述和常见规则" class="headerlink" title="happens-before的概述和常见规则"></a>happens-before的概述和常见规则</h2><p>第三章 volatile内存语义</p><h3 id="volatile写读建立的happens-before关系"><a href="#volatile写读建立的happens-before关系" class="headerlink" title="volatile写读建立的happens-before关系"></a>volatile写读建立的happens-before关系</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>上面的内容讲述了重排序原则，为了提高处理速度，JVM会对代码进行编译优化，也就是指令重排序优化，并发编程下指令重排序会带来一些安全隐患：<br>如指令重排序导致的多个线程操作之间的不可见性。<br>如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。</p><p>从JDK5开始，提出了happens-before的概念，通过这个概念来阐述操作之间的内存可见性。<br>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。<br>这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p><p>所以为了解决多线程的可见性问题，就提出了happens-before原则，让线程之间遵守这些原则，优化我们的语句，所以等于是给编译器优化的约束，不能让它优化的不知道东南西北了！</p><p>简单来说: happens-before应该翻译成：前一个操作的结果可以被后续的操作获取，讲白点就是：前面一个操作变量a赋值为1，那后面一个操作肯定能知道a已经变成了1。</p><h4 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h4><p>具体的一共有六项规则：</p><ol><li>程序顺序规则（单线程规则）<ul><li>解释：一个线程中的每个操作，happens-before于该线程中的任意后续操作</li><li>同一个线程中前面的所有写操作对后面的操作可见</li></ul></li><li>锁规则（Synchronized，Lock等）<ul><li>解释：对一个锁的解锁，happens-before于随后对这个锁的加锁；</li><li>如果线程1解锁了monitor a，接着线程2锁定了a，那么线程1解锁a之前的写操作都对线程线程2可见（线程1和线程2可以是同一个线程）</li></ul></li><li>volatile变量规则：<ul><li>解释：对一个volatile域的写，happens-before于任意后序对这个volatile域的读</li><li>如果线程1写入了volatile变量v(临界资源)，接着线程2读取了v，那么，线程1写入v及对线程2可见（线程1和线程2可以是同一个线程）</li></ul></li><li>传递性:<ul><li>解释： 如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li>A happens-before B， B happens-before C ，那么可以得到 A happens-before C</li></ul></li><li>start()规则：<ul><li>解释：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li><li>假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行前对线程B可见。注意：线程B启动之后，线程A对变量修改线程B未必可见。</li></ul></li></ol><h2 id="volatile写读建立的happens-before规则演示"><a href="#volatile写读建立的happens-before规则演示" class="headerlink" title="volatile写读建立的happens-before规则演示"></a>volatile写读建立的happens-before规则演示</h2><h2 id="long和double的原子性问题解决方案"><a href="#long和double的原子性问题解决方案" class="headerlink" title="long和double的原子性问题解决方案"></a>long和double的原子性问题解决方案</h2><p>第四章 volatile高频面试与总结</p><h3 id="long和double的原子性"><a href="#long和double的原子性" class="headerlink" title="long和double的原子性"></a>long和double的原子性</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>在java中，long和double都是8个字节共64位（一个字节=8bit）<br>那么如果是一个32位的系统，读写long或double的变量时会涉及到原子性问题，<br>因为32位的系统要读完64位的变量，需要分两步执行，每次读取32位，这样对double和long变量的赋值就会出现问题：</p><p>如果两个线程同时写一个变量内存，一个进程写低32位，而另一个写高32位，这样将导致获取的64位数据是失效的数据。</p><h4 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a>案例演示</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LongTest</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> aLong = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LongTest</span>(<span class="params"><span class="keyword">long</span> <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setValue(<span class="keyword">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( i &lt; <span class="number">100000</span>)&#123;</span><br><span class="line">      LongTest along = <span class="keyword">this</span>.getValue();</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">long</span> temp = LongTest.aLong;</span><br><span class="line">      <span class="keyword">if</span>(temp != <span class="number">1L</span> &amp;&amp; temp != <span class="number">-1L</span>)&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"出现错误结果"</span>+ temp);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"运行正确"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)throws InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例、懒汉、饿汉单例的概念"><a href="#单例、懒汉、饿汉单例的概念" class="headerlink" title="单例、懒汉、饿汉单例的概念"></a>单例、懒汉、饿汉单例的概念</h2><p>volatile在双重检查加锁的单例中的应用</p><h3 id="单例模式有八种"><a href="#单例模式有八种" class="headerlink" title="单例模式有八种"></a>单例模式有八种</h3><p>单例模式可以提供出8中写法，有很多时候存在饿汉式单例的概念，以及懒汉式单例的概念。</p><p>饿汉式单例的含义是：在获取单例对象之前对象已经创建完成了。<br>懒汉式单例是指：在真正需要单例的时候才创建出该对象。</p><h2 id="饿汉式单例的2种写法"><a href="#饿汉式单例的2种写法" class="headerlink" title="饿汉式单例的2种写法"></a>饿汉式单例的2种写法</h2><h3 id="饿汉单例的两种写法"><a href="#饿汉单例的两种写法" class="headerlink" title="饿汉单例的两种写法"></a>饿汉单例的两种写法</h3><h4 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 饿汉式（静态常量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton1 INSTANCE = <span class="keyword">new</span> Singleton1();</span><br><span class="line">    <span class="keyword">private</span> Singleton1&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="懒汉式单例的2种写法与线程安全分析"><a href="#懒汉式单例的2种写法与线程安全分析" class="headerlink" title="懒汉式单例的2种写法与线程安全分析"></a>懒汉式单例的2种写法与线程安全分析</h2><h3 id="懒汉式单例四种写法"><a href="#懒汉式单例四种写法" class="headerlink" title="懒汉式单例四种写法"></a>懒汉式单例四种写法</h3><h4 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h4><h4 id="懒汉式（线程安全）"><a href="#懒汉式（线程安全）" class="headerlink" title="懒汉式（线程安全）"></a>懒汉式（线程安全）</h4><h4 id="懒汉式（线程不安全）-1"><a href="#懒汉式（线程不安全）-1" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h4><h4 id="懒汉式（volatile双重检查模式-推荐）"><a href="#懒汉式（volatile双重检查模式-推荐）" class="headerlink" title="懒汉式（volatile双重检查模式 推荐）"></a>懒汉式（volatile双重检查模式 推荐）</h4><h5 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h5><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 描述： 双重检查，推荐面试中进行使用。</span><br><span class="line"> */</span><br><span class="line"><span class="keyword"> public</span> class Singleton6&#123;</span><br><span class="line">   // 静态属性，volatile保证可见性和禁止指令重排序</span><br><span class="line">  <span class="keyword"> private</span> volatile<span class="keyword"> static</span> Singleton6<span class="built_in"> instance </span>= null;</span><br><span class="line"></span><br><span class="line">   // 私有化构造器</span><br><span class="line">  <span class="keyword"> private</span> Singleton6()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword"> public</span><span class="keyword"> static</span> Singleton6 getInstance()&#123;</span><br><span class="line"></span><br><span class="line">     //第一重检查锁定</span><br><span class="line">     if(instance == null)&#123;</span><br><span class="line"></span><br><span class="line">       // 同步锁定代码块</span><br><span class="line">       synchronized(Singleton6.class)&#123;</span><br><span class="line"></span><br><span class="line">         //第二重检查锁定</span><br><span class="line">          if(instance == null)&#123;</span><br><span class="line"></span><br><span class="line">            //注意：非原子操作</span><br><span class="line">           <span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton6();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in"> return </span>instance;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>双重检查的优点：线程安全，延迟加载，效率较高！</p><p>为何要使用volatile保证安全？</p><p>1、禁止指令重排序</p><ul><li>对象实际上创建对象要经过如下几个步骤：</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. 看<span class="built_in">class</span>对象是否加载，如果没有就先加载<span class="built_in">class</span>对象</span><br><span class="line">b. 分配内存空间，初始化示例。</span><br><span class="line">c. 调用构造函数</span><br><span class="line">d. 返回地址给引用</span><br></pre></td></tr></table></figure><h4 id="静态内部类单例方式"><a href="#静态内部类单例方式" class="headerlink" title="静态内部类单例方式"></a>静态内部类单例方式</h4><h4 id="枚举实现单例"><a href="#枚举实现单例" class="headerlink" title="枚举实现单例"></a>枚举实现单例</h4><h2 id="懒汉式单例性能优化后的进阶写法"><a href="#懒汉式单例性能优化后的进阶写法" class="headerlink" title="懒汉式单例性能优化后的进阶写法"></a>懒汉式单例性能优化后的进阶写法</h2><h2 id="懒汉式双重检查模式与volatile修饰"><a href="#懒汉式双重检查模式与volatile修饰" class="headerlink" title="懒汉式双重检查模式与volatile修饰"></a>懒汉式双重检查模式与volatile修饰</h2><h2 id="懒汉式静态内部类单例方式"><a href="#懒汉式静态内部类单例方式" class="headerlink" title="懒汉式静态内部类单例方式"></a>懒汉式静态内部类单例方式</h2><h2 id="枚举实现单例思想介绍"><a href="#枚举实现单例思想介绍" class="headerlink" title="枚举实现单例思想介绍"></a>枚举实现单例思想介绍</h2><h2 id="volatile的使用场景之一：纯赋值操作"><a href="#volatile的使用场景之一：纯赋值操作" class="headerlink" title="volatile的使用场景之一：纯赋值操作"></a>volatile的使用场景之一：纯赋值操作</h2><p>volatile的使用场景</p><h3 id="纯赋值操作"><a href="#纯赋值操作" class="headerlink" title="纯赋值操作"></a>纯赋值操作</h3><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p>volatile不适合做a++。<br>适合做纯赋值操作：如<code>boolean flag = false/true;</code>。</p><h4 id="案例代码-1"><a href="#案例代码-1" class="headerlink" title="案例代码"></a>案例代码</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseVolatile1</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="literal">false</span>;</span><br><span class="line">  AtomicInteger realA = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws InterruptedException</span>&#123;</span><br><span class="line">    UseVolatile1 r  = <span class="keyword">new</span> UseVolatile1();</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread1.join();</span><br><span class="line">    thread2.join();</span><br><span class="line">    System.out.<span class="built_in">println</span>(r.flag);</span><br><span class="line">    System.out.<span class="built_in">println</span>(r.realA.<span class="built_in">get</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">      setDone();</span><br><span class="line">      realA.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setDone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    flag = <span class="literal">true</span>; <span class="comment">// 纯赋值操作符合预期</span></span><br><span class="line">    <span class="comment">// flag = !flag; // 这样做不符合预期</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>volatile 可以适合做多线程中的纯赋值操作；<br>如果一个共享变量自始至终只被各个线程赋值，而没有其他的操作，<br>那么就可以用volatile来代替synchronized或者代替原子变量。<br>因为赋值自身是有原子性的，而volatile又保证了可见性，所以就足以保证线程安全。</p><h2 id="volatile的第二种使用场景：触发器"><a href="#volatile的第二种使用场景：触发器" class="headerlink" title="volatile的第二种使用场景：触发器"></a>volatile的第二种使用场景：触发器</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>按照volatile的可见性和禁止重排序以及happens-before规则。<br>volatile可以作为刷新之前变量的触发器。<br>可以将某个变量设置为volatile修饰，其他线程一旦发现该变量修改的值后，<br>触发获取到该变量之前的操作都将是最新的且可见。</p><h3 id="案例演示-2"><a href="#案例演示-2" class="headerlink" title="案例演示"></a>案例演示</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisibilityHP</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">      a = <span class="number">3</span>;</span><br><span class="line">      b = <span class="number">4</span>;</span><br><span class="line">      c = a;</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// flag被volatile修饰，充当了触发器，一旦值为true，此处立即对变量之前的操作可见。</span></span><br><span class="line">      <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"a = "</span>+ a + <span class="string">"; b = "</span>+ b + <span class="string">"; c = "</span>+ c);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        VisibilityHP test = <span class="keyword">new</span> VisibilityHP();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">          &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="volatile与synchronized的区别说明"><a href="#volatile与synchronized的区别说明" class="headerlink" title="volatile与synchronized的区别说明"></a>volatile与synchronized的区别说明</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>volatile只能修饰实例变量和类变量，而synchronized可以修饰方法以及代码块。</li><li>volatile保证数据的可见性，但是不保证原子性（多线程进行写操作，不保证线程安全）；而synchronized是一种排他（互斥）的机制。</li><li>volatile用于禁止指令重排序：可以解决单例双重检查乱序问题。</li><li>volatile可看作是轻量版的synchronized，volatile不保证原子性；但是如果对一个共享变量进行多个线程的赋值，而没有其他的操作，那么就可以用volatile来代替synchronized，因为赋值本身是有原子性的，而volatile又保证了一致性，所以就可以保证线程安全了；</li></ul><h2 id="volatile总体总结说明"><a href="#volatile总体总结说明" class="headerlink" title="volatile总体总结说明"></a>volatile总体总结说明</h2><h3 id="总体总结"><a href="#总体总结" class="headerlink" title="总体总结"></a>总体总结</h3><ol><li>volatile 修饰符 用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如<code>boolean flag;</code>或者作为触发器实现轻量级同步。</li><li>volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁上，所以说它是低成本的。</li><li>volatile只能作用域属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序。</li><li>volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见。volatile属性不会被线程缓存，始终从主内存中读取。</li><li>volatile提供了happens-before保证对volatile变量的写入，happens-before所有其他线程后续对V的操作。</li><li>volatile可以使得long和double的赋值时原子的。</li><li>volatile可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看链接：&lt;code&gt;https://www.bilibili.com/video/BV1RC4y1h7YU&lt;/code&gt;。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="面试" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="锁" scheme="https://fengshana.github.io/tags/%E9%94%81/"/>
    
      <category term="volatile" scheme="https://fengshana.github.io/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>Gradle入门</title>
    <link href="https://fengshana.github.io/2020/06/16/%E3%80%90Gradle%E3%80%91/Gradle%E5%85%A5%E9%97%A8/"/>
    <id>https://fengshana.github.io/2020/06/16/%E3%80%90Gradle%E3%80%91/Gradle%E5%85%A5%E9%97%A8/</id>
    <published>2020-06-15T21:03:11.245Z</published>
    <updated>2020-06-16T12:55:21.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：<code>https://www.bilibili.com/video/BV1iW411C7CV?from=search&amp;seid=6869625427262249863</code>。<br>相关笔记截图放在qq:198866436的空间相册当中了；<br>这真是我听过的课程当中费时最少的一门课程；</p><h2 id="gradle介绍01"><a href="#gradle介绍01" class="headerlink" title="gradle介绍01"></a>gradle介绍01</h2><h3 id="课程引导语"><a href="#课程引导语" class="headerlink" title="课程引导语"></a>课程引导语</h3><p>java作为一门世界级主流编程语言，有一款高效易用的项目管理工具是java开发者共同追求的心愿和目标。<br>是2000年Ant（项目管理工具，很好的解决在项目开发当中一系列繁琐问题，但是好景不长，Ant又暴露出了其自身的一些问题），后有2004年Maven（项目管理工具，使用率非常高，但是仍然存在有不足之处）两个工具的诞生，都在Java市场上取得了巨大的成功，但是二者都有一定的不足和局限性。</p><p>Maven具有两大特性：</p><ol><li>管理jar包（最主要的功能）<ul><li>如何管理jar包<ul><li>maven将真正的jar包存放在仓库中，项目中存放着所依赖的jar包的坐标；这个坐标的配置使用的是XML文件来进行配置的；随着项目所依赖的jar包越来越多，XML文件当中的坐标也就越来越多从而导致XML文件越来越大，XML里面的内容也就会变得越来越繁琐，这个就是很多的java开发者所不想看到的一个现象，而gradle的出现就很好的弥补了这一缺陷；gradle不使用XML来进行配置，而是使用一种新的语言叫做Groovy；Groovy是一种新的编程语言，首先对java做了一个全面的兼容，也就是所有的java语言在Groovy环境下都是可以进行执行的；当然groovy也有很多其自己的特性；使得编程变得更加的简单；融合性也更加的高；也就是说如果想学习Gradle就需要对Groovy语言有一个大概的认识；Gradle工具现阶段主要应用于Java应用；</li></ul></li></ul></li><li>构建项目</li></ol><p>2012年基于Ant和Maven产生的Gradle，弥补了Ant和Maven的不足，带来了一些更高效的特点。<br>它使用一种基于Groovy的特定领域语言（DSL）来声明项目配置，抛弃了基于XML的各种繁琐配置。<br>面向Java应用为主。<br>当前其支持的语言限于Java、Groovy和Scala，计划未来将支持更多的语言。</p><h3 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h3><p>本课程主要分以下几个步骤来讲解gradle工具的使用：</p><ol><li>Gradle安装配置（Windows版）</li><li>Gradle和idea集成</li><li>Groovy语言简单介绍</li><li>Gradle仓库的配置</li><li>Gradle入门案例</li><li>Gradle创建Java web工程并在tomcat下运行</li><li>Gradle构建多模块项目</li></ol><h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><h2 id="gradle的安装"><a href="#gradle的安装" class="headerlink" title="gradle的安装"></a>gradle的安装</h2><p>下载实时最新的Gradle版本：<code>https://gradle.org/releases/</code>。</p><p>点击<code>Download: binary-only or complete</code>当中的<code>binary-only</code>或者<code>complete</code>即可下载；<br>下载好的gradle是一个压缩包的形式；<br>即首先需要进行解压；</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">v6.5</span><br><span class="line">Jun 02, 2020</span><br><span class="line"></span><br><span class="line">Download: binary-only <span class="keyword">or</span> complete</span><br><span class="line">User Manual</span><br><span class="line">API Javadoc</span><br><span class="line">DSL Reference</span><br><span class="line">Release Notes</span><br><span class="line">v6.4.1</span><br><span class="line">May 15, 2020</span><br><span class="line"></span><br><span class="line">Download: binary-only <span class="keyword">or</span> complete</span><br><span class="line">User Manual</span><br><span class="line">API Javadoc</span><br><span class="line">DSL Reference</span><br><span class="line">Release Notes</span><br><span class="line">v6.4</span><br><span class="line">May 05, 2020</span><br><span class="line"></span><br><span class="line">Download: binary-only <span class="keyword">or</span> complete</span><br><span class="line">User Manual</span><br><span class="line">API Javadoc</span><br><span class="line">DSL Reference</span><br><span class="line">Release Notes</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><p>gradle的目录结构：</p><ul><li>bin<ul><li>gradle</li><li>gradle.bat(构建项目非常重要的命令，所以说之后如果想要用gradle构建项目就需要用到这个文件；)</li></ul></li><li>caches(caches即缓存，由于是崭新下载好的，所以暂时没有缓存)<ul><li>4.7</li><li>jars-3</li><li>modules-2<ul><li>files-2.1</li><li>metadata-2.56<ul><li>descriptors</li><li>module-artifact.bin</li><li>module-artifacts.bin</li><li>module-metadata.bin</li><li>resource-at-url.bin</li></ul></li><li>modules-2.lock</li></ul></li><li>transforms-1<ul><li>transform-1.lock</li></ul></li></ul></li><li>daemon<ul><li>4.7</li></ul></li><li>init.d<ul><li>readme.txt</li></ul></li><li>lib(自身运行所需要的一些环境如jar包/plugins插件等)<ul><li>plugins</li><li>annotations-13.0.jar</li><li>…..</li></ul></li><li>media</li><li>native</li><li>wrapper</li><li>getting-started.html</li><li>LICENSE</li><li>NOTICE</li></ul><p>为了更好的使用gradle需要对gradle进行环境变量的配置；</p><blockquote><p>Gradle 环境变量配置</p></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">================================================</span><br><span class="line">Gradle目录：F:\Gradle\gradle-4.4-all\gradle-4.4</span><br><span class="line"></span><br><span class="line">点击-我的电脑</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">右击</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">点击-属性</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">点击-高级系统设置</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">点击-环境变量</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">点击-系统变量</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">点击-新建（W）...</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">变量名（N）：GRADLE<span class="emphasis">_HOME</span></span><br><span class="line"><span class="emphasis">变量值（V）：F:\Gradle\gradle-4.4-all\gradle-4.4</span></span><br><span class="line"><span class="emphasis">↓↓↓↓↓↓</span></span><br><span class="line"><span class="emphasis">找到Path</span></span><br><span class="line"><span class="emphasis">↓↓↓↓↓↓</span></span><br><span class="line"><span class="emphasis">点击-编辑</span></span><br><span class="line"><span class="emphasis">↓↓↓↓↓↓</span></span><br><span class="line"><span class="emphasis">新建（N）</span></span><br><span class="line"><span class="emphasis">%GRADLE_</span>HOME%\bin</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">点击-确定</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">点击-确定</span><br><span class="line">================================================</span><br></pre></td></tr></table></figure><blockquote><p>如何验证Gradle配置成功</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">======================================</span></span><br><span class="line"><span class="string">windows+r键：键入cmd；打开命令提示符；</span></span><br><span class="line"><span class="string">命令行键入：gradle</span> <span class="string">-v</span> <span class="comment">#回车</span></span><br><span class="line"></span><br><span class="line"><span class="string">Microsoft</span> <span class="string">Windows</span> <span class="string">[Version</span> <span class="number">10.0</span><span class="number">.17763</span><span class="number">.1282</span><span class="string">]</span></span><br><span class="line"><span class="string">(c)</span> <span class="number">2018</span> <span class="string">Microsoft</span> <span class="string">Corporation。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="string">C:\Users\ASUS&gt;gradle</span> <span class="string">-v</span></span><br><span class="line"><span class="attr">Picked up JAVA_TOOL_OPTIONS:</span> <span class="string">-Dfile.encoding=UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="string">------------------------------------------------------------</span></span><br><span class="line"><span class="string">Gradle</span> <span class="number">4.4</span></span><br><span class="line"><span class="string">------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Build time:</span>   <span class="number">2017</span><span class="number">-12</span><span class="number">-06</span> <span class="number">09</span><span class="string">:05:06</span> <span class="string">UTC</span></span><br><span class="line"><span class="attr">Revision:</span>     <span class="string">cf7821a6f79f8e2a598df21780e3ff7ce8db2b82</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Groovy:</span>       <span class="number">2.4</span><span class="number">.12</span></span><br><span class="line"><span class="attr">Ant:</span>          <span class="string">Apache</span> <span class="string">Ant(TM)</span> <span class="string">version</span> <span class="number">1.9</span><span class="number">.9</span> <span class="string">compiled</span> <span class="string">on</span> <span class="string">February</span> <span class="number">2</span> <span class="number">2017</span></span><br><span class="line"><span class="attr">JVM:</span>          <span class="number">1.8</span><span class="string">.0_202</span> <span class="string">(Oracle</span> <span class="string">Corporation</span> <span class="number">25.202</span><span class="string">-b08)</span></span><br><span class="line"><span class="attr">OS:</span>           <span class="string">Windows</span> <span class="number">10</span> <span class="number">10.0</span> <span class="string">amd64</span></span><br><span class="line"></span><br><span class="line"><span class="string">C:\Users\ASUS&gt;</span> <span class="string">exit</span> <span class="comment"># 退出</span></span><br><span class="line"><span class="string">=====================================</span></span><br><span class="line"><span class="string">如果出现以上信息及Gradle安装成功；</span></span><br></pre></td></tr></table></figure><h2 id="gradle介绍02"><a href="#gradle介绍02" class="headerlink" title="gradle介绍02"></a>gradle介绍02</h2><p>在idea当中创建gradle项目；<br>首先打开idea；</p><p>GroupId: 公司/组织名称<br>ArtifactId: 项目名称<br>Version: 版本号<br>gradle的运行需要用到jdk的环境；</p><ol><li><p>首先指定刚刚安装的gradle在什么地方，即选择Use local gradle wrapper(recommended)（即本地安装的gradle，选择了之后会发现它会去自动找本地所安装的gradle）</p></li><li><p>gradle的运行需要用到jdk的环境；那么就需要在Gradle JVM当中选择好自己本地的jdk环境；确认一下Gradle JVM当中所录入的是否为本地jdk的位置；</p></li><li><p>Use auto-import选项进行勾选上；Use auto-import的含义为：在项目开发时突然导入了一个c的jar包；那么这个时候就需要gradle来自动将这个jar包的坐标位置给找到；并且导入进来即可；</p></li><li><p>其余的不需要做改变使用默认即可；</p></li></ol><p>Use auto-import 自动导入</p><p>Project name: 项目名称<br>Project location: 项目放置的目录</p><p>点击Finish即可；<br>当前创建的该项目就可以使用gradle做开发了；<br>当gradle在创建的时候尽量让jdk为1.8或者是电脑是一个联网的状态；<br>因为要去网上下载一些相应的插件；</p><h2 id="gradle项目目录结构介绍"><a href="#gradle项目目录结构介绍" class="headerlink" title="gradle项目目录结构介绍"></a>gradle项目目录结构介绍</h2><p>在开发的时候，都讲究配置文件与代码分离原则，讲究该原则的原因在于因为最终项目开发完成之后是需要发布到线上的，那么发布到线上的时候只需要发布正式的源码即可；在正式源码开发过程中将产生大量的测试文件即单元测试；<br>src/main/java 放置正式代码目录<br>src/main/resources 放置正式配置文件目录<br>src/test/java 放置单元测试代码目录<br>src/test/resources 放置测试配置文件目录<br>src/main/webapp 放置页面元素，比如：js，css，img，jsp，html等等</p><h2 id="groovy简单语法"><a href="#groovy简单语法" class="headerlink" title="groovy简单语法"></a>groovy简单语法</h2><p>不进行创建gradle工程一样可以来进行使用该编辑器；<br>groovy更加的随意；</p><blockquote><p>代码</p></blockquote><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//介绍groovy编程语言</span></span><br><span class="line"><span class="comment">// java: System.out.println("");</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"hello, good morning, fsn"</span>);</span><br><span class="line"><span class="comment">// groovy可以省略语句最末尾的分号</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"hello world"</span>)</span><br><span class="line"><span class="comment">//groovy中可以省略小括号</span></span><br><span class="line"><span class="built_in">println</span><span class="string">"hello world, hello, world"</span></span><br><span class="line"><span class="comment">//groovy中如何定义变量，最后的分号加不加都行</span></span><br><span class="line"><span class="comment">//def 弱类型；有点类似于在JavaScript当中的var;</span></span><br><span class="line"><span class="comment">//groovy会自动根据情况来给变量赋予对应的类型；</span></span><br><span class="line"><span class="comment">//根据变量名后面的取值来进行判断是什么样的类型；</span></span><br><span class="line"><span class="comment">//int 类型</span></span><br><span class="line">def abc = <span class="number">21</span>;</span><br><span class="line">def defg = <span class="number">22</span></span><br><span class="line"><span class="built_in">println</span> abc</span><br><span class="line"><span class="built_in">println</span> abc+defg</span><br><span class="line"><span class="comment">//string 类型</span></span><br><span class="line">def s = <span class="string">"laowang"</span></span><br><span class="line"><span class="built_in">println</span> s</span><br><span class="line"><span class="comment">//定义一个集合类型</span></span><br><span class="line">def list = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>]</span><br><span class="line"><span class="comment">//往list中添加元素</span></span><br><span class="line">list &lt;&lt; <span class="string">'h'</span></span><br><span class="line"><span class="comment">//取出list中第三个元素</span></span><br><span class="line"><span class="built_in">println</span> list.<span class="built_in">get</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">println</span> list.<span class="built_in">size</span>()</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in">println</span> list.<span class="built_in">get</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个map</span></span><br><span class="line">def <span class="built_in">map</span> = [<span class="string">'key1'</span>:<span class="string">'value1'</span>,<span class="string">'key2'</span>:<span class="string">'value2'</span>]</span><br><span class="line"><span class="comment">//向map当中添加键值对</span></span><br><span class="line"><span class="built_in">map</span>.key3 = <span class="string">'value3'</span></span><br><span class="line"><span class="comment">//打印出key3的取值</span></span><br><span class="line"><span class="built_in">println</span> <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">'key3'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> //介绍groovy编程语言</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> // java: System.out.println(<span class="string">""</span>);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> println(<span class="string">"hello, good morning, fsn"</span>);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> // groovy可以省略语句最末尾的分号</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> println(<span class="string">"hello world"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> //groovy中可以省略小括号</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> println<span class="string">"hello world, hello, world"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> //groovy中如何定义变量，最后的分号加不加都行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> //def 弱类型；有点类似于在JavaScript当中的var;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> //groovy会自动根据情况来给变量赋予对应的类型；</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> //根据变量名后面的取值来进行判断是什么样的类型；</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> //int 类型</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> def abc = 21;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> def defg = 22</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> println abc</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> println abc+defg</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> //string 类型</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> def s = <span class="string">"laowang"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> println s</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> //定义一个集合类型</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> def list = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> //往list中添加元素</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> list &lt;&lt; <span class="string">'h'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> //取出list中第三个元素</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> println list.get(2)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> println list.size()</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">for</span> (int i = 0; i &lt; list.size(); i++) &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     println list.get(i)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> //定义一个map</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> def map = [<span class="string">'key1'</span>:<span class="string">'value1'</span>,<span class="string">'key2'</span>:<span class="string">'value2'</span>]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> //向map当中添加键值对</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> map.key3 = <span class="string">'value3'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> println map.get(<span class="string">'key3'</span>)</span></span><br><span class="line">hello, good morning, fsn</span><br><span class="line">hello world</span><br><span class="line">hello world, hello, world</span><br><span class="line">21</span><br><span class="line">43</span><br><span class="line">laowang</span><br><span class="line">c</span><br><span class="line">8</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">f</span><br><span class="line">g</span><br><span class="line">h</span><br><span class="line">value3</span><br></pre></td></tr></table></figure><h2 id="groovy中的闭包"><a href="#groovy中的闭包" class="headerlink" title="groovy中的闭包"></a>groovy中的闭包</h2><blockquote><p>Closure不可导入其他包</p></blockquote><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.corba.se.spi.orbutil.closure.Closure</span><br><span class="line"><span class="comment">//groovy中的闭包</span></span><br><span class="line"><span class="comment">//介绍：什么是闭包？</span></span><br><span class="line"><span class="comment">//闭包其实就是一段代码块，在gradle中，主要是把闭包当参数来进行使用</span></span><br><span class="line"><span class="comment">//首先需要进行定义一个闭包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span> </span>= &#123;</span><br><span class="line">    println <span class="string">"hello, fsn !"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再定义一个方法，该方法里面需要闭包类型的参数</span></span><br><span class="line"><span class="comment">//Closure closure不要导jar包，任何一个包都不要导入</span></span><br><span class="line"><span class="comment">//在groovy当中Closure该单词就表示闭包；如果导包进来就会出错；</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">method1</span></span>(Closure closure)&#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用方法method1()</span></span><br><span class="line">method1(test)</span><br></pre></td></tr></table></figure><blockquote><p>示例报错</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">F:\jdk\jdk1.<span class="number">8202</span>\jdk\bin\java.exe -<span class="module-access"><span class="module"><span class="identifier">Dtools</span>.</span></span>jar=F:\jdk\jdk1.<span class="number">8202</span>\jdk\lib\tools.jar <span class="string">"-Dgroovy.home=F:\ideaUI\IntelliJ IDEA 2018.3.1"</span> <span class="string">"-Dgroovy.starter.conf=F:\ideaUI\IntelliJ IDEA 2018.3.1\plugins\Groovy\lib\groovy-starter.conf"</span> -<span class="module-access"><span class="module"><span class="identifier">Dfile</span>.</span></span>encoding=UTF-<span class="number">8</span> -classpath <span class="string">"F:\ideaUI\IntelliJ IDEA 2018.3.1\lib\idea_rt.jar"</span> com.intellij.rt.execution.CommandLineWrapper C:\Users\ASUS\AppData\Local\Temp\idea_classpath1957904038 org.codehaus.groovy.tools.GroovyStarter --conf <span class="string">"F:\ideaUI\IntelliJ IDEA 2018.3.1\plugins\Groovy\lib\groovy-starter.conf"</span> --main groovy.ui.GroovyMain -p <span class="string">"F:\ideaUI\IntelliJ IDEA 2018.3.1\plugins\Groovy\lib\console.groovy"</span></span><br><span class="line"></span><br><span class="line">&gt; import com.sun.corba.se.spi.orbutil.closure.Closure</span><br><span class="line">&gt; <span class="comment">//groovy中的闭包</span></span><br><span class="line">&gt; <span class="comment">//介绍：什么是闭包？</span></span><br><span class="line">&gt; <span class="comment">//闭包其实就是一段代码块，在gradle中，主要是把闭包当参数来进行使用</span></span><br><span class="line">&gt; <span class="comment">//首先需要进行定义一个闭包</span></span><br><span class="line">&gt; def test = &#123;</span><br><span class="line">&gt;     println <span class="string">"hello, fsn !"</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">//再定义一个方法，该方法里面需要闭包类型的参数</span></span><br><span class="line">&gt; <span class="comment">//Closure closure不要导jar包，任何一个包都不要导入</span></span><br><span class="line">&gt; <span class="comment">//在groovy当中Closure该单词就表示闭包；如果导包进来就会出错；</span></span><br><span class="line">&gt; def method1(Closure closure)&#123;</span><br><span class="line">&gt;     closure<span class="literal">()</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">//调用方法method1()</span></span><br><span class="line">&gt; method1(test)</span><br><span class="line">hello, good morning, fsn</span><br><span class="line">hello world</span><br><span class="line">hello world, hello, world</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">43</span></span><br><span class="line">laowang</span><br><span class="line">c</span><br><span class="line"><span class="number">8</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">f</span><br><span class="line">g</span><br><span class="line">h</span><br><span class="line">value3</span><br><span class="line">groovy.lang.MissingMethodException: No signature <span class="keyword">of</span> <span class="keyword">method</span>: com.sun.proxy.$<span class="module-access"><span class="module"><span class="identifier">Proxy5</span>.</span></span>call<span class="literal">()</span> is applicable for argument types: <span class="literal">()</span> values: <span class="literal">[]</span></span><br><span class="line">Possible solutions: wait<span class="literal">()</span>, any<span class="literal">()</span>, wait(long), each(groovy.lang.Closure), any(groovy.lang.Closure), wait(long, <span class="built_in">int</span>)</span><br><span class="line">at org.codehaus.groovy.runtime.<span class="module-access"><span class="module"><span class="identifier">ScriptBytecodeAdapter</span>.</span></span>unwrap(<span class="module-access"><span class="module"><span class="identifier">ScriptBytecodeAdapter</span>.</span></span>java:<span class="number">71</span>)</span><br><span class="line">at org.codehaus.groovy.runtime.callsite.<span class="module-access"><span class="module"><span class="identifier">PojoMetaClassSite</span>.</span></span>call(<span class="module-access"><span class="module"><span class="identifier">PojoMetaClassSite</span>.</span></span>java:<span class="number">48</span>)</span><br><span class="line">at org.codehaus.groovy.runtime.callsite.<span class="module-access"><span class="module"><span class="identifier">CallSiteArray</span>.</span></span>default<span class="constructor">Call(CallSiteArray.<span class="params">java</span>:47)</span></span><br><span class="line">at org.codehaus.groovy.runtime.callsite.<span class="module-access"><span class="module"><span class="identifier">AbstractCallSite</span>.</span></span>call(<span class="module-access"><span class="module"><span class="identifier">AbstractCallSite</span>.</span></span>java:<span class="number">116</span>)</span><br><span class="line">at org.codehaus.groovy.runtime.callsite.<span class="module-access"><span class="module"><span class="identifier">AbstractCallSite</span>.</span></span>call(<span class="module-access"><span class="module"><span class="identifier">AbstractCallSite</span>.</span></span>java:<span class="number">120</span>)</span><br><span class="line">at ideaGroovyConsole.method1(ideaGroovyConsole.groovy:<span class="number">50</span>)</span><br><span class="line">at sun.reflect.<span class="module-access"><span class="module"><span class="identifier">NativeMethodAccessorImpl</span>.</span></span>invoke0(Native Method)</span><br><span class="line">at sun.reflect.<span class="module-access"><span class="module"><span class="identifier">NativeMethodAccessorImpl</span>.</span></span>invoke(<span class="module-access"><span class="module"><span class="identifier">NativeMethodAccessorImpl</span>.</span></span>java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.<span class="module-access"><span class="module"><span class="identifier">DelegatingMethodAccessorImpl</span>.</span></span>invoke(<span class="module-access"><span class="module"><span class="identifier">DelegatingMethodAccessorImpl</span>.</span></span>java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.<span class="module-access"><span class="module"><span class="identifier">Method</span>.</span></span>invoke(<span class="module-access"><span class="module"><span class="identifier">Method</span>.</span></span>java:<span class="number">498</span>)</span><br><span class="line">at org.codehaus.groovy.runtime.callsite.<span class="module-access"><span class="module"><span class="identifier">PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrap</span>.</span></span>invoke(<span class="module-access"><span class="module"><span class="identifier">PogoMetaMethodSite</span>.</span></span>java:<span class="number">190</span>)</span><br><span class="line">at org.codehaus.groovy.runtime.callsite.<span class="module-access"><span class="module"><span class="identifier">PogoMetaMethodSite</span>.</span></span>call<span class="constructor">Current(PogoMetaMethodSite.<span class="params">java</span>:59)</span></span><br><span class="line">at org.codehaus.groovy.runtime.callsite.<span class="module-access"><span class="module"><span class="identifier">CallSiteArray</span>.</span></span>default<span class="constructor">CallCurrent(CallSiteArray.<span class="params">java</span>:51)</span></span><br><span class="line">at org.codehaus.groovy.runtime.callsite.<span class="module-access"><span class="module"><span class="identifier">AbstractCallSite</span>.</span></span>call<span class="constructor">Current(AbstractCallSite.<span class="params">java</span>:157)</span></span><br><span class="line">at org.codehaus.groovy.runtime.callsite.<span class="module-access"><span class="module"><span class="identifier">AbstractCallSite</span>.</span></span>call<span class="constructor">Current(AbstractCallSite.<span class="params">java</span>:169)</span></span><br><span class="line">at ideaGroovyConsole.run(ideaGroovyConsole.groovy:<span class="number">53</span>)</span><br><span class="line">at groovy.lang.<span class="module-access"><span class="module"><span class="identifier">GroovyShell</span>.</span></span>run<span class="constructor">ScriptOrMainOrTestOrRunnable(GroovyShell.<span class="params">java</span>:263)</span></span><br><span class="line">at groovy.lang.<span class="module-access"><span class="module"><span class="identifier">GroovyShell</span>.</span></span>run(<span class="module-access"><span class="module"><span class="identifier">GroovyShell</span>.</span></span>java:<span class="number">507</span>)</span><br><span class="line">at groovy.lang.<span class="module-access"><span class="module"><span class="identifier">GroovyShell</span>.</span></span>run(<span class="module-access"><span class="module"><span class="identifier">GroovyShell</span>.</span></span>java:<span class="number">486</span>)</span><br><span class="line">at sun.reflect.<span class="module-access"><span class="module"><span class="identifier">NativeMethodAccessorImpl</span>.</span></span>invoke0(Native Method)</span><br><span class="line">at sun.reflect.<span class="module-access"><span class="module"><span class="identifier">NativeMethodAccessorImpl</span>.</span></span>invoke(<span class="module-access"><span class="module"><span class="identifier">NativeMethodAccessorImpl</span>.</span></span>java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.<span class="module-access"><span class="module"><span class="identifier">DelegatingMethodAccessorImpl</span>.</span></span>invoke(<span class="module-access"><span class="module"><span class="identifier">DelegatingMethodAccessorImpl</span>.</span></span>java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.<span class="module-access"><span class="module"><span class="identifier">Method</span>.</span></span>invoke(<span class="module-access"><span class="module"><span class="identifier">Method</span>.</span></span>java:<span class="number">498</span>)</span><br><span class="line">at org.codehaus.groovy.runtime.callsite.<span class="module-access"><span class="module"><span class="identifier">PogoMetaMethodSite$PogoCachedMethodSite</span>.</span></span>invoke(<span class="module-access"><span class="module"><span class="identifier">PogoMetaMethodSite</span>.</span></span>java:<span class="number">169</span>)</span><br><span class="line">at org.codehaus.groovy.runtime.callsite.<span class="module-access"><span class="module"><span class="identifier">PogoMetaMethodSite</span>.</span></span>call(<span class="module-access"><span class="module"><span class="identifier">PogoMetaMethodSite</span>.</span></span>java:<span class="number">71</span>)</span><br><span class="line">at org.codehaus.groovy.runtime.callsite.<span class="module-access"><span class="module"><span class="identifier">AbstractCallSite</span>.</span></span>call(<span class="module-access"><span class="module"><span class="identifier">AbstractCallSite</span>.</span></span>java:<span class="number">136</span>)</span><br><span class="line">at console.run(console.groovy:<span class="number">11</span>)</span><br><span class="line">at groovy.ui.<span class="module-access"><span class="module"><span class="identifier">GroovyMain</span>.</span></span>process<span class="constructor">Reader(GroovyMain.<span class="params">java</span>:576)</span></span><br><span class="line">at groovy.ui.<span class="module-access"><span class="module"><span class="identifier">GroovyMain</span>.</span></span>process<span class="constructor">Files(GroovyMain.<span class="params">java</span>:485)</span></span><br><span class="line">at groovy.ui.<span class="module-access"><span class="module"><span class="identifier">GroovyMain</span>.</span></span>run(<span class="module-access"><span class="module"><span class="identifier">GroovyMain</span>.</span></span>java:<span class="number">327</span>)</span><br><span class="line">at groovy.ui.<span class="module-access"><span class="module"><span class="identifier">GroovyMain</span>.</span></span>process(<span class="module-access"><span class="module"><span class="identifier">GroovyMain</span>.</span></span>java:<span class="number">315</span>)</span><br><span class="line">at groovy.ui.<span class="module-access"><span class="module"><span class="identifier">GroovyMain</span>.</span></span>process<span class="constructor">Args(GroovyMain.<span class="params">java</span>:134)</span></span><br><span class="line">at groovy.ui.<span class="module-access"><span class="module"><span class="identifier">GroovyMain</span>.</span></span>main(<span class="module-access"><span class="module"><span class="identifier">GroovyMain</span>.</span></span>java:<span class="number">114</span>)</span><br><span class="line">at sun.reflect.<span class="module-access"><span class="module"><span class="identifier">NativeMethodAccessorImpl</span>.</span></span>invoke0(Native Method)</span><br><span class="line">at sun.reflect.<span class="module-access"><span class="module"><span class="identifier">NativeMethodAccessorImpl</span>.</span></span>invoke(<span class="module-access"><span class="module"><span class="identifier">NativeMethodAccessorImpl</span>.</span></span>java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.<span class="module-access"><span class="module"><span class="identifier">DelegatingMethodAccessorImpl</span>.</span></span>invoke(<span class="module-access"><span class="module"><span class="identifier">DelegatingMethodAccessorImpl</span>.</span></span>java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.<span class="module-access"><span class="module"><span class="identifier">Method</span>.</span></span>invoke(<span class="module-access"><span class="module"><span class="identifier">Method</span>.</span></span>java:<span class="number">498</span>)</span><br><span class="line">at org.codehaus.groovy.tools.<span class="module-access"><span class="module"><span class="identifier">GroovyStarter</span>.</span></span>root<span class="constructor">Loader(GroovyStarter.<span class="params">java</span>:116)</span></span><br><span class="line">at org.codehaus.groovy.tools.<span class="module-access"><span class="module"><span class="identifier">GroovyStarter</span>.</span></span>main(<span class="module-access"><span class="module"><span class="identifier">GroovyStarter</span>.</span></span>java:<span class="number">138</span>)</span><br><span class="line">at sun.reflect.<span class="module-access"><span class="module"><span class="identifier">NativeMethodAccessorImpl</span>.</span></span>invoke0(Native Method)</span><br><span class="line">at sun.reflect.<span class="module-access"><span class="module"><span class="identifier">NativeMethodAccessorImpl</span>.</span></span>invoke(<span class="module-access"><span class="module"><span class="identifier">NativeMethodAccessorImpl</span>.</span></span>java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.<span class="module-access"><span class="module"><span class="identifier">DelegatingMethodAccessorImpl</span>.</span></span>invoke(<span class="module-access"><span class="module"><span class="identifier">DelegatingMethodAccessorImpl</span>.</span></span>java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.<span class="module-access"><span class="module"><span class="identifier">Method</span>.</span></span>invoke(<span class="module-access"><span class="module"><span class="identifier">Method</span>.</span></span>java:<span class="number">498</span>)</span><br><span class="line">at com.intellij.rt.execution.<span class="module-access"><span class="module"><span class="identifier">CommandLineWrapper</span>.</span></span>main(<span class="module-access"><span class="module"><span class="identifier">CommandLineWrapper</span>.</span></span>java:<span class="number">67</span>)</span><br></pre></td></tr></table></figure><blockquote><p>正确示意</p></blockquote><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//groovy中的闭包</span></span><br><span class="line"><span class="comment">//介绍：什么是闭包？</span></span><br><span class="line"><span class="comment">//闭包其实就是一段代码块，在gradle中，主要是把闭包当参数来进行使用</span></span><br><span class="line"><span class="comment">//首先需要进行定义一个闭包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span> </span>= &#123;</span><br><span class="line">    println <span class="string">"hello, fsn !"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再定义一个方法，该方法里面需要闭包类型的参数</span></span><br><span class="line"><span class="comment">//Closure closure不要导jar包，任何一个包都不要导入</span></span><br><span class="line"><span class="comment">//在groovy当中Closure该单词就表示闭包；如果导包进来就会出错；</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">method1</span></span>(Closure closure)&#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用方法method1()</span></span><br><span class="line">method1(test)</span><br></pre></td></tr></table></figure><blockquote><p>正确结果</p></blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hello,</span> fsn !</span><br></pre></td></tr></table></figure><blockquote><p>大概的执行流程</p></blockquote><p>首先method1()方法需要一个参数Closure closure，闭包类型的参数；<br>而上面的test变量正好是一个闭包类型；<br>所以可以将test变量传递下来到method1()方法当中；<br>在method1()拿到该闭包参数之后并没有其他的动作仅仅只是执行了闭包方法，即执行了test()方法当中的代码；而闭包方法即test()方法当中的代码即为输出打印；</p><blockquote><p>带有参数的闭包代码</p></blockquote><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个带有参数的闭包方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span> </span>= &#123;</span><br><span class="line">    v -&gt;</span><br><span class="line">        println <span class="string">"hello $&#123;v&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个方法，方法里面需要闭包类型的参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">method2</span></span>(Closure closure)&#123;</span><br><span class="line">    closure(<span class="string">"隔壁老王"</span>)</span><br><span class="line">&#125;</span><br><span class="line">method2(test2)</span><br></pre></td></tr></table></figure><blockquote><p>结果打印</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hello</span> 隔壁老王</span><br></pre></td></tr></table></figure><h2 id="gradle配置文件的介绍"><a href="#gradle配置文件的介绍" class="headerlink" title="gradle配置文件的介绍"></a>gradle配置文件的介绍</h2><blockquote><p>build.gradle</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">====================================================================</span><br><span class="line">https://mvnrepository.com/artifact/org.springframework/spring-context/5.0.2.RELEASE</span><br><span class="line"></span><br><span class="line">如果是maven工程直接选择Maven即可；</span><br><span class="line">&lt;!<span class="comment">-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-<span class="keyword">context</span>&lt;/artifactId&gt;</span><br><span class="line">    &lt;<span class="keyword">version</span>&gt;<span class="number">5.0</span><span class="number">.2</span>.RELEASE&lt;/<span class="keyword">version</span>&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">如果是Gradle工程则选择Gradle即可；</span><br><span class="line">// https://mvnrepository.com/artifact/org.springframework/spring-<span class="keyword">context</span></span><br><span class="line">compile <span class="keyword">group</span>: <span class="string">'org.springframework'</span>, <span class="keyword">name</span>: <span class="string">'spring-context'</span>, <span class="keyword">version</span>: <span class="string">'5.0.2.RELEASE'</span></span><br><span class="line">====================================================================</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行的环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    <span class="keyword">id</span> <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * group 公司/团队名</span></span><br><span class="line"><span class="comment"> * version 版本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">group</span> <span class="string">'com.fsn'</span></span><br><span class="line"><span class="keyword">version</span> <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java jdk版本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定所使用仓库的路径</span></span><br><span class="line"><span class="comment"> * mavenCentral() 表示使用中央仓库，此刻项目中所需要的jar包都会默认从中央仓库下载到本地指定目录</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. gradle工程所有的jar包的坐标都在dependencies属性内放置</span></span><br><span class="line"><span class="comment"> * 2. 每一个jar包的坐标都由三个基本元素组成 group、name、version</span></span><br><span class="line"><span class="comment"> * 3. testCompile 表示该jar包在测试的时候起作用，该属性为jar包的作用域；</span></span><br><span class="line"><span class="comment"> *    在gradle里面添加坐标的时候都要带上jar包的作用域</span></span><br><span class="line"><span class="comment"> * compile/testCompile其实是一个方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testCompile <span class="keyword">group</span>: <span class="string">'junit'</span>, <span class="keyword">name</span>: <span class="string">'junit'</span>, <span class="keyword">version</span>: <span class="string">'4.12'</span></span><br><span class="line">    compile <span class="keyword">group</span>: <span class="string">'org.springframework'</span>, <span class="keyword">name</span>: <span class="string">'spring-context'</span>, <span class="keyword">version</span>: <span class="string">'5.0.2.RELEASE'</span></span><br><span class="line">&#125;</span><br><span class="line">====================================================================</span><br></pre></td></tr></table></figure><h2 id="让gradle使用本地maven仓库"><a href="#让gradle使用本地maven仓库" class="headerlink" title="让gradle使用本地maven仓库"></a>让gradle使用本地maven仓库</h2><p>gradle默认使用的仓库是中央仓库即<code>repositories{mavenCentral()}</code>。</p><p>对该仓库进行重新配置；<br>如何使用本地的maven仓库来进行开发gradle工程；<br>复制得到本地maven仓库地址:<code>F:\maven\apache-maven-3.6.1-bin\repository</code>。<br>将该路径配置到环境变量当中；</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">================================================</span><br><span class="line">Maven仓库目录：F:\maven\apache-maven-3.6.1-bin\repository</span><br><span class="line"></span><br><span class="line">点击-我的电脑</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">右击</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">点击-属性</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">点击-高级系统设置</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">点击-环境变量</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">点击-系统变量</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">点击-新建（W）...</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">变量名（N）：GRADLE<span class="emphasis">_USER_</span>HOME</span><br><span class="line">变量值（V）：F:\maven\apache-maven-3.6.1-bin\repository</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">点击-确定</span><br><span class="line">↓↓↓↓↓↓</span><br><span class="line">点击-确定</span><br><span class="line">================================================</span><br><span class="line">环境变量设置完成之后查看IDEA的Default Settings当中的Service directory path就将会变成maven仓库的目录；</span><br><span class="line">也就意味着将从本地仓库当中找jar包；</span><br></pre></td></tr></table></figure><p>由于build.gradle当中<code>repositories{mavenCentral()}</code>该写法仍然会从中央仓库当中进行下载；此时则需要让它先从本地仓库当中进行查找即在<code>mavenCentral()</code>之前添加<code>mavenLocal()</code>；<br>写法为</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"><span class="bullet"> * </span>指定所使用仓库的路径</span><br><span class="line"><span class="bullet"> * </span>mavenCentral() 表示使用中央仓库，此刻项目中所需要的jar包都会默认从中央仓库下载到本地指定目录</span><br><span class="line"><span class="bullet"> * </span>mavenLocal() 表示使用本地maven仓库；</span><br><span class="line"> *</span><br><span class="line"><span class="bullet"> * </span>mavenLocal()</span><br><span class="line"><span class="bullet"> * </span>mavenCentral()</span><br><span class="line"><span class="bullet"> * </span>以上配置表示先从本地仓库寻找依赖，如果没有再从中央仓库下载。</span><br><span class="line"><span class="bullet"> * </span>mavenCentral()</span><br><span class="line"><span class="bullet"> * </span>如果只配置中央仓库，表示直接从中央仓库下载jar包；</span><br><span class="line"><span class="bullet"> * </span>但是如果指定下载的位置已经有了，就不会再次下载了；</span><br><span class="line"> */</span><br><span class="line">repositories &#123;</span><br><span class="line"><span class="code">    mavenLocal()</span></span><br><span class="line"><span class="code">    mavenCentral()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gradle介绍03"><a href="#gradle介绍03" class="headerlink" title="gradle介绍03"></a>gradle介绍03</h2><p>点击查看External Libraries下载好的jar包；</p><blockquote><p>Tasks</p></blockquote><ul><li>build<ul><li>assemble</li><li>build</li><li>buildDependents</li><li>buildNeeded</li><li>classes</li><li>clean</li><li>jar<ul><li>当前工程为一个java工程，所以只能打jar包；双击该命令行即可；<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>:<span class="number">36</span>:<span class="number">50</span>: Executing task <span class="string">'jar'</span>...</span><br><span class="line"></span><br><span class="line">:compileJava</span><br><span class="line">:processResources</span><br><span class="line">:classes</span><br><span class="line">:jar</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> <span class="number">3</span>s</span><br><span class="line"><span class="number">3</span> actionable tasks: <span class="number">3</span> executed</span><br><span class="line"><span class="number">14</span>:<span class="number">36</span>:<span class="number">53</span>: Task execution finished <span class="string">'jar'</span>.</span><br></pre></td></tr></table></figure></li></ul></li><li>testClasses</li></ul></li><li>build setup</li><li>documentation</li><li>help</li><li>other</li><li>verification</li></ul><h2 id="gradle开发web工程"><a href="#gradle开发web工程" class="headerlink" title="gradle开发web工程"></a>gradle开发web工程</h2><p>仓库地址：<code>https://github.com/fengshana/gradleDemo</code>。</p><h2 id="gradle工程拆分与聚合"><a href="#gradle工程拆分与聚合" class="headerlink" title="gradle工程拆分与聚合"></a>gradle工程拆分与聚合</h2><p>仓库地址：<code>https://github.com/fengshana/gradleDemo</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看笔记：&lt;code&gt;https://www.bilibili.com/video/BV1iW411C7CV?from=search&amp;amp
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Gradle" scheme="https://fengshana.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java8</title>
    <link href="https://fengshana.github.io/2020/06/11/%E3%80%90JDK8%E3%80%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java8/"/>
    <id>https://fengshana.github.io/2020/06/11/%E3%80%90JDK8%E3%80%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java8/</id>
    <published>2020-06-11T15:48:50.000Z</published>
    <updated>2020-06-16T00:09:32.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：<a href="https://www.bilibili.com/video/BV1w4411e7T8?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1w4411e7T8?p=1</a>  </p><p>看完书之后一定要做总结；将书中的内容或者是视频中的内容形成自己的知识体系；这样的话这个书的目的或者是这个视频的目的才达到了；<br>不建议将视频不要翻来覆去的看；在边看的同时将自己不了解的或者是一些重点做好记录；以及接下来一定要动手自己要去编写代码；否则看视频就跟看书一样过两天就全忘了；忘了的结果就是看完之后又要重头去看一遍；视频也是一样；所花费的时间成本大；<br>该记录的时候记录做笔记的时候做笔记敲代码的时候敲代码该看源代码的时候看源代码；<br>看视频绝非一个目的，它只是一个手段；看书也只是一个手段；不能将看书当做是一个目的；<br>如果说是把看书或者是看视频当做是一种目的的话，那么这是一种错误的做法；<br>将效率提升上来；这样不仅仅是视频以及看书才能够去发挥它最大的效果；</p><p>(系统完整深入)  </p><ul><li>课程说明（课程的发布顺序）<ul><li>① 深入Java8<ul><li>jdk8相关内容</li></ul></li><li>④ 并发与Netty<ul><li>Netty这个框架本身比较复杂；</li><li>如何将Netty用好，Netty涉及到的一些模式涉及到的一些底层的内容；</li><li>包括对于RPC的支持、对于WebSocket这种长连接的支持，Netty是如何实现的；Netty接口、API也是基于异步处理；</li><li>一旦接触到异步，复杂度上升；</li><li>Netty高性能可以处理大量的并发，其吞吐量也是不错的；</li><li>因此在很多的互联网公司也是得到了很多的应用；</li><li>Netty与Nodejs一样也是基于异步，异步处理；</li><li>Netty当中的接口，或者是API其实都是异步的；（而一旦涉及到异步，复杂程度立刻上升；）</li><li>因为异步，比如说写SpringMVC、Servlet这种是不一样的；因为相对于SpringMVC这种框架来说，发一个请求，然后服务端用一个线程去处理前端发过来的这个请求，从接受请求到一直将这个响应反馈给前端，这其中都是由一个线程来进行完成的一个完整处理；即整个流程都是清楚而又自然的；</li><li>而一旦涉及到异步就不是这个样子了，异步一般都是基于事件，基于回调的；</li><li>那么当这个事件一旦发生了，那么其对应的方法就会被调用，即被某个线程调用；而线程完成之后该线程不会去继续往下走，而是去处理其他地方去了；</li><li>那么等这个事件for example：IO操作完成之后，该框架/线程收到事件的一个紧急的通知那么其就将会去紧接着后续的代码；</li><li>关于Netty或者是Nodejs来说，感觉就是程序在整个执行过程当中就是跳来跳去的；一会跳到这里一会跳到哪里，即没有一个对异步好的一个理解的话那么是不太容易这两个框架或者是这两门技术的；而这两门技术本身又是比较重要的；</li><li>基本成为国内互联网公司的标配；因为Netty是高性能的；可以处理大量的并发；吞吐量也是不错的；因此在很多的互联网公司都得到和广泛地应用；</li><li>讲Netty还会涉及到Netty底层的一些源代码的梳理；</li></ul></li><li>⑤ JVM<ul><li>关于JVM的介绍</li><li>虽然每天都在JVM上开发，程序跑在JVM上面；但是对于JVM的了解并不是很多人能够做到的一件事情；而且JVM当中涉及到的知识体系理论体系以及方法实践是非常多的；而且涉及到一些相关的一些工具；</li><li>Java内存模型、各种锁、可见性、原子性有序性等都是非常细节化，而且又跟计算机理论硬件等级别相关的；</li></ul></li><li>③ Node<ul><li>关于Nodejs的介绍；</li><li>无论是做前端还是做后台，Nodejs都是需要去掌握的一门重要的技术；</li><li>因为通过Nodejs可以将前后端打通；</li><li>正所谓全栈工程师；全栈工程师最早就是来自于原来做前端开发即用js去写代码的只能做界面上的一些功能，现在也可以转到后端进行开发，即通过Nodejs也可以转到后端开发；</li><li>通过这样一种方式就可以将前后端打通；</li><li>可以通过一种语言既可以一边写前端又可以一边写后端；</li><li>甚至前后端分离模式也是可以通过Nodejs做中间的转介和桥梁；</li><li>Nodejs本身基于异步，Nodejs都是异步处理的；</li></ul></li><li>② Spring精髓<ul><li>关于Spring原理知识的一个介绍和讲解</li></ul></li></ul></li></ul><p>异步基于事件基于回调当某个事件发生了从而某些线程就会调用相应的方法；<br>线程完成之后不会继续往下走而是处理其他任务去了；</p><h2 id="JAVA8新特性课程介绍"><a href="#JAVA8新特性课程介绍" class="headerlink" title="JAVA8新特性课程介绍"></a>JAVA8新特性课程介绍</h2><p>介绍：<br>Java 8 可谓Java语言历史上变化最大的一个版本。<br>其承诺要 调整Java编程向着 <code>函数式风格</code> 迈进，<br>这有助于编写出 更为<code>简洁、表达力更强</code>，<br>并且在很多情况下能够利用<code>并行硬件</code>的代码<br>(并行硬件代码：之前的<code>串行</code>执行流程代码，现在通过java8的一些新特性，比如说Stream流、Lambda表达式等之类的就可以<code>并行化</code>的执行；)。<br>本门课程将会深入介绍 Java8新特性，<br>将会通过本门课程的学习深入掌握Java8新增特性并能灵活运用在项目中。<br>学习者将学习到如何通过Lambda表达式使用一行代码编写Java函数，<br>如果通过这种功能使用新的Stream API（即流API）进行编程，<br>如何将冗[ rǒng ] 长的集合处理代码压缩为简单且可读性更好的流程序。<br>学习创建和消费流的机制，分析其性能，能够判断何时应该调用API的并行执行特性。</p><p>与函数式相对的之前的那种编程方式称之为命令式编程（即给它一个指令它就执行一个指令）；<br>之前java针对的是数据，即继承封装多态；面向对象三大特性；</p><ul><li>Java 8新特性介绍（概览一下Java8有哪一些新特性）</li><li>Lambda表达式介绍<ul><li>通过Lambda表达式Java从一个纯粹的面向对象编程语言转向函数式的编程语言；</li><li>函数式编程语言之前也在很多的语言当中都有过体现；</li><li>比如说Python，即Python支持Lambda表达式即一种函数式编程语言；</li><li>另外像JavaScript，本质上也是属于一种函数式编程语言；当然JavaScript也是面向对象的编程语言；</li><li>那么另外像Scala，Scala本身就是融合了面向对象以及函数式这两种特性的静态语言，并且Scala是可以运行在JVM之上的；</li><li>函数式编程最早只是一小部分人所推崇的一种方式；函数式编程已经由来已久；但是之前一直没有流行起来；自从这几年大数据的出现；函数式编程开始崭露头角渐渐被更多的人接受；</li><li>与函数式编程相对的之前一直使用的编程方式即命令式的编程；命令式的编程即给它一个指令让它执行就可以了；</li><li>之前比如说像java这种面向对象这样的编程语言针对的是数据，即面向对象三大特性（封装继承多态）；<ul><li>比如说封装，其实使用面向对象语言实际上最终操作的就是数据（将对象封装到数据当中，这个对象可以在构造方法或者是各个层次调用之间进行彼此值的传递，传递完成之后对这个数据进行处理，处理完成之后再去对其一个提取、抽象等相关操作，处理最后可能需要将这个数据保存在数据库当中，保存完成之后再对数据做一个额外的包装或者说一些其他的处理然后返回给客户端，然后客户端看到的就是处理完成的结果）；</li><li>那么面向对象语言其所针对的目标其实就是data，即数据；</li></ul></li><li>而函数式编程语言所面向的是行为；</li><li>什么叫做面向对象是面向的数据，而函数式面向行为呢？<ul><li>比如说java当中在进行方法传递的时候，从这当中从来传递的都是参数，即传值；即将数值传递给一个方法，如果是原生类型的话直接将值复制过去传一份；如果是引用对象类型的话直接将引用复制过去，然后两个引用会指向同一个对象；总的来说即进行数据的传递；</li><li>而Lambda表达式则可以通过方法来把一个方法参数，甚至是可以是一个行为，可以将该行为作为参数作为不同的调用之间或者是不同的层次之间进行传递；这一种编程方式与之前的编程方式是有这天壤之别的；区别非常的明显；而函数式编程方式这种编程行为在掌握之后可以给工作效率的一个极大提升，使得代码的可读性其实更好；（一开始变扭，时间久了之后就会觉得这种方式更好，在效率上也有一个很大的提升；）</li><li>针对于传递行为，再举一个例子：<ul><li>比如说原来进行两个整数进行求和的一个方式；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">传递两个整型数据；返回这个两个数据求和的结果</span></span><br><span class="line"><span class="comment">当前传递的即为数据，即值本身；</span></span><br><span class="line"><span class="comment">而函数式编程传递的是行为；</span></span><br><span class="line"><span class="comment">甚至可以将add()这样一个方法作为一个行为参数给进行传递进去；</span></span><br><span class="line"><span class="comment">那么这样一种方式对于jdk8之前其他版本来说其实是一种颠覆性的创新；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">( <span class="keyword">int</span> a , <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  a + b ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li>使用Lambda表达式代替匿名内部类</li><li>Lambda表达式的作用</li><li>外部迭代与内部迭代</li><li>Java Lambda表达式语法详解</li><li>函数式接口详解<ul><li>即FunctionalInterface；</li><li>函数式接口与Lambda表达式密切相关；</li><li>Lambda表达式与Stream流之间也是密切相关的；那么通过这两种新特性的融合改变了以前操作集合的那种笨拙的办法；特别是像操作匿名内部类；</li><li>匿名内部类或者是方法回调在什么时候会进行使用？比如说在编写android时，就存在有大量的匿名内部类；因为android开发和像AWT或者是Swing那种界面开发是一样的是基于事件的，即给一个控件注册了一个事件；那么当那个事件发生了比如说用户点击了某个按钮的话，那么这个按钮相关的方法回调就会得到执行；而这种回调都是基于事件的；而这种方法回调都是基于匿名内部类的形式来去进行表达和实现的；虽然通过这种匿名内部类的方式已经十分熟悉但是存在啰嗦，那么这个时候可以通过Lambda表达式极大的去进行改善这样一种现状；</li></ul></li><li>传递值与传递行为</li><li>Stream深度解析</li><li>Stream API详解</li><li>串行流与并行流</li><li>Stream构成</li><li>Stream源生成方式</li><li>Stream操作类型</li><li>Stream转换</li><li>Optional详解<ul><li>Java8 引入了关于Optional的一个增强；</li><li>Optional在java8 出现之前就已经出现在了Google的Guava库当中了；</li><li>Google Guava是一个非常强大的库；提供了非常多的新特性包括像对集合的增强；（比如说要对两个集合进行求交集并集差集补集等等功能，如果是自己写代码的话还是比较繁琐的，通过Google的Guava框架可以非常方便的去实现这些关于集合的操作）；另外Google Guava也提供了对Optional的一个支持；</li><li>Optional是什么？可以理解为防止在java代码当中出现NullPointerException这样一种情况所作出的一个处理；NullPointerException空指针异常是一种最为常见的一种异常类型；那么这种异常出现的根本原因在于在使用某一个引用的时候，断定其一定不为空然后去进行调用了该引用的一些方法，但是在某些情况下这个引用确实是为空了，那么在这种情况下就会出现空指针异常；即java 8 对于这种情况作了一个增强；其实当前现下很多语言都提供了对Optional的支持；除了Google的Guava库提供了Optional之外，如果做android开发，使用Kotlin的话，<ul><li>Kotlin是由IntelliJ IDEA所在的公司JetBrains所推出的一个运行于JVM之上的语言，它面向的领域主要有两个，一个是面向浏览器端，另外一个是面向安卓开发；特别是安卓开发，其应用场景是比较广阔的；因为现在的安卓开发还无法使用Java8；之前只能够使用Java 6；而Java 6实际上是没有Lambda表达式的支持的；那么这个时候就由一些第三方的工具来进行提供，那么Kotlin就很好的弥补了这一点；由Kotlin开发安卓可以使代码非常精简，同时又能够利用非常强大的Lambda表达式的特性；Kotlin也提供了对Optional的支持；</li><li>除了像Kotlin还有像Apple最新推出的Swift语言，Swift语言也提供了对Optional直接的支持，通过枚举的方式支持Optional；Java8也提供了对Optional的支持；</li></ul></li></ul></li><li>默认方法详解<ul><li>默认方法颠覆了之前对java接口的一个认识；</li><li>java接口，什么是接口？即所有的方法都是抽象的，没有具体实现的方法；但是从java8开始这个概念就不再成立了；</li></ul></li><li>方法与构造方法引用</li><li>Predicate接口详解<ul><li>Predicate的含义即谓词；在函数式接口当中使用的最多的一个概念；</li></ul></li><li>Function接口详解</li><li>Consumer接口剖析</li><li>Filter介绍<ul><li>过滤</li></ul></li><li>Map-Reduce讲解、中间操作与终止操作<ul><li>Map-Reduce出现了已经有很多年了；随着Hadoop这种大数据框架，Map-Reduce现在也越来越被人所理解和所知道；Map-Reduce即先进行Map即映射，然后再进行Reduce，Reduce理解为精简收敛等含义，变成一个值来作为结果进行输出；</li></ul></li><li>新的Date API分析<ul><li>对于jdk来说原先的日期API一直为人所诟病太低级，问题太多；</li><li>首先对于时区的支持差劲以及日期的一些操作也是十分低效的；</li><li>比如说想要进行计算当前该天的后三天是星期几，如果使用Java当中已有的Date API来说，是难以做到的，即便做到也是非常麻烦的；而且像Java Date API当中比较老的Calendar、Date等日期相关处理类的时候，其主要就是操作这几个类；而且Date当中有很多方法过期；</li><li>所有就有人开发了Joda Time，Joda Time可以非常方便的实现之前所提出的那个需求即想要进行计算当前该天的后三天是星期几、当前该天再加两个月是星期几这种，通过Joda Time非常简单的通过一个方法调用即可；而且Joda Time与Java Date原生API之间是可以相互进行转换的；所以Joda Time就得到了非常广泛的应用；后来Oracle借鉴了Joda Time当中很多新的设计思想所以在Java 8当中提供了新的日期API；其功能与Joda Time差不多在一个层次上了；</li></ul></li></ul><p>使用Lambda表达式是Java8当中的一个核心功能，从学习者的角度来看待java8带来的便捷性，新的特点以及功能上的增强；<br>java8 即java的第8个版本，那么它的出现带来了变革性的特性，那么这种变革性的特性其实对于java来说是非常非常难以实现的；并不是说难以是实现该功能，而是说它要实现如此之多重要而又颠覆性的新特性的同时，又要能兼容与老版本的特性以及功能以及语言上的这些特点，其实这一点非常难以实现；<br>产生新特性的同时又不会对老版本的使用产生干扰；即在jdk5、6、7上的开发代码平滑到jdk8上依旧可以兼容代码等特性这是极其困难的一件事情；<br>保持在增加java8的新特性的同时又不会对原有的功能造成破坏性的影响；所以提供了像函数式接口、默认方法等这种新特性；而函数式接口又或者是默认方法这种新功能在对于老版本java的视角来看是很奇怪的（接口当中怎么能有方法的实现呢）；这是由于要增加新特性的同时又要去兼容老版本所做出的一种权衡和折中；</p><h2 id="JAVA8新特性课程介绍续"><a href="#JAVA8新特性课程介绍续" class="headerlink" title="JAVA8新特性课程介绍续"></a>JAVA8新特性课程介绍续</h2><p><strong>并发与Netty</strong>  </p><p>介绍：Netty 可谓是国内外诸多互联网公司的标配。<br>其高性能的异步通信框架、NIO支持、WebSocket的强大实现使得其成为很多大型互联网公司在处理高并发时的首选。<br>不过，由于Netty架构复杂，模块众多，学习曲线陡峭，让很多人望而却步。<br>市面上的几本Netty相关图书也只是对其进行了粗浅的介绍（入门），并无法直接应用到实际项目中。<br>该课程就是为了帮助大家深入且透彻学习Netty的。<br>Netty深入掌握需要大量的实践思考和总结；<br>netty的官网：<code>https://netty.io</code>。<br>Netty与之前所学习的SpringMVC、Struts2等框架不一样；SpringMVC、Struts2解决的即MVC这样一个问题，即客户端与服务器端，客户端如何将数据传递给到服务器端，服务器端按照框架的设定定义好各个层次接收数据，接收数据之后则相应的Controller就会去调用service方法，而service则去调用dao层；即传统的非常经典的多层架构设计模式；<br>Netty本质上是一个网络通信应用框架；而且Netty本身是对于底层的无论是TCP还是HTTP做了一层薄薄的封装；那么Netty本身又是基于完全异步的这样一种框架，异步的通信模式，即NIO；Netty源代码复杂；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</span><br><span class="line"></span><br><span class="line">Netty 是 一个 异步的 事件驱动 网络应用框架，</span><br><span class="line">针对于 可维护（maintainable）的 高性能协议 服务器与客户端的快速（rapid）开发（development）；</span><br><span class="line"></span><br><span class="line">Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients.</span><br><span class="line"></span><br><span class="line">Netty 是一个异步的IO客户端服务框架；（Netty对于网络协议分层的这样一种支持；Netty的升级具有破坏性，比如说包的名字发生变化之类的，原来其包名是以 org.jboss开头，现在以io.netty开头；之前还出现过netty5该版本，不是最终版而是阿尔法版本；出现有相当长一段时间之后又从网站上撤掉了；可以到其github上看netty5的分支以及为什么netty5会被取消的原因。）</span><br><span class="line"></span><br><span class="line">It greatly simplifies and streamlines network programming such as TCP and UDP socket server.</span><br><span class="line">'Quick and easy' doesn't mean that a resulting application will suffer from a maintainability or a performance issue.</span><br><span class="line"></span><br><span class="line">Netty hash been designed carefully <span class="keyword">with</span> the experiences earned <span class="keyword">from</span> the implementation <span class="keyword">of</span> a lot <span class="keyword">of</span> protocols such <span class="keyword">as</span> <span class="keyword">FTP</span>, SMTP, <span class="keyword">HTTP</span>, <span class="keyword">and</span> various <span class="built_in">binary</span> <span class="keyword">and</span> <span class="built_in">text</span>-based legacy protocols,</span><br><span class="line"></span><br><span class="line"><span class="keyword">As</span> a <span class="keyword">result</span>, Netty <span class="keyword">hash</span> succeeded <span class="keyword">to</span> find a way <span class="keyword">to</span> achieve ease <span class="keyword">of</span> development , <span class="keyword">performance</span>, stability, <span class="keyword">and</span> flexibility <span class="keyword">without</span> a compromise.</span><br><span class="line"></span><br><span class="line">Features</span><br><span class="line"></span><br><span class="line">Design // 设计</span><br><span class="line">  * Unified API <span class="keyword">for</span> various transport types - blocking <span class="keyword">and</span> non-blocking socket</span><br><span class="line">  * Based <span class="keyword">on</span> a flexible <span class="keyword">and</span> extensible <span class="keyword">event</span> <span class="keyword">model</span> which allows <span class="keyword">clear</span> separation <span class="keyword">of</span> concerns</span><br><span class="line">  * Highly customizable <span class="keyword">thread</span> <span class="keyword">model</span> - single <span class="keyword">thread</span>, one <span class="keyword">or</span> more <span class="keyword">thread</span> pools such <span class="keyword">as</span> SEDA</span><br><span class="line">  * <span class="literal">True</span> connectionles datagram socket support(since <span class="number">3.1</span>)</span><br><span class="line"></span><br><span class="line">Ease <span class="keyword">of</span> <span class="keyword">use</span> //易于使用，快速开发</span><br><span class="line">  * Well-documented Javadoc, <span class="keyword">user</span> guide <span class="keyword">and</span> examples</span><br><span class="line">  * <span class="keyword">No</span> additional dependencies, JDK5(Netty <span class="number">3.</span>x) <span class="keyword">or</span> <span class="number">6</span>(Netty <span class="number">4.</span>x) <span class="keyword">is</span> enough</span><br><span class="line">    * Note: <span class="keyword">Some</span> components such <span class="keyword">as</span> <span class="keyword">HTTP</span>/<span class="number">2</span> might have more requirements. Please refer <span class="keyword">to</span> the Requirements page <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Performance</span></span><br><span class="line">  * Better throughput, <span class="keyword">lower</span> latency</span><br><span class="line">  * <span class="keyword">Less</span> <span class="keyword">resource</span> consumption</span><br><span class="line">  * Minimized unnecessary <span class="keyword">memory</span> copy</span><br><span class="line"></span><br><span class="line"><span class="keyword">Security</span></span><br><span class="line">  * <span class="keyword">Complete</span> SSL/TLS <span class="keyword">and</span> StartTLS support</span><br><span class="line"></span><br><span class="line">Community</span><br><span class="line">  * <span class="keyword">Release</span> early, <span class="keyword">release</span> often</span><br><span class="line">  * The author has been writing similar frameworks since <span class="number">2003</span> <span class="keyword">and</span> he still finds your feed back precious !</span><br></pre></td></tr></table></figure><ul><li>Netty介绍<ul><li>Netty干什么，做什么事情的以及怎么做</li><li>从宏观的角度介绍Netty的架构以及Netty的模块分析</li><li>知其然</li></ul></li><li>Netty架构实现</li><li>Netty模块分析</li><li>Netty HTTP Tunnel</li><li>Netty对Socket的实现<ul><li>Socket编程一直以来都是一个难点；因为Socket可以认为是一种比较底层的网络编程模式；它在基于传统HTTP应用层的编程，因为HTTP是位于OSI/ISO七层网络参考模型最上层，是一种应用层的模型；将底层的一些东西都已经封装好了；只需要针对HTTP即可；相对于HTTP来说socket更加复杂；</li></ul></li><li>Netty压缩与解压缩</li><li>Netty对于RPC的支援<ul><li>RPC：Remote Procedure Call-远程过程调用(百度)；</li><li>该视频上讲述的RPC是Remote Procedure communication-远程过程通信</li><li>对于一些分布式应用来说，模块与模块或者系统与系统之间都是在内网当中进行通信的，顶多也是跨机房，不管是不是跨机房整个也是在公司的服务端进行通信；这种通信模式存在两种模式：第一种模式是通过传统的HTTP的方式，即REST full方式，开发起来比较容易，只要提供相应的http接口即可；第二种方式即通过RPC的方式，那么RPC这种方式更为底层的实现，类似java当中的RMI，RMI即Remote Method Invocation 远程方法调用，RMI即RPC的一种特例，因为RMI只能够被用到java当中；多年之前流行的EZB，EZB其底层就是使用RMI进行实现的；（EZB现在大多用在银行，而互联网公司使用的少；）RPC可以相比于RMI来说可以实现多语言即异构平台之间的通信，比如说java可以直接调用python的一个方法（此处python不是提供一个http接口从而java去调用接口这种模式，因为通过HTTP接口方式来调用的与完全是与语言无关的，只要定义好接口定义好实现，客户端就可以进行调用，不管是怎么去进行实现的；对于RPC来说不是这样的，RPC本身就是通过框架的资源，（框架资源这些）自己写是不太现实非常复杂，通过框架的一些资源来去进行调用，而且是可以实现异构平台之间的调用，比如说现在很多互联网公司都在使用阿里的dubbo，有一些公司对dubbo做了一些扩展，那么dubbo可以说是一站式的这种分布式框架，底层也提供了RPC的支持，提供了关于分布式的这些基础设施等等）</li></ul></li><li>WebSocket连接建立方式与生命周期分解<ul><li>WebSocket本身来源于HTML5，HTML5在提出之初就给出了WebSocket的一些资源，WebSocket也正式成为HTML5的一部分。</li><li>WebSocket主要做的事情即为长连接；对应于与长连接相对的即短连接，HTTP即为一种短连接（什么叫做短连接，客户端去访问服务端，客户端发起一个请求，然后服务端接收到这个请求之后，顶多可以通过HTTP的keep-alive这样的特性让这个连接保持一段时间不被关闭掉，但是一段时间之后如果客户端不再去给服务端发送更多的请求的话，这个连接就会被关闭掉了，所以HTTP本身是一种无状态的协议，一定是由客户端主动的发起这个请求，然后服务端去接收请求，接着服务端将响应返回给客户端；接着客户端再去发起新的请求，服务端再去处理再去将响应返回给前端；这对于传统HTTP1.0以及1.1的方式；现在HTTP2在很多浏览器内也逐渐开始提供长连接了）；</li><li>但是对于WebSocket来说，WebSocket是目前为主最为成熟也是标准化的一种长连接的实现，WebSocket的实现方式其实是基于HTTP的；首先；客户端向服务端发起一个连接请求，连接一旦建立好之后，将这个连接upgrade升级成WebSocket的协议；WebSocket协议表现为ws；</li><li>（比如说访问一个网站时通常都是http://… 或者是https://… 开头；而WebSocket即ws://… 开头后面接地址；如果带证书的话即wss://… 与https类似；）WebSocket特别适合于客户端与服务端需要保持双向，即全双工通信的这样一种场景，换种说法即实现服务端的推送；在WebSocket出现之前实现服务端的推送也有，但是这些技术其实都是假的推送；</li><li>假的推送：（即轮询，客户端不断向服务端发起请求访问，比如说5s或者是10s等时间段间隔轮询发起一个请求判断服务端有没有相应的数据，如果没有的话则此次轮询结束，隔一段时间间隔之后再去发起请求）；这种轮询方式是非常不优雅的；因为大多数的轮询都是无意义无效果的；HTTP还有一个缺陷即在于每一次的请求响应都会带有HTTP的header，称之为头，然而绝大多数数据只占据了一小部分，在每一次请求响应数据当中，header部分倒是占据很了很多的网络流量，而真正所需要包当中的数据很少，即这实际上是一种非常不好的方式；</li><li>然而WebSocket就完全解决了这样一种问题；即一旦客户端与服务端建立好连接之后，不管是服务端还是客户端都可以向对方进行推请求，即所谓全双工，即客户端与服务端都可以向对方进行推送数据，而且数据本身可以不带header，仅仅是包含真正需要的数据本身，这即WebSocket实现的一个优势；对于像手机端即移动端要实现的聊天应用，就需要长连接，那么使用WebSocket就属于一种比较好的一种实现方式；WebSocket适合用于手机端以及即时通信这样一种场景的；Netty对于WebSocket本身提供了非常完备的支持；通过若干个回调方法就可以比较好的去实现WebSocket这种长连接的通信；</li></ul></li><li>WebSocket服务端与客户端开发</li><li>RPC框架分析</li><li>Google Protobuf使用方式分析（RPC重要框架）<ul><li>可以实现异构平台之间的通信；比如说java作为客户端调用python的服务端，或者是Ruby的客户端调用java的服务端，这都是没有问题的；RPC框架模式都是比较类似的，不外乎是要去编写一个中间的文件称之为描述文件，然后通过框架提供的工具来自动去生成服务端和客户端的代码；接着服务端和客户端代码去编写相应的逻辑去调用自动生成的代码实现双向的通信，底层的通信都是由自动生成的代码去完成的；</li></ul></li><li>Apache Thrift使用方式与文件编写方式分析（RPC重要框架）<ul><li>可以实现异构平台之间的通信；</li><li>用于在公司内网实现RPC的通信，也支持异构语言之间的通信，效率高，相比于传统HTTP方式效率高很多；</li></ul></li><li>Netty大文件传送支持</li><li>可扩展的事件模型</li><li>Netty统一通信API</li><li>零拷贝在Netty中的实现与支持</li><li>TCP粘包与拆包分析<ul><li>TCP本身都是通过包的方式，有可能出现两个包黏在一起了，或者是一个包拆成两个了，那么Netty对于这种情况是如何处理的；</li></ul></li><li>NIO模型在Netty中的实现<ul><li>NIO，非阻塞模型在Netty中的实现，这一点非常重要；NIO本身就是一个难以掌握的点，jdk在实现NIO这一块其实还是有些问题的，Netty通过它的包装或者一些封装屏蔽了底层的一些问题向上层暴露出来了更加友好以及更易于使用的接口。</li></ul></li><li>Netty编解码开发技术</li><li>Netty重要类与接口源代码剖析</li><li>Channel分析<ul><li>Channel在Netty中是一个非常重要的概念，可以认为Channel就是一条连接，跟客户端的Connection，通过Channel来进行数据的传递；</li></ul></li><li>序列化讲解</li></ul><p><strong>JVM</strong></p><p>介绍：JVM是一个令人望而却步的领域，因为它博大精深，涉及到的内容与知识点非常之多。<br>虽然Java开发者每天都在使用JVM，但对其所研究并且深入研究的人却少之又少。<br>然而，JVM的重要性却又是不言而喻的。<br>基于JVM的各种动态与静态语言生态圈已经异常繁荣了，对JVM的运行机制有一定的了解不但可以提升我们的竞争力，还可以让我们在面对问题时能够沉着应对，加速问题的解决速度；同时还能够增强我们的自信心，让我们更加游刃有余。</p><ul><li>JVM介绍</li><li>HotSpot虚拟机讲解</li><li>垃圾收集方式详解</li><li>垃圾收集算法详解</li><li>垃圾收集器详解</li><li>分代垃圾收集机制详解</li><li>新生代讲解</li><li>老年代讲解</li><li>G1收集器分析与实例<ul><li>从jdk7引入的G1收集器，分析</li></ul></li><li>常见且重要虚拟机参数示例</li><li>栈</li><li>方法区</li><li>线程共享内存区</li><li>根搜索算法</li><li>Serial收集器</li><li>ParNew收集器</li><li>类加载机制详解</li><li>类加载的双亲委托机制</li><li>字节码文件生成与分析</li><li>魔数<ul><li>关于jdk字节码class文件的分析</li></ul></li><li>常量池与方法表</li><li>各种指令详解</li><li>锁详解</li><li>线程安全</li><li>偏向锁、自旋锁与轻量级锁</li><li>JIT编译器</li><li>GC日志生成与分析</li><li>虚拟机监控工具详解<ul><li>jmat、jConsole…</li></ul></li><li>jConsole使用方式详解</li><li>何为逃逸与逃逸分析</li><li>方法内联</li><li>虚拟机内存模型详解</li></ul><p><strong>Node</strong></p><p>介绍：在当下的互联网时代，Node的重要性已经不言而喻，诸多国内外的互联网公司都已经有大量的高性能系统运行在Node之上，Node凭借其单线程、异步等举措实现了极高的性能基准。<br>此外，目前最为流行的Web开发模式是前后端分离的形式，即前端开发者与后端开发者在自己喜欢的IDE上独立进行开发，<br>然后通过HTTP或是RPC等方式实现数据与流程的交互。<br>这种开发模式在Node的强大功能的引领下变得越来越搞笑，也越来越受到互联网公司的青睐。<br>在GitHub上搜索，你会看到与Node相关的项目始终呈现出火爆的态势，这也进一步证明了Node的巨大商业价值与技术价值。<br>因此，无论是前端开发者，还是传统的后台开发者，掌握Node已经是刻不容缓了。<br>而且，Node的完美搭档NPM也提供了异常丰富的工具包与框架供开发者使用。<br>学习Node应该是每一个对前端开发或是后端开发有追求的人所必须要做的事情。</p><p>Node本身使用javaScript来进行编写的；<br>前后端不分离的模式比如JSP开发，毫无疑问，前端代码与后端代码肯定是耦合在一起的；第一点，即便使用各种标签，标签背后也是代码；标签只是代码的一种载体；标签可以认为是后端一些源代码的载体跟前端的html、css、js肯定是耦合在一起的；<br>第二点，前端一定得迁就着后端，因为是JSP开发所以肯定得在后端的IDE（idea、eclipse….）上进行开发，而前端如果想使用别的自己顺手的ide则比较麻烦，就肯定只能在后端的ide上进行开发；<br>第三点，开发完一个功能之后需要测试，测试就需要去启动后端服务，那么此时前端还需要去进行学习后端的那一套东西就非常麻烦了；<br>NPM可以看做是java当中的gradle以及maven，当然不是特别一样；</p><ul><li>Node的安装与配置，使用NPM</li><li>使用nvm（Node Version Manager）来管理Node与npm<ul><li>Node社区分裂史：有两拨人对Node的发展前景抱有不同的看法，其中一拨人从Node领域中走出来了，给Node包做了一个分支，这个新的分支叫做io.js，原来叫做Nodejs，所以后来Node和io这两拨人独自进行开发，从此变化就非常快了。后期Nodejs与iojs又复合在一起了，<code>https://nodejs.org/en/</code>；（Chrome的版本发展速度也很快）</li><li>由于Node版本升级非常快，所以不可能在一台电脑上只装一个Node版本，因为Node安装完成之后再升级是一件非常痛苦的一件事情；所以可以使用工具nvm，可以在装任意多个Node版本；这也是相当于python的开发环境一样，通过python的一些包管理器来去在一台电脑上安装多个python的版本；</li></ul></li><li>nvm配置与重要命令解读</li><li>Node事件与回调机制<ul><li>Node事件与回调机制、Node异步IO模型、Node的单线程模型这三个是了解Node的基本设计架构；</li></ul></li><li>Node异步IO模型</li><li>Node的单线程模型</li><li>Node模块</li><li>npm使用方式<ul><li>npm除了能像maven、gradle一样做包管理器还提供了NPMScript这样的功能，可以从中编写脚本；</li></ul></li><li>package.json详解</li><li>全局安装与局部安装方式</li><li>npm重要功能详解</li><li>Node异步编程详解</li><li>Node流分析</li><li>输入与输出</li><li>Node网络功能</li><li>Node的控制台</li><li>事件循环机制</li><li>Node调试</li><li>使用exports对象</li><li>Node操纵文件系统详解</li><li>Buffer详解</li><li>Node的错误处理模型</li><li>使用Node访问MongoDB</li><li>使用Node访问MySQL</li><li>使用Node访问Redis</li><li>中间件详解</li><li>Node Web服务器详解</li><li>WebSocket在Node中的实现方式</li><li>WebSocket数据传输</li><li>SocketIO详解</li><li>Express或KOA全功能详解（全方位讲解Node领域最为重要的Web框架）</li></ul><h2 id="lambda表达式初步与函数式接口"><a href="#lambda表达式初步与函数式接口" class="headerlink" title="lambda表达式初步与函数式接口"></a>lambda表达式初步与函数式接口</h2><h2 id="深入函数式接口与方法引用"><a href="#深入函数式接口与方法引用" class="headerlink" title="深入函数式接口与方法引用"></a>深入函数式接口与方法引用</h2><h2 id="lambda表达式深入与流初步"><a href="#lambda表达式深入与流初步" class="headerlink" title="lambda表达式深入与流初步"></a>lambda表达式深入与流初步</h2><h2 id="function接口详解"><a href="#function接口详解" class="headerlink" title="function接口详解"></a>function接口详解</h2><h2 id="function与bifunction函数式接口详解"><a href="#function与bifunction函数式接口详解" class="headerlink" title="function与bifunction函数式接口详解"></a>function与bifunction函数式接口详解</h2><h2 id="predicate深入剖析与函数式编程本质"><a href="#predicate深入剖析与函数式编程本质" class="headerlink" title="predicate深入剖析与函数式编程本质"></a>predicate深入剖析与函数式编程本质</h2><h2 id="supplier与函数式接口总结"><a href="#supplier与函数式接口总结" class="headerlink" title="supplier与函数式接口总结"></a>supplier与函数式接口总结</h2><h2 id="optional深入讲解"><a href="#optional深入讲解" class="headerlink" title="optional深入讲解"></a>optional深入讲解</h2><h2 id="方法引用详解"><a href="#方法引用详解" class="headerlink" title="方法引用详解"></a>方法引用详解</h2><h2 id="方法引用场景剖析与默认方法分析"><a href="#方法引用场景剖析与默认方法分析" class="headerlink" title="方法引用场景剖析与默认方法分析"></a>方法引用场景剖析与默认方法分析</h2><h2 id="stream介绍与操作方式详解"><a href="#stream介绍与操作方式详解" class="headerlink" title="stream介绍与操作方式详解"></a>stream介绍与操作方式详解</h2><h2 id="stream深度解析与源码实践"><a href="#stream深度解析与源码实践" class="headerlink" title="stream深度解析与源码实践"></a>stream深度解析与源码实践</h2><h2 id="stream实例剖析"><a href="#stream实例剖析" class="headerlink" title="stream实例剖析"></a>stream实例剖析</h2><h2 id="stream陷阱剖析"><a href="#stream陷阱剖析" class="headerlink" title="stream陷阱剖析"></a>stream陷阱剖析</h2><h2 id="内部迭代与外部迭代本质剖析及流本源分析"><a href="#内部迭代与外部迭代本质剖析及流本源分析" class="headerlink" title="内部迭代与外部迭代本质剖析及流本源分析"></a>内部迭代与外部迭代本质剖析及流本源分析</h2><h2 id="流的短路与并发流"><a href="#流的短路与并发流" class="headerlink" title="流的短路与并发流"></a>流的短路与并发流</h2><h2 id="stream分组与分区详解"><a href="#stream分组与分区详解" class="headerlink" title="stream分组与分区详解"></a>stream分组与分区详解</h2><h2 id="collector源码分析与收集器核心"><a href="#collector源码分析与收集器核心" class="headerlink" title="collector源码分析与收集器核心"></a>collector源码分析与收集器核心</h2><h2 id="collector同一性与结合性分析"><a href="#collector同一性与结合性分析" class="headerlink" title="collector同一性与结合性分析"></a>collector同一性与结合性分析</h2><h2 id="collector复合与注意事项"><a href="#collector复合与注意事项" class="headerlink" title="collector复合与注意事项"></a>collector复合与注意事项</h2><h2 id="收集器用法详解与多级分组和分区"><a href="#收集器用法详解与多级分组和分区" class="headerlink" title="收集器用法详解与多级分组和分区"></a>收集器用法详解与多级分组和分区</h2><h2 id="比较器详解与类型推断特例"><a href="#比较器详解与类型推断特例" class="headerlink" title="比较器详解与类型推断特例"></a>比较器详解与类型推断特例</h2><h2 id="比较器深入"><a href="#比较器深入" class="headerlink" title="比较器深入"></a>比较器深入</h2><h2 id="自定义收集器实现"><a href="#自定义收集器实现" class="headerlink" title="自定义收集器实现"></a>自定义收集器实现</h2><h2 id="自定义收集器深度剖析与并行流陷阱"><a href="#自定义收集器深度剖析与并行流陷阱" class="headerlink" title="自定义收集器深度剖析与并行流陷阱"></a>自定义收集器深度剖析与并行流陷阱</h2><h2 id="收集器枚举特性深度解析与并行流原理"><a href="#收集器枚举特性深度解析与并行流原理" class="headerlink" title="收集器枚举特性深度解析与并行流原理"></a>收集器枚举特性深度解析与并行流原理</h2><h2 id="collectors工厂类源码分析与实战"><a href="#collectors工厂类源码分析与实战" class="headerlink" title="collectors工厂类源码分析与实战"></a>collectors工厂类源码分析与实战</h2><h2 id="groupinby源码分析"><a href="#groupinby源码分析" class="headerlink" title="groupinby源码分析"></a>groupinby源码分析</h2><h2 id="partioningby与groupingbyconcurrent源码分析"><a href="#partioningby与groupingbyconcurrent源码分析" class="headerlink" title="partioningby与groupingbyconcurrent源码分析"></a>partioningby与groupingbyconcurrent源码分析</h2><h2 id="stream源码分析"><a href="#stream源码分析" class="headerlink" title="stream源码分析"></a>stream源码分析</h2><h2 id="stream与basestream源码分析"><a href="#stream与basestream源码分析" class="headerlink" title="stream与basestream源码分析"></a>stream与basestream源码分析</h2><h2 id="分割迭代器源码剖析"><a href="#分割迭代器源码剖析" class="headerlink" title="分割迭代器源码剖析"></a>分割迭代器源码剖析</h2><h2 id="分割迭代器与forkjoin详解"><a href="#分割迭代器与forkjoin详解" class="headerlink" title="分割迭代器与forkjoin详解"></a>分割迭代器与forkjoin详解</h2><h2 id="分割迭代器实现分析"><a href="#分割迭代器实现分析" class="headerlink" title="分割迭代器实现分析"></a>分割迭代器实现分析</h2><h2 id="ofprimitive与ofint实现原理剖析"><a href="#ofprimitive与ofint实现原理剖析" class="headerlink" title="ofprimitive与ofint实现原理剖析"></a>ofprimitive与ofint实现原理剖析</h2><h2 id="流源构造代码分析"><a href="#流源构造代码分析" class="headerlink" title="流源构造代码分析"></a>流源构造代码分析</h2><h2 id="referencepipeline与abstractpipeline源码深度解读"><a href="#referencepipeline与abstractpipeline源码深度解读" class="headerlink" title="referencepipeline与abstractpipeline源码深度解读"></a>referencepipeline与abstractpipeline源码深度解读</h2><h2 id="iteratorspliterator与流源操作方式详解"><a href="#iteratorspliterator与流源操作方式详解" class="headerlink" title="iteratorspliterator与流源操作方式详解"></a>iteratorspliterator与流源操作方式详解</h2><h2 id="流调用机制与原理大揭秘"><a href="#流调用机制与原理大揭秘" class="headerlink" title="流调用机制与原理大揭秘"></a>流调用机制与原理大揭秘</h2><h2 id="sink与opwrapsink源码解读"><a href="#sink与opwrapsink源码解读" class="headerlink" title="sink与opwrapsink源码解读"></a>sink与opwrapsink源码解读</h2><h2 id="terminalop源码分析与终止操作层次体系"><a href="#terminalop源码分析与终止操作层次体系" class="headerlink" title="terminalop源码分析与终止操作层次体系"></a>terminalop源码分析与终止操作层次体系</h2><h2 id="流延迟求值底层分析与sink连接机制揭秘"><a href="#流延迟求值底层分析与sink连接机制揭秘" class="headerlink" title="流延迟求值底层分析与sink连接机制揭秘"></a>流延迟求值底层分析与sink连接机制揭秘</h2><h2 id="stream中间操作与终止操作层次体系分析与设计思想剖析"><a href="#stream中间操作与终止操作层次体系分析与设计思想剖析" class="headerlink" title="stream中间操作与终止操作层次体系分析与设计思想剖析"></a>stream中间操作与终止操作层次体系分析与设计思想剖析</h2><h2 id="joda项目介绍与实战"><a href="#joda项目介绍与实战" class="headerlink" title="joda项目介绍与实战"></a>joda项目介绍与实战</h2><h2 id="java8全新日期与时间api详解与utc介绍"><a href="#java8全新日期与时间api详解与utc介绍" class="headerlink" title="java8全新日期与时间api详解与utc介绍"></a>java8全新日期与时间api详解与utc介绍</h2><h2 id="java8全新日期与时间api实战"><a href="#java8全新日期与时间api实战" class="headerlink" title="java8全新日期与时间api实战"></a>java8全新日期与时间api实战</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看笔记：&lt;a href=&quot;https://www.bilibili.com/video/BV1w4411e7T8?p=1&quot; target=
      
    
    </summary>
    
    
      <category term="jdk8" scheme="https://fengshana.github.io/categories/jdk8/"/>
    
    
      <category term="jdk8" scheme="https://fengshana.github.io/tags/jdk8/"/>
    
      <category term="java" scheme="https://fengshana.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java必备基础教程-MongoDB基础入门到高级进阶</title>
    <link href="https://fengshana.github.io/2020/06/11/%E3%80%90MongoDB%E3%80%91/java%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-MongoDB%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/"/>
    <id>https://fengshana.github.io/2020/06/11/%E3%80%90MongoDB%E3%80%91/java%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-MongoDB%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/</id>
    <published>2020-06-11T15:48:50.000Z</published>
    <updated>2020-06-16T00:09:32.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看链接：<code>https://www.bilibili.com/video/BV1bJ411x7mq?from=search&amp;seid=450814707258177810</code>。</p><h2 id="课程目标"><a href="#课程目标" class="headerlink" title="课程目标"></a>课程目标</h2><blockquote><p>MongoDB快速上手</p></blockquote><ul><li>MongoDB相关概念<ul><li>业务应用场景</li><li>MongoDB简介</li><li>体系结构</li><li>数据模型</li><li>MongoDB的特点</li></ul></li><li>单机部署<ul><li>Windows系统中的安装启动</li><li>Shell连接（mongo命令）</li><li>Compass-图形化界面客户端</li><li>Linux系统中的安装启动和连接</li></ul></li><li>基本常用命令<ul><li>案例需求</li><li>数据库操作<ul><li>选择和创建数据库</li><li>数据库的删除</li></ul></li><li>集合操作<ul><li>集合的显式创建（了解）</li><li>集合的隐式创建</li><li>集合的删除</li></ul></li><li>文档基本CRUD<ul><li>文档的插入</li><li>文档的基本查询</li><li>文档的基本修改</li><li>删除文档</li></ul></li><li>文档的分页查询<ul><li>统计查询</li><li>分页列表查询</li></ul></li></ul></li></ul><h3 id="MongoDB快速上手"><a href="#MongoDB快速上手" class="headerlink" title="MongoDB快速上手"></a>MongoDB快速上手</h3><p>MongoDB用起来 - 快速上手 &amp; 集群和安全系列</p><p>课程目标：</p><ul><li>理解MongoDB的业务场景、熟悉MongoDB的简介、特点和体系结构、数据类型等。</li><li>能够在windows和linux下安装和启动MongoDB、图形化管理界面Compass的安装使用</li><li>掌握MongoDB基本常用命令实现数据的CRUD</li><li>掌握MongoDB的索引类型、索引管理、执行计划。</li><li>使用Spring Data MongoDB（Java框架）完成文章评论业务的开发</li></ul><h3 id="MongoDB相关概念"><a href="#MongoDB相关概念" class="headerlink" title="MongoDB相关概念"></a>MongoDB相关概念</h3><h4 id="业务应用场景"><a href="#业务应用场景" class="headerlink" title="业务应用场景"></a>业务应用场景</h4><p>传统的关系型数据库（如MySQL），在数据操作的 “三高” 需求以及应对 Web2.0的网站需求面前，显得力不从心。<br>解释：“三高”需求</p><ul><li>High proformance - 对数据<strong>高并发读写</strong>的需求。</li><li>Huge Storage - 对<strong>海量数据</strong>的<strong>高效率存储和访问</strong>的需求。</li><li>High Scalability &amp;&amp; High Availability - 对<strong>数据库</strong>的<strong>高扩展性和高可用性</strong>的需求。</li></ul><p>而<strong>MongoDB可应对“三高”需求</strong>。</p><h2 id="MongoDB-应用场景"><a href="#MongoDB-应用场景" class="headerlink" title="MongoDB-应用场景"></a>MongoDB-应用场景</h2><h2 id="MongoDB简介-amp-体系结构-amp-数据模型-amp-特点"><a href="#MongoDB简介-amp-体系结构-amp-数据模型-amp-特点" class="headerlink" title="MongoDB简介 &amp; 体系结构 &amp; 数据模型 &amp; 特点"></a>MongoDB简介 &amp; 体系结构 &amp; 数据模型 &amp; 特点</h2><h2 id="windows启动和部署"><a href="#windows启动和部署" class="headerlink" title="windows启动和部署"></a>windows启动和部署</h2><h2 id="shell连接-amp-compass使用"><a href="#shell连接-amp-compass使用" class="headerlink" title="shell连接 &amp; compass使用"></a>shell连接 &amp; compass使用</h2><h2 id="linux系统中的安装启动和连接"><a href="#linux系统中的安装启动和连接" class="headerlink" title="linux系统中的安装启动和连接"></a>linux系统中的安装启动和连接</h2><h2 id="数据库的创建和删除"><a href="#数据库的创建和删除" class="headerlink" title="数据库的创建和删除"></a>数据库的创建和删除</h2><h2 id="集合的创建和删除"><a href="#集合的创建和删除" class="headerlink" title="集合的创建和删除"></a>集合的创建和删除</h2><h2 id="文档的插入和查询"><a href="#文档的插入和查询" class="headerlink" title="文档的插入和查询"></a>文档的插入和查询</h2><h2 id="文档插入使用-try-catch"><a href="#文档插入使用-try-catch" class="headerlink" title="文档插入使用 try catch"></a>文档插入使用 try catch</h2><h2 id="文档的更新操作"><a href="#文档的更新操作" class="headerlink" title="文档的更新操作"></a>文档的更新操作</h2><h2 id="文档的删除操作"><a href="#文档的删除操作" class="headerlink" title="文档的删除操作"></a>文档的删除操作</h2><h2 id="文档的分页查询"><a href="#文档的分页查询" class="headerlink" title="文档的分页查询"></a>文档的分页查询</h2><h2 id="文档的更多查询"><a href="#文档的更多查询" class="headerlink" title="文档的更多查询"></a>文档的更多查询</h2><h2 id="索引的概述和类型"><a href="#索引的概述和类型" class="headerlink" title="索引的概述和类型"></a>索引的概述和类型</h2><h2 id="索引的管理操作"><a href="#索引的管理操作" class="headerlink" title="索引的管理操作"></a>索引的管理操作</h2><h2 id="索引的使用-执行计划"><a href="#索引的使用-执行计划" class="headerlink" title="索引的使用 执行计划"></a>索引的使用 执行计划</h2><h2 id="索引的使用-涵盖的查询"><a href="#索引的使用-涵盖的查询" class="headerlink" title="索引的使用 涵盖的查询"></a>索引的使用 涵盖的查询</h2><h2 id="文章评论-需求-amp-表结构-amp-技术选型"><a href="#文章评论-需求-amp-表结构-amp-技术选型" class="headerlink" title="文章评论 需求 &amp; 表结构 &amp; 技术选型"></a>文章评论 需求 &amp; 表结构 &amp; 技术选型</h2><h2 id="文章微服务模块搭建"><a href="#文章微服务模块搭建" class="headerlink" title="文章微服务模块搭建"></a>文章微服务模块搭建</h2><h2 id="文章评论实体类的编写"><a href="#文章评论实体类的编写" class="headerlink" title="文章评论实体类的编写"></a>文章评论实体类的编写</h2><h2 id="文章评论的基本增删改查"><a href="#文章评论的基本增删改查" class="headerlink" title="文章评论的基本增删改查"></a>文章评论的基本增删改查</h2><h2 id="根据上级ID查询文章评论的分页列表"><a href="#根据上级ID查询文章评论的分页列表" class="headerlink" title="根据上级ID查询文章评论的分页列表"></a>根据上级ID查询文章评论的分页列表</h2><h2 id="MongoTemplate实现评论点赞"><a href="#MongoTemplate实现评论点赞" class="headerlink" title="MongoTemplate实现评论点赞"></a>MongoTemplate实现评论点赞</h2><h2 id="课程目标-副本集的三个角色"><a href="#课程目标-副本集的三个角色" class="headerlink" title="课程目标 副本集的三个角色"></a>课程目标 副本集的三个角色</h2><h2 id="副本集的创建"><a href="#副本集的创建" class="headerlink" title="副本集的创建"></a>副本集的创建</h2><h2 id="初始化副本集"><a href="#初始化副本集" class="headerlink" title="初始化副本集"></a>初始化副本集</h2><h2 id="添加副本节点和仲裁节点"><a href="#添加副本节点和仲裁节点" class="headerlink" title="添加副本节点和仲裁节点"></a>添加副本节点和仲裁节点</h2><h2 id="副本集合数据的读写操作"><a href="#副本集合数据的读写操作" class="headerlink" title="副本集合数据的读写操作"></a>副本集合数据的读写操作</h2><h2 id="仲裁节点数据操作"><a href="#仲裁节点数据操作" class="headerlink" title="仲裁节点数据操作"></a>仲裁节点数据操作</h2><h2 id="主节点的选举原则"><a href="#主节点的选举原则" class="headerlink" title="主节点的选举原则"></a>主节点的选举原则</h2><h2 id="故障测试-1"><a href="#故障测试-1" class="headerlink" title="故障测试_1"></a>故障测试_1</h2><h2 id="故障测试"><a href="#故障测试" class="headerlink" title="故障测试"></a>故障测试</h2><h2 id="SpringData连接副本集"><a href="#SpringData连接副本集" class="headerlink" title="SpringData连接副本集"></a>SpringData连接副本集</h2><h2 id="分片概念-amp-架构目标"><a href="#分片概念-amp-架构目标" class="headerlink" title="分片概念 &amp; 架构目标"></a>分片概念 &amp; 架构目标</h2><h2 id="分片第一套和第二套副本集搭建"><a href="#分片第一套和第二套副本集搭建" class="headerlink" title="分片第一套和第二套副本集搭建"></a>分片第一套和第二套副本集搭建</h2><h2 id="配置副本集搭建"><a href="#配置副本集搭建" class="headerlink" title="配置副本集搭建"></a>配置副本集搭建</h2><h2 id="初始化三套副本集"><a href="#初始化三套副本集" class="headerlink" title="初始化三套副本集"></a>初始化三套副本集</h2><h2 id="第一个路由节点创建"><a href="#第一个路由节点创建" class="headerlink" title="第一个路由节点创建"></a>第一个路由节点创建</h2><h2 id="路由节点进行分片操作"><a href="#路由节点进行分片操作" class="headerlink" title="路由节点进行分片操作"></a>路由节点进行分片操作</h2><h2 id="分片策略-哈希-amp-范围演示"><a href="#分片策略-哈希-amp-范围演示" class="headerlink" title="分片策略 哈希 &amp; 范围演示"></a>分片策略 哈希 &amp; 范围演示</h2><h2 id="再增加一个路由节点"><a href="#再增加一个路由节点" class="headerlink" title="再增加一个路由节点"></a>再增加一个路由节点</h2><h2 id="compass-amp-springData连接测试"><a href="#compass-amp-springData连接测试" class="headerlink" title="compass &amp; springData连接测试"></a>compass &amp; springData连接测试</h2><h2 id="安全认证简介"><a href="#安全认证简介" class="headerlink" title="安全认证简介"></a>安全认证简介</h2><h2 id="添加用户和权限"><a href="#添加用户和权限" class="headerlink" title="添加用户和权限"></a>添加用户和权限</h2><h2 id="单实例-服务端开启-amp-客户端登录验证"><a href="#单实例-服务端开启-amp-客户端登录验证" class="headerlink" title="单实例-服务端开启 &amp; 客户端登录验证"></a>单实例-服务端开启 &amp; 客户端登录验证</h2><h2 id="springData认证连接"><a href="#springData认证连接" class="headerlink" title="springData认证连接"></a>springData认证连接</h2><h2 id="副本集安全认证"><a href="#副本集安全认证" class="headerlink" title="副本集安全认证"></a>副本集安全认证</h2><h2 id="分片集群安全认证"><a href="#分片集群安全认证" class="headerlink" title="分片集群安全认证"></a>分片集群安全认证</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看链接：&lt;code&gt;https://www.bilibili.com/video/BV1bJ411x7mq?from=search&amp;amp
      
    
    </summary>
    
    
      <category term="MongoDB" scheme="https://fengshana.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://fengshana.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Java面试热点问题，synchronized原理剖析与优化</title>
    <link href="https://fengshana.github.io/2020/06/09/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>https://fengshana.github.io/2020/06/09/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/</id>
    <published>2020-06-08T20:20:50.000Z</published>
    <updated>2020-06-08T20:12:36.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：<code>https://www.bilibili.com/video/BV1aJ411V763?from=search&amp;seid=6293835933701781647</code></p><p>观看了这个视频之后，我建议啊😉，可以去看下那个《<strong>深入java虚拟机</strong>》这本书，因为这个课讲的内容跟这本书当中的<strong>第13章 线程安全与锁优化</strong>，内容十分相似；所以我认为可以当做是课后复习书的那种；<br>我也是经过了对比两者的内容才这么觉得；因为真的很相似；<br>包括后面举的string的那个例子；<br>为了我更深刻的记忆；我决定我还是仔细看一遍这一部分内容；<br>（现在看来其实就是<strong>第五部分 高效并发</strong> 跟该课程视频讲的 非常非常相同了；）</p><p>为了做完这点屁笔记，熬的我真是老眼昏花；<br>我可真是太讨厌做笔记了；</p><h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typora-root-ur<span class="variable">l:</span> img</span><br><span class="line">typora-<span class="keyword">copy</span>-images-<span class="keyword">to</span>: img</span><br></pre></td></tr></table></figure><h3 id="深入学习并发编程中的synchronized"><a href="#深入学习并发编程中的synchronized" class="headerlink" title="深入学习并发编程中的synchronized"></a>深入学习并发编程中的synchronized</h3><blockquote><p>课程背景  </p></blockquote><p><strong>第一</strong>： <strong>并发编程</strong>是java知识体系当中比较重要而且比较是比较难的一块内容。  </p><p>因为<strong>并发编程</strong>涉及的知识面比较广，然后比较抽象不好理解，<br>因此如果我们想很好的掌握并发编程这块内容，其实是有一定难度的。<br><strong>synchronized的原理</strong>以及其<strong>优化</strong>了解少。  </p><p><strong>第二</strong>： <strong>并发编程</strong>在实际企业开发当中也是会遇到的，一个比较重要的比较棘手的问题。  </p><p>举个例子，铁道售票的12306网站，<br>在<strong>一个时间段</strong>内，可能有<strong>大量</strong>的用户过来进行买票，那么此时就需要进行保证卖出去的<strong>票的数量</strong>是<strong>正确</strong>的，既<strong>不能超卖</strong>也<strong>不能少卖</strong>。<br>另外还要保证整个执行过程的卖票的<strong>执行效率</strong>是比较<strong>高</strong>的。  </p><p>那么可以通过<strong>synchronized</strong>来进行<strong>保证卖票的数量</strong>是<strong>正确</strong>的，既<strong>不会超卖</strong>也<strong>不会少卖</strong>。  </p><p>但是又要去考虑这个<strong>性能问题</strong>，那么就可以看到<strong>synchronized</strong>在实际的企业开发当中也是一个棘手的问题。  </p><p><strong>第三</strong>： <strong>并发编程</strong>现在是一个热点面试题。  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>当中出现了异常，会不会释放锁？</span><br><span class="line"><span class="keyword">synchronized</span>和Lock有什么区别？</span><br><span class="line"><span class="keyword">synchronized</span>和<span class="keyword">volatile</span>有什么区别？</span><br><span class="line">etc...</span><br></pre></td></tr></table></figure><p>面试官通过并发面试题来考查面试者的<strong>并发编程</strong>掌握情况，<br>来判断面试者是否能够满足企业需要，<br>另外也能够判断面试者的技术水平。  </p><blockquote><p>课程介绍</p></blockquote><p>深入学习<strong>并发编程</strong>中的<strong>synchronized</strong></p><ul><li>第一章：<strong>并发编程</strong>中的<strong>三个问题</strong><ul><li><strong>可见性</strong><ul><li>案例：<ul><li><font style="color:red;">共享变量</font>;</li><li>一个<font style="color:red;">线程A</font>不断地来<font style="color:red;">读</font>这个<font style="color:red;">共享变量的值</font>；</li><li>再用另一个<font style="color:red;">线程B</font>对该<font style="color:red;">共享变量的取值</font>进行<font style="color:red;">修改</font>；</li><li>可以观测到另一个<font style="color:red;">线程B</font>对该<font style="color:red;">共享变量的修改</font>；</li><li><font style="color:red;">A线程</font>并<font style="color:red;">不能够感知得到</font>；</li><li>这就出现了<strong>可见性</strong>问题</li></ul></li><li>目标<ul><li>学习什么是<strong>可见性</strong>问题</li></ul></li><li><strong>可见性</strong>概念<ul><li><strong>可见性（VIsibility）：是指当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。</strong></li></ul></li><li><strong>可见性</strong>演示<ul><li>案例演示：<ul><li>一个A线程根据boolean类型的标记flag；while循环；</li><li>另一个B线程改变这个flag变量的值；</li><li>而第一个while循环的A线程并不会停止循环。</li></ul></li></ul></li><li>小结<ul><li>什么是<strong>可见性</strong>?<br><strong>可见性（Visibility）：是指当一个线程对共享变量进行了修改，那么另外的线程可以理解看到修改后的最新值</strong>。</li></ul></li></ul></li><li><strong>原子性</strong><ul><li>案例：<br>使用i++，<br>通过5个线程分别来进行执行1000次i++，<br>最终可以发现加出来的效果并非是5000，<br>可能会少于5000，<br>那么这个问题的原因就在于<strong>i++</strong>并<strong>不是一个原子操作</strong>，<br>到时会通过<strong>java反汇编</strong>的方式来进行演示分析这个i++其实有4条指令</li><li>目标<ul><li>学习什么是原子性问题</li></ul></li><li><strong>原子性</strong>概念<ul><li><strong>原子性（Atomicity）：指在一次操作或多次操作中，呀么所有的操作全部得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</strong></li></ul></li><li><strong>原子性</strong>演示<ul><li>案例演示：5个线程各执行1000次i++</li></ul></li></ul></li><li><strong>有序性</strong><ul><li>一般来想的是程序会按照<strong>编写的代码的顺序</strong>来进行执行，<br>那么实际上<strong>程序</strong>会去做一些<strong>优化措施</strong>，<br>为了让代码的<strong>执行效率更高</strong>一点，<br>会做<strong>编译器和运行期的优化</strong>操作，<br>这其中也是用到了一个案例，</li><li><em>有序性问题*</em>有可能会被<strong>重排序</strong>，<br>那么导致在<strong>多线程</strong>的情况下，</li><li><em>数据*</em>会出现<strong>错乱</strong>。</li><li>目标<ul><li>学习什么是<strong>有序性</strong>问题</li></ul></li><li><strong>有序性</strong>概念<ul><li><strong>有序性（Ordering）: 是指程序代码在执行过程中的先后顺序，由于java在编译器以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序。</strong></li></ul></li><li><strong>有序性</strong>演示<ul><li>jcstress是java并发压测工具….</li></ul></li></ul></li></ul></li><li>第二章：<strong>java内存模型</strong>（<strong>JMM</strong>）（开始解决问题）<ul><li><strong>计算机结构</strong><ul><li>（<strong>CPU</strong>、<strong>内存</strong>、<strong>缓存</strong>由此来引出<strong>java内存模型</strong>，<strong>主内存</strong>、<strong>工作内存</strong>如何<strong>操作变量</strong>）</li></ul></li><li><strong>java内存模型</strong><ul><li><strong>主内存</strong>与<strong>工作内存</strong>之间的<strong>交互</strong></li></ul></li></ul></li><li>第三章：<strong>synchronized</strong>保证<strong>三大特性</strong><ul><li><strong>synchronized</strong>与<strong>原子性</strong><ul><li>目标</li><li>使用<strong>synchronized</strong>保证<strong>原子性</strong></li><li><strong>synchronized保证原子性的原理</strong></li><li>小结</li></ul></li><li><strong>synchronized</strong>与<strong>可见性</strong></li><li><strong>synchronized</strong>与<strong>有序性</strong></li></ul></li><li>第四章：<strong>synchronized</strong>的<strong>特性</strong>（<strong>同步锁机制</strong>，<strong>synchronized</strong>作为锁的特性）<ul><li><strong>可重入特性</strong><ul><li>指的是当一个线程进入到一个同步代码块当中时，</li><li>获取了某一个锁之后，</li><li>还能够再次进入同步代码块获取同一把锁。</li><li>即可以重新再进入。</li></ul></li><li><strong>不可中断特性</strong></li></ul></li><li>第五章：<strong>synchronized</strong>的原理<ul><li><strong>javap</strong> 反汇编</li><li>深入JVM源码<ul><li>目标</li><li><strong>monitor监视器锁</strong></li><li><strong>monitor竞争</strong></li><li><strong>monitor等待</strong></li><li><strong>monitor释放</strong></li><li><strong>monitor</strong>是<strong>重量级锁</strong></li></ul></li></ul></li><li>第六章：<strong>JDK6 synchronized优化</strong><ul><li><strong>CAS</strong></li><li><strong>java对象</strong>的<strong>布局</strong><ul><li><strong>锁升级</strong>过程</li></ul></li><li><strong>偏向锁</strong></li><li><strong>轻量级锁</strong></li><li><strong>重量级锁</strong></li><li><strong>锁消除</strong></li><li><strong>锁粗化</strong></li><li>平时写代码如何对<strong>synchronized优化</strong><ul><li><strong>减少synchronized的范围</strong></li><li><strong>降低synchronized锁的粒度</strong></li><li><strong>读写分离</strong></li></ul></li></ul></li></ul><h2 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h2><p>第一章：<strong>并发编程</strong>中的<strong>三个问题</strong> (可见性、原子性、有序性)</p><p>在使用<strong>多线程</strong>进行<strong>并发编程</strong>的时候，如果存在有<strong>多个线程</strong>来<strong>操作共享数据</strong>，<br>那么很有可能这个<strong>共享数据的值</strong>会出现<strong>错乱</strong>。<br>那么以上称之为 <strong>线程安全问题</strong>。<br>那么导致 <strong>线程安全问题</strong>的<strong>根本原因</strong>有这三种：</p><ul><li><strong>可见性</strong></li><li><strong>原子性</strong></li><li><strong>有序性</strong></li></ul><p>在讲解<strong>可见性</strong>概念之前，要注意几个<strong>前提条件</strong>：<br><strong>1、</strong>  如果只有一个线程操作，那么就肯定不会存在线程之间的<strong>可见性</strong>问题。<br><strong>2、</strong> 还需要存在有<strong>共享数据</strong>，如果没有共享数据，那么也不会存在有可见性问题。<br><strong>可见性（Visibility）</strong>：是指一个线程对共享变量进行修改，另一个线程立即得到修改后的最新值。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>学习什么是<strong>可见性问题</strong></p><h3 id="可见性概念"><a href="#可见性概念" class="headerlink" title="可见性概念"></a>可见性概念</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可见性（<span class="keyword">Visibility</span>）：是指当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。</span><br></pre></td></tr></table></figure><h3 id="可见性演示"><a href="#可见性演示" class="headerlink" title="可见性演示"></a>可见性演示</h3><p>案例演示：<br>一个线程A根据boolean类型的标记flag，while循环；<br>另一个线程B改变这个flag变量的值；<br>那么线程A并不会停止循环。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">          一个线程对共享变量的修改，另一个线程不能立即得到最新值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Visibility</span>&#123;</span></span><br><span class="line">    <span class="comment">//多个线程都会访问的数据，我们成为线程的共享数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="built_in">run</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException</span>&#123;</span><br><span class="line">      <span class="comment">//t1线程不断的来读取run共享变量的取值</span></span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">run</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      t1.start();</span><br><span class="line"></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//t2线程对该共享变量的取值进行修改</span></span><br><span class="line">      Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="built_in">run</span> =  <span class="literal">false</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"时间到，线层2设置为false"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">      t2.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//可以观测得到t2线程对run共享变量的修改，t1线程并不能够读取到更改了之后的值；</span></span><br><span class="line">      <span class="comment">//这就出现了可见性问题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo01_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  目标：演示可见性问题</span></span><br><span class="line"><span class="comment">    1. 创建一个共享变量</span></span><br><span class="line"><span class="comment">    2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">    3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test01Visibility&#123;</span><br><span class="line">  <span class="comment">// 1. 创建一个共享变量；静态的成员变量；boolean类型名为flag；</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)&#123;</span><br><span class="line">    <span class="comment">/* 2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">          采用lambda表达式的方式进行创建线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        <span class="comment">/* 循环，如果该布尔类型变量的值为true则一直循环否则结束循环；</span></span><br><span class="line"><span class="comment">           在循环当中千万不要进行打印，打印了的话就看不到效果了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    沉睡两秒钟；</span></span><br><span class="line"><span class="comment">    让效果更加明显；</span></span><br><span class="line"><span class="comment">    这样则更加明显的来分析问题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">       放到lambda表达式中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将flag改为false；并且输出打印；</span></span><br><span class="line">      flag = <span class="keyword">false</span>;</span><br><span class="line">      System.out.<span class="keyword">println</span>(<span class="string">"线程修改了变量的值为false"</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  分析一下这段代码：</span></span><br><span class="line"><span class="comment">  程序从main方法开始执行；</span></span><br><span class="line"><span class="comment">  开启了线程A不断读取共享变量的取值进行循环；</span></span><br><span class="line"><span class="comment">  开启了线程B去进行修改共享变量的值并打印；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  多线程执行具有 fu jin/fu ji(我没听清)性，</span></span><br><span class="line"><span class="comment">  有可能先进行跑A线程也有可能跑B线程；</span></span><br><span class="line"><span class="comment">  如果先跑B线程那么则看不到A线程当中的循环；</span></span><br><span class="line"><span class="comment">  为了让这个效果更佳明显一点；</span></span><br><span class="line"><span class="comment">  所以后加了一个Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  首先执行main方法的时候；</span></span><br><span class="line"><span class="comment">  会创建出一个线程A；</span></span><br><span class="line"><span class="comment">  这个线程A会来进行读取共享变量A的取值；</span></span><br><span class="line"><span class="comment">  则读取到flag共享变量的取值为true；</span></span><br><span class="line"><span class="comment">  那么该while循环则将会一直进行循环；</span></span><br><span class="line"><span class="comment">  那么当主线程沉睡了两秒之后，又会启动一个新线程B；</span></span><br><span class="line"><span class="comment">  新线程B将flag共享变量的取值变为了false；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  问题就在于分析</span></span><br><span class="line"><span class="comment">  线程A当中通过flag来进行while循环当中的该flag共享变量</span></span><br><span class="line"><span class="comment">  是否也从一开始的取值true到后期的线程B当中对共享变量flag取值进行修改为false</span></span><br><span class="line"><span class="comment">  是否也是同时进行了更改取值true为false；</span></span><br><span class="line"><span class="comment">  如果线程A当中的共享变量flag的取值与线程B操作共享变量flag的取值同时进行了更改；</span></span><br><span class="line"><span class="comment">  那么线程A当中根据flag取值进行while循环的循环操作就会停下来；</span></span><br><span class="line"><span class="comment">  如果没有进行修改线程A当中的flag共享变量</span></span><br><span class="line"><span class="comment">  那么线程A当中的flag共享变量的取值就将还会是true，</span></span><br><span class="line"><span class="comment">  即while循环根据flag共享变量的取值true继续其循环操作；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  效果：</span></span><br><span class="line"><span class="comment">  等待两秒之后，输出了线程B当中的打印 “线程修改了变量的值为false”；</span></span><br><span class="line"><span class="comment">  然而但是运行Run的的红灯仍然开启显示在运行着；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  那么这个就意味着；</span></span><br><span class="line"><span class="comment">  上面的那个线程A还在while(true)执行当中；</span></span><br><span class="line"><span class="comment">  也就是线程A当中的共享变量</span></span><br><span class="line"><span class="comment">  没有受到线程B当中操作共享变量flag取值从true变为false操作的影响；</span></span><br><span class="line"><span class="comment">  flag在线程A当中取值依然还是true；</span></span><br><span class="line"><span class="comment">  所以while循环根据该flag共享变量的取值依旧在进行着循环操作。</span></span><br><span class="line"><span class="comment">  即线程A当中认为flag共享变量依旧是true，所以并没有去进行停止while循环。</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  这个时候就可以进行观察得到 可见性问题；</span></span><br><span class="line"><span class="comment">  下面的线程B对共享变量flag取值的修改，而上面的线程A并没有立即得到最新的结果；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  最后做个小结：</span></span><br><span class="line"><span class="comment">  当并发编程时，如果有多线程来进行操作共享变量；</span></span><br><span class="line"><span class="comment">  一个线程来进行读取操作；</span></span><br><span class="line"><span class="comment">  一个线程来进行写操作；</span></span><br><span class="line"><span class="comment">  那么这个当中就可能会出现 线程安全问题；</span></span><br><span class="line"><span class="comment">  即一个线程B进行修改，而另外一个线程A并没有得到修改后的最新取值；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>什么是<strong>可见性</strong>？</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可见性（<span class="keyword">Visibility</span>）：是指当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。</span><br></pre></td></tr></table></figure><h2 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h2><p>现在来看并发编程中的第二个问题：<strong>原子性</strong>问题；<br>前期讲的是并发编程中的第一个问题<strong>可见性</strong>问题；<br>后期要讲的是并发编程中的第三个问题<strong>有序性</strong>问题；<br>学习分两步第一步介绍<strong>原子性的概念</strong>；<br>第二步通过一个案例来进行演示<strong>原子性问题</strong>；</p><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>学习什么是<strong>原子性问题</strong></p><h3 id="原子性概念"><a href="#原子性概念" class="headerlink" title="原子性概念"></a>原子性概念</h3><p>原子性的前提：</p><p><strong>1.</strong> 需要存在有<strong>多个线程</strong>；如果是一个线程，没有竞争的这种情况是看不出来问题所在的；<br><strong>2.</strong> 依然还是需要存在<strong>共享变量</strong>；即到时候多个线程来对共享变量来进行操作；</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">原子性（Atomicity）: 在一次或多次操作中，要么所有的操作都执行 并且 不会受 其他因素干扰 而 中断，要么所有的操作都不执行；</span></span><br></pre></td></tr></table></figure><h3 id="原子性演示"><a href="#原子性演示" class="headerlink" title="原子性演示"></a>原子性演示</h3><p>案例演示：5个线程各执行1000次i++</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo01_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    案例演示：5个线程各执行1000次 i++;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> class Test02Atomicity&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5个线程都执行1000次i++</span></span><br><span class="line">    Runnable increment = () -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        number++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5个线程</span></span><br><span class="line">    ArrayList&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">      t.start();</span><br><span class="line">      ts.<span class="built_in">add</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t : ts)&#123;</span><br><span class="line">      t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 最终的效果即，加出来的效果不是5000，可能会少于5000</span></span><br><span class="line"><span class="comment">        那么原因就在于i++并不是一个原子操作</span></span><br><span class="line"><span class="comment">        到时候会通过java反汇编的方式来进行演示和分析，这个i++其实有4条指令</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"number = "</span>+ number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo01_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  目标：演示原子性问题</span></span><br><span class="line"><span class="comment">      1. 定义一个共享变量 number</span></span><br><span class="line"><span class="comment">      2. 对number进行 1000次的++操作</span></span><br><span class="line"><span class="comment">      3. 使用5个线程来进行操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02Atomicity</span>&#123;</span></span><br><span class="line">  <span class="comment">// 1. 定义一个共享变量 number；先赋值为0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 存在有5个线程需要来对number共享变量1000次的++操作</span></span><br><span class="line"><span class="comment">     2. 对number进行1000的++操作</span></span><br><span class="line"><span class="comment">     做任务；使用lambda表达式来进行编写</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  Runnable increment = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">      number++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 使用5个线程来进行</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该5个线程所做的事情即为 上面的increment所实现的run()</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    ts.add(t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t : <span class="built_in">list</span>)&#123;</span><br><span class="line">      t.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印number的取值</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"number = "</span>+ number);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    由于有可能存在 主线程跑得更快；</span></span><br><span class="line"><span class="comment">    所以就有可能出现5个线程其run()当中的for循环没有跑完就有可能去执行输出number的取值了；</span></span><br><span class="line"><span class="comment">    为了一定要让5个线程当中的for循环跑完然后再来取number的取值；</span></span><br><span class="line"><span class="comment">    这个时候使用join的操作；</span></span><br><span class="line"><span class="comment">    先把这个5个线程放置到ArrayList集合ts当中；</span></span><br><span class="line"><span class="comment">    最后在打印之前遍历一下list集合ts；</span></span><br><span class="line"><span class="comment">    得到每个线程让其执行join();</span></span><br><span class="line"><span class="comment">    按照分析；每个线程都执行1000次number++；</span></span><br><span class="line"><span class="comment">    正常来说最后输出打印这个number时的打印结果应当为5000；</span></span><br><span class="line"><span class="comment">    那么这个运行结果有可能是5000也有可能会小于5000；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    效果：</span></span><br><span class="line"><span class="comment">    number = 5000</span></span><br><span class="line"><span class="comment">    多运行几次</span></span><br><span class="line"><span class="comment">    number = 4542（这次运行之后就会发现number的取值少了很多）</span></span><br><span class="line"><span class="comment">    那么为什么会出现number取值少了很多的这种情况呢？</span></span><br><span class="line"><span class="comment">    那么这是由于 i++（number++）这是多个操作；</span></span><br><span class="line"><span class="comment">    而且其是通过多线程来进行操作的；</span></span><br><span class="line"><span class="comment">    并没有来进行保证 i++(number++)这个操作的一个原子性；</span></span><br><span class="line"><span class="comment">    那么这个时候通过javap反汇编的方式来查看i++(number++)到底是由几个部分来组成的；</span></span><br><span class="line"><span class="comment">    找到编译后的结果（工程名/target/classes/com.xxx.demo01_concurrent_problem/Test02Atomicity.class）</span></span><br><span class="line"><span class="comment">    找到该文件之后通过使用Windows PowerShell打开或者是通过CMD等命令行进行打开也可以；</span></span><br><span class="line"><span class="comment">    键入命令：javap 可以对该字节码文件Test02Atomicity.class进行反汇编；</span></span><br><span class="line"><span class="comment">    从而看到一些字节码的指令；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    javap -p -v .\Test02Atomicity.class</span></span><br><span class="line"><span class="comment">    # -p 即显示私有的；-v 即详细信息也显示出来；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    通过反汇编之后可以看到很多的代码；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<strong>javap 反汇编</strong>class文件，得到下面的 字节码指令：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="built_in">void</span> lambda$main();</span><br><span class="line">  Code:</span><br><span class="line">     <span class="number">0</span>: iconst_0</span><br><span class="line">     <span class="number">1</span>: istore_0</span><br><span class="line">     <span class="number">2</span>: iload_0</span><br><span class="line">     <span class="number">3</span>: sipush        <span class="number">1000</span></span><br><span class="line">     <span class="number">6</span>: if_           <span class="number">23</span></span><br><span class="line">     <span class="number">9</span>: getstatic     #<span class="number">12</span>               <span class="comment">// Field number:I</span></span><br><span class="line">    <span class="number">12</span>: iconst_1</span><br><span class="line">    <span class="number">13</span>: iadd</span><br><span class="line">    <span class="number">14</span>: putstatic     #<span class="number">12</span>               <span class="comment">// Field number:I</span></span><br><span class="line">    <span class="number">17</span>: linc          <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="number">20</span>: goto</span><br><span class="line">    <span class="number">23</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>反汇编</strong>内容：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    offset_delta = <span class="number">27</span></span><br><span class="line">  Exception:</span><br><span class="line">    throws java.lang.InterruptedException</span><br><span class="line"></span><br><span class="line"># 通过反汇编可以看到lambda表达式的代码在此处</span><br><span class="line"><span class="keyword">private</span> static <span class="built_in">void</span> lambda$main$<span class="number">0</span>()</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, loclas=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_0</span><br><span class="line">        <span class="number">2</span>: iload_0</span><br><span class="line">        <span class="number">3</span>: sipush       <span class="number">1000</span></span><br><span class="line">        <span class="number">6</span>: if_icmpge    <span class="number">23</span></span><br><span class="line">        <span class="number">9</span>: getstatic    #<span class="number">18</span>         <span class="comment">// Field number:I</span></span><br><span class="line">       <span class="number">12</span>: iconst_1</span><br><span class="line">       <span class="number">13</span>: iadd</span><br><span class="line">       <span class="number">14</span>: putstatic    #<span class="number">18</span>         <span class="comment">// Field number:I</span></span><br><span class="line">       <span class="number">17</span>: iinc         <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">       <span class="number">20</span>: goto</span><br><span class="line">       <span class="number">23</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">18</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">17</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">23</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length   Slot   Name   Signature</span><br><span class="line">            <span class="number">2</span>      <span class="number">21</span>      <span class="number">0</span>      <span class="number">1</span>   I</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">252</span> <span class="comment">/* append */</span></span><br><span class="line">          offset_delta = <span class="number">2</span></span><br><span class="line">          locals = [ <span class="built_in">int</span> ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">20</span></span><br><span class="line">  static &#123;&#125;:</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>,  locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">          <span class="number">0</span>: iconst_0</span><br><span class="line">          <span class="number">1</span>: putstatic  #<span class="number">18</span>         <span class="comment">// Field number:I</span></span><br><span class="line">          <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中，对于 number++ 而言（number为静态变量 ），实际会产生如下的JVM字节码指令：</p><blockquote><p>9: getstatic     #18     // Field number:I<br>12: iconst_1<br>13: iadd<br>14: putstatic    #18     // Field number:I</p></blockquote><blockquote><p>代码当中的<br>number++;<br>对应反汇编代码当中的4句<br>9: getstatic     #18     // Field number:I<br>12: iconst_1<br>13: iadd<br>14: putstatic    #18     // Field number:I</p></blockquote><p>即 <code>number++</code>是由<strong>四条字节码指令</strong>组成的；<br>那么其中在<strong>一个线程</strong>下是没有问题的；<br>但如果是放在<strong>多线程</strong>的情况下那么就是有问题的；<br>当前来进行分析下这个<strong>原子性问题</strong>：<br>程序有主方法main方法开始进行执行的；</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">public class Test02Atomicity&#123;</span><br><span class="line">  // <span class="number">1</span>. 定义一个共享变量<span class="keyword">number</span></span><br><span class="line">  private static int <span class="keyword">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  public static void main(<span class="keyword">String</span>[] args) throws InterruptedException&#123;</span><br><span class="line">    // <span class="number">2</span>. 对<span class="keyword">number</span>进行<span class="number">1000</span>的++操作</span><br><span class="line">    Runnable increment = ()-&gt;&#123;</span><br><span class="line">      for(int i = <span class="number">0</span>; i<span class="tag">&lt; 1000; i++)&#123;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        number++;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">/**</span></span><br><span class="line"><span class="tag">-------------             ------------------------------------------</span></span><br><span class="line"><span class="tag">|           |             |                                        |</span></span><br><span class="line"><span class="tag">|           |             | 9: getstatic    #18  // Field number:I |</span></span><br><span class="line"><span class="tag">| number++; |===========》|12: iconst_1                            |</span></span><br><span class="line"><span class="tag">|           |             |13: iadd                                |</span></span><br><span class="line"><span class="tag">|           |             |14: putstatic    #18  // Field number:I |</span></span><br><span class="line"><span class="tag">|           |             |                                        |</span></span><br><span class="line"><span class="tag">-------------             ------------------------------------------</span></span><br><span class="line"><span class="tag">*/</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">      &#125;</span></span><br><span class="line"><span class="tag">    &#125;;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    List&lt;Thread&gt;</span> list = new ArrayList<span class="tag">&lt;Thread&gt;</span>();</span><br><span class="line">    // <span class="number">3</span>. 使用<span class="number">5</span>个线程来进行</span><br><span class="line">    for(int i = <span class="number">0</span> ; i<span class="tag">&lt; 5; i++)&#123;</span></span><br><span class="line"><span class="tag">      Thread t = new Thread(increment);</span></span><br><span class="line"><span class="tag">      t.start();</span></span><br><span class="line"><span class="tag">      list.add(t);</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    for(Thread t: list)&#123;</span></span><br><span class="line"><span class="tag">      t.join();</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    System.out.println("number = " + number);</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  /**</span></span><br><span class="line"><span class="tag">  以下进行约定：红色的箭头代表主线程</span></span><br><span class="line"><span class="tag">  那么主线程先会进行执行（main()）；</span></span><br><span class="line"><span class="tag">  Runnable该语句先不会进行执行（Runnable increment=()-&gt;</span>&#123;...&#125;;）；</span><br><span class="line">  然后走下面的执行语句创建list集合（List<span class="tag">&lt;Thread&gt;</span> <span class="attr">list=</span>new ArrayList<span class="tag">&lt;Thread&gt;</span>();)）</span><br><span class="line">  以及for循环<span class="number">5</span>次创建生成<span class="number">5</span>个Thread线程；</span><br><span class="line">  然后这个时候每个线程才会去执行上面的Runnable；</span><br><span class="line">  <span class="number">5</span>个线程分析起来有点麻烦；</span><br><span class="line">  当前在for()循环创建生成<span class="number">5</span>个线程途中，</span><br><span class="line">  那么此时当前假设已经创建生成线程Thread A与线程Thread B；</span><br><span class="line">  </span><br><span class="line">  那么此时在Thread A与Thread B同时都运行<span class="literal">start</span>()方法的时候</span><br><span class="line">  那么就都将会去执行Runnable当中的run()方法即循环<span class="number">1000</span>次的<span class="keyword">number</span>++操作；</span><br><span class="line">  那么假设此时的<span class="keyword">number</span>取值为<span class="number">0</span>；</span><br><span class="line">  假设线程Thread A先进行走，那么即循环<span class="number">1000</span>次执行<span class="keyword">number</span>++；</span><br><span class="line">  那么这每一次的<span class="keyword">number</span>++都是在执行字节码的那<span class="number">4</span>条指令；</span><br><span class="line">  即</span><br><span class="line">  <span class="number">9</span>:  getstatic <span class="comment">#18</span></span><br><span class="line">  <span class="number">12</span>: iconst_1</span><br><span class="line">  <span class="number">13</span>: iadd</span><br><span class="line">  <span class="number">14</span>: putstatic <span class="comment">#18</span></span><br><span class="line">  <span class="comment">#9: getstatic该指令即为取到共享变量number的取值，此时为0</span></span><br><span class="line">  <span class="comment">#12: 字节码指令继续往下执行一步，iconst_1该字节码指令的含义为是在准备一个常量1</span></span><br><span class="line">  <span class="comment">#13: 假设再往下走一步执行字节码指令iadd；那么该指令执行后会让12: iconst_1 准备的常量1与9: getstatic #18 获取得到的number 该共享变量的取值进行相加操作；最终的结果是1；</span></span><br><span class="line">  </span><br><span class="line">  但是注意假设此时并没有真正发生赋值操作，即运算出结果为<span class="number">1</span>；</span><br><span class="line">  但是并没有赋值给<span class="keyword">number</span>该共享变量的取值上；</span><br><span class="line">  然后此时CPU切换到另外一个线程上面去即线程B上去执行了；</span><br><span class="line">  那么此时另外一个线程，即线程B，也进入了for循环来执行<span class="keyword">number</span>++操作；</span><br><span class="line">  那么线程B也有四条字节码指令需要进行执行；</span><br><span class="line">  </span><br><span class="line">  先执行字节码指令的第一条指令 <span class="number">9</span>: getstatic <span class="comment">#18 获取得到共享变量number的取值，</span></span><br><span class="line">  目前该共享变量的取值是没有线程进行改变的；</span><br><span class="line">  即也就是说线程A刚刚在操作<span class="keyword">number</span>++字节码指令操作的步骤三时只是运算得出运算结果为<span class="number">1</span>；</span><br><span class="line">  但是并没有进行赋值就进行了CPU切换到了线程B上，</span><br><span class="line">  所以相对于线程B当前的共享变量<span class="keyword">number</span>来说，线程B认为<span class="keyword">number</span>共享变量的取值是<span class="number">0</span>；</span><br><span class="line">  那么当getstatic获取得到共享变量<span class="keyword">number</span>的取值之后，</span><br><span class="line">  然后执行字节码指令的第二条指令 <span class="number">12</span>: iconst_1 即同样是准备一个常量<span class="number">1</span>；</span><br><span class="line">  再执行字节码指令的第三条指令 <span class="number">13</span>: iadd 这个时候同样是将<span class="keyword">number</span>++操作当中的第一条字节码指令当中<span class="number">9</span>: getstatic <span class="comment">#18 获取得到的 共享变量number的取值与 number++操作当中的第二条指令 12: iconst_1 所准备的常量1 这两者进行相加操作；</span></span><br><span class="line">  运算结果得到<span class="number">1</span>；</span><br><span class="line">  假设线程B再继续往下走，</span><br><span class="line">  那么此时到了<span class="keyword">number</span>++操作所对应字节码指令的第四个指令了；</span><br><span class="line">  即<span class="number">14</span>: putstatic   <span class="comment">#18 ；</span></span><br><span class="line">  那么该指令执行之后就会将指令三当中得到的结果<span class="number">1</span>赋值给共享变量<span class="keyword">number</span>的取值，</span><br><span class="line">  而<span class="keyword">number</span>变量的取值此时从<span class="number">0</span>变为<span class="number">1</span>；</span><br><span class="line">  那么此时该线程的一次<span class="keyword">number</span>++执行完成；</span><br><span class="line"></span><br><span class="line">  假设CPU又切换到前一条线程，即线程A；</span><br><span class="line">  那么在切换到线程B之前，</span><br><span class="line">  线程A的<span class="keyword">number</span>++操作的<span class="number">4</span>条字节码指令已经执行完了前三条即iadd执行运算得出运算结果为<span class="number">1</span>；</span><br><span class="line">  那么此时当CPU又切换回线程A则继续执行<span class="keyword">number</span>++操作字节码指令的第四条指令即<span class="number">14</span>: putstatic <span class="comment">#18该指令；</span></span><br><span class="line">  则该指令同样是需要进行put即给共享变量<span class="keyword">number</span>进行赋值操作；</span><br><span class="line">  即将A线程运算得到的<span class="number">1</span>赋值给已经被线程B之前赋值好<span class="keyword">number</span>为<span class="number">1</span>的共享变量取值为<span class="number">1</span>；</span><br><span class="line">  所以当前共享变量<span class="keyword">number</span>的取值依旧是<span class="number">1</span>；</span><br><span class="line">  那么这个时候就看到了，两个线程执行<span class="keyword">number</span>++；</span><br><span class="line">  按道理其值应该是<span class="number">2</span>；</span><br><span class="line">  那么因为<span class="keyword">number</span>++的字节码指令这<span class="number">4</span>条字节码指令没有保证其一个原子性；</span><br><span class="line">  所以发现导致最后的结果<span class="keyword">number</span>只加了<span class="number">1</span>；</span><br><span class="line">  就让数据产生了错误；</span><br><span class="line">  那么这个问题的原因就在于让两个线程来进行操作<span class="keyword">number</span>++；</span><br><span class="line">  而<span class="keyword">number</span>++的字节码指令又是多条指令（<span class="number">4</span>条指令）；</span><br><span class="line">  其中一个线程执行到一半的时候；</span><br><span class="line">  CPU又切换到另外一个线程，即另外一个线程又来执行了；</span><br><span class="line">  即第二个线程干扰了第一个线程的执行从而导致执行结果的错误；</span><br><span class="line">  即没有保证原子性；（即没有使得应该的结果正确）</span><br><span class="line"></span><br><span class="line">  小结：</span><br><span class="line">  在并发编程的时候，很有可能会出现原子性问题；</span><br><span class="line">  当一个线程对共享变量操作到一半的时候，</span><br><span class="line">  另外一个线程也有可能来对共享变量来进行操作；</span><br><span class="line">  那么此时另外一个线程就有可能会干扰前一个线程的操作；</span><br><span class="line">  让前一个线程的操作没有保证其原子性；</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见 number++ 是由多条<strong>字节码</strong>语句组成，<br>以上<strong>多条指令</strong> 在<strong>一个线程的情况下</strong> 是不会出问题的，<br>但是在<strong>多线程情况下</strong>就可能会出现问题。<br>比如一个线程在执行 13: iadd 时，<br>另一个线程又执行 9: getstatic，<br>会导致两次 number++，实际上只加了1。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>什么是<strong>原子性</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">原子性（Atomicity）: 在一次的操作或多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</span></span><br></pre></td></tr></table></figure><h2 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h2><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><p>学习什么是<strong>有序性问题</strong></p><p>学习分成两步；<br>第一步：学习有序性的概念；<br>第二步：通过一个案例来演示有序性问题<br>有序性（Ordering）：是指程序中代码的执行顺序<br>一般会认为编写代码的顺序就是代码最终的执行顺序；<br>那么实际上并不一定是这样的；<br>为了提高程序的执行效率；java在编译时和运行时会对代码进行优化，会导致程序最终的执行顺序不一定就是编写代码时的顺序。<br>接下来通过一个案例来演示有序性问题；</p><h3 id="有序性概念"><a href="#有序性概念" class="headerlink" title="有序性概念"></a>有序性概念</h3><p>有序性（Ordering）：是指程序代码在执行过程中的先后顺序，由于java在编译器以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码的顺序。</p><h3 id="有序性演示"><a href="#有序性演示" class="headerlink" title="有序性演示"></a>有序性演示</h3><p><strong>jcstress</strong> 是java并发压测工具： </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>wiki.openjdk.java.net<span class="regexp">/display/</span>CodeTools<span class="regexp">/jcstress</span></span><br></pre></td></tr></table></figure><p>修改pom文件，添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jcstress<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcstress-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jcstress.version<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码<br>Test03Orderliness.java</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@OutCome</span>(id = &#123;<span class="string">"1"</span> , <span class="string">"4"</span>&#125;, expect =  Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>)</span><br><span class="line"><span class="meta">@OutCome</span>(id = <span class="number">0</span>, expect = EXPECT.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger"</span>)</span><br><span class="line"><span class="meta">@State</span></span><br><span class="line">public class Test03Orderliness&#123;</span><br><span class="line">    int num = <span class="number">0</span>;</span><br><span class="line">    boolean ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    /* 线程一 执行的代码；先进行判断ready的值然后进行相关操作；</span><br><span class="line">       I_Result为并发压测工具自带的类；</span><br><span class="line">       <span class="meta">@Actor</span>注解：表示到时候有多个线程来执行这两个方法；</span><br><span class="line">       <span class="meta">@JCStressTest</span>注解：表示用这个并发压测工具来对这个类的方法进行测试</span><br><span class="line">       <span class="meta">@OutCome</span>注解：对输出结果的处理；</span><br><span class="line">       如果当id为&#123;<span class="string">"1"</span>,<span class="string">"4"</span>&#125;的时候，表示这种结果是我们所预期所接受的结果，则打印信息<span class="string">"ok"</span>;</span><br><span class="line">       如果程序最终I_Result当中保存的结果是<span class="number">0</span>；则也认为结果是可接受感兴趣的；然后打印信息<span class="string">"danger"</span></span><br><span class="line">       接下来分析下有几种运行结果；</span><br><span class="line">    */</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    public void actor1(I_Result r)&#123;</span><br><span class="line">      <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //线程二 执行的代码；对两个变量进行相应的修改；</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    public void actor2(I_Result r)&#123;</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      画两个箭头代表两个线程；</span><br><span class="line">      (蓝色箭头与紫色箭头)</span><br><span class="line">      而实际上这标有<span class="meta">@Actor</span>注解的两个方法有很多的线程来执行；</span><br><span class="line">      那么为了演示方法，一个线程一个方法也是可以的；</span><br><span class="line">      那么这里存在有几种情况；</span><br><span class="line">      分有线程A与线程B分别执行actor1(I_Result r)与actor2(I_Result r)；</span><br><span class="line">      第一种情况是上面的线程A先走；</span><br><span class="line">      执行actor1(I_Result r)方法；</span><br><span class="line">      则获取得到共享变量 ready取值为<span class="literal">false</span>；</span><br><span class="line">      则此时走<span class="keyword">else</span>块；</span><br><span class="line">      将<span class="number">1</span>赋值给I_Result r当中的成员变量r1，即将r.r1即I_Result成员变量r1属性的取值修改为<span class="number">1</span>；</span><br><span class="line"></span><br><span class="line">      记录一下r.r1(I_Result中r1属性取值的变化)：</span><br><span class="line">      结果<span class="number">1</span>：  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">      接着假设第二种情况下面的线程B先走；</span><br><span class="line">      执行actor2(I_Result r)方法；</span><br><span class="line">      执行代码语句给共享变量num以及ready重新赋值；</span><br><span class="line">      即num该数值变为了<span class="number">2</span>；</span><br><span class="line">      ready该布尔类型取值变为了<span class="literal">true</span>；</span><br><span class="line"></span><br><span class="line">      接着CPU又切换到上面的线程A当中进行执行；</span><br><span class="line">      由于线程B修改num以及ready这两个共享变量成功了；</span><br><span class="line">      即num取值为<span class="number">2</span>；ready取值为<span class="literal">true</span>；</span><br><span class="line">      则此时线程A再一次进行判断ready该变量的取值时此时ready为<span class="literal">true</span>；</span><br><span class="line">      则进入actor1(I_Result r)当中的<span class="keyword">if</span>块中；</span><br><span class="line">      执行赋值语句，此时num取值为<span class="number">2</span>；</span><br><span class="line">      那么此时I_Result r.r1取值又被重新赋值为num+num，即运算结果为<span class="number">4</span>；</span><br><span class="line">      r.r1取值重新赋值为<span class="number">4</span>；</span><br><span class="line"></span><br><span class="line">      记录一下r.r1(I_Result中r1属性取值的变化)：</span><br><span class="line">      结果<span class="number">2</span>：  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">      第三种可能性：</span><br><span class="line">      依然还是假设下面的线程先走即先走线程B；</span><br><span class="line">      执行actor2(I_Result r)方法；</span><br><span class="line">      执行到代码语句 num = <span class="number">2</span>; 时，CPU又切换到线程A中去执行actor1(I_Result r)方法了；</span><br><span class="line">      那么这个时候就是由线程A去执行actor1(I_Result r)方法；</span><br><span class="line">      此时线程A获取得到ready变量的取值：为<span class="literal">false</span>；</span><br><span class="line">      由于是执行线程B执行到num=<span class="number">2</span>;赋值完成之后但是并未执行ready=<span class="literal">true</span>该语句之前CPU进行切换到了线程A的操作上去了；</span><br><span class="line">      所以此时线程A去进行获取ready变量时，ready变量的取值依旧是<span class="literal">false</span>；</span><br><span class="line">      所以此时不会进入<span class="keyword">if</span>块当中而是进入<span class="keyword">else</span>块当中执行操作使得r.r1=<span class="number">1</span>;</span><br><span class="line">      即对I_Result r当中的成员变量r1进行重新赋值为<span class="number">1</span>；</span><br><span class="line"></span><br><span class="line">      记录一下r.r1(I_Result中r1属性取值的变化)：</span><br><span class="line">      结果<span class="number">3</span>：  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">      第四种可能性：</span><br><span class="line">      很难发现；这是由于java在编译时和运行时的优化；</span><br><span class="line">      就可能会对actor2(I_Result r)当中的代码语句</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">      进行重排序；</span><br><span class="line">      比如说有可能会被排成这样：</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">      因为这两句代码并没有什么直接间接的一个因果关系；</span><br><span class="line">      如果说通过编译时和运行时的优化代码变成了</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">      的这种顺序则再来进行分析一下：</span><br><span class="line">      依然还是假设下面的线程B先走，即执行actor2(I_Result r)；</span><br><span class="line">      则执行了第一句ready = <span class="literal">true</span>;</span><br><span class="line">      那么此时假设CPU正好在ready 赋值为 <span class="literal">true</span>之后以及num = <span class="number">2</span>赋值之前又切换到了上面的那个线程，即线程A即执行actor1(I_Result r)方法；</span><br><span class="line">      那么此时线程A在执行actor1(I_Result r)时首先会去获取ready该共享变量的取值，</span><br><span class="line">      则此时的ready变量的取值是在线程B的操作actor2(I_Result r)时进行了修改了的，并且赋值成功了；那么这个时候线程A获取得到ready的取值为<span class="literal">true</span>则进入<span class="keyword">if</span>块当中执行对I_Result r.r1的赋值语句，r.r1=num+num；那么此时的num在线程B的操作actor2(I_Result r)并没有进行执行，即没有赋值成功；所以此时线程A获取得到num的取值依然为<span class="number">0</span>；</span><br><span class="line">      则此时赋值给I_Result r.r1成员变量的取值为num+num=<span class="number">0</span>;即赋值给r1的取值为<span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">      记录一下r.r1(I_Result中r1属性取值的变化)：</span><br><span class="line">      结果<span class="number">4</span>：  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      此时出现结果<span class="number">4</span>: <span class="number">0</span>的原因就是因为actor2(I_Result r)中的两句代码的执行顺序被重排序过了从而导致的；</span><br><span class="line"></span><br><span class="line">      效果：</span><br><span class="line">      通过jcstress来进行检测结果；</span><br><span class="line">      打开idea终端；即Terminal；</span><br><span class="line">      键入命令行：mvn clean install</span><br><span class="line">      完成之后会在target目录当中形成两个jar包（前提是安装了jcstress的依赖；） - jcstress.jar、Synchronized<span class="number">-1.0</span>-SNAPSHOT.jar</span><br><span class="line">      此时运行jcstress.jar该jar包；</span><br><span class="line">      C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; java -jar target/jcstress.jar</span><br><span class="line">      运行之后，进行多轮的压力测试；</span><br><span class="line"></span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压力测试结果（代码重排序所导致state结果出现了0）:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    [OK] com.xxx.demo02_concurrent_probleam.Test03Ordering</span><br><span class="line">  （JVM args: [-XX:-TieredCompilation]）</span><br><span class="line">Observed state Occurrences         Expectation     Interpretation</span><br><span class="line">             <span class="number">0</span>       <span class="number">5</span>,<span class="number">630</span>  ACCEPTABLE_INTERESTING  danger</span><br><span class="line">             <span class="number">1</span> <span class="number">150</span>,<span class="number">985</span>,<span class="number">557</span>          ACCEPTABLE      ok</span><br><span class="line">             <span class="number">4</span>  <span class="number">41</span>,<span class="number">594</span>,<span class="number">004</span>          ACCEPTABLE      ok</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_probleam.Test03Ordering</span><br><span class="line">  （JVM args: []）</span><br><span class="line">Observed state Occurrences         Expectation     Interpretation</span><br><span class="line">             <span class="number">0</span>       <span class="number">2</span>,<span class="number">787</span>  ACCEPTABLE_INTERESTING  danger</span><br><span class="line">             <span class="number">1</span> <span class="number">113</span>,<span class="number">540</span>,<span class="number">468</span>          ACCEPTABLE      ok</span><br><span class="line">             <span class="number">4</span>  <span class="number">46</span>,<span class="number">388</span>,<span class="number">436</span>          ACCEPTABLE      ok</span><br></pre></td></tr></table></figure><p>I_Result.class<br>jcstressjava并发压测工具当中并不只有I_Result这一个类；还存在有多个类似的类来进行保存各种不同的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.openjdk.jcstress.infra.results;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Result</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I_Result</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    成员变量r1 来保存一个int类型的结果</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Contended</span></span><br><span class="line">  <span class="meta">@jdk</span>.internal.vm.annotation.Contended</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> r1;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">I_Result</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">31</span> * result + <span class="keyword">this</span>.r1;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（有序性问题，有可能重排序从而导致在多线程的情况下，数据出现错乱问题。）</p><p>I_Result 是一个对象，有一个属性r1 用来保存结果，在多线程情况下可能出现几种结果？</p><p>情况1：线程1先执行actor1，这时 ready=false，所以进入else分支结果为1。<br>情况2：线程2执行到actor2，执行了num=2;和ready=true，线程1执行，这回进入if分支，结果为4；<br>情况3：线程2先执行actor2，只执行num=2; 但没来得及执行ready=true; 线程1执行，还是进入else分支，结果为1；<br><strong>还有一种结果为0</strong>；</p><p>运行测试：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn clean <span class="keyword">install</span></span><br><span class="line">java -jar <span class="keyword">target</span>/jcstress.jar</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>程序代码在执行工程中的 先后顺序，<br>由于java在 编译期以及运行期的优化（为了提高执行效率），<br>导致了 代码的执行顺序 未必就是 开发者编写代码的顺序。（最终程序的执行顺序可能跟编写的顺序不一样）</p><p>最后也就能够了解到并发编程当中存在的三个问题；<br>可见性、原子性、有序性；这三个问题有可能会导致共享数据错乱；<br>会出现线程安全问题；</p><h2 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h2><p>第二章：Java内存模型（JMM）</p><p>在介绍 Java内存模型之前，先来看一下到底什么是计算机内存模型。</p><p>当使用多线程并发访问共享资源的时候，会出现可见性、原子性、有序性等线程安全问题；<br>为什么会出现这三种问题以及出现这三种问题如何来进行解决呢？</p><p>这也是第二章所需要学习的内容；java内存模型（JMM）；<br>在第二章中分成三部分来进行学习；<br>首先介绍计算机的结构；那么就需要了解知道计算机有哪些重要的组成部分；<br>第二来进行学习java内存模型；需要知道java内存模型的概念和作用；<br>最后来进行学习java内存模型当中的主内存和工作内存之间是如何进行数据交互的；</p><h3 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h3><p>学习计算机的主要组成<br>学习缓存的作用</p><h3 id="计算机结构简介"><a href="#计算机结构简介" class="headerlink" title="计算机结构简介"></a>计算机结构简介</h3><p>1945年6月，美籍 匈牙利 科学家 <strong>冯 诺依曼</strong> 最先提出把 <strong>计算机</strong>分作 <strong>五部分</strong>：<strong>计算器</strong>、<strong>控制器</strong>、<strong>存储器</strong>、<strong>输入和输出设备</strong>。<br>由于他对 现代计算机技术的特殊贡献，因此 冯 诺依曼 又被称为 “现代计算机之父”。  </p><blockquote><p>冯诺依曼，提出计算机由五大组成部分，输入设备、输出设备、存储器、控制器、运算器</p><ul><li>输入设备：键盘、鼠标、扫描仪、etc.</li><li>输出设备：显示器、打印机、etc.</li><li>存储器：内存条</li><li>控制器：控制器+运算器–→CPU</li><li>运算器：控制器+运算器–→CPU</li></ul></blockquote><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">--------------     -----------------        -------------</span><br><span class="line">|<span class="string"> 输入设备</span>|<span class="string"> ------→ </span>|<span class="string">    存储器    </span>|<span class="string"> -------→ </span>|<span class="string"> 输出设备 </span>|</span><br><span class="line">------------       -----------------         ------------</span><br><span class="line">     ↑                |<span class="string">  ↑    </span>|<span class="string">  ↑                 ↑</span></span><br><span class="line"><span class="string">     </span>|<span class="string">                </span>|<span class="string">  </span>|<span class="string">    </span>|<span class="string">  </span>|<span class="string">                 </span>|</span><br><span class="line">     |<span class="string">       ---------</span>|<span class="string">--</span>|<span class="string">----</span>|<span class="string">--</span>|<span class="string">----------       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">        </span>|<span class="string">  </span>|<span class="string">    </span>|<span class="string">  </span>|<span class="string">         </span>|<span class="string">       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">        ↓  </span>|<span class="string">    ↓  </span>|<span class="string">         </span>|<span class="string">       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">   ----------  -----------   </span>|<span class="string">       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">   </span>|<span class="string"> 运算器 </span>|<span class="string">   </span>|<span class="string"> 控制器 </span>|<span class="string">----</span>|<span class="string">-------</span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">   ----------  -----------   </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">                    </span>|<span class="string">        </span>|</span><br><span class="line">     --------|<span class="string">---------------------        </span>|</span><br><span class="line">             |<span class="string">                        CPU  </span>|</span><br><span class="line">             -------------------------------</span><br></pre></td></tr></table></figure><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><strong>中央处理器</strong>（<strong>CPU</strong>，<strong>central processing unit</strong>）是<strong>计算机</strong>系统的<strong>运算</strong>和<strong>控制核心</strong>。（相当于人类的大脑）<br>计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。<br>程序最终都会变成 <strong>指令</strong> 让 <strong>CPU</strong> 去执行，处理程序中的数据。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>计算机中所有<strong>程序</strong>的<strong>运行</strong> 都是在 <strong>内存中</strong> 进行的， 内存的作用是 用于暂时存放 CPU的运算数据，以及与 硬盘等 外部存储器 交换的数据。</p><p>CPU自产生以来，在逻辑结构、运行效率以及功能外延上取得了巨大发展。<br>但受制于 制造工艺以及成本等的限制，计算机的内存反倒在访问速度上并没有多大的突破，<br>因此CPU的处理速度和内存的访问速度之间的差距越拉越大，通常这种差距可以达到上千倍，极端情况下甚至会在上万倍以上。<br>这就导致CPU每次操作内存都要耗费很多等待时间。<br>内存的读写速度成为了计算机运行的瓶颈。</p><p>（程序都是在内存中运行的，内存 会保存 程序运行时的数据，供CPU处理；CPU运行的时候，是需要到内存当中读取数据进行相关处理的；）</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>由于CPU和内存两边速度 严重的不对等，会导致CPU资源受到大量的限制，降低CPU整体的吞吐量，于是就有了在CPU与主内存之间增加缓存的设计，现在缓存的数量都可以增加到3级了，最靠近CPU的缓存称为L1，然后依次是L2，L3和主内存，CPU缓存模型如图 下图所示。  </p><p>CPU自从产生以来，在运行速度运行效率上得到了巨大的发展；<br>但是内存由于制造工艺制造成本的控制在访问速度上面并没有多大的提升。<br>因此CPU的运行速度和内存的读写速度其差距就将变得越来越大；<br>这样也就导致了CPU在运算的时候要花上很长的时间去等待内存的读取；<br>那么也就是说内存的读写速度成为了计算机运行的一个瓶颈；<br>那么如何来解决这个两面速度不对等的问题？<br>于是人们就在CPU与主内存之间增加了缓存的设计；</p><p>打开任务管理器[CTRL + ALT + DEL]，点开[性 能]菜单栏，可以看到；</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内核：      <span class="number">6</span>             # 我电脑只有<span class="number">4</span></span><br><span class="line">逻辑处理器: <span class="number">12</span>            # 我电脑只有<span class="number">8</span></span><br><span class="line">虚拟化：    已启用</span><br><span class="line">L1缓存：    <span class="number">384</span> KB</span><br><span class="line">L2缓存：    <span class="number">1.5</span> MB</span><br><span class="line">L3缓存：    <span class="number">12.0</span> MB</span><br></pre></td></tr></table></figure><p>其中缓存L1缓存最小；L2缓存较之L1缓存较大；L3缓存最大；<br>CPU的缓存是内置在CPU当中的；<br>首先离CPU最近的是L1缓存；其空间比较小但是速度比较快；价格也比较昂贵；<br>L2缓存空间稍大；速度稍慢些；价格的话也会更加便宜些；<br>L3缓存空间更大；速度较之前两者更慢，价格也更便宜些；</p><p>看图说话：<br>CPU 在操作内存的时候有59.4 ns(纳秒)的一个延迟(Latency)<br>CPU 在操作L1缓存的时候大约 1.2 ns(纳秒)<br>CPU 在操作L2缓存的时候大约 5.5 ns(纳秒)<br>CPU 在操作L3缓存的时候大约 15.9 ns(纳秒)</p><p>从中可以看到的是内存的速度要比缓存的速度慢很多；<br>当CPU有了缓存之后，其数据是如何进行处理的呢？<br>首先CPU运算的时候需要数据，那么CPU直接去一级缓存L1Cache当中找要查找的数据看是否能够查找得到；<br>如果命中了一级缓存则直接从一级缓存当中进行读取数据到CPU，处理完成之后就会将CPU当中处理后的结果又接着放回到缓存L1、L2、L3中以及内存中；<br>那么如果CPU需要数据时，但是此时并没有在一级缓存L1 Cache当中命中缓存；<br>那么这个时候CPU就会去进行读取二级缓存L2 Cache当中所需要查找的数据；<br>如果二级缓存L2 Cache当中也没有找到所需要查找得到的数据，即没有命中缓存；<br>那么这个时候CPU就会去进行读取三级缓存L3 Cache当中所需要查找的数据；<br>如果此时三级缓存L3 Cache当中也没有找到所需要查找得到的数据，即也没有命中缓存；<br>那么这个时候就会去查找内存Memory；从内存当中拿取到相应的所需要查找的数据之后，在CPU中运行计算之后；另外相应的其处理结果也会保存在缓存当中；</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                    单CPU双核的缓存结构</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|<span class="string">--------------------------------------------</span>|</span><br><span class="line">|<span class="string">      -----------          -------------    </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">  Core1  </span>|<span class="string">           </span>|<span class="string">  Core 2  </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">      -----------          -------------    </span>|</span><br><span class="line">|<span class="string">           ↓                     ↓          </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">  L1 Cache </span>|<span class="string">         </span>|<span class="string"> L1 Cache </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">           ↓                    ↓           </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">  L2 Cache </span>|<span class="string">         </span>|<span class="string"> L2 Cache </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">           ↓                    ↓           </span>|</span><br><span class="line">|<span class="string">     ------------------------------------   </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">          L3   Cache             </span>|<span class="string">   </span>|</span><br><span class="line">|<span class="string">     ------------------------------------   </span>|</span><br><span class="line">|<span class="string">                       </span>|<span class="string">                    </span>|</span><br><span class="line">|<span class="string">-----------------------</span>|<span class="string">---------------------</span></span><br><span class="line"><span class="string">                        ↓</span></span><br><span class="line"><span class="string">     ------------------------------------</span></span><br><span class="line"><span class="string">     </span>|<span class="string">              Memory              </span>|</span><br><span class="line">     ------------------------------------</span><br></pre></td></tr></table></figure><p><strong>CPU Cache</strong> 分成了三个级别：<strong>L1、L2、L3。</strong><br><strong>级别越小越接近CPU</strong>，<strong>速度也更快</strong>，同时也代表着<strong>容量越小</strong>。</p><p><strong>1.</strong> <strong>L1 Cache</strong>是<strong>最接近CPU</strong>的，它<strong>容量最小</strong>，例如32k，<strong>速度最快</strong>，每个核上都有一个L1 Cache。<br><strong>2.</strong> <strong>L2 Cache</strong> <strong>更大</strong>一些，例如256k，<strong>速度要慢</strong>一些，一般情况下每个核上都有一个独立的L2 Cache。<br><strong>3.</strong> <strong>L3 Cache</strong>是三级缓存中<strong>最大</strong>的一级，例如12MB，同时也是缓存中<strong>最慢</strong>的一级，在同一个CPU插槽之间的核共享一个L3 Cache。</p><p><strong>Cache的出现</strong>是为了<strong>解决 CPU直接访问内存效率低下问题的</strong>，<br>程序在运行的过程中，CPU接收到指令后，<br>它会最先向CPU中的一级缓存（L1 Cache）去寻找相关的数据，<br>如果命中缓存，CPU进行计算时就可以直接对CPU Cache中的数据进行读取和写入，<br>当运算结束之后，再将CPU Cache中的最新数据刷新到主内存当中，<br><strong>CPU</strong> 通过<strong>直接访问Cache</strong>的方式 <strong>代替</strong> <strong>直接访问主内存</strong>的方式 极大地<strong>提高</strong>了 <strong>CPU的吞吐能力</strong>。  </p><p>但是由于 <strong>一级缓存（L1 Cache）</strong> <strong>容量较小</strong>，<br>所以不可能每次都命中，<br>这时 <strong>CPU</strong> 会继续向下一级的<strong>二级缓存（L2 Cache）</strong> 寻找，<br>同样的道理，当所需要的数据在二级缓存中也没有的话，<br>会继续转向<strong>L3 Cache</strong>、<strong>内存（主存）</strong>和<strong>硬盘</strong>。  </p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>计算机的主要组成 <strong>CPU</strong>、<strong>内存</strong>、<strong>输入设备</strong>、<strong>输出设备</strong></p><blockquote><p><strong>CPU</strong>：计算机的核心；用来控制和处理的<br><strong>内存</strong>：用来保存正在运行的这些程序的数据；<br><strong>输入设备</strong>：<br><strong>输出设备</strong>：<br><strong>缓存</strong>：<br>  CPU的运算速度比内存的访问速度快很多；<br>  那么如果CPU直接从内存当中进行读取数据进行相关处理的话；<br>  则内存读取时间花费开销大就会导致拖累CPU的运算速度；<br>  所以在CPU与内存之间增加了缓存；<br>  缓存的读写速度较之内存的读写速度要快很多；<br>  因此可以让CPU的执行速度高一点；</p></blockquote><p><strong>1.</strong> 说出计算机的主要组成</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU</span><br><span class="line">内存</span><br><span class="line">缓存</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 为什么会出现缓存？</p><p>缓存是为了解决CPU直接访问内存效率低下问题的</p><h2 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h2><h3 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h3><p>全称：<strong>Java Memory Model</strong>(翻译成中文名为:<strong>Java内存模型</strong>；一般简称为<strong>JMM</strong>)<br><strong>Java 内存模型</strong> <strong>JMM</strong>千万不要和<strong>Java内存结构</strong>混淆；<br>以前学习Java的时候知道<strong>JVM</strong>会<strong>对内存</strong>进行一个<strong>划分</strong>；会划分成<strong>栈</strong>、<strong>堆</strong>、<strong>方法区</strong>、etc.那么这个是指的是<strong>Java内存结构</strong>；<br>那么<strong>java内存模型</strong> <strong>JMM</strong>则<strong>是一套规范</strong>；关于<strong>Java内存模型</strong>的权威解释可以查看网址；（Oracle提供的纯英文版本，即Java内存模型的详细的说明文档，其实即一套规范，那么这套规范主要描述了两个关键字；一个是synchronized；一个是volatile；）</p><p>学习java内存模型的概念和作用<br>java内存模型（即 java Memory Model，简称JMM）。<br>（java内存模型 和 以前学习的栈、堆、方法区、原空间这样的java内存结构是不一样的）<br>很多小伙伴 将 “java内存结构” 与 “java内存模型”混淆。<br>关于 “java内存模型”的权威解释，请参考 <code>https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf</code>。</p><p>为什么会出现Java内存模型；<br>Java是一门跨平台的语言；可以在不同的操作系统上运行；<br>那么其底层是依赖JVM虚拟机来进行实现的跨平台这一特性；<br>每一个平台都有其对应的一个虚拟机；<br>那么此时Java程序就可以跑在不同的操作系统上；<br>那么java内存模型是java虚拟机规范当中的一部分；<br>它主要是用来屏蔽java运行在不同操作系统上的一些细节问题；<br>那么java程序仅仅只需要关注java内存模型即可；</p><p>Java 内存模型，是 Java虚拟机规范 中 所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。<br>JMM是一套规范， 描述了 Java程序中 各种变量（线程共享变量）的访问规则，以及在 JVM中 将变量 存储到 内存和从内存中读取变量 这样的底层细节，具体如下。</p><p>（学习主内存和工作内存，以及它们是如何操作这些共享变量的）<br>Java内存模型主要分作两部分来看；<br>一部分叫做主内存；<br>另一部分叫做工作内存；<br>首先来看主内存，java当中的共享变量；都放在主内存当中；<br>比如说类的成员变量也称之为实例变量；还有静态的成员变量；或者说叫类变量；都是存储在主内存当中的；<br>那么每一个线程都可以来进行访问主内存；<br>接着来看第二部分工作内存；每一个线程都有其自己的工作内存；<br>当线程要执行代码的时候，就必须在工作内存当中来进行处理完成；</p><p>假设现在一个线程A要访问主内存当中的一个共享变量X；<br>要对该共享变量X进行操作；<br>那么线程是不能够在主内存当中来进行直接操作共享变量X的；<br>即该线程只能够将该共享变量先进行复制一份放到线程自己的工作内存当中，<br>然后才去进行数据的相关处理；<br>当线程在其工作内存对该复制过来的共享变量相应处理完成之后再将处理完成的结果同步回主内存当中去；</p><p>假设线程A想要对共享变量x操作；<br>此时共享变量x的取值在主内存当中为 int x = 10; 这样一个取值；<br>那么首先线程A需要将该共享变量x的取值从主内存当中进行拷贝一份放到自己的工作内存当中去；<br>然后进行相应处理，比方说这里处理为重新赋值为9，<br>即int x = 9;那么假设处理完成之后，<br>那么这个时候该线程A就需要将对该共享变量重新赋值的结果即9需要同步回主内存当中；<br>那么其他的线程也是一样的，<br>也是先要进行将共享变量先要从主内存当中进行拷贝一份放到自己的工作内存当中去；<br>然后再去进行操作for example：int x = 8;<br>最后相应操作（赋值）完成之后再由线程从工作内存同步至主内存当中去；</p><ul><li><strong>主内存</strong><ul><li><strong>主内存</strong>是 所有<strong>线程</strong>都<strong>共享</strong>的，都能访问的。所有的<strong>共享变量</strong>都<strong>存储于主内存</strong>。</li><li>共享变量主要包括类当中的成员变量，以及一些静态变量等；线程的局部变量是不会出现在主内存当中的；因为线程的局部变量只能够自己该线程进行使用；</li></ul></li><li><strong>工作内存</strong><ul><li>每一个线程有自己的<strong>工作内存</strong>，工作内存只存储 该线程 对<strong>共享变量的副本</strong>。 线程对变量的所有的操作（<strong>读、取</strong>）都必须在<strong>工作内存</strong>中完成，而<strong>不能直接读写主内存中的变量</strong>，不同线程之间也<strong>不能直接访问</strong> <strong>对方工作内存中的 变量</strong>。</li><li>线程对共享变量的操作都是对其副本进行操作，操作完成之后再同步回主内存当中去；</li></ul></li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">                    Java Memory Model(Java 内存模型)</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    --------------------------          ----------------------------</span><br><span class="line">    |<span class="string">        线程1           </span>|<span class="string">           </span>|<span class="string">          线程2           </span>|</span><br><span class="line">    |<span class="string">                        </span>|<span class="string">           </span>|<span class="string">                          </span>|</span><br><span class="line">    |<span class="string">  -------------------   </span>|<span class="string">           </span>|<span class="string">  --------------------    </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string">  线程1工作内存    </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string">  线程2工作内存    </span>|<span class="string">    </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string">                  </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string">                   </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string"> ---------------- </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string"> ----------------  </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string"> </span>|<span class="string"> 共享变量x副本 </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string"> 共享变量x副本 </span>|<span class="string">  </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string"> ---------------- </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string"> ----------------- </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string">                  </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string">                   </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  --------------------  </span>|<span class="string">           </span>|<span class="string">  ---------------------   </span>|</span><br><span class="line">                ↑                                      ↑</span><br><span class="line">                |<span class="string">                                      </span>|</span><br><span class="line">                |<span class="string">←---------------JMM控制--------------→</span>|</span><br><span class="line">                |<span class="string">                                      </span>|</span><br><span class="line">                ↓                                      ↓</span><br><span class="line">   --------------------------------------------------------------------</span><br><span class="line">   |<span class="string">                            主内存                                </span>|</span><br><span class="line">   |<span class="string">  ------------------      ------------------     --------------   </span>|</span><br><span class="line">   |<span class="string">  </span>|<span class="string">   共享变量x    </span>|<span class="string">       </span>|<span class="string">   共享变量 y   </span>|<span class="string">      </span>|<span class="string"> 共享变量z  </span>|<span class="string">  </span>|</span><br><span class="line">   |<span class="string">  ------------------      -------------------    ---------------  </span>|</span><br><span class="line">   |<span class="string">                                                                  </span>|</span><br><span class="line">   --------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="Java内存模型的作用"><a href="#Java内存模型的作用" class="headerlink" title="Java内存模型的作用"></a>Java内存模型的作用</h3><p>java内存模型是一套规范；<br>主要的目的就是在多线程对共享变量进行读写时，来保证共享变量的可见性、有序性、原子性；<br>java内存模型该规范当中主要阐述了两个关键字；<br>一个是synchronized；一个是volatile；<br>那么在编程当中也是通过这两个关键字来进行保证共享变量的三个特性即可见性、有序性、原子性；</p><p>java内存模型 是一套在多线程读写共享数据时，对共享数据的可见性、有序性、原子性的规则和保障。</p><p>java内存模型与真实的计算机结构有什么关系？</p><h3 id="CPU缓存、内存与Java内存模型的关系"><a href="#CPU缓存、内存与Java内存模型的关系" class="headerlink" title="CPU缓存、内存与Java内存模型的关系"></a>CPU缓存、内存与Java内存模型的关系</h3><p>通过对前面的 <strong>CPU硬件内存架构</strong>、<strong>Java内存模型</strong> 以及 <strong>Java多线程的实现原理</strong> 的了解，应该已经意识到，<strong>多线程的执行</strong> <strong>最终</strong>都会<strong>映射</strong>到 <strong>硬件处理器</strong> 上进行<strong>执行</strong>。</p><p>但 <strong>Java内存模型</strong> 和 <strong>硬件内存架构</strong> 并<strong>不完全一致</strong>。<br>对于 <strong>硬件内存</strong> 来说只有 <strong>寄存器</strong>、<strong>缓存内存</strong>、<strong>主内存</strong>的概念，<br>并<strong>没有工作内存和主内存之分</strong>，<br>也就是说 <strong>Java内存模型对内存的划分</strong> 对 <strong>硬件内存</strong> 并<strong>没有任何问题</strong>，<br>因为<strong>JMM</strong>只是一种 <strong>抽象的概念</strong>，是<strong>一组规则</strong>，<br>不管是 <strong>工作内存的数据</strong> 还是 <strong>主内存的数据</strong>，<br>对于 <strong>计算机硬件</strong>来说 都会 <strong>存储在计算机主内存</strong>中，<br>当然也有可能 <strong>存储到CPU缓存</strong>或者<strong>寄存器</strong>中，<br>因此总体上来说，<strong>Java内存模型</strong>和<strong>计算机硬件内存架构</strong> 是一个<strong>相互交叉</strong>的关系，<br>是一种 <strong>抽象概念划分</strong> 与 <strong>真实物理硬件</strong>的<strong>交叉</strong>。</p><p>JMM内存模型与CPU硬件内存架构的关系：</p><p>图的右边是真实的CPU硬件内存架构；有CPU、CPU当中存在有CPU寄存器、CPU缓存、内存（RAM）；<br>图的左边是Java内存模型：线程、线程当中存在有工作内存、主内存；<br>Java内存模型是一套抽象出来的规范，抽象的概念，是一组规则；<br>java内存模型当中的线程中的工作内存有可能对应着 硬件内存架构当中的CPU寄存器也有可能对应着CPU缓存也有可能对应内存（RAM）；<br>java内存模型当中的主内存也有可能对应着 硬件内存架构当中的CPU寄存器、CPU缓存、内存（RAM）；</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>java内存模型是一套规范（主要是让java程序来可以实现跨平台这一特性；又不需要去关注平台的底层细节），<br>描述了 java程序中各种变量 （线程共享变量）的访问规则，<br>以及在 JVM中将变量 存储到内存和从内存中读取变量这样的 底层细节，<br>java内存模型是对共享数据的可见性、有序性、原子性的规则和保障。</p><h2 id="主内存与工作内存之间的数据交互过程"><a href="#主内存与工作内存之间的数据交互过程" class="headerlink" title="主内存与工作内存之间的数据交互过程"></a>主内存与工作内存之间的数据交互过程</h2><p>java内存模型有主内存、工作内存之分；<br>当线程A需要进行操作一个共享变量X的时候，<br>需要将存在在主内存的共享变量X复制拷贝一份放到线程A自己的工作内存当中；<br>线程A即对自己工作内存当中拷贝过来的共享变量副本进行操作，<br>操作处理完成之后；<br>然后再将结果从工作内存同步回主内存当中去；<br>那么该过程当中其中详细的细节是怎样的？</p><h3 id="主内存与工作内存之间的交互"><a href="#主内存与工作内存之间的交互" class="headerlink" title="主内存与工作内存之间的交互"></a>主内存与工作内存之间的交互</h3><h3 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h3><p>了解主内存与工作内存之间的数据交互过程</p><p>Java内存模型 中定义了以下 8中操作来完成（为了保证主内存与工作内存之间的数据交互数据是正确的），<br>主内存与工作内存之间 具体的交互协议，<br>即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，<br>虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的；</p><p>对应的流程图如下：<br>这8个原子操作先不关心 Lock与Unlock操作；除此之外还余六个操作；<br>假设现在线程1想要来进行访问主内存当中的共享变量x，即当前主内存当中的共享变量x的取值为 boolean x = true;</p><p>那么该线程1首先会做一个原子操作叫做Read，那么也就是读取主内存当中的共享变量x的取值即boolean x = true的这样一个取值；<br>那么接下来就是执行一个操作叫做Load，即将该在主内存当中读取到的共享变量加载到了工作内存当中；<br>那么接着会做一个Use操作，也就是说如果该线程1需要对该共享变量x进行操作，即会取到这个从主内存当中加载过来的共享变量x的取值去进行一些操作；<br>那么操作之后会有一个新的结果进行返回；那么假设这个操作的新的结果令这个共享变量的取值变为了false；那么即给这个共享变量x进行赋值操作，即完成操作Assign；那么操作完成之后；就需要同步回主内存；<br>同步回主内存首先会完成一个 Store的这样一个原子操作；表示要来保存这个处理结果；<br>然后接着执行Write操作，即把在工作内存当中处理完成之后最新的取值，即Assign赋值给共享变量的值同步到主内存当中；即主内存中共享变量取值x由true更改为false；<br>另外还有两个操作即Lock与Unlock；这个是与锁相关的操作；<br>比如说加了synchronized，即加了锁；才会产生有lock与unlock操作；<br>如果共享变量的操作没有加这个synchronized即没有加锁；<br>那么也就不会产生有lock与unlock操作；</p><p>注意；<br>（对于lock有一些特殊的情况；）</p><ol><li>如果对一个变量执行 lock操作，将会清空工作内存中 此变量的值。</li><li>对一个变量执行unlock操作，必须先把此变量同步到主内存中。</li></ol><p>即如果线程1中在Read主内存当中的共享变量之前，线程1的工作内存当中已经存在有该共享变量的副本；那么又有lock操作的话则将会将该线程1当中的共享变量的副本进行清空掉，然后再去进行Read读取主内存当中共享变量取值的操作；即读取主内存当中有关该共享变量最新的取值；</p><p>unlock操作也需要注意；假设线程1当中的工作内存当中存在有该共享变量的副本；那么在执行unlock之前一定会先将工作内存当中该共享变量副本的取值同步到主内存当中去；然后再进行unlock操作；</p><p>synchronized如何保证可见性其实就与lock、unlock这两个原子操作有关；</p><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>主内存 与 工作内存 之间的 数据交互过程(即主内存与工作内存的交互过程中是通过这8个原子操作来进行保证数据的正确性；)</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">lock</span> --<span class="comment">→</span> <span class="comment">read</span> --<span class="comment">→</span> <span class="comment">load</span> --<span class="comment">→</span> <span class="comment">use</span> --<span class="comment">→</span> <span class="comment">assign</span> --<span class="comment">→</span> <span class="comment">store</span> --<span class="comment">→</span> <span class="comment">write</span> --<span class="comment">→</span> <span class="comment">unlock</span></span><br></pre></td></tr></table></figure><h2 id="synchronized保证原子性"><a href="#synchronized保证原子性" class="headerlink" title="synchronized保证原子性"></a>synchronized保证原子性</h2><p>（通过synchronized关键字和内存模型来详细的分析原子性问题，以及如何来进行解决原子性问题，如何解决可见性问题以及有序性问题等）</p><p>第三章：synchronized保证三大特性（即synchronized是如何进行来保证可见性、原子性、有序性）</p><h3 id="回顾synchronized的使用"><a href="#回顾synchronized的使用" class="headerlink" title="回顾synchronized的使用"></a>回顾synchronized的使用</h3><p>synchronized 能够保证在 同一时刻 最多只有一个线程执行该段代码，已达到保证并发安全的效果。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//到时候只有一个线程能够拿到获取锁进入同步代码块当中来；其他的线程拿不到获取不到锁；只能够在同步代码块外进行等待</span></span><br><span class="line"><span class="function"><span class="title">synchronized</span><span class="params">( 锁对象 )</span></span>&#123;</span><br><span class="line">  <span class="comment">// 受保护资源 / 临界区资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized 与 原子性</p><h3 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h3><p>学习使用 synchronized 保证原子性的原理</p><h3 id="使用-synchronized-保证原子性"><a href="#使用-synchronized-保证原子性" class="headerlink" title="使用 synchronized 保证原子性"></a>使用 synchronized 保证原子性</h3><p>案例演示：5个线程各执行1000次 i++；<br>（回顾之前原子性问题的代码，<strong>产生原子性问题的原因</strong>）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">    1. 定义一个共享变量number</span></span><br><span class="line"><span class="comment">    2. 对number进行1000的++操作</span></span><br><span class="line"><span class="comment">    3. 使用5个线程来进行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02Atomicity</span>&#123;</span></span><br><span class="line">  <span class="comment">// 1. 定义一个共享变量number</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">// 2. 对number进行1000的++操作</span></span><br><span class="line">    <span class="comment">// Runnable当中执行1000次的循环；每次循环使得number++</span></span><br><span class="line">    Runnable increment =  () -&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        number++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Thread&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">    <span class="comment">// 3. 使用5个线程来进行</span></span><br><span class="line">    <span class="comment">// 创建5个线程都去执行Runnable当中的run()</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">      t.start();</span><br><span class="line">      <span class="built_in">list</span>.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t : <span class="built_in">list</span>)&#123;</span><br><span class="line">      t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"number = "</span> + number);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    之前存在线程安全问题；</span></span><br><span class="line"><span class="comment">    即多次运行测试发现数据可能会小于5000；</span></span><br><span class="line"><span class="comment">    number = 5000;</span></span><br><span class="line"><span class="comment">    number = 4935;</span></span><br><span class="line"><span class="comment">    导致这种结果的原因是因为number++是由4条字节码指令进行组成的；</span></span><br><span class="line"><span class="comment">    并没有保证这4条字节码指令的原子性操作；</span></span><br><span class="line"><span class="comment">    接下来使用synchronized；synchronized需要一把锁对象；</span></span><br><span class="line"><span class="comment">    则创建一把锁；Object obj即可；</span></span><br><span class="line"><span class="comment">    那么使用了synchronized之后就可以保证number++是一个原子操作；</span></span><br><span class="line"><span class="comment">    再次多次运行就会发现number的取值不会进行变动了；而是直接就是5000；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<strong>synchronized</strong>来进行保证number++的原子性操作；即进行加锁</p></blockquote><p>再怎么多次运行得到的number的结果也会是5000；因为synchronized保证了number++的原子性；那么数据就不会错乱；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo02_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：5个线程各执行1000次 i++;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Atomicity</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">      Runnable increment = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Test01Atomicity<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">              number++;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      ArrayList&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList();</span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; <span class="number">50</span> ; i++)&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">        t.start();</span><br><span class="line">        ts.add(t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Thread t : ts)&#123;</span><br><span class="line">        t.join();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"number = "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">    synchronized( Test01Atomicity.<span class="keyword">class</span> )&#123;</span><br><span class="line">      number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示</span></span><br><span class="line"><span class="comment">    1. 定义一个共享变量number</span></span><br><span class="line"><span class="comment">    2. 对number进行1000次的++操作</span></span><br><span class="line"><span class="comment">    3. 使用5个线程来进行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test02Atomicity&#123;</span><br><span class="line">  <span class="comment">// 1. 定义一个共享变量number</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  priavte Object obj = <span class="keyword">new</span> Object();<span class="comment">//对象锁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)<span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="comment">// 2. 对number进行1000次的++操作</span></span><br><span class="line">    Runnable increment = ()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">          number++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">    <span class="comment">// 3. 使用5个线程来进行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">      t.start();</span><br><span class="line">      list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t : list)&#123;</span><br><span class="line">      t.<span class="keyword">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">"number = "</span> + number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  进行分析；为什么加了synchronized之后就可以保证number++是一个原子操作；</span></span><br><span class="line"><span class="comment">  还是通过javap反汇编的方式来进行查看number++这一块的字节码指令的变化；</span></span><br><span class="line"><span class="comment">  通过命令行（Windows PowerShell、CMD等）打开文件；</span></span><br><span class="line"><span class="comment">  目录（工程名/target/classes/com/xxx/demo02_concurrent_probleam/Test02Atomicity.class）</span></span><br><span class="line"><span class="comment">  通过键入命令javap对字节码文件进行反汇编；查看到字节码指令；</span></span><br><span class="line"><span class="comment">  &gt;PS C:\Users\13666\IdeaProjects\XXX\Synchronized\target\classes\com\xxx\demo02_concurrent_probleam&gt; javap -p -v .\Test02Atomicity.class</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  接着依旧是分析下synchronized保证原子性操作的原理；</span></span><br><span class="line"><span class="comment">  在第三步骤时创建了5个线程分别都来进行执行Runnable当中的run()操作；</span></span><br><span class="line"><span class="comment">  即进行循环1000次number++操作；</span></span><br><span class="line"><span class="comment">  分析的时候就以两个线程为例；线程A与线程B；</span></span><br><span class="line"><span class="comment">  假设第一个线程A先进行执行Runnable当中的1000次number++的循环；</span></span><br><span class="line"><span class="comment">  当线程A进入到synchronized的时候，如果发现对象锁obj没有线程在使用的话，</span></span><br><span class="line"><span class="comment">  那么线程A就会拿着对象锁obj进入同步代码块当中；</span></span><br><span class="line"><span class="comment">  那么进来之后就将执行number++操作；</span></span><br><span class="line"><span class="comment">  而number++操作所对应的字节码指令有4条字节码指令；</span></span><br><span class="line"><span class="comment">  那么首先来进行执行读取静态共享变量number的取值指令，</span></span><br><span class="line"><span class="comment">  即15: getstatic     #18   //Field number:I该指令；</span></span><br><span class="line"><span class="comment">  当前读取得到number的取值为0；那么读取之后就继续拿着对象锁obj往下进行执行；</span></span><br><span class="line"><span class="comment">  执行指令准备一个常量1即指令18: iconst_1</span></span><br><span class="line"><span class="comment">  准备一个常量1完成之后又接着往下继续执行；</span></span><br><span class="line"><span class="comment">  接着进行一个相加的操作即指令19: iadd的操作即指令15: getstatic当中获取得到静态共享变量number的取值0与18: iconst_1所准备的常量1进行相加得出运算结果为0+1=1；</span></span><br><span class="line"><span class="comment">  假设执行完该相加操作之后，即19: iadd操作完成之后CPU又切换到了第二个线程，即线程B；</span></span><br><span class="line"><span class="comment">  注意此时线程是在19: iadd执行之后但是在20: putstatic指令执行之前进行了CPU的切换，</span></span><br><span class="line"><span class="comment">  即共享变量并未被重新赋值之前只是得出了运算结果的时候进行了CPU切换到线程B上去了；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  第二个线程即线程B也是要来进行执行同步代码块synchronized()&#123;&#125;当中的代码；</span></span><br><span class="line"><span class="comment">  但是此时的这个对象锁obj已经被线程A锁获取得到了即线程A此时还并没有进行释放锁unlock的操作；所以导致尽管CPU切换到了线程B上但是由于线程A没有释放锁；</span></span><br><span class="line"><span class="comment">  线程B没有办法获取得到锁，</span></span><br><span class="line"><span class="comment">  就只能在synchronized同步代码块的外侧进行等待；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  那么CPU最终还是会切换到第一个线程即线程A上面来继续完成number++所对应的未完成的字节码指令的第四条指令即20: putstatic   #18   //Field number:I</span></span><br><span class="line"><span class="comment">  执行putstatic那么就会将19: iadd所运算得出的取值结果1赋值给静态共享变量number取值；</span></span><br><span class="line"><span class="comment">  最后线程A执行外字节码指令之后就会出同步代码块，</span></span><br><span class="line"><span class="comment">  就会将对象锁obj给还回去；</span></span><br><span class="line"><span class="comment">  那么此时CPU又切换回第二个线程，线程B当中上来了；</span></span><br><span class="line"><span class="comment">  线程B又来执行同步代码块synchronized()&#123;&#125;；</span></span><br><span class="line"><span class="comment">  这次就能够获取得到对像锁了；</span></span><br><span class="line"><span class="comment">  基于线程A完成了其在synchronized同步代码块当中的number++操作之后释放了锁，</span></span><br><span class="line"><span class="comment">  CPU又切换到了线程B上，</span></span><br><span class="line"><span class="comment">  所以此时线程B可以拿到获取得到对象锁obj；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  那么此时线程B也拿着对象锁obj进入同步代码块synchronized当中执行number++操作即所对应的4个字节码指令(getstatic、iconst_1、iadd、putstatic)；</span></span><br><span class="line"><span class="comment">  那么线程B先来进行执行number++操作的第一条字节码指令：15: getstatic    #18     // Field number:I 操作获取得到此时共享变量number的取值，</span></span><br><span class="line"><span class="comment">  那么此时线程B来获取共享变量number的取值时，</span></span><br><span class="line"><span class="comment">  共享变量number变量在之前的线程A当中的操作当中已经由0变为了1，</span></span><br><span class="line"><span class="comment">  所以此时线程B获取得到number共享变量的取值为1；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  接着执行number++操作的第二个字节码指令准备一个常量1即18: iconst_1操作；</span></span><br><span class="line"><span class="comment">  在往下继续执行number操作的第三个字节码指令19: iadd，即获取得到静态共享变量取值number为1 与 所准备的常量1进行相加得到运算结果 1+1=2；</span></span><br><span class="line"><span class="comment">  那么最后走到第四步进行执行20:putstatic   # 18   // Field number:I操作</span></span><br><span class="line"><span class="comment">  那么就会把从第三步字节码指令所运算得出的结果 2 赋值给共享变量number取值；</span></span><br><span class="line"><span class="comment">  那么此时静态共享变量的取值就由1更改为2了；</span></span><br><span class="line"><span class="comment">  这个时候可以看到两个线程进行执行number++操作；</span></span><br><span class="line"><span class="comment">  最终得到的number的结果为2；</span></span><br><span class="line"><span class="comment">  数据没有出现错乱；</span></span><br><span class="line"><span class="comment">  那么这里最根本的原因就是有了同步代码块之后；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  当第一个线程进来执行number++所对应的其四个字节码操作指令；</span></span><br><span class="line"><span class="comment">  执行到一半，就算CPU切换到了第二个线程进行执行相同的操作也会由于没有对象锁而无法进入同步代码块只能够在同步代码块外侧进行等待第一个线程释放锁第二个线程才能够获取锁从而进入同步代码块；</span></span><br><span class="line"><span class="comment">  所以也就能够保证第一个线程在执行number++所对应的四个字节码指令时，</span></span><br><span class="line"><span class="comment">  不会受到其他线程的干扰，</span></span><br><span class="line"><span class="comment">  从而也就保证了操作的原子性。</span></span><br><span class="line"><span class="comment">  所以数据才不会出现错乱。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>字节码指令：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">      frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">27</span></span><br><span class="line">    Exceptions:</span><br><span class="line">      thows java.lang.InterruptedException</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> static <span class="built_in">void</span> lambda$main$<span class="number">0</span>();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">          <span class="number">0</span>: iconst_0</span><br><span class="line">          <span class="number">1</span>: istore_0</span><br><span class="line">          <span class="number">2</span>: iload_0</span><br><span class="line">          <span class="number">3</span>: sipush          <span class="number">1000</span></span><br><span class="line">          <span class="number">6</span>: if_icmpge       <span class="number">39</span></span><br><span class="line">          <span class="number">9</span>: getstatic       #<span class="number">22</span>             <span class="comment">// Field obj:Ljava/lang/Object;</span></span><br><span class="line">         <span class="number">12</span>: dup</span><br><span class="line">         <span class="number">13</span>: astore_1</span><br><span class="line">         <span class="number">14</span>: monitorenter</span><br><span class="line">         <span class="number">15</span>: getstatic       #<span class="number">18</span>             <span class="comment">// Field number:I</span></span><br><span class="line">         <span class="number">18</span>: iconst_1</span><br><span class="line">         <span class="number">20</span>: putstatic       #<span class="number">18</span>             <span class="comment">// Field number:I</span></span><br><span class="line">         <span class="number">23</span>: aload_1</span><br><span class="line">         <span class="number">24</span>: monitorexit</span><br><span class="line">         <span class="number">25</span>: goto            <span class="number">33</span></span><br><span class="line">         <span class="number">28</span>: astore_2</span><br><span class="line">         <span class="number">29</span>: aload_1</span><br><span class="line">         <span class="number">30</span>: monitorexit</span><br><span class="line">         <span class="number">31</span>: aload_2</span><br><span class="line">         <span class="number">32</span>: athrow</span><br><span class="line">         <span class="number">33</span>: iinc            <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">         <span class="number">36</span>: goto</span><br><span class="line">         <span class="number">39</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">          <span class="keyword">from</span>     to     target   type</span><br><span class="line">            <span class="number">15</span>     <span class="number">25</span>         <span class="number">28</span>     any</span><br><span class="line">            <span class="number">28</span>     <span class="number">31</span>         <span class="number">28</span>     any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">19</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">15</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">23</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">33</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>number++操作依旧对应着这四条字节码指令</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>: getstatic         #<span class="number">18</span>       <span class="comment">// Field number:I</span></span><br><span class="line"><span class="number">18</span>: iconst_1</span><br><span class="line"><span class="number">19</span>: iadd</span><br><span class="line"><span class="number">20</span>: putstatic         #<span class="number">18</span>       <span class="comment">// Field number:I</span></span><br></pre></td></tr></table></figure><p>而此时包含着这四条字节码指令的还有<code>monitorenter</code>以及<code>monitorexit</code>这两条指令；即；</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>: monitorenter</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>: getstatic        #<span class="number">18</span>        <span class="comment">// Field number:I</span></span><br><span class="line"><span class="number">18</span>: iconst_1</span><br><span class="line"><span class="number">19</span>: iadd</span><br><span class="line"><span class="number">20</span>: putstatic        #<span class="number">18</span>        <span class="comment">// Field number:I</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">23</span>: aload_1</span><br><span class="line"><span class="number">24</span>: monitorexit</span><br></pre></td></tr></table></figure><h3 id="synchronized-保证原子性的原理"><a href="#synchronized-保证原子性的原理" class="headerlink" title="synchronized 保证原子性的原理"></a>synchronized 保证原子性的原理</h3><p>对 number++ ，增加同步代码块后，保证同一时间 只有 一个线程操作 number++; 就不会出现安全问题。</p><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>synchronized保证原子性的原理: synchronized保证只有一个线程拿到锁，能够进入同步代码块中，当第一个线程进入了同步代码块当中即使操作到了一半没有操作完由于CPU切换，切换到了其他线程，其他线程也会由于没有对象锁的缘故无法进入同步代码块当中只能进行等待；即其他线程不会来干扰第一个线程的操作；就能够保证同步代码块当中的代码是一个原子性的操作，不会受到其他线程的干扰；</p><p>synchronized 保证原子性的原理</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对 <span class="built_in">number</span>++; 增加同步代码块后，保证同一时间只有一个线程操作 <span class="built_in">number</span>++;</span><br></pre></td></tr></table></figure><h2 id="synchronized保证可见性"><a href="#synchronized保证可见性" class="headerlink" title="synchronized保证可见性"></a>synchronized保证可见性</h2><h3 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h3><p>学习使用 synchronized 保证可见性的原理</p><h3 id="使用synchronized保证可见性"><a href="#使用synchronized保证可见性" class="headerlink" title="使用synchronized保证可见性"></a>使用synchronized保证可见性</h3><p>案例演示： 一个线程根据 boolean类型的标记flag，while循环，另一个线程改变这个flag变量的值，根据boolean 类型的标记flag进行while循环的那个线程 并不会停止循环。</p><p>回顾之前的代码（<strong>可见性问题产生的原因</strong>）：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">    1. 创建一个共享变量</span></span><br><span class="line"><span class="comment">    2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">    3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test01Visibility&#123;</span><br><span class="line">  <span class="comment">// 1. 创建一个共享变量；</span></span><br><span class="line">  <span class="comment">// boolea布尔类型flag默认取值为true</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="comment">// 2. 创建一条线程不断读取共享变量；</span></span><br><span class="line">    <span class="comment">// 开启一条线程进行循环；</span></span><br><span class="line">    <span class="comment">// 如果flag变量一直为true则一直循环否则停止循环；</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">while</span>(flag)&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  </span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);<span class="comment">// 主线程沉睡两秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建一条线程修改共享变量flag取值为false</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      flag = <span class="keyword">false</span>;</span><br><span class="line">      System.out.<span class="keyword">println</span>(<span class="string">"线程修改了变量的值为false"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      之前的效果为；两秒之后进行打印了语句“线程修改了变量的值为false”；</span></span><br><span class="line"><span class="comment">      但是另外一个线程并没有获取得到最新值，</span></span><br><span class="line"><span class="comment">      也就是根据flag变量进行while循环的那个线程并没有获取得到最新flag取值从而也就导致这个线程一直在while(flag)/while(true)运行中；</span></span><br><span class="line"><span class="comment">      Run一直为红灯。</span></span><br><span class="line"><span class="comment">      接着来进行分析其原因以及如何来进行解决。</span></span><br><span class="line"><span class="comment">      为什么会出现可见性问题分析：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      首先Test01Visibility当中存在有一个成员变量flag取值为true；</span></span><br><span class="line"><span class="comment">      那么该成员变量是两个线程都会来进行操作的；</span></span><br><span class="line"><span class="comment">      线程A与线程B；</span></span><br><span class="line"><span class="comment">      线程A负责执行根据flag取值变化从而while循环的线程；</span></span><br><span class="line"><span class="comment">      线程B则是负责修改成员变量flag取值的线程；</span></span><br><span class="line"><span class="comment">      那么该成员变量位于主内存当中；即线程A与线程B的共享变量；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      红色的箭头代表主线程，主线程从main()开始执行；</span></span><br><span class="line"><span class="comment">      执行Test01Visibility当中mian()中的代码，创建线程A并启动线程A中的run();</span></span><br><span class="line"><span class="comment">      接着画一个新线程，该新线程用绿色箭头表示，表示的即为线程A，</span></span><br><span class="line"><span class="comment">      那么该A线程就会去进行执行while(flag)&#123;&#125;循环；</span></span><br><span class="line"><span class="comment">      当线程A进行执行的时候就需要用到共享变量flag的取值；</span></span><br><span class="line"><span class="comment">      而该共享变量位于主内存当中；</span></span><br><span class="line"><span class="comment">      那么这个时候线程A就会从主内存当中进行复制一份共享变量flag的取值boolean flag=true的副本放到线程A自己的工作内存当中来；</span></span><br><span class="line"><span class="comment">      那么当前进行循环这个flag为true那么也就会导致一直在进行循环的操作；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      主线程继续往下进行执行，Thread.sleep(2000);主线程沉睡两秒钟；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      那么当主线程沉睡完两秒之后，又会进行启动一个新的线程即线程B，也就是那个修改共享变量flag取值的那个线程；</span></span><br><span class="line"><span class="comment">      再画一个紫色的箭头来代表一个新的线程即线程B；</span></span><br><span class="line"><span class="comment">      那么线程B则对应着图中的右边的那块工作内存；</span></span><br><span class="line"><span class="comment">      那么线程B启动之后也是需要来进行执行线程B当中的run()当中的代码即修改共享变量flag的取值为false并打印输出日志；</span></span><br><span class="line"><span class="comment">      所以此时线程B需要做的是也是从主内存当中去进行读取复制拷贝获取得到一份共享变量flag的副本即boolean flag = true;到线程B自己的工作内存当中来；</span></span><br><span class="line"><span class="comment">      另外在线程B自己的工作内存当中对其共享变量副本进行相关操作即进行重新赋值为false；</span></span><br><span class="line"><span class="comment">      那么当线程B修改工作内存当中共享变量flag副本取值之后会将工作内存当中该共享变量副本的取值同步回主内存当中的共享变量取值；</span></span><br><span class="line"><span class="comment">      也就是主内存当中该共享变量flag取值就由true变为了false；</span></span><br><span class="line"><span class="comment">      那么接着线程B再去打印“线程修改了变量的值为false”信息；</span></span><br><span class="line"><span class="comment">      那么该线程B执行至此就结束了。</span></span><br><span class="line"><span class="comment">      那么可以看到的是线程B所进行修改线程B自己工作内存当中的共享变量副本flag的取值为false并且同步回到了主内存当中去了；</span></span><br><span class="line"><span class="comment">      那么此时的线程A并不知道主内存当中共享变量flag的取值被更改了，线程A依然在进行循环操作；</span></span><br><span class="line"><span class="comment">      即while(true)的循环操作；</span></span><br><span class="line"><span class="comment">      线程A使用到的共享变量依然还是线程A自己工作内存当中之前从主内存中复制拷贝过来的flag共享变量也就是那个flag=true那个时候的取值；</span></span><br><span class="line"><span class="comment">      所以线程A就一直循环一直循环根本停不下来；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      那么造成这种现象的原因就是因为：</span></span><br><span class="line"><span class="comment">      一个线程进行修改了共享变量副本的取值并且同步回了主内存当中；</span></span><br><span class="line"><span class="comment">      第二个线程即根据该共享变量副本的取值做while循环的线程并没有感知到主内存当中共享变量取值发生的变化，</span></span><br><span class="line"><span class="comment">      因为第二个线程当中使用的共享变量副本的取值并没有随着一同主内存当中的共享变量取值改变；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      那么解决方案有两种；先简单介绍下；有一个关键字叫做volatile；</span></span><br><span class="line"><span class="comment">      用该关键字volatile来进行修饰共享变量就可以解决可见性问题；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<strong>volatile</strong>关键字来进行解决可见性问题</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">    1. 创建一个共享变量</span></span><br><span class="line"><span class="comment">    2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">    3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Visibility</span>&#123;</span></span><br><span class="line">  <span class="comment">// 1. 创建一个共享变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">// 2. 创建一条线程不断读取共享变量</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">while</span>(flag)&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);<span class="comment">//主线程沉睡两秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      flag =  <span class="literal">false</span>;</span><br><span class="line">      System.out.<span class="built_in">println</span>(<span class="string">"线程修改了变量的值为false"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    那么此时就需要进行分析 volatile关键字是如何进行解决可见性问题的?</span></span><br><span class="line"><span class="comment">    简单介绍下；</span></span><br><span class="line"><span class="comment">    当共享变量flag添加了 volatile关键字之后，线程B进行修改了共享变量flag副本取值为false之后同步回主内存时；由于volatile关键字的修饰，会有一个缓存一致性协议；会把其他线程当中的工作内存中的该共享变量flag的副本全部进行设置为失效状态；那么这个时候其他线程由于线程自己内部工作内存中需要用到的共享变量flag数据失效的缘故就会重新到主内存当中来进行读取最新的共享变量取值；这是采用volatile的规则；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    那么现在不使用volatile，使用synchronized也可以解决这个可见性问题；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <strong>synchronized</strong> 关键字来进行解决可见性问题</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo02_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    案例演示：</span></span><br><span class="line"><span class="comment">      一个线程根据 boolean 类型的标记flag，while循环，另一个线程改变这个flag变量的值，</span></span><br><span class="line"><span class="comment">      根据boolean 类型的标记flag进行while循环的那个线程 并不会停止循环。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Visibility</span> &#123;</span></span><br><span class="line">    <span class="comment">// 多个线程都会访问的数据，我们称为 线程的共享变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="built_in">run</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException</span>&#123;</span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">run</span>)&#123;</span><br><span class="line">          <span class="comment">//增加对象共享数据的打印，println是同步方法</span></span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="string">"run = "</span> + <span class="built_in">run</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      t1.start();</span><br><span class="line"></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">      Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="built_in">run</span> = <span class="literal">false</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"时间到，线程2设置为 false"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">    1. 创建一个共享变量</span></span><br><span class="line"><span class="comment">    2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">    3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test01Visibility</span>&#123;</span></span><br><span class="line">  <span class="regexp">// 1. 创建一个共享变量</span></span><br><span class="line"><span class="regexp">  private static boolean flag = true;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  private static Object obj =  new Object();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  public static void main(String[] args) throws InterruptedException&#123;</span></span><br><span class="line"><span class="regexp">    //</span> <span class="number">2.</span> 创建一条线程不断读取共享变量</span><br><span class="line">    <span class="keyword">new</span> Tread<span class="function"><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">while</span>(flag)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        synchronized(obj)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">2000</span>)</span>;// 主线程沉睡两秒</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="function">    <span class="title">new</span> <span class="title">Thread</span><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      flag = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">      System.out.println(<span class="string">"线程修改了变量的值为false"</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span>;</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  /**</span></span><br><span class="line"><span class="function">  分析<span class="title">synchronized</span>是如何进行解决的可见性问题？</span></span><br><span class="line"><span class="function">  那么<span class="title">synchronized</span>关键字其实会变成8个原子操作当中的<span class="title">lock</span>与<span class="title">unlock</span>原子操作；</span></span><br><span class="line"><span class="function">  即8个原子操作<span class="params">(主内存与工作内存之间具体的交互协议)</span>为</span></span><br><span class="line"><span class="function">  <span class="title">lock</span> --→<span class="title">read</span> --→ <span class="title">load</span>--→ <span class="title">use</span>--→ <span class="title">assign</span>--→ <span class="title">store</span>--→ <span class="title">write</span>--→ <span class="title">unlock</span>  </span></span><br><span class="line"><span class="function">  那么这个<span class="title">lock</span>原子操作之前就会让线程<span class="title">A</span>当中的工作内存进行去刷新，</span></span><br><span class="line"><span class="function">  也就是如果线程<span class="title">A</span>中存在有该共享变量的副本会被清除，</span></span><br><span class="line"><span class="function">  然后再去获取最新的共享变量<span class="title">flag</span>取值；</span></span><br><span class="line"><span class="function">  也就可以得到最新的<span class="title">false</span>取值；</span></span><br><span class="line"><span class="function">  由线程<span class="title">B</span>进行修改共享变量副本并同步回主内存后的那个最新值；</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  所以这个时候的效果就是线程<span class="title">A</span>当中由于接收到了主内存当中共享变量最新取值的副本<span class="title">flag</span>=<span class="title">false</span>;所以就会不再执行<span class="title">while</span>循环；</span></span><br><span class="line"><span class="function">  另外可以不用进行写 <span class="title">synchronized</span><span class="params">(obj)</span>&#123;&#125; ；</span></span><br><span class="line"><span class="function">  可以直接进行打印也是可以做到解决可见性问题的 <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(flag)</span>;</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  而分析下为什么通过打印语句<span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(flag)</span>;也可以使得<span class="title">while</span>循环停下来呢？</span></span><br><span class="line"><span class="function">  原因在于<span class="title">PrintStream</span>.<span class="title">java</span>中的<span class="title">println</span><span class="params">(boolean x)</span>方法中也使用到了<span class="title">synchronized</span>，</span></span><br><span class="line"><span class="function">  所以也就导致也会去刷新线程<span class="title">A</span>当中工作内存当中的变量从而去获取主内存当中最新的共享变量的取值：</span></span><br><span class="line"><span class="function">  -------------------------------------------------------------------</span></span><br><span class="line"><span class="function">  /**</span></span><br><span class="line"><span class="function">    <span class="title">Prints</span> <span class="title">a</span> <span class="title">boolean</span> <span class="title">and</span> <span class="title">then</span> <span class="title">terminate</span> <span class="title">the</span> <span class="title">line</span>.</span></span><br><span class="line"><span class="function">    <span class="title">This</span> <span class="title">method</span> <span class="title">behaves</span> <span class="title">as</span> <span class="title">though</span> <span class="title">it</span> <span class="title">invokes</span></span></span><br><span class="line"><span class="function">    &lt;<span class="title">code</span>&gt;&#123;@<span class="title">link</span> #<span class="title">print</span><span class="params">(boolean)</span>&#125;&lt;/<span class="title">code</span>&gt; <span class="title">and</span> <span class="title">then</span></span></span><br><span class="line"><span class="function">    &lt;<span class="title">code</span>&gt;&#123;@<span class="title">link</span> #<span class="title">println</span><span class="params">()</span>&#125;&lt;/<span class="title">code</span>&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    @<span class="title">param</span> <span class="title">x</span> <span class="title">The</span> &lt;<span class="title">code</span>&gt;<span class="title">boolean</span>&lt;/<span class="title">code</span>&gt; <span class="title">to</span> <span class="title">be</span> <span class="title">printed</span></span></span><br><span class="line"><span class="function">  */</span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">void</span> <span class="title">println</span><span class="params">(boolean x)</span>&#123;</span></span><br><span class="line"><span class="function">    <span class="title">synchronized</span><span class="params">(<span class="keyword">this</span>)</span>&#123;</span></span><br><span class="line"><span class="function">      <span class="title">print</span><span class="params">(x)</span>;</span></span><br><span class="line"><span class="function">      <span class="title">newLine</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  -------------------------------------------------------------------</span></span><br><span class="line"><span class="function">  */</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="synchronized-保证可见性的原理"><a href="#synchronized-保证可见性的原理" class="headerlink" title="synchronized 保证可见性的原理"></a>synchronized 保证可见性的原理</h3><p>synchronized同步的时候会对应8个原子操作当中的lock与unlock这两个原子操作；<br>那么lock操作执行时回去刷新该线程工作内存当中共享变量的取值；<br>从而该线程就会去主内存中去获取得到最新的值；<br>也就是说synchronized会刷新工作内存中的变量得到主内存中最新共享变量取值的副本；<br>从而保证可见性；</p><h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p>synchronized保证可见性的原理</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行<span class="keyword">synchronized</span>时，其对应的lock原子操作会刷新工作内存中共享变量的值</span><br></pre></td></tr></table></figure><h2 id="synchronized保证有序性"><a href="#synchronized保证有序性" class="headerlink" title="synchronized保证有序性"></a>synchronized保证有序性</h2><p>synchronized 与 有序性</p><h3 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h3><p>学习使用 synchronized 保证有序性的原理</p><h3 id="为什么要重排序"><a href="#为什么要重排序" class="headerlink" title="为什么要重排序"></a>为什么要重排序</h3><p>为了提高程序的执行效率，有可能所写的代码对CPU来说其执行效率并不高；<br>它可能经过重排序之后执行的效率更高一点；所以编译器和CPU会对程序中的代码进行重排序；（编译器和CPU不会进行乱排，会满足某种规则；所以就有一个<strong>as-if-serial语义</strong>）</p><p>重排序 是指 编译器 和 处理器 为了优化程序性能 而对 指令序列 进行 重新排序 的一种手段。  </p><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>as-if-serial 语义的意思是：</p><p>（不管编译器和CPU如何重排序。必须保证在单线程情况下程序的结果是正确的；那么在多线程的情况下就有可能是有问题存在问题的）<br>不管怎么 重排序（编译器和处理器 为了提高 并行度），单线程程序的执行结果不能被改变。<br>编译器、runtime和处理器 都必须遵守 as-if-serial 语义。</p><p>以下数据有依赖关系，不能 重排序。</p><p>写后读：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int <span class="keyword">a</span> = <span class="number">1</span>; <span class="comment"># 对一个变量进行写操作</span></span><br><span class="line">int b = <span class="keyword">a</span>; <span class="comment"># 在对一个变量写操作完成之后又将该变量的取值读取出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么在这种情况下是不能够进行重排序的；</span></span><br><span class="line"><span class="comment"># 即不能够换成</span></span><br><span class="line"><span class="comment"># int b = a;</span></span><br><span class="line"><span class="comment"># int a = 1;</span></span><br><span class="line"><span class="comment"># 那么在执行 int b = a;的时候，a是没有取值的；</span></span><br></pre></td></tr></table></figure><p>写后写：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; # 先给变量a进行赋值操作即写操作；</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>; # 再来给变量a进行赋值操作即写操作；</span><br><span class="line"></span><br><span class="line"><span class="meta"># 那么在这种情况下也是不能够进行重排序的；</span></span><br><span class="line"><span class="meta"># 即不能够换成</span></span><br><span class="line"><span class="meta"># int a = 2;</span></span><br><span class="line"><span class="meta"># int a = 1;</span></span><br><span class="line"><span class="meta"># 的这样一种情况，</span></span><br><span class="line"><span class="meta"># 因为在执行原来没有重排序的代码时最终获取得到a变量的结果为2；</span></span><br><span class="line"><span class="meta"># 而经过重排序之后a变量的取值被重新赋值为了1；</span></span><br><span class="line"><span class="meta"># 导致数据最终结果的不正确性；</span></span><br><span class="line"><span class="meta"># 所以在这种情况下也是不能够进行重排序；</span></span><br></pre></td></tr></table></figure><p>读后写：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; # 给变量a进行赋值写操作</span><br><span class="line"><span class="keyword">int</span> b = a; # 将变量a的取值进行读取出来</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>; # 再将变量a的取值进行重新赋值</span><br><span class="line"></span><br><span class="line"><span class="meta"># 这种情况下也是不能够进行重排序的；</span></span><br><span class="line"><span class="meta"># 即不能够换成</span></span><br><span class="line"><span class="meta"># int a = 1;</span></span><br><span class="line"><span class="meta"># int a = 2;</span></span><br><span class="line"><span class="meta"># int b = a;</span></span><br><span class="line"><span class="meta"># 这样一种顺序；</span></span><br><span class="line"><span class="meta"># 如果是这样排序的话；将会导致变量b取值的变化；</span></span><br><span class="line"><span class="meta"># 在原来没有进行重排序的时候变量b原本正确赋有的值应该是1；</span></span><br><span class="line"><span class="meta"># 而当重新排序之后变量b的取值发生了改变，即变成了2；</span></span><br><span class="line"><span class="meta"># 同样是导致了数据的最终不正确性；</span></span><br><span class="line"><span class="meta"># 所以在这种情况下也是不能够进行重排序的；</span></span><br></pre></td></tr></table></figure><p>编译器 和 处理器不会对 存在数据依赖关系的 操作 做重排序，<br>因为这种 重排序 会改变执行结果。</p><p>但是，如果操作之间 不存在数据依赖关系，这些操作就可能被 编译器和处理器 重排序。</p><p>（在有些时候是可以进行重排序的；只要没有影响到单线程执行运行结果的正确性；比如说下面这种情况就是可以进行重排序的；即int a =1;int b=2;这两句代码是可以进行互换位置的；彼此互不影响；即int b = 2; int a=1;但是int c =a +b;一定要处于最下面；否则不能得到变量a与变量b的取值；）</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int a</span> = 1;</span><br><span class="line"><span class="attribute">int b</span> = 2;</span><br><span class="line"><span class="attribute">int c</span> = a + b;</span><br></pre></td></tr></table></figure><p>上面3个操作的数据依赖关系如图所示：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line">                                  ---------</span><br><span class="line">-------                            |<span class="string">     </span>|</span><br><span class="line">|<span class="string">  a  </span>|<span class="string">---------------------------→</span>|<span class="string">     </span>|</span><br><span class="line">-------                            |<span class="string">     </span>|</span><br><span class="line">                                   |<span class="string">  c  </span>|</span><br><span class="line">-------                            |<span class="string">     </span>|</span><br><span class="line">|<span class="string">  b  </span>|<span class="string">---------------------------→</span>|<span class="string">     </span>|</span><br><span class="line">-------                            |<span class="string">     </span>|</span><br><span class="line">                                  ---------</span><br><span class="line">-------------------------------------------</span><br><span class="line">/<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">即 变量c 依赖 变量a与变量b 的取值；</span><br><span class="line">但是 变量a 与 变量b 并没有直接的依赖关系；</span><br><span class="line">所以这种情况下是可以进行重排序的；</span><br><span class="line"><span class="symbol">*</span>/</span><br></pre></td></tr></table></figure><p>如上图所示 a和c 之间存在数据依赖关系，<br>同时 b和c 之间也存在数据依赖关系。<br>因此在最终执行的指令序列中，<br>c 不能被重排序到 a和b 的前面。<br>但 a和b 之间没有数据依赖关系，<br>编译器和处理器 可以重排序 a和b 之间的执行顺序。<br>下图是该程序的两种执行顺序。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="comment">|</span>  <span class="comment">a</span>  <span class="comment">|</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">→|</span>  <span class="comment">b</span>  <span class="comment">|</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">→|</span>  <span class="comment">c</span>  <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="comment">|</span>  <span class="comment">b</span>  <span class="comment">|</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">→|</span>  <span class="comment">a</span>  <span class="comment">|</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">→|</span>  <span class="comment">c</span>  <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">可以这样：</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">a</span> <span class="comment">=</span> <span class="comment">1;</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">b</span> <span class="comment">=</span> <span class="comment">2;</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">c</span> <span class="comment">=</span> <span class="comment">a</span> <span class="literal">+</span> <span class="comment">b;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">也可可以重排序这样：</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">b</span> <span class="comment">=</span> <span class="comment">2;</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">a</span> <span class="comment">=</span> <span class="comment">1;</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">c</span> <span class="comment">=</span> <span class="comment">a</span> <span class="literal">+</span> <span class="comment">b;</span></span><br></pre></td></tr></table></figure><h3 id="使用synchronized保证有序性"><a href="#使用synchronized保证有序性" class="headerlink" title="使用synchronized保证有序性"></a>使用synchronized保证有序性</h3><p>Test03Ordering.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.results.I_Result;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"1"</span>, <span class="string">"4"</span>&#125;, expect = Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>)</span><br><span class="line"><span class="meta">@OUtcome</span>(id = <span class="string">"0"</span>, expect =  Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger"</span>)</span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 线程一 执行的代码</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">      r.r1 = num + num;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程二 执行的代码</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾代码分析有序性问题产生的原因</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome</span>( id = &#123;<span class="string">"1"</span>, <span class="string">"4"</span>&#125;, expect =  Expect.ACCEPTABLE, desc=<span class="string">"ok"</span>)</span><br><span class="line"><span class="meta">@Outcome</span>( id = <span class="string">"0"</span>, expect =  Expect.ACCEPTABLE_INTERESTING, desc=<span class="string">"danger"</span>)</span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程一 执行的代码</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">      r.r1 = num + num;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//线程二 执行的代码</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  以前会观察得到4种可能性；3种结果为0,1,4</span></span><br><span class="line"><span class="comment">  分析回顾下：</span></span><br><span class="line"><span class="comment">  假设有两个线程在执行；分别是线程A与线程B；</span></span><br><span class="line"><span class="comment">  线程A执行actor1(I_Result r)；线程B执行actor2(I_Result r)；</span></span><br><span class="line"><span class="comment">  当初出现0的结果是这样来的：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  是actor2(I_Result r)当中的代码</span></span><br><span class="line"><span class="comment">  num = 2;</span></span><br><span class="line"><span class="comment">  ready = true;</span></span><br><span class="line"><span class="comment">  经过了重排序变成了</span></span><br><span class="line"><span class="comment">  ready = true;</span></span><br><span class="line"><span class="comment">  num = 2;</span></span><br><span class="line"><span class="comment">  的一个顺序；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  假设下面的这个线程，也就是执行actor2(I_Result r)的线程B先走；</span></span><br><span class="line"><span class="comment">  那么走了第一句也就是执行了第一句ready=true该句话；</span></span><br><span class="line"><span class="comment">  但是注意并没有执行num=2;</span></span><br><span class="line"><span class="comment">  所以此时共享变量当中的num仍然为0；而ready为true;</span></span><br><span class="line"><span class="comment">  然后此时CPU切换线程到了第二个线程当中来了；</span></span><br><span class="line"><span class="comment">  那么这个时候线程A进行执行actor1(I_Result r)方法；</span></span><br><span class="line"><span class="comment">  那么这个时候线程A就会进入到判断if(ready)&#123;&#125;代码块中；</span></span><br><span class="line"><span class="comment">  因为此时获取得到的ready变量已经由线程B在actor2(I_Result r)中进行了修改取值；</span></span><br><span class="line"><span class="comment">  所以也就会得到 r.r1 = num + num;</span></span><br><span class="line"><span class="comment">  而此时的num并未被重新赋值也就是说此时的num依旧是取值为0；</span></span><br><span class="line"><span class="comment">  所以得到结果记录 r.r1 为0；</span></span><br><span class="line"><span class="comment">  那么这是之前出现的有序性问题分析；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  那么现在来进行添加synchronized来解决有序性问题；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>synchronized关键字解决有序性问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"1"</span> , <span class="string">"4"</span>&#125;, expect = Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>)</span><br><span class="line"><span class="meta">@Outcome</span>(id = <span class="string">"0"</span>, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger"</span>)</span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 先搞一个对象作为对象锁</span></span><br><span class="line">  <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> ready = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程一 执行的代码</span></span><br><span class="line">  <span class="comment">// 测试方法actor1(I_Result r)进行添加synchronized</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">       <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">         r.r1 = num + num;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         r.r1 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程二 执行的代码</span></span><br><span class="line">  <span class="comment">// 下面的测试方法actor2(I_Result r)同样进行添加synchronized</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">     num = <span class="number">2</span>;</span><br><span class="line">     ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>压力测试指令以及结果查看</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">Terminal执行指令(进行多轮压力测试)：</span><br><span class="line"></span><br><span class="line">C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; mvn clean install</span><br><span class="line">C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; java -jar target/jcstress.jar</span><br><span class="line"></span><br><span class="line">测试结果打印：</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">    [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">(ETA:  <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>) (Rate: <span class="number">4.15E+07</span> samples/sec) (Tests: <span class="number">1</span> of <span class="number">1</span>) (Forks: <span class="number">4</span> of <span class="number">4</span>) (Iterations: <span class="number">15</span> of <span class="number">24</span>; <span class="number">15</span> passed, <span class="number">0</span> failed, <span class="number">0</span> soft errs, <span class="number">0</span> hard....)</span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">(ETA:  <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>) (Rate: <span class="number">3.97E+07</span> samples/sec) (Tests: <span class="number">1</span> of <span class="number">1</span>) (Forks: <span class="number">4</span> of <span class="number">4</span>) (Iterations: <span class="number">15</span> of <span class="number">24</span>; <span class="number">15</span> passed, <span class="number">0</span> failed, <span class="number">0</span> soft errs, <span class="number">0</span> hard....)</span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">(ETA:  <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>) (Rate: <span class="number">3.53E+07</span> samples/sec) (Tests: <span class="number">1</span> of <span class="number">1</span>) (Forks: <span class="number">4</span> of <span class="number">4</span>) (Iterations: <span class="number">15</span> of <span class="number">24</span>; <span class="number">15</span> passed, <span class="number">0</span> failed, <span class="number">0</span> soft errs, <span class="number">0</span> hard....)</span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">(ETA:  <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>) (Rate: <span class="number">3.83E+07</span> samples/sec) (Tests: <span class="number">1</span> of <span class="number">1</span>) (Forks: <span class="number">4</span> of <span class="number">4</span>) (Iterations: <span class="number">15</span> of <span class="number">24</span>; <span class="number">15</span> passed, <span class="number">0</span> failed, <span class="number">0</span> soft errs, <span class="number">0</span> hard....)</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">结果分析：</span><br><span class="line">  发现并没有出现那几种结果出现的次数；</span><br><span class="line">  说明这个代码就没有问题；即没有出现这种<span class="number">0</span>的情况；</span><br><span class="line">  如果真的想看的话；可以这么做；</span><br><span class="line">  假设将取值为<span class="number">4</span>也变为感兴趣的则重新来进行压力测试</span><br><span class="line"></span><br><span class="line">@JCStressTest</span><br><span class="line">@Outcome(id = <span class="string">"1"</span>, expect = Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>)</span><br><span class="line">@Outcome(id = <span class="string">"4"</span>, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger2"</span>)</span><br><span class="line">@Outcome(id = <span class="string">"0"</span>, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger"</span>)</span><br><span class="line">@State</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">Terminal执行指令(进行多轮压力测试)：</span><br><span class="line"></span><br><span class="line">C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; mvn clean install</span><br><span class="line">C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; java -jar target/jcstress.jar</span><br><span class="line"></span><br><span class="line">测试结果打印：</span><br><span class="line">      [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">    (JVM args: [-XX:TieredStopAtLevel=<span class="number">1</span>])</span><br><span class="line">Observed state Occurrences         Expectation     Interpretation</span><br><span class="line">             <span class="number">0</span>       <span class="number">0</span>      ACCEPTABLE_INTERESTING  danger</span><br><span class="line">             <span class="number">1</span>   <span class="number">5</span>,<span class="number">427</span>,<span class="number">079</span>          ACCEPTABLE      ok</span><br><span class="line">             <span class="number">4</span>   <span class="number">5</span>,<span class="number">672</span>,<span class="number">602</span>  ACCEPTABLE_INTERESTING  danger2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_probleam.Test03Ordering</span><br><span class="line">  （JVM args: []）</span><br><span class="line">Observed state Occurrences         Expectation     Interpretation</span><br><span class="line">             <span class="number">0</span>       <span class="number">0</span>      ACCEPTABLE_INTERESTING  danger</span><br><span class="line">             <span class="number">1</span>  <span class="number">42</span>,<span class="number">176</span>,<span class="number">771</span>          ACCEPTABLE      ok</span><br><span class="line">             <span class="number">4</span>  <span class="number">26</span>,<span class="number">991</span>,<span class="number">710</span>  ACCEPTABLE_INTERESTING  danger2</span><br><span class="line">....</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">结果分析：</span><br><span class="line">  此时可以看到的是出现<span class="number">0</span>的此时已经为<span class="number">0</span>了；</span><br><span class="line">  即都不会再出现<span class="number">0</span>了也就表示有序性问题得到了解决；</span><br><span class="line"></span><br><span class="line">分析synchronized是如何进行解决有序性问题的？</span><br><span class="line">当前假设actor2(I_Result r)当中的代码已经出现了重排序，</span><br><span class="line">即</span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line">变为了</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line">这样一个顺序；</span><br><span class="line"></span><br><span class="line">其实会产生很多的线程来执行actor1(I_Result r)与actor2(I_Result r)方法；</span><br><span class="line">那么这个时候举例各有一个线程A、B来分别进行执行actor1(I_Result r)与actor2(I_Result r)；</span><br><span class="line">那么还是一样假设下面的线程先走，即线程B先来执行代码块actor2(I_Result r)当中的同步代码块；</span><br><span class="line">那么线程B就会拿着对象锁Object obj进入actor2(I_Result r)的同步代码块当中执行已经重排序过了的代码即；</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line">那么拿着对象锁obj的线程B就先会去执行ready=<span class="literal">true</span>该句代码；</span><br><span class="line">那么假设此时CPU又切换到另外一个线程上面去了，</span><br><span class="line">注意是在线程B执行ready=<span class="literal">true</span>;之后但是并没有执行num=<span class="number">2</span>该句代码之前进行了CPU切换；</span><br><span class="line">也就是说当前的共享变量当中num取值仍然为<span class="number">0</span>；但是ready的取值已经变为了<span class="literal">true</span>；</span><br><span class="line">即切换到线程A上去执行actor1(I_Result r)方法当中的同步代码块了；</span><br><span class="line">那么到actor1(I_Result r)当中来看，</span><br><span class="line">线程A如果想要进入同步代码块则首先需要去获取拿到对象锁Object obj；</span><br><span class="line">但是该对象锁Object obj现在仍然在线程B当中，</span><br><span class="line">即线程B获取拿到对象锁obj之后还没有释放锁没有执行完成，</span><br><span class="line">CPU就切换到了线程A上了，</span><br><span class="line">导致线程A没有办法拿到获取对象锁Object obj，</span><br><span class="line">从而只能够在同步代码块外侧进行等待；</span><br><span class="line"></span><br><span class="line">等待CPU又切换到线程B上，让线程B执行完流程后释放锁；</span><br><span class="line">这个时候CPU再切换到线程B上时，没有其它线程竞争的话，</span><br><span class="line">那么这个时候线程B就能够获取得到对象锁从而进入同步代码块当中；</span><br><span class="line"></span><br><span class="line">所以来看，即使actor2(I_Result r)当中的代码发生了重排序，也没有问题了；</span><br><span class="line">接着CPU又切换到线程B上来执行actor2(I_Result r)没有执行完成的内容；</span><br><span class="line">即执行num = <span class="number">2</span>; 那么这个时候此时的共享变量 num被更新赋值为<span class="number">2</span>，以及ready取值为<span class="literal">true</span>；</span><br><span class="line">最后线程B出同步代码块，出了同步代码块之后线程B才会将对象锁Object obj还回去。</span><br><span class="line"></span><br><span class="line">假设线程B当前已经执行完成出了同步代码块也已经释放了锁，</span><br><span class="line">此时CPU再次切换到线程A上，</span><br><span class="line">那么这个时候线程A就可以能够获取得到对象锁Object obj了；</span><br><span class="line">那么得到对象锁之后就可以进入到同步代码块中了；</span><br><span class="line">通过判断ready取值进入<span class="keyword">if</span>/<span class="keyword">else</span>块；</span><br><span class="line">由于共享变量ready以及num在线程B的actor2(I_Result r)中被进行了修改；</span><br><span class="line">当前线程A读取到变量ready取值为<span class="literal">true</span>；num取值为<span class="number">2</span>；</span><br><span class="line">所以此时线程A就将会拿着对象锁Object obj 进入到<span class="keyword">if</span>(ready)块当中去；</span><br><span class="line">I_Result r.r1将会被重新赋值为 <span class="number">2</span>+<span class="number">2</span>=<span class="number">4</span>；</span><br><span class="line">所以此时的一个记录结果为<span class="number">4</span>；</span><br><span class="line">现在可以观察到的是：</span><br><span class="line">尽管加了同步代码块synchronized，</span><br><span class="line">但是actor2(I_Result r)当中依然会发生重排序；</span><br><span class="line">但是发生了重排序也没有问题；</span><br><span class="line">因为actor1(I_Result r)与actor2(I_Result r)都添加了同步代码块synchronized，</span><br><span class="line">保证只有一个线程来进行执行；</span><br><span class="line">就算actor2(I_Result r)中线程B执行到ready=<span class="literal">true</span>之后CPU又切换到线程A上面去了；那么线程A将由于无法获取得到对象锁Object obj也无法进入同步代码块当中去；由于线程B没有执行完成，即没有释放锁；所以线程A只能够进行等待；</span><br><span class="line">那么也就相当于是单线程在执行这些代码；</span><br><span class="line">那么重排序是能够保证单线程的执行效果没有问题；</span><br></pre></td></tr></table></figure><h3 id="synchronized-保证有序性的原理"><a href="#synchronized-保证有序性的原理" class="headerlink" title="synchronized 保证有序性的原理"></a>synchronized 保证有序性的原理</h3><p>synchronized后，虽然进行了重排序，保证只有一个线程会进入同步代码块，也能保证有序性。</p><h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><p>synchronized保证有序性的原理：加synchronized，依然会发生重排序，只不过，存在有同步代码块，可以保证只有一个线程执行同步代码块当中的代码。<br>也就能保证有序性。</p><p>有序性除了可以使用synchronized来进行解决，还能够进行给 共享变量num以及ready变量进行添加volatile关键字来进行解决有序性问题。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  添加了volatile关键字之后，</span></span><br><span class="line"><span class="comment">  可以保证共享变量num以及ready变量不会发生重排序；</span></span><br><span class="line"><span class="comment">  也就不会发生有序性问题了；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span> Object obj =  <span class="keyword">new</span> Object();<span class="comment">//对象锁</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> <span class="built_in">ready</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程一 执行的代码</span></span><br><span class="line">  @Actor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ready</span>)&#123;</span><br><span class="line">      r.r1 = num + num;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程二 执行的代码</span></span><br><span class="line">  @Actor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">ready</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized的可重入特性"><a href="#synchronized的可重入特性" class="headerlink" title="synchronized的可重入特性"></a>synchronized的可重入特性</h2><p>第四章：synchronized的特性</p><blockquote><p>synchronized属于同步锁机制，<br>第四章介绍synchronized作为锁的两个特性：<br>1、 可重入性（当一个线程执行到同步代码块，获取了某一个锁之后，还能够再次进入同步代码块当中，获取同样的一把锁，这个是可以的，可以重新再次进入，将分析其原理以及其可重入性的好处）；<br>2、不可中断性（synchronized是不可中断的：当一个线程进入了同步代码块，那么另外一个线程只能够在外面进行等待，这个处于等待的线程会一直处于等待状态，不会中断，所以也就叫做不可中断；<br>另外还会通过ReentrantLock的代码来进行演示ReentrantLock是可以进行中断的）</p></blockquote><p>可重入特性</p><p>synchronized作为锁，具有两个特性；<br>一个是 可重入性；一个是不可中断性；</p><h3 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a>目标</h3><p>了解什么是可重入<br>了解可重入的原理</p><h3 id="什么是可重入"><a href="#什么是可重入" class="headerlink" title="什么是可重入"></a>什么是可重入</h3><p>指的是 同一个线程的 可以多次获得 同一把锁。<br>（一个线程可以多次执行synchronized，重复获取同一把锁；）</p><p>(当一个线程执行到同步代码块获取到某一个锁之后，还能再次进入同步代码块，获取同样的一把锁，这是可以的，可以重新再进入)</p><h3 id="演示可重入特性"><a href="#演示可重入特性" class="headerlink" title="演示可重入特性"></a>演示可重入特性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  可重入特性</span></span><br><span class="line"><span class="comment">    指的是 同一个线程获得锁之后，可以直接再次获取该锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Runnable sellTicket =  <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(Demo01<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是run"</span>);</span><br><span class="line">            test01();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(Demo01<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是test01"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Thread(sellTicket).start();</span><br><span class="line">      <span class="keyword">new</span> Thread(sellTicket).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>演示</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：演示synchronized可重入</span></span><br><span class="line"><span class="comment">    1. 自定义一个线程类</span></span><br><span class="line"><span class="comment">    2. 在线程类的run方法中使用 嵌套的代码同步块</span></span><br><span class="line"><span class="comment">    3. 使用两个线程来执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span></span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">MyThread</span>().start();</span><br><span class="line">      <span class="keyword">new</span> <span class="type">MyThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 自定义一个线程类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  如果一个线程能够获取得到MyThread.class这把锁从而进入同步代码块1并打印；</span></span><br><span class="line"><span class="comment">  还依然能够拿着相同的一把锁再次进入同步代码块2，</span></span><br><span class="line"><span class="comment">  这就说明synchronized是可重入的；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  public void run()&#123;</span><br><span class="line">    synchronized(<span class="type">MyThread</span><span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">      <span class="type">System</span>.out.println(getName() + <span class="string">"进入了同步代码块1"</span>);</span><br><span class="line"></span><br><span class="line">      synchronized(<span class="type">MyThread</span><span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">         <span class="type">System</span>.out.println(getName() + <span class="string">"进入了同步代码块2"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果并分析synchronized可重入性执行流程</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">结果:</span><br><span class="line">Thread-<span class="number">0</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">-------------------------</span><br><span class="line"></span><br><span class="line">先画一个红色的箭头代表主线程；</span><br><span class="line">主线程从main<span class="literal">()</span>方法开始执行；</span><br><span class="line">那么就会启动两个线程即<span class="keyword">new</span> <span class="constructor">MyThread()</span>.start<span class="literal">()</span><span class="operator"> * </span><span class="number">2</span>；</span><br><span class="line">那么画两个箭头，一个绿色的箭头一个紫色的箭头即分别代表A线程与B线程；</span><br><span class="line">那么这两个线程A、B会来进行执行MyThread当中实现的run<span class="literal">()</span>方法；</span><br><span class="line">假设线程A先执行；</span><br><span class="line">那么线程A会获取得到锁<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>从而能够进入代码块当中；</span><br><span class="line">那么这个锁对象<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中存在一个计数器，</span><br><span class="line">该锁对象<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中的计数器会记录自己被获取了几次，</span><br><span class="line">那么当前是线程A第一次获取得到该锁<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>；即计数器取值加<span class="number">1</span>；</span><br><span class="line">那么线程A进入到同步代码块<span class="number">1</span>当中即会进行打印 线程名+<span class="string">"进入了同步代码块1"</span>信息；</span><br><span class="line">接着该线程A继续往下进行执行发现又是一个同步代码块，且还是获取的一个相同的锁；那么这个时候；会将锁对象<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中计数器的取值再次++，设置为<span class="number">2</span>；</span><br><span class="line">假设CPU此时依然在该线程A上，而线程A继续往下进行执行，那么此时就会进行打印 线程名++<span class="string">"进入了同步代码块2"</span>信息；</span><br><span class="line">那么也就可以观察得到同一个线程多次执行synchronized拿到同一把锁；</span><br><span class="line">那么这个锁当中存在有一个计数器，这个计数器当中会进行记录自己被拿到了几次。</span><br><span class="line"></span><br><span class="line">那么假设此时CPU又切换到了另外一个线程；即线程B；</span><br><span class="line">那么此时线程B也会来进行执行MyThread当中实现的run<span class="literal">()</span>方法；</span><br><span class="line">但是会发现<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>该对象锁依然在线程A那里，即线程A还并没有进行释放锁CPU就切换到了线程B上；</span><br><span class="line">所以也就导致了线程B无法获取得到锁从而也就无法进入同步代码块<span class="number">1</span>中，只能够在同步代码块<span class="number">1</span>的外侧进行等待；</span><br><span class="line"></span><br><span class="line">那么这个时候CPU又切换回来到了线程A上；</span><br><span class="line">那么线程A继续接着CPU切换之前的的那个地方往下进行执行；</span><br><span class="line">即当时已经打印完成 线程名称+“进入了同步代码块<span class="number">2</span>”信息了；</span><br><span class="line">即线程A走到了同步代码块<span class="number">2</span>的大括号处说明同步代码块<span class="number">2</span>要结束了；</span><br><span class="line">那么此时同步代码块<span class="number">2</span>结束的时候就会将该同步代码块<span class="number">2</span>的锁给释放掉；</span><br><span class="line">也就意味着对象锁<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中的计数器会进行减<span class="number">1</span>操作；</span><br><span class="line">即此时计数器取值由<span class="number">2</span>变成了<span class="number">1</span>；</span><br><span class="line">那么接着继续往下走；那么线程A就又走到了同步代码块<span class="number">1</span>的结束大括号上，也就意味着此时线程A要出同步代码块<span class="number">1</span>，即又释放一次，即锁对象<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中的计数器又会发生一次减<span class="number">1</span>操作；即此时计数器的取值由<span class="number">1</span>变为<span class="number">0</span>；</span><br><span class="line">计数器取值为<span class="number">0</span>也就意味着当前没有线程来进行获取这把锁了；</span><br><span class="line">也就是相当于线程A将锁还回去了；</span><br><span class="line">那么此时其他线程就可以去进行竞争获取得到该锁进入同步代码块当中来；</span><br></pre></td></tr></table></figure><blockquote><p>其实也可以不用两个synchronized同步代码块嵌套；<br>可以放到两个不同的方法也可以完成；</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">MyThread</span> <span class="symbol">extends</span> <span class="symbol">Thread</span>&#123;</span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> run()&#123;</span><br><span class="line">    synchronized(MyThread.<span class="keyword">class</span>)&#123;</span><br><span class="line">      System.<span class="keyword">out</span>.println(getName() + <span class="string">"进入了同步代码块1"</span>);</span><br><span class="line"></span><br><span class="line">      test01();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> test01()&#123;</span><br><span class="line">    synchronized(MyThread.<span class="keyword">class</span>)&#123;</span><br><span class="line">         System.<span class="keyword">out</span>.println(getName() + <span class="string">"进入了同步代码块2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment">// 再次运行，线程依旧可以重入拿到锁两次；</span></span><br><span class="line">结果:</span><br><span class="line">Thread<span class="number">-0</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread<span class="number">-0</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">Thread<span class="number">-1</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread<span class="number">-1</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">-----------------------------------------</span><br></pre></td></tr></table></figure><blockquote><p>另外不仅是放到同一个类的方法可以实现，放到不同类的方法也可以实现；</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：演示synchronized可重入</span></span><br><span class="line"><span class="comment">    1. 自定义一个线程类</span></span><br><span class="line"><span class="comment">    2. 在线程类的run方法中使用 嵌套的代码同步块</span></span><br><span class="line"><span class="comment">    3. 使用两个线程来执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123;</span><br><span class="line">      new MyThread().start();</span><br><span class="line">      new MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> test01()&#123;</span><br><span class="line">      synchronized(MyThread.<span class="keyword">class</span>)&#123;</span><br><span class="line">          String name = Thread.currentThread.getName();</span><br><span class="line">          System.<span class="keyword">out</span>.println(name + <span class="string">"进入了同步代码块2"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 自定义一个线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">MyThread</span> <span class="symbol">extends</span> <span class="symbol">Thread</span>&#123;</span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> run()&#123;</span><br><span class="line">    synchronized(MyThread.<span class="keyword">class</span>)&#123;</span><br><span class="line">      System.<span class="keyword">out</span>.println(getName() + <span class="string">"进入了同步代码块1"</span>);</span><br><span class="line"></span><br><span class="line">      Demo01.test01();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment">// 再次运行，线程依旧可以重入拿到锁两次；</span></span><br><span class="line">结果:</span><br><span class="line">Thread<span class="number">-0</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread<span class="number">-0</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">Thread<span class="number">-1</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread<span class="number">-1</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">-----------------------------------------</span><br></pre></td></tr></table></figure><p>由此说明了synchronized的可重入特性与调用哪一个对象的哪一个方法无关；<br>主要是看线程，看锁；</p><h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><p>synchronized的锁对象中有一个计数器（recursions变量）会记录线程获得几次锁；<br>加锁次数 计数器（recursions 变量）</p><h3 id="可重入的好处"><a href="#可重入的好处" class="headerlink" title="可重入的好处"></a>可重入的好处</h3><ol><li>可以避免死锁</li><li>更好的封装代码</li></ol><p>依然是上述存在有两个同步代码块嵌套的代码；<br>即如果一个线程A进入了一个同步代码块当中去了；<br>那么假设synchronized没有可重入特性；<br>那么就会导致无法再次进入同步代码块当中；<br>那么这个时候就会卡在一个地方；<br>这个地方即为进入到synchronized同步代码块1之后，<br>打印执行完成 线程名+“进入了同步代码块1”之后；<br>没有办法进入下一句代码，即下一个同步代码块2synchronized中；<br>从而无法结束该流程也没有办法释放锁；<br>而其他线程也由于无法获取得到锁从而无法进入同步代码块1只能够在同步代码块1外层进行等待；<br>也就造成了死锁的状态；就相当于是线程A被困在同步代码块1当中了；<br>那么有了synchronized的可重入特性就可以避免死锁；</p><p>因为可以在同步代码块1当中调用其他方法，即比如说上述代码中的Demo01.test01();而Demo01.test01()中也存在有同步代码块，那么也就方便了使用方法来进行封装代码；</p><h3 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h3><p>synchronized是可重入锁；内部锁对象中会有一个计数器记录线程获取了几次锁了；在执行完同步代码块时，计数器的数量会-1，直到计数器的数量为0，就释放这个锁。</p><p>什么是可重入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指的是 同一个线程的 可以 多次 获得 同一把锁</span><br></pre></td></tr></table></figure><p>可重入的原理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加锁次数计数器。（recursions变量）</span><br></pre></td></tr></table></figure><h2 id="synchronized的不可中断性"><a href="#synchronized的不可中断性" class="headerlink" title="synchronized的不可中断性"></a>synchronized的不可中断性</h2><h3 id="目标-10"><a href="#目标-10" class="headerlink" title="目标"></a>目标</h3><p>了解什么是不可中断<br>学习<strong>synchronized</strong>的<strong>不可中断特性</strong>；<br>学习<strong>Lock</strong>的<strong>可中断特性</strong>；</p><h3 id="什么是不可中断"><a href="#什么是不可中断" class="headerlink" title="什么是不可中断"></a>什么是不可中断</h3><p>一旦这个锁 被别人 获得了，如果里另一个锁想获得锁，只能等待或者阻塞，直到别的线程释放这个锁，如果别人永远不释放锁，这个线程只能永远等下去，很执着！<br>（一个线程获得锁后，另一个线程想要锁，必须处于阻塞或等待状态；如果第一个线程不释放锁，第二个线程会一直处于阻塞或等待状态，在阻塞或者等待过程中，不可被中断，将一直等待或阻塞；）</p><h3 id="synchronized-不可中断演示"><a href="#synchronized-不可中断演示" class="headerlink" title="synchronized 不可中断演示"></a>synchronized 不可中断演示</h3><p>synchronized 是不可中断，处于阻塞状态的线程会一直等待锁。</p><p>(当一个线程进入一个同步代码块，那么另外一个线程只能在外面等待，这个处于等待的线程将会一直等待，不会中断，所以就叫做不可中断)</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Demo02_Uninterruptible&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span> o1 = <span class="keyword">new</span> <span class="keyword">Object</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    Runnable runnable =  () - &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>( <span class="number">01</span> )&#123;</span><br><span class="line">        <span class="keyword">String</span> name = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(name + <span class="string">"start"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(name + <span class="string">"interrupted"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>演示synchronized的不可中断特性</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------</span><br><span class="line">package com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：演示synchronized不可中断</span></span><br><span class="line"><span class="comment">    1. 定义一个Runnable</span></span><br><span class="line"><span class="comment">    2. 在Runnable定义同步代码块</span></span><br><span class="line"><span class="comment">    3. 先开启一个线程来执行同步代码块，保证不退出同步代码块</span></span><br><span class="line"><span class="comment">    4. 后开启一个线程来执行同步代码块（阻塞状态）</span></span><br><span class="line"><span class="comment">    5. 停止第二个线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="keyword">class</span> Demo02_Uninterruptible&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> static Object obj = <span class="keyword">new</span> <span class="constructor">Object()</span>;<span class="comment">//定义锁对象</span></span><br><span class="line"></span><br><span class="line">  public static void main(String<span class="literal">[]</span> args)&#123;</span><br><span class="line">      <span class="comment">// 1. 定义一个Runnable</span></span><br><span class="line">      Runnable run = <span class="literal">()</span>-&gt;&#123;</span><br><span class="line">        <span class="comment">// 2. 在Runnable定义同步代码块；</span></span><br><span class="line">        <span class="comment">// 同步代码块需要一个锁对象；</span></span><br><span class="line">        synchronized(obj)&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 进行打印是哪一个线程进入的同步代码块</span></span><br><span class="line">          String name = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>;</span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(name + <span class="string">"进入同步代码块"</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 需要进行保证不进行退出同步代码块；</span></span><br><span class="line">          <span class="comment">// 所以让此线程进行沉睡sleep</span></span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">888888</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 先开启一个线程来执行同步代码块</span></span><br><span class="line">      Thread t1 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">run</span>)</span>;</span><br><span class="line">      t1.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 沉睡一秒钟；</span></span><br><span class="line">      <span class="comment">// 保证第一个线程先去执行同步代码块之后再来创建第二个线程；</span></span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      4. 后开启一个线程来执行同步代码块（阻塞状态）</span></span><br><span class="line"><span class="comment">      到时候第二个线程去执行同步代码块的时候，</span></span><br><span class="line"><span class="comment">      锁已经被t1线程锁获取得到了；</span></span><br><span class="line"><span class="comment">      所以线程t2是无法获取得到Object obj对象锁的；</span></span><br><span class="line"><span class="comment">      那么也就将会在同步代码块外处于阻塞状态。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      Thread t2 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">run</span>)</span>;</span><br><span class="line">      t2.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 5. 停止第二个线程；</span></span><br><span class="line"><span class="comment">      观察此线程t2能够被中断；</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"停止线程前"</span>);</span><br><span class="line">      t2.interrupt<span class="literal">()</span>;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"停止线程后"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最后得到两个线程的执行状态</span></span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t1.get<span class="constructor">State()</span>);</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t2.get<span class="constructor">State()</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line">运行效果：</span><br><span class="line">(Run显示红灯即没有停止运行依然在继续)</span><br><span class="line">Thread-<span class="number">0</span>进入同步代码块</span><br><span class="line">停止线程前</span><br><span class="line">停止线程后</span><br><span class="line">TIMED_WAITING</span><br><span class="line">BLOCKED</span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">通过interrupt<span class="literal">()</span>方法给t2线程进行强行中断；</span><br><span class="line">最后进行打印t2的状态及State发现状态依然为BLOCKED；</span><br><span class="line">即线程不可中断；</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">synchronized的不可中断性具体分析流程</span><br><span class="line">红色的箭头表示主线程；主线程从main<span class="literal">()</span>方法开始执行；</span><br><span class="line">然后执行到步骤<span class="number">3</span>（<span class="number">3.</span> 先开启一个线程来执行同步代码块）启动第一个线程t1；</span><br><span class="line">那么再画一个箭头代表启动的这第一个线程t1，用线程A表示；</span><br><span class="line">那么线程A启动之后就会去执行Runnable run中的所重写的run方法；</span><br><span class="line">那么线程A第一次执行同步代码块；获取得到对象锁Object obj；</span><br><span class="line">然后进入同步代码块中打印 线程名称+“进入同步代码块”；</span><br><span class="line">继续往下进行执行就会使得线程A进行入沉睡状态；</span><br><span class="line">那么此时CPU再切换到另外一个线程；即主线程继续往下执行；</span><br><span class="line">当主线程沉睡一秒之后，接下来又会启动一个线程即t2，用线程B表示；</span><br><span class="line">线程B启动之后也会来进行执行Runnable当中重写的run<span class="literal">()</span>方法；</span><br><span class="line">但是由于在CPU切换之前线程A并没有释放锁；</span><br><span class="line">即第一个线程，即线程A由于沉睡时间过长；没有办法释放锁；</span><br><span class="line">所以导致线程B无法获取得到锁；</span><br><span class="line">从而只能在同步代码块外侧进行等待锁，处于阻塞状态；</span><br><span class="line">那么此时CPU再次切换到主线程，主线程继续往下进行执行；</span><br><span class="line">进行打印输出“停止线程前”；后继续往下执行；</span><br><span class="line">准备强行将等待锁对象的线程B进行停止掉，即使用了interrupt<span class="literal">()</span>方法（但是停不掉；就是因为synchronized是不可中断的；这个处于阻塞等待的线程是无法被中断的；这个线程会一直处于等待锁状态即不可被中断）；</span><br><span class="line">主线程继续往下执行输出打印“停止线程后”；</span><br><span class="line">最后打印线程A与线程B这两个线程的状态；</span><br><span class="line">线程A由于执行了<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">888888</span>);所以导致线程A的状态处于TIMED_WAITING；</span><br><span class="line">线程B由于synchronized的不可中断性所以一直在同步代码块外侧进行等待获取锁处于等待阻塞状态，所以其状态为BLOCKED；不可被中断；</span><br><span class="line"></span><br><span class="line">至此，可以观察到的是synchronized是不可被中断的；</span><br><span class="line">它会导致没有获取得到锁的线程一直在同步代码块外侧一直处于一个等待阻塞获取锁的一个状态；</span><br></pre></td></tr></table></figure><h3 id="ReentrantLock可中断演示"><a href="#ReentrantLock可中断演示" class="headerlink" title="ReentrantLock可中断演示"></a>ReentrantLock可中断演示</h3><p>ReentrantLock可中断</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.<span class="keyword">Lock</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Demo03_INterruptible&#123;</span><br><span class="line">    private static final <span class="keyword">Lock</span> o1 = <span class="built_in">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws InterruptedException&#123;</span><br><span class="line">      Runnable runnable = () -&gt; &#123;</span><br><span class="line">        String <span class="type">name</span> =  Thread.currentThread().getName();</span><br><span class="line">        <span class="type">boolean</span> isLock = <span class="keyword">false</span>;</span><br><span class="line">        try&#123;</span><br><span class="line">            isLock = o1.tryLock( <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">              <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + "lock");</span><br><span class="line">              Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">          <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + "interrupted");</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">              o1.unlock();</span><br><span class="line">              <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + "unlock");</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + "指定时间内没有得到锁，中断，不等了，可以接着做其他事情。");</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>演示 ReentrantLock 的不可中断特性</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：</span></span><br><span class="line"><span class="comment">    演示 Lock不可中断特性</span></span><br><span class="line"><span class="comment">    Lock具有两种特性（一种是可中断；另外一种是不可中断；）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="keyword">class</span> Demo03_Interruptible&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在类的成员变量位置来进行创建一个Lock对象</span></span><br><span class="line">  <span class="keyword">private</span> static Lock lock = <span class="keyword">new</span> <span class="constructor">ReentrantLock()</span>;</span><br><span class="line"></span><br><span class="line">  public static void main(String<span class="literal">[]</span> args)throws InterruptedException&#123;</span><br><span class="line">    test01<span class="literal">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 演示 Lock 不可中断</span></span><br><span class="line">  public static void test01<span class="literal">()</span>&#123;</span><br><span class="line">    Runnable run = <span class="literal">()</span>-&gt;&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        这种方式是属于不可中断的；</span></span><br><span class="line"><span class="comment">        可以看到的是:lock() void</span></span><br><span class="line"><span class="comment">        即该方法是没有返回值的；</span></span><br><span class="line"><span class="comment">        那么这种情况就属于不可中断；</span></span><br><span class="line"><span class="comment">        它也会一直等待锁；</span></span><br><span class="line"><span class="comment">        另外获取锁之后一定要记得unlock()；</span></span><br><span class="line"><span class="comment">        那么将unlock()操作放入到finally块当中进行执行；</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      String name =<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        lock.lock<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">//获取线程的名字</span></span><br><span class="line">        <span class="comment">//打印当前进入run()中的线程名称</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(name + <span class="string">"获得锁，进入锁执行"</span>);</span><br><span class="line">        <span class="comment">//加一个睡眠保证该线程一直在里面进行执行不退出</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">888888</span>);</span><br><span class="line"></span><br><span class="line">      &#125;catch(InterruptedException e)&#123;</span><br><span class="line">          e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">      &#125;finally&#123;</span><br><span class="line">        <span class="comment">//同样unlock也是没有返回值的；void</span></span><br><span class="line">        lock.unlock<span class="literal">()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(name + <span class="string">"释放锁"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">run</span>)</span>;</span><br><span class="line">    t1.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让主线程沉睡一秒；</span></span><br><span class="line">    <span class="comment">//让第一个线程t1启动之后去进行执行Runnable当中的所实现的run()</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续创建第二个线程</span></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">run</span>)</span>;</span><br><span class="line">    t2.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//终止一下t2线程看是否能够进行终止；</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"终止t2线程前"</span>);</span><br><span class="line">    t2.interrupt<span class="literal">()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"终止t2线程后"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//让主线程沉睡一秒</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取两个线程的状态</span></span><br><span class="line">    <span class="comment">//第二个线程t2是后来的即在第一个线程t1创建并启动之后以及主线程沉睡了1秒之后才创建的第二个线程t2；</span></span><br><span class="line">    <span class="comment">//即第一个线程t1已经获取得到锁了；</span></span><br><span class="line">    <span class="comment">//由于第一个线程t1在Runnable所实现的run()方法当中进行了长时间的沉睡又没有办法释放锁；</span></span><br><span class="line">    <span class="comment">//所导致第二个线程，即线程t2只能够在同步代码块外进行阻塞等待获取锁；</span></span><br><span class="line">    <span class="comment">//看第二个线程t2是否能够被中断以及观察这两个线程的状态；</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t1.get<span class="constructor">State()</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t2.get<span class="constructor">State()</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line">运行效果：</span><br><span class="line">(Run显示红灯即没有停止运行依然在继续)</span><br><span class="line">Thread-<span class="number">0</span>进入同步代码块</span><br><span class="line">停止t2线程前</span><br><span class="line">停止t2线程后</span><br><span class="line">TIMED_WAITING</span><br><span class="line">WAITING</span><br><span class="line">--------------------------------------------------</span><br><span class="line">那么通过运行结果可以看出t2.interrupt<span class="literal">()</span>是没有执行成功的；</span><br><span class="line">因为t2进行打印其线程状态发现依旧处于等待状态即WAITING；</span><br><span class="line">也就是说t2线程没有抢到锁所以导致一直处于等待状态；</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">主线程从main<span class="literal">()</span>方法开始进行执行；</span><br><span class="line">即执行test01<span class="literal">()</span>方法；</span><br><span class="line">创建一个Runnable，Runnable当中实现run<span class="literal">()</span>方法；</span><br><span class="line">创建并启动一个线程t1；去进行执行Runnable run当中的run<span class="literal">()</span>方法；</span><br><span class="line">即线程t1执行run<span class="literal">()</span>当中的内容；</span><br><span class="line">此时还没有其他线程获取得到lock.lock<span class="literal">()</span>当中的锁；</span><br><span class="line">所以线程t1此时可以获取得到锁；</span><br><span class="line">即进入同步代码块中进行打印 <span class="string">"Thread-0获得锁，进入锁执行"</span>后进入线程t1长时间睡眠且并未释放锁；</span><br><span class="line">那么此时CPU切换到主线程，主线程继续向下执行；</span><br><span class="line">主线程沉睡一秒之后；又进行创建并启动第二个线程t2；</span><br><span class="line">那么第二个线程t2也会去进行执行Runnable run当中的run<span class="literal">()</span>方法；</span><br><span class="line">但是此时第二个线程t2是无法得到锁的；</span><br><span class="line">由于线程t1并未释放锁而是出于长时间的睡眠状态；</span><br><span class="line">所以导致线程t2无法获取得到锁从而导致在同步代码块外侧进行等待获取锁；</span><br><span class="line">所以线程t2会处于一种叫做WAITING的状态；</span><br><span class="line">那么这个时候CPU又切换到主线程当中来；</span><br><span class="line">则主线程继续往下进行执行准备去强行停止线程t2但是停不掉</span><br><span class="line">（lock.lock<span class="literal">()</span>也是属于不可中断的；）；</span><br><span class="line">打印“停止t2线程前”以及继续往下执行对线程t2进行中断以及打印“停止t2线程后”；</span><br><span class="line"></span><br><span class="line">继续向下执行主线程又一次进行沉睡一秒后；</span><br><span class="line">打印线程t1与线程t2的状态；</span><br><span class="line">那么这个时候就会发现线程t2处于一种WAITING的状态；</span><br><span class="line">即也说明了<span class="module-access"><span class="module"><span class="identifier">ReentrantLock</span>.</span></span>lock<span class="literal">()</span>是不可被中断的；</span><br><span class="line">即lock.lock<span class="literal">()</span>方法则导致在同步代码块外侧的线程状态是不可中断的；</span><br><span class="line">但是ReentrantLock还有一个方法叫做<span class="keyword">try</span><span class="constructor">Lock()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>演示 ReentrantLock的可中断特性</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：演示Lock的可中断特性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03_Interruptible</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws InterruptedException</span>&#123;</span><br><span class="line">    test02();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 演示 Lock 可中断</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> throws InterruptedException</span>&#123;</span><br><span class="line">    Runnable <span class="built_in">run</span> = ()-&gt;&#123;</span><br><span class="line">      <span class="keyword">String</span> name = Thread.currentThread().getName();</span><br><span class="line">      <span class="keyword">boolean</span> b = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        tryLock(long time, TimeUnit unit) 返回boolean类型</span></span><br><span class="line"><span class="comment">        tryLock会进行尝试获取锁，</span></span><br><span class="line"><span class="comment">        如果能够获得锁则返回true；</span></span><br><span class="line"><span class="comment">        反之不能获得锁则返回false；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        到时候如果是第二个线程要来进行获取锁来进行抢锁；</span></span><br><span class="line"><span class="comment">        那么这个时候如果三秒内没有获取得到锁；</span></span><br><span class="line"><span class="comment">        那么就会进行中断；从而进入else块中做其他操作；</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//尝试3秒，时间单位为秒；</span></span><br><span class="line">        <span class="comment">//由于单位是秒所以直接输入3即可而不是3000</span></span><br><span class="line">        <span class="comment">//b = lock.tryLock(3000, TimeUnit.SECONDS);</span></span><br><span class="line">        b = lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//说明尝试获取得到了锁；则进入if块当中</span></span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">          System.out.<span class="built_in">println</span>(name + <span class="string">"获得锁，进入锁执行"</span>);</span><br><span class="line">          Thread.sleep(<span class="number">888888</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//那么else则说明没有获取得到锁；</span></span><br><span class="line">          <span class="comment">//则可以让其做其他操作从而也就证明了Lock.tryLock()是可中断的；</span></span><br><span class="line">          System.out.<span class="built_in">println</span>(name + <span class="string">"在指定时间内没有获取得到锁则做其他操作"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;finally&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        此时的unlock()需要进行注意；</span></span><br><span class="line"><span class="comment">        如果说CPU当前切换到的当前线程没有获取得到锁则并不需要进行unlock()操作；</span></span><br><span class="line"><span class="comment">        如果CPU当前切换到的当前线程获取得到了锁并执行完成同步代码块当中的内容所以此时finally当中是需要进行执行unlock()操作的；</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(b)&#123;<span class="comment">//得到了锁才进行释放锁操作</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.<span class="built_in">println</span>(name + <span class="string">"释放锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在后续的代码中让两个线程进行启动起来即可其余代码可以不要；</span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="built_in">run</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="built_in">run</span>);</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    System.out.println("停止t2线程前");</span></span><br><span class="line"><span class="comment">    t2.interrupt();</span></span><br><span class="line"><span class="comment">    System.out.println("停止t2线程后");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">    System.out.println(t1.getState());</span></span><br><span class="line"><span class="comment">    System.out.println(t2.getState());</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">代码执行效果：</span><br><span class="line">Thread<span class="number">-0</span>获得锁，进入锁执行</span><br><span class="line">Thread<span class="number">-1</span>在指定时间没有得到锁做其他操作</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">详细分析一下ReentrantLock可中断性流程：</span><br><span class="line">先画一个红色的箭头来表示主线程；然后来分析整个流程；</span><br><span class="line">程序由main()方法开始进行执行；然后执行test02()方法；</span><br><span class="line">创建一个Runnable并实现其<span class="built_in">run</span>()方法；</span><br><span class="line">创建Runnable完成之后；创建第一个线程t1并启动去执行Runnable当中的<span class="built_in">run</span>()方法即执行<span class="built_in">run</span>()方法内部的内容；</span><br><span class="line">而第一个线程t1是可以进行获取得到锁的；即lock.tryLock(<span class="number">3</span>,TimeUnit.SECONDS)时；则进入代码块<span class="keyword">if</span>(b)当中并打印第一句话“Thread<span class="number">-0</span>获得锁，进入锁执行”；那么接着线程t1就一直睡眠了Thread.sleep(<span class="number">888888</span>);</span><br><span class="line">那么此时CPU又切换会主线程；接着往下走沉睡一秒之后进行创建t2线程并启动t2线程；</span><br><span class="line">那么线程t2此时也会来进行执行Runnable当中的<span class="built_in">run</span>()方法；</span><br><span class="line">那么第二个线程t2进来时执行lock.tryLock时会发现锁已经被t1线程获取得到了；且t1线程并没有释放锁而且处于长时间的睡眠状态；</span><br><span class="line">那么这个时候t2线程会进行尝试获取锁<span class="number">3</span>秒；</span><br><span class="line"><span class="number">3</span>秒过后如果依旧无法获取得到锁（即线程t1三秒后依旧没有进行释放锁）那么线程t2则将中断且不会继续等待获取锁，</span><br><span class="line">即tryLock则返回<span class="literal">false</span>；</span><br><span class="line">返回<span class="literal">false</span>则将会执行<span class="keyword">else</span>块当中的代码即打印输出“Thread<span class="number">-1</span>在指定时间没有得到锁做其他操作”做其他操作去了；</span><br><span class="line">那么此时可以看到的是 tryLock的话则会等待指定的时间，</span><br><span class="line">在指定的时间内去尝试获取锁；</span><br><span class="line">也就是说在指定的时间内等待上一个获取锁的线程进行释放锁；</span><br><span class="line">如果说在指定的时间内上一个获取得到锁的线程执行完成并释放了锁那么则当前该线程就在指定的时间结束后会返回<span class="literal">true</span>表示获取得到锁；</span><br><span class="line">如果上一个获取得到锁的线程在指定的时间内并没有释放锁那么则当前等待的线程在指定等待的时间结束后；则进行中断不会再去等待获取锁；</span><br><span class="line">直接返回<span class="literal">false</span>表示没有获取得到锁，该为去做其他的操作；</span><br></pre></td></tr></table></figure><h3 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h3><p>不可中断是指：当一个线程获得锁之后，另一个线程一致处于阻塞或等待状态，前一个线程不释放锁，后一个线程会一直阻塞或者等待，并且在阻塞或等待的过程中它是不可被中断的，它会一直等待或者被阻塞；  </p><p><strong>synchronized</strong>是属于<strong>不可被中断</strong>的；<br><strong>Lock（ReentrantLock）</strong>的<strong>lock</strong>方法是<strong>不可被中断</strong>的；<br><strong>Lock（ReentrantLock）</strong>的<strong>tryLock</strong>方法是<strong>可中断</strong>的；</p><h2 id="javap反汇编学习synchronized的原理"><a href="#javap反汇编学习synchronized的原理" class="headerlink" title="javap反汇编学习synchronized的原理"></a>javap反汇编学习synchronized的原理</h2><p>第五章：synchronized原理</p><p>（较难的一块，由浅入深，涉及<strong>synchronized的原理</strong>讲解；）</p><blockquote><ul><li>首先会通过<strong>javap反汇编</strong>的方式，</li><li><em>synchronized*</em>其实被转换成了<strong>两条字节码指令</strong>，<br>分别是<strong>monitorenter</strong>以及<strong>monitorexit</strong>；<br>然后会通过Oracle的官方文档即<strong>JVM规范</strong>来对<strong>字节码指令</strong> <strong>monitorenter</strong>以及<strong>monitorexit</strong>的一个简单的介绍，<br>介绍这<strong>两个指令</strong>时如何来进行<strong>加锁和解锁</strong>的，<br>通过<strong>字节码指令</strong>来介绍<strong>synchronized</strong>属于比较深入，<br>但是有并不是特别的深入，<br>那么为了更加深层次的理解<strong>synchronized的底层机制</strong>，<br>将会深入<strong>JVM的源码</strong>来进行源码分析。</li><li><strong>JVM底层</strong>是使用<strong>c、c++</strong>所编写的；</li><li><em>synchronized*</em>是一个<strong>关键字</strong>，</li><li><em>底层*</em>由<strong>c、c++</strong>来编写。<br>会进行分析这一块的代码；<br>到时候就可以清晰的知道<strong>synchronized</strong>的一个清晰的<strong>底层结构</strong>以及如何<strong>获得锁</strong>、<strong>等待锁</strong>以及如何<strong>释放锁</strong>的；</li><li>另外还会去介绍<strong>synchronized</strong>为什么是一个<strong>重量级的锁</strong>，<br>以及<strong>synchronized</strong>为什么会<strong>开销比较大</strong>；<br>因为<strong>synchronized</strong>是一个<strong>重量级的锁</strong>，<br>所以其<strong>效率不高</strong>，<br>那么在第六章就会来进行介绍<strong>JDK6</strong>当中对<strong>synchronized</strong>的一个<strong>优化措施</strong>，<strong>synchronized</strong>的涉及到一个叫做<strong>CAS操作</strong>，<br>那么就会先去进行介绍<strong>CAS</strong>的一个<strong>原理</strong>，<br>那么其实<strong>CAS</strong>也属于一个<strong>原子操作</strong>，<br>可以将<strong>CAS操作</strong>看做是一个<strong>轻量级的synchronized</strong>，<br>它能够<strong>保证变量修改</strong>的这样一个<strong>原子操作</strong>；<br>介绍了<strong>CAS</strong>之后就将会介绍<strong>锁升级</strong>的一个<strong>过程</strong>，</li><li><em>锁升级*</em>是由 <strong>无锁-→偏向锁-→轻量级锁-→重量级锁</strong> ；</li><li>由浅入深的来进行学习，那么存在这么多锁就会存在一个问题；<br>如何来得知是<strong>属于哪一种锁</strong>，<br>那么这个时候会先进行了解<strong>JAVA对象的布局</strong>；<br>以前对java对象的理解是这样的-→java对象是存在在堆中，然后有一块空间可以来进行存放其对象当中的成员变量；<br>那么介绍的<strong>java对象布局</strong>，其当中不仅会有<strong>java对象的实例数据</strong>还会有<strong>对象头</strong>以及一些<strong>对齐数据</strong>；<br>那么<strong>锁升级过程</strong>中的这些<strong>锁</strong>是<strong>存在于对象头当中的Mark Word</strong>当中的，<br>到时候通过c++的源码来进行详细分析；</li><li>另外<strong>JDK6</strong>还对<strong>synchronized</strong>做了一些<strong>锁消除和锁粗化的优化</strong>操作，<br>经过对<strong>synchronized的原理</strong>的学习之后就可以总结出写代码应该如何对<strong>synchronized优化</strong>，写出更<strong>高效</strong>更<strong>好</strong>的代码；<br>那么会从以下几个方面进行来介绍；<br>第一个：<strong>减少synchronized的范围</strong>；<br>第二个：<strong>降低synchronized锁的粒度</strong><br>（这当中有一个经典的例子就是<strong>HashTable</strong>，<strong>HashTable</strong>会<strong>锁</strong>住所有的<strong>数据</strong>；而后又推出了一个叫做<strong>ConcurrentHashMap</strong>，那么<strong>ConcurrentHashMap</strong> <strong>只</strong>会<strong>锁</strong>住<strong>一个桶</strong>当中的<strong>数据</strong>）；<br>第三个：通过<strong>读写分离</strong>的方式来进行<strong>提高效率</strong>；<br>以上就是<strong>synchronized</strong>课程的主要内容；</li></ul></blockquote><p>javap 反汇编</p><p>synchronized原理的学习；<br>首先通过javap反汇编的方式来进行学习synchronized原理；<br>接着再通过JVM源码再来深入的学习synchronized原理；</p><h3 id="目标-11"><a href="#目标-11" class="headerlink" title="目标"></a>目标</h3><p>通过 <strong>javap 反汇编</strong> 学习 synchronized的原理</p><p>编写一个简单的synchronized代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo04_synchronized_monitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span></span>&#123;</span><br><span class="line">  <span class="comment">//依赖的锁对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//synchronized同步代码块；且在代码块当中做了简单的打印操作；</span></span><br><span class="line">      <span class="comment">//重点是看synchronized在反汇编之后形成的字节码指令</span></span><br><span class="line">      <span class="keyword">synchronized</span>( obj )&#123;</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//编写了一个synchronized修饰的方法</span></span><br><span class="line">  <span class="comment">//synchronized修饰代码块与synchronized修饰方法反汇编之后的结果是不太一样的；</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"a"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="comment">//代码写好之后让idea进行一个编译得到字节码文件；</span></span><br><span class="line">  <span class="comment">//编译好的字节码文件目录：工程名/target/classes/xxx/demo04_synchronized_monitor/Demo01.class</span></span><br></pre></td></tr></table></figure><p>要看 synchronized的原理，但是 synchronized是一个关键字，看不到源码。<br>可以将class文件进行反汇编。<br>JDK自带的一个工具: javap，对字节码进行反汇编，查看字节码指令。<br>在DOS命令行或者是Windows PowerShell等其他命令行输入(对字节码文件进行反汇编)：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3666<span class="symbol">\I</span>deaProjects<span class="symbol">\X</span>xx<span class="symbol">\S</span>ynchronized<span class="symbol">\t</span>arget<span class="symbol">\c</span>lasses<span class="symbol">\c</span>om<span class="symbol">\x</span>xx<span class="symbol">\d</span>emo04_synchronized_monitor<span class="symbol">\j</span>avap -p -v Demo01.class</span><br><span class="line"># -p 是显示包括所有的私有的</span><br><span class="line"># -v 就是详细的来进行显示</span><br></pre></td></tr></table></figure><blockquote><p>反汇编之后得到的字节码指令如下所示：</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">      <span class="attr">LineNumberTable:</span></span><br><span class="line">          <span class="attr">line 3:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">LocalVariableTable:</span></span><br><span class="line">          <span class="string">Start</span>     <span class="string">Length</span>      <span class="string">Slot</span>     <span class="string">Name</span>     <span class="string">Signature</span></span><br><span class="line">              <span class="number">0</span>          <span class="number">5</span>         <span class="number">0</span>     <span class="string">this</span>      <span class="string">Lcom/xxx/demo04_synchronized_monitor/Demo01;</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">public</span> <span class="string">static</span> <span class="string">void</span> <span class="string">main(java.lang.String[]);</span></span><br><span class="line">    <span class="attr">descriptor:</span> <span class="string">([Ljava/lang/String;)V</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">ACC_PUBLIC,</span> <span class="string">ACC_STATIC</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="string">stack=2,</span>  <span class="string">locals=3;</span>   <span class="string">args_size=1</span></span><br><span class="line">          <span class="attr">0:</span> <span class="string">getstatic</span>           <span class="comment">#2        // Field obj:Ljava/lang/Object;</span></span><br><span class="line">          <span class="attr">3:</span> <span class="string">dup</span></span><br><span class="line">          <span class="attr">4:</span> <span class="string">astore_1</span></span><br><span class="line">          <span class="attr">5:</span> <span class="string">monitorenter</span></span><br><span class="line">          <span class="attr">6:</span> <span class="string">getstatic</span>           <span class="comment">#3        // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">          <span class="attr">9:</span> <span class="string">1dc</span>                 <span class="comment">#4        // String 1</span></span><br><span class="line">         <span class="attr">11:</span> <span class="string">invokevirtual</span>       <span class="comment">#5        // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="attr">14:</span> <span class="string">aload_1</span></span><br><span class="line">         <span class="attr">15:</span> <span class="string">monitorexit</span></span><br><span class="line">         <span class="attr">16:</span> <span class="string">goto</span>                <span class="number">24</span></span><br><span class="line">         <span class="attr">19:</span> <span class="string">astore_2</span></span><br><span class="line">         <span class="attr">20:</span> <span class="string">aload_1</span></span><br><span class="line">         <span class="attr">21:</span> <span class="string">monitorexit</span></span><br><span class="line">         <span class="attr">22:</span> <span class="string">aload_2</span></span><br><span class="line">         <span class="attr">23:</span> <span class="string">athrow</span></span><br><span class="line">         <span class="attr">24:</span> <span class="string">return</span></span><br><span class="line">      <span class="attr">Exception table:</span></span><br><span class="line">          <span class="string">from</span>     <span class="string">to</span>    <span class="string">target</span>   <span class="string">type</span></span><br><span class="line">             <span class="number">6</span>      <span class="number">16</span>       <span class="number">19</span>    <span class="string">any</span></span><br><span class="line">            <span class="number">19</span>      <span class="number">22</span>       <span class="number">19</span>    <span class="string">any</span></span><br><span class="line">      <span class="attr">LineNumberTable:</span></span><br><span class="line">        <span class="attr">line 7:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">line 8:</span> <span class="number">6</span></span><br><span class="line">        <span class="attr">line 9:</span> <span class="number">14</span></span><br><span class="line">        <span class="attr">line 10:</span> <span class="number">24</span></span><br><span class="line">      <span class="attr">LocalVariableTable:</span></span><br><span class="line">        <span class="string">Start</span>      <span class="string">Length</span>     <span class="string">Slot</span>   <span class="string">Name</span>    <span class="string">Signature</span></span><br><span class="line">            <span class="number">0</span>          <span class="number">25</span>        <span class="number">0</span>   <span class="string">args</span>    <span class="string">[Ljava/lang/String;</span></span><br><span class="line">      <span class="attr">StackMapTable:</span> <span class="string">number_of_entries</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line">        <span class="string">frame_type</span> <span class="string">=</span> <span class="number">255</span> <span class="string">/*</span> <span class="string">full_frame</span> <span class="string">*/</span></span><br><span class="line">          <span class="string">offset_delta</span> <span class="string">=</span> <span class="number">19</span></span><br><span class="line">          <span class="string">locals</span> <span class="string">=</span> <span class="string">[</span> <span class="string">class</span> <span class="string">"[Ljava/lang/String;"</span><span class="string">,</span> <span class="string">class</span> <span class="string">java/lang/Object</span> <span class="string">]</span></span><br><span class="line">          <span class="string">stack</span> <span class="string">=</span> <span class="string">[</span> <span class="string">class</span> <span class="string">java/lang/Throwable</span> <span class="string">]</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>反汇编后的效果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">class</span> <span class="string">com.xxx.demo04_synchronized_monitor.Increment</span> <span class="string">implements</span> <span class="string">java.lang.Runnable&#123;</span></span><br><span class="line">  <span class="string">public</span> <span class="string">static</span> <span class="string">int</span> <span class="string">number;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">private</span> <span class="string">static</span> <span class="string">java.lang.Object</span> <span class="string">obj;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">com.xxx.demo04_synchronized_monitor.Increment();</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="attr">0 :</span> <span class="string">aload_0</span></span><br><span class="line">      <span class="attr">1 :</span> <span class="string">invokespecial</span>   <span class="comment">#1       // Method java/lang/Object."&lt;init&gt;":()v</span></span><br><span class="line">      <span class="attr">4 :</span> <span class="string">return</span></span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">void</span> <span class="string">run();</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="attr">0 :</span> <span class="string">iconst_0</span></span><br><span class="line">      <span class="attr">1 :</span> <span class="string">istore_1</span></span><br><span class="line">      <span class="attr">2 :</span> <span class="string">iload_1</span></span><br><span class="line">      <span class="attr">3 :</span> <span class="string">sipush</span>    <span class="number">1000</span></span><br><span class="line">      <span class="attr">6 :</span> <span class="string">if_icmpge</span> <span class="number">39</span></span><br><span class="line">      <span class="attr">9 :</span> <span class="string">getstatic</span> <span class="comment">#2           // Field obj:Ljava/lang/Object</span></span><br><span class="line">      <span class="attr">12:</span> <span class="string">dup</span></span><br><span class="line">      <span class="attr">13:</span> <span class="string">astore_2</span></span><br><span class="line">      <span class="attr">14:</span> <span class="string">monitorenter</span></span><br><span class="line">      <span class="attr">15:</span> <span class="string">getstatic</span> <span class="comment">#3           // Field number:I</span></span><br><span class="line">      <span class="attr">18:</span> <span class="string">iconst_1</span></span><br><span class="line">      <span class="attr">19:</span> <span class="string">iadd</span></span><br><span class="line">      <span class="attr">20:</span> <span class="string">putstatic</span> <span class="comment">#3           // Field number:I</span></span><br><span class="line">      <span class="attr">23:</span> <span class="string">aload_2</span></span><br><span class="line">      <span class="attr">24:</span> <span class="string">monitorexit</span></span><br><span class="line">      <span class="attr">25:</span> <span class="string">goto</span>      <span class="number">33</span></span><br><span class="line">      <span class="attr">28:</span> <span class="string">astore_3</span></span><br><span class="line">      <span class="attr">29:</span> <span class="string">aload_2</span></span><br><span class="line">      <span class="attr">30:</span> <span class="string">monitorexit</span></span><br><span class="line">      <span class="attr">31:</span> <span class="string">aload_3</span></span><br><span class="line">      <span class="attr">32:</span> <span class="string">athrow</span></span><br><span class="line">      <span class="attr">33:</span> <span class="string">iinc</span>      <span class="number">1</span><span class="string">,</span>  <span class="number">1</span></span><br><span class="line">      <span class="attr">36:</span> <span class="string">goto</span>      <span class="number">2</span></span><br><span class="line">      <span class="attr">39:</span> <span class="string">return</span></span><br><span class="line">   <span class="attr">Exception table:</span></span><br><span class="line">        <span class="string">from</span>   <span class="string">to</span>  <span class="string">target</span> <span class="string">type</span></span><br><span class="line">          <span class="number">15</span>   <span class="number">25</span>    <span class="number">29</span>    <span class="string">any</span></span><br><span class="line">          <span class="number">28</span>   <span class="number">31</span>    <span class="number">28</span>    <span class="string">any</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">synchronized</span> <span class="string">void</span> <span class="string">test();</span></span><br><span class="line">    <span class="attr">descriptor:</span> <span class="string">()V</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">ACC_PUBLIC,</span> <span class="string">ACC_SYNCHRONIZED</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">        <span class="string">stack=2,</span>  <span class="string">locals=1,</span>  <span class="string">args_size=1</span></span><br><span class="line">            <span class="attr">0:</span> <span class="string">getstatic</span>     <span class="comment">#4              // Field</span></span><br><span class="line"><span class="attr">java/lang/System.out:Ljava/io/PrintStream:</span></span><br><span class="line">            <span class="attr">3:</span> <span class="string">ldc</span>           <span class="comment">#5              // String a</span></span><br><span class="line">            <span class="attr">5:</span> <span class="string">invokevirtual</span> <span class="comment">#6              // Method java/io/PrintStream.println:(Ljava/lang.String;)V</span></span><br><span class="line">            <span class="attr">8:</span> <span class="string">return</span></span><br><span class="line">        <span class="attr">LineNumberTable:</span></span><br><span class="line">          <span class="attr">line 16:</span> <span class="number">0</span></span><br><span class="line">          <span class="attr">line 17:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">LocalVariableTable:</span></span><br><span class="line">          <span class="string">Start</span>     <span class="string">Length</span>    <span class="string">Slot</span>  <span class="string">Name</span>  <span class="string">Signature</span></span><br><span class="line">            <span class="number">0</span>          <span class="number">9</span>       <span class="number">0</span>     <span class="string">this</span>   <span class="string">Lcom/xxx/demo04_synchronized_monitor/Increment;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">static</span> <span class="string">&#123;&#125;;</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">       <span class="attr">0:</span> <span class="string">iconst_0</span></span><br><span class="line">       <span class="attr">1:</span> <span class="string">putstatic</span>       <span class="comment">#3       // Field number:I</span></span><br><span class="line">       <span class="attr">4:</span> <span class="string">new</span>             <span class="comment">#4       // class java/lang/Object</span></span><br><span class="line">       <span class="attr">7:</span> <span class="string">dup</span></span><br><span class="line">       <span class="attr">8:</span> <span class="string">invokespecial</span>   <span class="comment">#1       // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">      <span class="attr">11:</span> <span class="string">putstatic</span>       <span class="comment">#2       // Field obj:Ljava/lang/Object</span></span><br><span class="line">      <span class="attr">14:</span> <span class="string">return</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>主要是看观看这一块的字节码指令与Demo01.java当中的代码做对比分析:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------</span><br><span class="line">  <span class="keyword">public</span> static <span class="built_in">void</span> main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>,  locals=<span class="number">3</span>;   args_size=<span class="number">1</span></span><br><span class="line">          <span class="number">0</span>: getstatic           #<span class="number">2</span>        <span class="comment">// Field obj:Ljava/lang/Object;</span></span><br><span class="line">          <span class="number">3</span>: dup</span><br><span class="line">          <span class="number">4</span>: astore_1</span><br><span class="line">          <span class="number">5</span>: monitorenter</span><br><span class="line">          <span class="number">6</span>: getstatic           #<span class="number">3</span>        <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">          <span class="number">9</span>: <span class="number">1</span>dc                 #<span class="number">4</span>        <span class="comment">// String 1</span></span><br><span class="line">         <span class="number">11</span>: invokevirtual       #<span class="number">5</span>        <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">14</span>: aload_1</span><br><span class="line">         <span class="number">15</span>: monitorexit</span><br><span class="line">         <span class="number">16</span>: goto                <span class="number">24</span></span><br><span class="line">         <span class="number">19</span>: astore_2</span><br><span class="line">         <span class="number">20</span>: aload_1</span><br><span class="line">         <span class="number">21</span>: monitorexit</span><br><span class="line">         <span class="number">22</span>: aload_2</span><br><span class="line">         <span class="number">23</span>: athrow</span><br><span class="line">         <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">          <span class="keyword">from</span>     to    target   type</span><br><span class="line">             <span class="number">6</span>      <span class="number">16</span>       <span class="number">19</span>    any</span><br><span class="line">            <span class="number">19</span>      <span class="number">22</span>       <span class="number">19</span>    any</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">首先<span class="number">0</span>: getstatic 代表的是获取得到静态的成员变量Object obj的值；</span><br><span class="line">即<span class="keyword">private</span> static Object obj = new Object();</span><br><span class="line"></span><br><span class="line">同步代码块开始的地方即synchronized(obj)&#123; 对应于字节码指令当中的<span class="number">5</span>: monitorenter指令；</span><br><span class="line">那么接着往下字节码指令当中的<span class="number">6</span>: getstatic 其实对应着java代码层中的System.<span class="keyword">out</span>.println(<span class="string">"1"</span>);该句中的<span class="keyword">out</span>变量；到时候进行执行其实是进行执行的println()方法；</span><br><span class="line">那么结束的时候就需要注意了，同步代码块synchronized结束的地方也就是synchronized(obj)&#123; 的返回花括号&#125;处，即对应着字节码指令当中的<span class="number">15</span>: monitorexit</span><br><span class="line">那么字节码指令monitorenter与monitorexit这两个字节码指令分别有什么含义呢？</span><br></pre></td></tr></table></figure><h3 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h3><p>首先来看一下JVM规范中对于 monitorenter 和 monitorexit 的描述：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>docs.oracle.com<span class="regexp">/javase/</span>specs<span class="regexp">/jvms/</span>se8<span class="regexp">/html/</span>jvms-<span class="number">6</span>.html<span class="comment">#jvms-6.5.monitorenter</span></span><br><span class="line"></span><br><span class="line">https:<span class="regexp">//</span>docs.oracle.com<span class="regexp">/javase/</span>specs<span class="regexp">/jvms/</span>se8<span class="regexp">/html/i</span>ndex.html</span><br></pre></td></tr></table></figure><p>（Oracle官方 java虚拟机规范文档；Java虚拟机有好多种Oracle公司有，IBM公司也有，淘宝也有；java虚拟机是一套规范；该文档指的就是java虚拟机的规范）  </p><blockquote><p>Each object is associlated with a monitor.<br>A monitor is locked if and only if it has an owner.<br>The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p></blockquote><ul><li>If the entry count of the monitor associated with objectref is zero,<br>the thread enters the monitor and sets its entry count to one.<br>The thread is then the owner of the monitor.</li><li>If the thread already owns the monitor associated with objectref,<br>it reenters the monitor, incrementing its entry count.</li><li>If another thread already owns the monitor associated with objectref,<br>the thread blocks until the monitor’s entry count is zero,<br>then tries again to gain ownership.</li></ul><p>翻译过来：<br>  每一个对象 都会和 一个监视器monitor关联。<br>  监视器被占用时会被锁住，其他线程无法来获取该monitor。<br>  （其实可以理解为这个monitor才是真正的锁）<br>  当JVM执行某个线程的某个方法内部的monitorenter时，它会尝试去获取当前对象对应的monitor的所有权。<br>  （即尝试去获取这把锁；有可能获取得到有可能获取不到）<br>  其过程如下：</p><ol><li>若monitor的进入数为0，线程可以进入 monitor，并将 monitor的进入数 置为1。 当前线程成为 monitor的 owner（所有者）。</li><li>若线程已拥有 monitor的所有权，允许它 重入 monitor，则进入monitor的进入数加1。</li><li>若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，直到monitor的进入数变为0，才能重新尝试获取monitor的所有权。</li></ol><p>monitorenter线程获取锁，宁进入同步代码块。<br>同时只能有一个线程获取锁。<br>monitorenter 插入在同步代码块的开始位置，当底代码执行到该指令时，将会尝试获取该对象monitor的所有权，即尝试获得该对象的锁。</p><blockquote><p>monitorenter流程分析</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">分析<span class="keyword">monitor</span>流程画图说明：</span><br><span class="line">通过刚才的描述可以知道synchronized是需要传一个对象进来也就是对象锁；</span><br><span class="line">即synchronized(obj)&#123;；</span><br><span class="line">而真正的锁并非是这个传入进来的该对象obj；</span><br><span class="line">而是该对象obj会去关联一个叫做<span class="keyword">monitor</span>的东西，而这个叫做<span class="keyword">monitor</span>的东西才是真正的锁；</span><br><span class="line">而这个对象<span class="keyword">monitor</span>并非是手动式使用代码进行创建的；</span><br><span class="line">当拿到一个对象放到同步代码块的参数当中来；</span><br><span class="line">即synchronized(obj)&#123;中来的时候，JVM会去进行检查该对象obj是否有进行关联<span class="keyword">monitor</span>对象；</span><br><span class="line">如果JVM进行检测得到该对象obj没有进行关联<span class="keyword">monitor</span>对象的话那么就会去创建一个与之关联的<span class="keyword">monitor</span>对象；</span><br><span class="line">而且该<span class="keyword">monitor</span>对象还需要进行注意的是<span class="keyword">monitor</span>并不是一个java对象；</span><br><span class="line"><span class="keyword">monitor</span>而是一个C++对象；</span><br><span class="line">在<span class="keyword">monitor</span>对象当中又这么几个内容是需要注意的；</span><br><span class="line"><span class="keyword">monitor</span>当中有两个比较重要的成员变量；</span><br><span class="line">一个是owner：指的是用有锁的线程；</span><br><span class="line">另一个是recursions:指的是记录获取锁的次数；</span><br><span class="line">当JVM执行到monitorenter的时候；那么会找到该对象Object obj上的<span class="keyword">monitor</span>对象看这个Object obj所关联的<span class="keyword">monitor</span>锁对象是否被别的线程所拿走了；如果别的线程没有拿走即没有竞争走；那么当前该线程就来获取该<span class="keyword">monitor</span>锁对象；</span><br><span class="line">首先先会将<span class="keyword">monitor</span>锁对象中的成员变量owner变成当前线程；</span><br><span class="line">现在假设t1线程来执行到同步代码块synchronized(obj)&#123;；</span><br><span class="line">那么当t1线程来执行同步代码块的时候就会找到该Object obj对象所关联的<span class="keyword">monitor</span>对象；看这个所关联的<span class="keyword">monitor</span>有没有被其他的锁给获取得到；</span><br><span class="line">如何查看该<span class="keyword">monitor</span>是否有被其他线程获取得到？</span><br><span class="line">如果别的线程没有竞争得到该<span class="keyword">monitor</span>锁对象，那么该锁对象<span class="keyword">monitor</span>的owner成员变量属性就会变成当前线程t1；</span><br><span class="line">那么这也是t1线程第一次进入同步代码块当中来；</span><br><span class="line">所以<span class="keyword">monitor</span>其成员变量recursions（记录获取锁的次数，计数器）也会进行改变取值进行++操作；即当前由<span class="number">0</span>变为<span class="number">1</span>；</span><br><span class="line">接着t1线程就拥有了这把锁，即Object obj所关联的锁对象<span class="keyword">monitor</span>从而进入了同步代码块synchronized(obj)&#123;&#125;当中；</span><br><span class="line">在t1进入到同步代码块中时如果同步代码块当中依然存在有同步代码块，即嵌套的同步代码块时并且锁对象依然还是Object obj的话则；synchronized具有可重入特性；那么这个时候t1线程就会重入到嵌套同步代码块中去；重入的话就会将Object obj所关联的<span class="keyword">monitor</span>锁对象的成员变量属性取值recursions计数器的取值进行++操作；即由次数<span class="number">1</span>变为次数<span class="number">2</span>；那么也就是说出一次同步代码块计数器recursions进行--操作即次数减一操作，由<span class="number">2</span>变为<span class="number">1</span>；这种类似；</span><br><span class="line">另外当t1线程进入同步代码块时，并执行到输出打印语句“<span class="number">1</span>”时；</span><br><span class="line">此时<span class="meta">CPU</span>切换到了t2线程上；那么t2线程同时会来进行执行Runnable当中所实现的run()方法内容；</span><br><span class="line">那么t2线程也会来进行竞争获取得到这把锁；即Object obj所关联的锁对象<span class="keyword">monitor</span>；</span><br><span class="line">那么此时由于线程t1并没有进行释放锁操作，<span class="meta">CPU</span>就开始进行切换到了线程t2上来了；</span><br><span class="line">那么这个时候t2线程就会发现Object obj所关联的<span class="keyword">monitor</span>锁对象当中的成员变量属性取值为并不是当前线程t2而是线程t1；</span><br><span class="line">那么通过这个观察也就知道当前获取锁的线程是哪一个线程了；</span><br><span class="line">那么此时t2线程就会进入阻塞状态；</span><br><span class="line">那么这个就是monitorenter的原理；</span><br></pre></td></tr></table></figure><h4 id="monitorenter小结"><a href="#monitorenter小结" class="headerlink" title="monitorenter小结"></a>monitorenter小结</h4><p>synchronized的锁对象会关联一个monitor，<br>这个monitor不是主动进行创建的，<br>而是JVM的线程执行到这个同步代码块时，<br>会检查发现到对象没有monitor，那么此时就会创建monitor；<br>monitor内部有两个重要的成员变量；<br>owner: 拥有这把锁的线程；<br>recursions: 会记录线程拥有锁的次数；<br>当一个线程拥有monitor之后其他的线程只能够进行等待；</p><h3 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h3><p>首先来看一下 JVM规范 中对于 monitorenter和monitorexit的描述：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>docs.oracle.com<span class="regexp">/javase/</span>specs<span class="regexp">/jvms/</span>se8<span class="regexp">/html/</span>jvms-<span class="number">6</span>.html<span class="comment">#jvms-6.5.monitorexit</span></span><br></pre></td></tr></table></figure><blockquote><p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced ny objectref.<br>  The thread decrements the entry count of the monitor associated with objectref.<br>  iIf as a result the value of the entry count is zero , the thread exits the monitor and is no longer its owner.<br>  Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p></blockquote><p>翻译过来：</p><ol><li>能执行 monitorexit 指令的线程 一定是 拥有当前对象的 monitor的所有权的线程。</li><li>执行 monitorexit时 会将 monitor的进入数减1。 当monitor的进入数减为0时，当前线程退出monitor，不再拥有monitor的所有权，此时其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。</li></ol><p>monitorexit：释放锁；<br>monitorexit插入在方法结束处和异常处；<br>JVM保证每个 monitorenter必须有对应的monitorexit；</p><blockquote><p>monitorexit流程分析</p></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">假设线程t1获取拿到Object obj所关联的对象锁monitor之后从而进入到同步代码块当中走到要结束同步代码块的位置，即synchronized(obj)&#123;所对应返回&#125;花括号的位置处，即将要释放锁的位置；</span><br><span class="line">t1线程执行完同步代码块之后就会执行字节码指令15: monitorexit 指令；</span><br><span class="line">遇到这个指令之后，就会去找到这个锁对象Object obj真正的锁对象monitor；</span><br><span class="line">找到之后会进行对monitor的成员变量的属性取值owner以及recursions进行更改赋值；</span><br><span class="line">那么此时线程t1仍然在拥有着这把锁；所以此时monitor的owner依然是当前线程t1，不需要改变；</span><br><span class="line">而线程t2即将要出同步代码块，则recursions计数器就需要进行减一操作；即赋值为0，由1变为0；</span><br><span class="line">当monitor锁对象的成员变量recursions计数器取值变为0时也就代表着当前线程t1释放了当前其所拥有的这一把锁；</span><br><span class="line">那么同时monitor锁对象的成员变量owner属性取值即锁的拥有者也不存在了；</span><br><span class="line"></span><br><span class="line">另外还需要注意一个问题；</span><br><span class="line">进入同步代码块时：synchronized(obj)&#123; ------→ 字节码指令5: monitorenter</span><br><span class="line">出同步代码块时：&#125;  ------→ 字节码指令15: monitorexit</span><br><span class="line">除了这两处地方存在有monitor相关的指令之外其余的地方也存在有monitor相关字节码指令操作；</span><br><span class="line">即 21: monitorexit（为什么此处也存在有monitor相关字节码指令操作呢？）</span><br><span class="line"></span><br><span class="line">字节码指令最下面的Exception table称作为异常表；即：</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="code">      Exception table:</span></span><br><span class="line"><span class="code">          from     to    target   type</span></span><br><span class="line"><span class="code">             6      16       19    any</span></span><br><span class="line"><span class="code">            19      22       19    any</span></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">from ... to : 指的是从哪一行到哪一行；即指的是6~16行或者19~22行之间的字节码指令；</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="code">          6: getstatic           #3        // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="code">          9: 1dc                 #4        // String 1</span></span><br><span class="line"><span class="code">         11: invokevirtual       #5        // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line"><span class="code">         14: aload_1</span></span><br><span class="line"><span class="code">         15: monitorexit</span></span><br><span class="line"><span class="code">         16: goto                24</span></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">也就是所对应在java代码当中的：</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">synchronized(obj)&#123;</span><br><span class="line"><span class="code">  System.out.println("1");</span></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">也就意味着如果同步代码块当中的代码当中出现了异常；</span><br><span class="line">那么也就是指的字节码指令6~16行出现了异常则target为19；</span><br><span class="line">那么也就会走字节码指令编号为19的字节码指令代码：即19: astore<span class="emphasis">_2</span></span><br><span class="line"><span class="emphasis">那么执行完字节码指令19之后继续向下执行字节码指令20: aload_</span>1、21: monitorexit；</span><br><span class="line">也就说明了其最终也会去进行释放锁；</span><br><span class="line">这也就是在告知：如果在同步代码块当中出现了异常；monitor会自动帮助释放锁即monitorexit字节码指令；</span><br></pre></td></tr></table></figure><p><strong>面试题</strong>：synchronized出现异常会释放锁吗？</p><p>答：会释放锁；</p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>docs.oracle.com<span class="regexp">/javase/</span>specs<span class="regexp">/jvms/</span>se8<span class="regexp">/html/</span>jvms-<span class="number">2</span>.html<span class="comment">#jvms-2.11.10</span></span><br></pre></td></tr></table></figure><p>可以看到 同步方法 在反汇编之后，<br>会增加<code>ACC_SYNCHRONIZED</code>修饰。<br>会隐式地调用 monitorenter和monitorexit。<br>在执行 同步方法 之前会调用monitorenter，在执行完同步方法后会调用monitorexit；</p><blockquote><p>查看反汇编之后的字节码指令-同步方法</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> synchronized <span class="built_in">void</span> test();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>,    locals=<span class="number">1</span>,     args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: getstatic         #<span class="number">3</span>        <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">3</span>: <span class="number">1</span>dc               #<span class="number">6</span>        <span class="comment">// String a</span></span><br><span class="line">        <span class="number">5</span>: invokevirtual     #<span class="number">5</span>        <span class="comment">// Method java/io/PrintStream.println(Ljava/lang/String;)V</span></span><br><span class="line">    LineNUmberTable:</span><br><span class="line">      line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTalbe:</span><br><span class="line">      Start       Length       Slot     Name     Signature</span><br><span class="line">          <span class="number">0</span>            <span class="number">9</span>          <span class="number">0</span>     <span class="keyword">this</span>     Lcom/xxx/demo04_synchronized_monitor/Demo01;</span><br><span class="line">......</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">对应的代码：</span><br><span class="line"><span class="keyword">public</span> synchronized <span class="built_in">void</span> test()&#123;</span><br><span class="line">  System.<span class="keyword">out</span>.println(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">同步方法test()内部并没有形成monitorenter以及monitorexit；</span><br><span class="line">只是对该方法做了一个标识；即观察flags:标识；</span><br><span class="line">ACC_SYNCHRONIZED：那么该标识的作用即在于（在JVM规范当中也有相关说明）同步方法会被JVM隐式地调用monitorenter和monitorexit；</span><br><span class="line">也就是说java虚拟机的线程执行到同步方法的时候它会自动的去调用字节码指令monitorenter；</span><br><span class="line">当执行完同步方法之后也会自动的去调用字节码指令monitorexit；</span><br><span class="line">即所谓隐式调用；</span><br></pre></td></tr></table></figure><h3 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h3><p>通过 javap反汇编，看到synchronized使用变成了monitorenter和monitorexit两个字节码指令；真正的锁是monitor；每个锁对象都会关联一个monitor(监视器,monitor才是真正的锁对象)，monitor内部有两个重要的成员变量owner（owner：会保存获得锁的线程）和recursions（会保存线程获得锁的次数）；<br>执行monitorenter那么线程就会来进行竞争monitor这把锁；<br>抢到monitor这把锁之后；<br>就会将monitor当中的成员变量owner的取值改为当前抢到锁的该线程；<br>以及拥有锁的次数recursions变为1；<br>如果再次进入同步代码块即嵌套同步代码块也是同样的这一把锁；<br>那么（可重入特性）重入即monitor的成员变量recursions的取值就会进行加一操作；<br>当执行到monitorexit时，那么monitor的成员变量recursions计数器就会进行减一操作；<br>当monitor的计数器recursions减到0时，那么当前拥有该锁monitor的现场称就会去进行释放锁；</p><h2 id="面试题：synchronized与Lock的区别"><a href="#面试题：synchronized与Lock的区别" class="headerlink" title="面试题：synchronized与Lock的区别"></a>面试题：synchronized与Lock的区别</h2><p><strong>1、</strong> synchronized是关键字，而Lock是一个接口（ReentrantLock为其实现类）。  </p><p>synchronized是JDK提供的一个关键字；无法查看得到其源码；<br>synchronized由JVM直接来支持的；<br>而前面所使用到的Lock实际上是一个接口；</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  <span class="doctag">@since</span> 1.5            //从jdk1.5之后有的</span></span><br><span class="line"><span class="comment">  <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span></span>&#123;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*并且该接口Lock存在相应的实现类；</span></span><br><span class="line"><span class="comment">  ReadLockView in StampedLock (java.util.concurrent.....)</span></span><br><span class="line"><span class="comment">  WriteLock in ReetrantReadWriteLock (java.....)</span></span><br><span class="line"><span class="comment">  ReentrantLock (java.util.concurrent.locks)</span></span><br><span class="line"><span class="comment">  WriteLockView in StampedLock (java.util.concurrent....)</span></span><br><span class="line"><span class="comment">  ReadLock in ReentrantReadWriteLock (java....)</span></span><br><span class="line"><span class="comment">  这些实现类当中大部分都在(WriteLock in )ReetrantReadWriteLock类当中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><strong>2、</strong> synchronized会自动释放锁，而Lock必须手动释放锁。  </p><p>通过javap 反汇编的形式就可以进行查看得到；<br>synchronized并没有手动的去获取锁以及释放锁；<br>它在反汇编之后会形成相应的字节码指令；<br>当执行到synchronized(obj){ 的时候会执行到5: monitorenter字节码指令；<br>当执行到synchronized(obj){所对应的回括号}（同步代码块执行完时）时会执行到15: monitorexit字节码指令；<br>并且就算同步代码块当中出现了异常；synchronized也会将锁给释放掉；<br>即Exception table中from…to的6~16行字节码指令如果出现异常则target跳转至字节码指令19行执行 19: astore_2以及接着19行字节码指令继续往下进行执行；20: aload_1、21: monitorexit即释放锁；  </p><p>而Lock就需要手动的来进行释放锁；<br>当去尝试获取锁之后获取返回得到boolean类型变量；<br>根据该布尔类型变量判断是否获取得到了锁；<br>并且在finally块当中需要进行保证锁的释放<br>（前提是如果tryLock返回为true则需要进行执行unlock()操作；如果tryLock返回为true但是没有执行unlock操作那么就将会导致锁一直不释放；）</p><p><strong>3、</strong> synchronized是不可中断的，而Lock可以是不可中断的也可以是可中断的。  </p><p>synchronized：当有一个线程执行到synchronized同步代码块当中执行代码的时候；另外一个线程由于没有锁只能够在同步代码块外侧进行等待操作；<br>这个等待的线程是不能够被中断的，它会一直等待获取锁；  </p><p>而Lock有两种处理方式：可以中断也可以不中断；<br>一种是可中断式的采用tryLock()的方式；<br>（尝试去获取锁，并且可以定义等待获取锁的时间以及时间单位；指定等待获取锁的时间到了如果仍然没有获取得到锁的话那么这个时候是可以中断的，即一直处于等待状态的线程不必再进行等待获取锁而是可以去执行其他的任务）<br>另外一种是lock()方式的而这种方式是不可中断的；</p><p><strong>4、</strong> 通过Lock可以知道线程有没有拿到锁（tryLock()），而synchronized不能。  </p><p>比如说Lock定义使用了其tryLock(3, TimeUnit.SECONDS);方法；<br>则将返回有布尔类型的取值；<br>如果其返回值为true则说明当前该等待的线程拿到了锁；<br>如果其返回值为false则说明当前等待的该线程并没有拿到锁；则进行中断完成其他的操作；<br>而synchronized是不能够去进行判断有没有拿到锁的；synchronized就是一个代码块；<br>比如说这段代码当中拿到锁则自动进入同步代码块当中执行相应的打印操作；没有拿到锁则只能够在同步代码块外侧进行等待拿到锁的线程进行释放锁；如果没有释放则将一直等待；</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">  System.<span class="keyword">out</span>.println(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、</strong> synchronized能锁住方法和代码块，而Lock只能锁住代码块。  </p><p>通过语法层面可以看到synchronized可以用来锁住方法以及代码块；<br>而Lock只能够锁住代码块而不能锁住方法；<br>也就是该Lock只能够在方法内部进行调用；<br>而不能将Lock放到方法上进行修饰方法；</p><p><strong>6、</strong> Lock可以使用读锁提高多线程效率。  </p><p>Lock当中有一个实现类叫做ReentrantReadWriteLock；<br>这种锁可以进行提高读的效率的；</p><p>ReentrantReadWriteLock.java<br>这个锁的机制是这样的；<br>如果在读的时候它允许多个线程来进行读操作；<br>那么如果写的时候那就只能一个线程来进行写也不能进行读取操作；<br>所以它是可以提高多个线程来进行读的效率。</p><p><strong>7、</strong> synchronized是非公平锁，ReentrantLock可以控制是否是公平锁。  </p><p>synchronized是非公平锁；<br>即其进行唤醒的时候并不是公平的先来后到的方式来进行唤醒；<br>举个例子：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pubilc <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">  synchronized(obj)&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"1"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设一个线程A先进行获取得到锁从而进入同步代码块当中进行执行相关内容如打印“1”；<br>那么后面还有其他的线程B、C、D、E、F……进来；那么后面的线程B、C、D、E、F……在抢不到锁，即第一个线程A没有释放锁的情况下，只能在同步块外侧进行等待；<br>那么此时假设线程A执行完同步代码块之后；那么肯定就需要去唤醒等待在同步代码块外侧的线程B、C、D、E、F……中的某一个来获取锁进入同步代码块中；<br>那么唤醒的时候则不是按照先来后到的方式进行唤醒；<br>而是属于随机的唤醒一个线程；<br>所以；synchronized是非公平的；<br>而ReentrantLock是可以去进行控制它是否为公平锁的；</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 此时使用的是ReentrantLock当中的无参构造器；</span><br><span class="line">//而无参构造器默认是非公平的；</span><br><span class="line">private<span class="keyword"> static</span> Lock lock =<span class="built_in"> new </span>ReentrantLock();</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line">ReentrantLock.java</span><br><span class="line">/**</span><br><span class="line">  Creates an<span class="built_in"> instance </span>of &#123;@code ReentantLock&#125;</span><br><span class="line">  This is equivalent to using &#123;@Code ReentrantLock(false)&#125;</span><br><span class="line">  无参构造器</span><br><span class="line">*/</span><br><span class="line">public ReentrantLock()&#123;</span><br><span class="line">  sync =<span class="built_in"> new </span>NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  Creates an<span class="built_in"> instance </span>of &#123;@code ReentrantLock&#125; with the</span><br><span class="line">  given fairness policy.</span><br><span class="line">  有参构造器；boolean类型操作来指定ReentrantLock是否公平；</span><br><span class="line">  也就是唤醒等待线程的时候是否采用先来后到的方式进行唤醒；</span><br><span class="line">  如果是先来后到的方式那么就是采用的是公平锁；</span><br><span class="line">  如果不是先来后到的方式那么就是非公平锁；</span><br><span class="line"></span><br><span class="line">  @param fair&#123;@code true&#125;<span class="built_in"> if </span>this lock should use a fair ordering policy.</span><br><span class="line">*/</span><br><span class="line">public ReentrantLock(boolean fair)&#123;</span><br><span class="line">  sync = fair ?<span class="built_in"> new </span>FairSync()<span class="keyword"> :</span><span class="built_in"> new </span>NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深入JVM源码-monitor监视器锁"><a href="#深入JVM源码-monitor监视器锁" class="headerlink" title="深入JVM源码-monitor监视器锁"></a>深入JVM源码-monitor监视器锁</h2><p>synchronized是java当中的一个关键字；<br>通过java是看不到synchronized关键字源码的；<br>synchronized是由JVM直接来进行支持的；<br>现在通过JVM源码的方式来进行分析synchronized原理；<br>JVM的源代码是使用C++编写的；那么介绍IDE工具来方便查看JVM的源代码；<br>synchronized本质是通过monitor然后来进行同步操作的；<br>那么会详细介绍monitor的结构；<br>另外当存在有多个线程来执行synchronized的时候，只存在有一个线程竞争得到锁，那么这个时候就会来进行介绍monitor的竞争；<br>以及线程没有竞争得到锁是如何处理的也就是monitor等待；<br>以及synchronized执行完成之后线程要释放锁；那么线程是如何来进行释放的呢？<br>这里就牵扯到了monitor释放；<br>最后还会介绍到monitor是一个重量级锁，monitor其性能开销比较大；</p><p>学习部分分为：</p><ul><li>深入JVM源码<ul><li>目标</li><li>JVM源码下载</li><li>IDE(Clion)下载</li><li>monitor监视器锁</li><li>monitor竞争</li><li>monitor等待</li><li>monitor释放</li><li>monitor是重量级锁</li></ul></li></ul><h3 id="目标-12"><a href="#目标-12" class="headerlink" title="目标"></a>目标</h3><p>通过JVM源码 分析 synchronized的原理</p><h3 id="JVM源码下载"><a href="#JVM源码下载" class="headerlink" title="JVM源码下载"></a>JVM源码下载</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//openjdk.java.net/</span></span><br><span class="line">选中左边菜单栏中[Source Code]下的子菜单栏[Mercurial]</span><br><span class="line">点击完之后得到的就是jdk所有源代码的一个托管结构；</span><br><span class="line">那么在这当中找到jdk8；</span><br><span class="line">找到的页面：http:<span class="comment">//hg.openjdk.java.net/jdk8</span></span><br><span class="line">页面中就是jdk8的源码；</span><br><span class="line">选择hotspot进行下载，Hotspot是jdk自带的虚拟机；</span><br><span class="line">进行跳转页面：http:<span class="comment">//hg.openjdk.java.net/jdk8/hotspot</span></span><br><span class="line">看到左侧菜单栏选择zip格式进行下载源代码；</span><br><span class="line">S<span class="function"><span class="title">ource</span> Code ---&gt;</span> M<span class="function"><span class="title">ercurial</span> ---&gt;</span> <span class="function"><span class="title">jdk8</span> ---&gt;</span> <span class="function"><span class="title">hotspot</span> ---&gt;</span> zip</span><br></pre></td></tr></table></figure><p>java 是开源的；<br>那么java开源部分的代码就属于在openjdk这个项目当中；<br>那么在该网站当中就能够下载得到其源代码；</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">jvm所有的源码都在其src目录下；</span><br><span class="line"><span class="title">.ideea</span></span><br><span class="line"><span class="title">.jcheck</span></span><br><span class="line">agent</span><br><span class="line">cmake-build-debug</span><br><span class="line">make</span><br><span class="line">src</span><br><span class="line"><span class="title">.hg_archival.txt</span></span><br><span class="line"><span class="title">.hgignore</span></span><br><span class="line"><span class="title">.hgtags</span></span><br><span class="line">ASSEMBLY<span class="emphasis">_EXCEPTION</span></span><br><span class="line"><span class="emphasis">CMakeLists.txt</span></span><br><span class="line"><span class="emphasis">LICENSE</span></span><br><span class="line"><span class="emphasis">README</span></span><br><span class="line"><span class="emphasis">THIRD_</span>PARTY<span class="emphasis">_README</span></span><br><span class="line"><span class="emphasis">--------------------------------------</span></span><br><span class="line"><span class="emphasis">src下的目录又分成几个部分：</span></span><br><span class="line"><span class="emphasis">cpu</span></span><br><span class="line"><span class="emphasis">os</span></span><br><span class="line"><span class="emphasis">os_</span>cpu</span><br><span class="line">share</span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">第一部分cpu；cpu跟虚拟机相关的一些代码；</span><br><span class="line">其下目录有</span><br><span class="line">sparc</span><br><span class="line">x86</span><br><span class="line">zero</span><br><span class="line">----------------------------------------</span><br><span class="line">第二部分os: 操作系统（也就是虚拟机在不同的操作系统当中存在有一些特别的代码）</span><br><span class="line">其下目录有</span><br><span class="line">bsd</span><br><span class="line">linux</span><br><span class="line">posix</span><br><span class="line">solaris</span><br><span class="line">windows</span><br><span class="line">-------------------------------------------</span><br><span class="line">第三部分os<span class="emphasis">_cpu: 与cpu相关也与操作系统相关的一些特殊代码</span></span><br><span class="line"><span class="emphasis">其下目录有</span></span><br><span class="line"><span class="emphasis">bsd_</span>x86</span><br><span class="line">bxd<span class="emphasis">_zero</span></span><br><span class="line"><span class="emphasis">linux_</span>sparc</span><br><span class="line">linux<span class="emphasis">_x86</span></span><br><span class="line"><span class="emphasis">linux_</span>zero</span><br><span class="line">solaris<span class="emphasis">_sparc</span></span><br><span class="line"><span class="emphasis">solaris_</span>x86</span><br><span class="line">windows<span class="emphasis">_x86</span></span><br><span class="line"><span class="emphasis">-------------------------------------------------------</span></span><br><span class="line"><span class="emphasis">第四部分share: 即公共的JVM源码</span></span><br><span class="line"><span class="emphasis">其下目录有</span></span><br><span class="line"><span class="emphasis">tools //工具类</span></span><br><span class="line"><span class="emphasis">vm    //所有JVM公共的源码都在vm当中</span></span><br><span class="line"><span class="emphasis">-------------------------------------------------------</span></span><br><span class="line"><span class="emphasis">-------------------------------------------------------</span></span><br><span class="line"><span class="emphasis">vm目录下又分有一些子目录：</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">adlc</span></span><br><span class="line"><span class="emphasis">asm</span></span><br><span class="line"><span class="emphasis">c1</span></span><br><span class="line"><span class="emphasis">ci</span></span><br><span class="line"><span class="emphasis">classfile</span></span><br><span class="line"><span class="emphasis">code</span></span><br><span class="line"><span class="emphasis">compiler</span></span><br><span class="line"><span class="emphasis">gc_</span>implementation</span><br><span class="line">gc<span class="emphasis">_interface</span></span><br><span class="line"><span class="emphasis">interpreter</span></span><br><span class="line"><span class="emphasis">libadt</span></span><br><span class="line"><span class="emphasis">memory</span></span><br><span class="line"><span class="emphasis">oops</span></span><br><span class="line"><span class="emphasis">opto</span></span><br><span class="line"><span class="emphasis">precompiled</span></span><br><span class="line"><span class="emphasis">prims</span></span><br><span class="line"><span class="emphasis">runtime</span></span><br><span class="line"><span class="emphasis">Xusage.txt</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">-----------------------------------------------------</span></span><br><span class="line"><span class="emphasis">-----------------------------------------------------</span></span><br><span class="line"><span class="emphasis">主要关注vm文件夹下的</span></span><br><span class="line"><span class="emphasis">oops：即面向对象即一些类的描述类的结构都存储放在该文件夹下；</span></span><br><span class="line"><span class="emphasis">runtime文件夹：主要是一些线程还有一些monitor锁都在该文件夹下。</span></span><br><span class="line"><span class="emphasis">---------------------------------------------------------</span></span><br></pre></td></tr></table></figure><h3 id="IDE-Clion-下载"><a href="#IDE-Clion-下载" class="headerlink" title="IDE(Clion)下载"></a>IDE(Clion)下载</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------</span><br><span class="line">下载c++的ide:</span><br><span class="line">https://www.jetbrains.com/</span><br><span class="line"><span class="code">          |</span></span><br><span class="line"><span class="code">          ↓</span></span><br><span class="line">https://jetbrains.com/clion/</span><br><span class="line">-----------------------------------</span><br><span class="line"></span><br><span class="line">导入java虚拟机的源码：</span><br><span class="line">File--&gt;new Project；</span><br><span class="line">导入文件夹当中的源码；</span><br><span class="line">该文件夹即为当前该目录的文件夹；</span><br><span class="line"><span class="title">.ideea</span></span><br><span class="line"><span class="title">.jcheck</span></span><br><span class="line">agent</span><br><span class="line">cmake-build-debug</span><br><span class="line">make</span><br><span class="line">src</span><br><span class="line"><span class="title">.hg_archival.txt</span></span><br><span class="line"><span class="title">.hgignore</span></span><br><span class="line"><span class="title">.hgtags</span></span><br><span class="line">ASSEMBLY<span class="emphasis">_EXCEPTION</span></span><br><span class="line"><span class="emphasis">CMakeLists.txt</span></span><br><span class="line"><span class="emphasis">LICENSE</span></span><br><span class="line"><span class="emphasis">README</span></span><br><span class="line"><span class="emphasis">THIRD_</span>PARTY<span class="emphasis">_README</span></span><br></pre></td></tr></table></figure><h3 id="monitor监视器锁"><a href="#monitor监视器锁" class="headerlink" title="monitor监视器锁"></a>monitor监视器锁</h3><p>(JVM底层由C++实现)</p><p>可以看出 无论是 synchronized代码块 还是 synchronized方法，<br>（最终需要一个java对象；而java对象又会关联到一个monitor监视器锁的东西；真正的同步是靠monitor监视器锁来实现的；那么monitor监视器锁的结果是什么样的？）<br>其线程安全的语义实现 最终依赖一个叫 monitor的东西，那么这个神秘的东西是什么呢？<br>下面来详细介绍一下。</p><p>在HotSpot虚拟机中，monitor是由ObjectMonitor实现的。<br>其源码是用c、c++来实现的，位于HotSpot虚拟机源码 ObjectMonitor.hpp文件中（src/share/vm/runtime/objectMonitor.hpp）。<br>ObjectMonitor主要数据结构如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 构造器，给很多的成员变量赋值（让其与java源代码组合起来进行分析比较方便）</span></span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">  _header              = NULL;</span><br><span class="line">  _<span class="built_in">count</span>               = <span class="number">0</span>;</span><br><span class="line">  _waiters             = <span class="number">0</span>;</span><br><span class="line">  _recursions          = <span class="number">0</span><span class="comment">; // 线程的重入次数</span></span><br><span class="line">  _object              = NULL<span class="comment">; //存储该monitor的对象</span></span><br><span class="line">  _owner               = NULL<span class="comment">; //标识拥有该monitor的线程</span></span><br><span class="line">  _WaitSet             = NULL<span class="comment">; //处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">  _WaitSetLock         = <span class="number">0</span>;</span><br><span class="line">  _Responsible         = NULL;</span><br><span class="line">  _succ                = NULL;</span><br><span class="line">  _cxq                 = NULL<span class="comment">; // 多线程竞争锁时的单项列表</span></span><br><span class="line">  FreeNext             = NULL;</span><br><span class="line">  _EntryList           = NUll<span class="comment">; //处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">  _SpinFreq            = <span class="number">0</span>;</span><br><span class="line">  _SpinClock           = <span class="number">0</span>;</span><br><span class="line">  OwnerIsThread        = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">  <span class="keyword">synchronized(obj)&#123;</span></span><br><span class="line"><span class="keyword"> </span>   System.out.println(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">    obj.<span class="keyword">wait();</span></span><br><span class="line"><span class="keyword"> </span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">分析：</span><br><span class="line"><span class="keyword">Java代码：synchronized(obj)&#123; </span>同步代码块需要一个<span class="keyword">java对象，类对象都可以；</span></span><br><span class="line"><span class="keyword">那么这个java对象new出来是肯定存放在java内存结构当中的堆中的；</span></span><br><span class="line"><span class="keyword">那么对象当中存在一些什么呢？</span></span><br><span class="line"><span class="keyword">以前知道对象当中存在有成员变量；</span></span><br><span class="line"><span class="keyword">堆中会存放对象中的成员变量；也叫示例数据；</span></span><br><span class="line"><span class="keyword">那么其实；除了示例数据以外还会有一个叫做对象头的内容；</span></span><br><span class="line"><span class="keyword">那么这个对象头的作用就在于保存对应的monitor对象；</span></span><br><span class="line"><span class="keyword">这个对象会关联一个monitor对象；那么这个monitor对象如何来的呢？</span></span><br><span class="line"><span class="keyword">monitor时候由C++的类ObjectMonitor.hpp所造的这样一个对象；</span></span><br><span class="line"><span class="keyword">首先在ObjectMonitor.hpp当中进行查看一些比较重要的成员变量；</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">_recursions；_recursions记录线程拿了几次锁了；即线程锁重入的次数；</span></span><br><span class="line"><span class="keyword">举个例子:</span></span><br><span class="line"><span class="keyword">假设线程第一次进入同步代码块中；获取得到锁对象；即synchronized(obj)&#123;；</span></span><br><span class="line"><span class="keyword">那么此时锁对象所关联的monitor对象当中的成员属性中的_recursions就会记录拿了一次；</span></span><br><span class="line"><span class="keyword">那么假设该同步代码块当中还存在了一个同步代码块即嵌套同步代码块以及同样的一把锁；</span></span><br><span class="line"><span class="keyword">那么这个_recursions计数器就会执行加1操作；</span></span><br><span class="line"><span class="keyword">假设该嵌套同步代码块当中还存在有一个同步代码块且依旧是同样的一把锁，</span></span><br><span class="line"><span class="keyword">那么这个_recursions计数器就又会执行加1操作；</span></span><br><span class="line"><span class="keyword">接着如果当前线程出一个同步代码块那么计数器_recursions就会减1；</span></span><br><span class="line"><span class="keyword">再出一个同步代码块_recursions减1；</span></span><br><span class="line"><span class="keyword">直到_recursions减到0为止就说明该线程就把该锁给释放掉了；</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">_object: </span>存储该monitor的对象；</span><br><span class="line">即该_object会进行存储<span class="keyword">java对象即 </span><span class="keyword">synchronized(obj)&#123;&#125;中的obj对象；</span></span><br><span class="line"><span class="keyword">也就是说是相互引用的；</span></span><br><span class="line"><span class="keyword">即java对象当中的obj会引用monitor对象；而monitor对象中的成员变量属性_object取值也会引用着java对象；</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">_owner: </span>指的是标识拥有该monitor的线程（即指的就是线程的拥有者）</span><br><span class="line">假设线程A抢到锁进入到了同步代码块当中来了；</span><br><span class="line">那么到时候ObjectMonitor当中的_owner所指的就是当前该线程A；</span><br><span class="line"></span><br><span class="line"><span class="symbol">_WaitSet:</span> 处于<span class="keyword">wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line"><span class="keyword">Wait是等待的意思；Set代表集合；</span></span><br><span class="line"><span class="keyword">WaitSet是用来存放处于wait状态的线程的集合</span></span><br><span class="line"><span class="keyword">比如说，当前线程A获取得到锁之后从而进入同步代码块执行同步代码块中的代码；</span></span><br><span class="line"><span class="keyword">执行obj.wait()方法；那么当前该锁住就将进入无限的等待中；</span></span><br><span class="line"><span class="keyword">那么无限等待的线程就会被放置在_WaitSet集合当中去；</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">_cxq: </span>多个线程在竞争锁时的单向列表；</span><br><span class="line">假设当前有一个<span class="built_in">t1</span>线程进入到同步代码块当中；</span><br><span class="line">由于<span class="built_in">t1</span>线程是第一次先进入同步代码块当中来的；</span><br><span class="line">所以抢得到锁从而进入同步代码块；</span><br><span class="line">假设又来了另外一个线程即<span class="built_in">t2</span>线程；</span><br><span class="line">那么<span class="built_in">t2</span>线程是没有抢到锁的；</span><br><span class="line">那么没有抢到锁的线程依旧要等待；</span><br><span class="line">那么这些没有抢到锁的线程去哪里进行等待；</span><br><span class="line">或者说用什么来进行保存这些正在等待的线程呢？</span><br><span class="line">准备要等待的线程会进入到_cxq该变量当中去，_cxq是一个单向列表；</span><br><span class="line">那么此时假如还有一个线程进来叫做<span class="built_in">t3</span>线程；</span><br><span class="line">那么这个<span class="built_in">t3</span>线程执行同步代码块也抢不到锁，也会先进行进入这个_cxq单向列表当中；</span><br><span class="line">假设线程<span class="built_in">t1</span>往下继续进行执行；执行完同步代码块那么就会将锁进行给释放掉了；</span><br><span class="line">那么此时就有可能是由线程<span class="built_in">t1</span>、<span class="built_in">t2</span>、<span class="built_in">t3</span>都有可能获取抢到锁；</span><br><span class="line">那么还是假设线程<span class="built_in">t1</span>进行抢到了锁；</span><br><span class="line">那么这就是线程<span class="built_in">t1</span>第二次抢到了锁；也就是<span class="built_in">t1</span>线程第二次进入同步代码块了；那么这个时候<span class="built_in">t1</span>线程拿着锁进入同步代码块当中；</span><br><span class="line">那么上一次放在在等待中的_cxq单向列表中的等待中的线程<span class="built_in">t2</span>、<span class="built_in">t3</span>此时就会进入到_EntryList变量当中去；</span><br><span class="line"></span><br><span class="line"><span class="symbol">_EntryList:</span> 处于等待锁<span class="keyword">block状态的线程，会被加入到该列表</span></span><br><span class="line"><span class="keyword">即就处于BLOCK状态的线程就会被添加入到_EntryList变量当中来；</span></span><br><span class="line"><span class="keyword">假设t1在执行的时候，这个时候又来了一个线程叫做t4;</span></span><br><span class="line"><span class="keyword">那么t4线程进入同步代码块由于没有抢到锁会先进入_cxq单向列表当中去；</span></span><br><span class="line"><span class="keyword">假设再来了一个线程叫做t5；那么t5也要执行同步代码块也没有获取得到锁从而也会被放置到_cxq单向列表中去；</span></span><br><span class="line"><span class="keyword">假设t1线程执行完成出了同步代码块了；假设t1又再次争抢获取得到锁进入了同步代码块当中；那么上一次在_cxq单向列表中进行等待的两个线程t4、t5就会进入到_EntryList当中去；即变为BLOCK状态；</span></span><br><span class="line"><span class="keyword">-----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">分析Monitor结构图</span></span><br><span class="line"><span class="keyword">Monitor主要由三个组件进行构成: </span>_owner、_EntryList、_WaitSet</span><br><span class="line">等待一轮之后依旧没有抢到锁的线程被放置到_EntryList当中来了；</span><br><span class="line">那么还有就是执行obj.<span class="keyword">wait()方法的被放置放到_WaitSet单项列表中去；</span></span><br><span class="line"><span class="keyword">当线程拥有者在执行那么执行完就会出同步代码块；</span></span><br><span class="line"><span class="keyword">那么当线程拥有者在执行完成出同步代码块的时候</span></span><br><span class="line"><span class="keyword">有可能会是_EntryList当中正在阻塞的线程竞争获取拿到锁变成monitor当中的_owner；</span></span><br><span class="line"><span class="keyword">也有可能会是_WaitSet当中处于Wait的线程被别的操作所唤醒了；</span></span><br><span class="line"><span class="keyword">那么它也有可能会获得锁变成线程的user即monitor结构中的_owner；</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">竞争到锁的线程、处于阻塞状态的线程、处于等待状态的线程；</span></span><br></pre></td></tr></table></figure><ol><li>_owner: 初始化为NUll，当有线程占有该monitor时，owner标记为该线程的唯一表示。当线程释放monitor时，owner又恢复到NULL。owner是一个临界资源，JVM是通过CAS操作来保证其线程安全的。</li><li>_cxq: 竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。_cxq是一个临界资源，JVM通过CAS原子指令来修改_cxq队列。 修改前 _cxq的旧值 填入了 node的next字段， _cxq指向新值（新线程）。因此 _cxq是一个后进先出的stack(栈)。</li><li>_EntryList: _cxq队列中 有资格成为 候选资源的 线程 会被移动到该队列中。</li><li>_WaitSet: 因为调用wait方法而被阻塞的 线程会被放在该队列中。</li></ol><p>每一个java对象都可以与一个监视器 monitor关联，<br>可以把它理解成为一把锁，<br>当一个线程想要执行一段被synchronized圈起来的同步方法或者代码块时，<br>该线程得 先获取到 synchronized修饰的对象 对应的monitor。</p><p>java代码里不会 显式地去创造这么一个 monitor对象，<br>也无需创建，<br>事实上可以这么理解：<br>monitor并不是随着对象创建而创建的。<br>是通过 synchronized 修饰符 告诉 JVM 需要为 某个对象创建关联的 monitor对象。<br>每个线程都存在两个ObjectMonitor对象列表，分别为 free和 used列表。<br>同时JVM中也维护着 global locklist。<br>当线程需要 ObjectMonitor对象时，首先从线程自身的free表中申请，若存在则使用，若不存在则从 globallist 中申请。</p><p>ObjectMonitor 的数据结构包含三种队列： _cxq、_WaitSet和 _EntryList，他们之间的关系转换可以用下图表示：</p><h2 id="深入JVM源码-monitor竞争"><a href="#深入JVM源码-monitor竞争" class="headerlink" title="深入JVM源码-monitor竞争"></a>深入JVM源码-monitor竞争</h2><p>monitor竞争<br>monitor对象监视器锁竞争的过程；</p><p>synchronized为什么是重量级锁，为什么开销比较大？<br>synchronized是重量级的锁，效率不高。<br>synchronized的优化涉及到一个叫做CAS的操作。<br>CAS也属于一个原子操作，可以将其看做是一个轻量级的synchronized。</p><h3 id="目标-13"><a href="#目标-13" class="headerlink" title="目标"></a>目标</h3><p>分两步<br>第一步；了解何时会出现monitor竞争？<br>第二步：monitor是如何竞争的？</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java代码举例：</span><br><span class="line">----------------------------------------</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"><span class="code">  synchronized(obj)&#123;</span></span><br><span class="line"><span class="code">    System.out.println("1");</span></span><br><span class="line"><span class="code">  &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------</span><br><span class="line">假设有一个t1线程；再来一个t2线程；</span><br><span class="line">可能这两个线程t1、t2都会来进行执行同步代码块synchronized(obj)&#123;；</span><br><span class="line">那么这个时候就会处于monitor竞争状态；</span><br><span class="line">线程执行同步代码块就会出现竞争的现象；</span><br><span class="line">之前反汇编javap看到synchronized会变成两条字节码指令monitorenter以及monitorexit；</span><br><span class="line">当线程进入同步代码块synchronized时会执行monitorenter字节码指令；</span><br><span class="line">当线程执行完同步代码块中的内容即退出同步代码块时会执行monitorexit字节码指令；</span><br><span class="line">这个monitorenter字节码指令最终会调用到InterpreterRuntime.cpp代码中的一个方法；</span><br></pre></td></tr></table></figure><ol><li>执行 monitorenter时，会调用 InterpreterRuntime.cpp<br>（位于：src/share/vm/interpreterRuntime.cpp）的InterpreterRuntime::monitorenter 函数。</li></ol><p>具体代码可参见 HotSpot源码。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 截取的部分代码</span><br><span class="line"><span class="constructor">IRT_ENTRY_NO_ASYNC(<span class="params">void</span>, InterpreterRuntime:<span class="params">monitorenter</span>(JavaThread<span class="operator">*</span>  <span class="params">thread</span>, BasicObjectLock<span class="operator">*</span> <span class="params">elem</span>)</span>)</span><br><span class="line">#ifdef ASSERT</span><br><span class="line">  thread-&gt;last<span class="constructor">_frame()</span>.interpreter<span class="constructor">_frame_verify_monitor(<span class="params">elem</span>)</span>;</span><br><span class="line">#endif</span><br><span class="line">  <span class="keyword">if</span>(PrintBiasedLockingStatistics)&#123;</span><br><span class="line">    Atomic::inc(BiasedLocking::slow<span class="constructor">_path_entry_count_addr()</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Handle h<span class="constructor">_obj(<span class="params">thread</span>, <span class="params">elem</span>-&gt;<span class="params">obj</span>()</span>);</span><br><span class="line">  <span class="keyword">assert</span>(Universe::heap<span class="literal">()</span>-&gt;is<span class="constructor">_in_reserved_or_null(<span class="params">h_obj</span>()</span>),</span><br><span class="line">          <span class="string">"must be NULL or an object"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  重点代码if()&#123;&#125;else&#123;&#125;块</span></span><br><span class="line"><span class="comment">  UseBiasedLocking是不是使用了偏向锁；</span></span><br><span class="line"><span class="comment">  这个UseBiasedLocking条件其实是JVM可以进行设置的一个启动参数；</span></span><br><span class="line"><span class="comment">  如果进行设置了启用偏向锁那么就会走if()&#123;&#125;块当中的代码；</span></span><br><span class="line"><span class="comment">  如果没有设置启用偏向锁那么则会走else&#123;&#125;块中的代码；</span></span><br><span class="line"><span class="comment">  也就是所要分析的monitor重量级锁的过程叫做slow_enter慢进入；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span>(UseBiasedLocking)&#123;</span><br><span class="line">    <span class="comment">//Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast<span class="constructor">_entry(<span class="params">h_obj</span>, <span class="params">elem</span>-&gt;<span class="params">lock</span>()</span>, <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ObjectSynchronizer::slow<span class="constructor">_enter(<span class="params">h_obj</span>, <span class="params">elem</span>-&gt;<span class="params">lock</span>()</span>, CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">assert</span>(Universe::heap<span class="literal">()</span>-&gt;is<span class="constructor">_in_reserved_or_null(<span class="params">elem</span>-&gt;<span class="params">obj</span>)</span>),</span><br><span class="line">          <span class="string">"must be NULL or an object"</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>对于重量级锁，monitorenter的函数中(slow_enter最终)会调用ObjectSynchronizer::slow_enter</li><li>最终调用 ObjectMonitor::enter（对象监视器锁monitor的enter方法，说明还是要回到ObjectMonitor.cpp）<br>(位于：src/share/vm/runtime/objectMonitor.cpp)，源码如下：</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">void ATTR ObjectMonitor::enter(TRAPS)&#123;</span><br><span class="line">  <span class="comment">// The following code is ordered to check the most common cases first</span></span><br><span class="line">  <span class="comment">// and to reduce RTS-&gt;RTO cache line upgrades on SPARC and IA32 processors.</span></span><br><span class="line">  Thread * <span class="keyword">const</span> <span class="keyword">Self</span> = THREAD;</span><br><span class="line">  void * cur ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  通过 CAS 操作尝试把 monitor 的 _owner 字段设置为当前线程</span></span><br><span class="line"><span class="comment">  在ObjectMonitor::enter进入的时候会调用Actomic当中的cmpxchg_ptr；</span></span><br><span class="line"><span class="comment">  Atomic::cmpxchg_ptr(Self, &amp;_owner, NULL)</span></span><br><span class="line"><span class="comment">  该函数属于linux系统内存当中的一个函数最终会依赖CPU去做原子赋值操作；</span></span><br><span class="line"><span class="comment">  CAS是一个原子的赋值操作；</span></span><br><span class="line"><span class="comment">  作用就是将monitor对象当中的_owner设置成这个当前线程Self；</span></span><br><span class="line"><span class="comment">  看其是否能够设置成功</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  cur = Atomic::cmpxchg_ptr(<span class="keyword">Self</span>, &amp;_owner, <span class="keyword">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(cur == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">// Either ASSERT _recursions == 0 or explicitly Set _recursions = 0.</span></span><br><span class="line">    assert (_recursions == <span class="number">0</span> ,   <span class="string">"invariant"</span>) ;</span><br><span class="line">    assert (_owner      == <span class="keyword">Self</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">    <span class="comment">// CONSIDER: set or assert OwnerIsThread == 1</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//线程重入；recursions++</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    如果上一步骤当中设置monitor对象中的_owner设置成当前这个线程Self成功；</span></span><br><span class="line"><span class="comment">    并且当前线程Self的线程名字，即之前的_owner保存的线程就是当前线程Self的线程的名字，即名称一致的话；</span></span><br><span class="line"><span class="comment">    那么这样就意味着锁重入；即重新又进入了一个代码块有获取得到了同一把锁；</span></span><br><span class="line"><span class="comment">    那么这个时候进行monitor对象当中的_recursions变量进行++操作，即该线程的重入次数；并且return;</span></span><br><span class="line"><span class="comment">    说明当前线程竞争到该锁；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span>(cur == <span class="keyword">Self</span>)&#123;</span><br><span class="line">    <span class="comment">// TODO-<span class="doctag">FIXME:</span> : check for integer overflow! BUGID 6557169</span></span><br><span class="line">    _recursions ++;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如果当前线程第一次来抢monitor该锁；</span></span><br><span class="line"><span class="comment">如果当前线程是第一次进入该monitor，如果抢到锁了；</span></span><br><span class="line"><span class="comment">设置_recursions为1，并且将_owner设置为当前线程；</span></span><br><span class="line"><span class="comment">最后返回即表示当前线程竞争到该锁；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">Self</span> -&gt; is_lock_owned((address)cur))&#123;</span><br><span class="line">  assert (_recursions == <span class="number">0</span>, <span class="string">"internal state error"</span>);</span><br><span class="line">  _recursions = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// Commute error from a thread-specific on-stack BasicLockObject address to</span></span><br><span class="line">  <span class="comment">// a full-fledged "Thread *".</span></span><br><span class="line">  _owner = <span class="keyword">Self</span>;</span><br><span class="line">  OwnerIsThread = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略一些代码</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  那么如果经过以上操作当前线程都没有抢到锁的话；</span></span><br><span class="line"><span class="comment">  则就将进入到该for循环当中；</span></span><br><span class="line"><span class="comment">  假设第一个线程t1抢到锁进入到了同步代码块当中；</span></span><br><span class="line"><span class="comment">  那么第二个线程t2就由于t1线程已经抢到锁且当前时间内没有进行释放锁的缘故第二个线程没有抢到锁；</span></span><br><span class="line"><span class="comment">  那么抢不到锁的第二个线程t2就会执行方法EnterI(THREAD)；</span></span><br><span class="line"><span class="comment">  最终进入到monitor对象的成员变量_cxq单向列表当中进行等待获取锁；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">    jt-&gt;set_suspend_equivalent();</span><br><span class="line">    <span class="comment">// cleared by handle_special_suspend_equivalent_condition()</span></span><br><span class="line">    <span class="comment">// or java_suspend_self()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果获取锁失败，则等待锁的释放</span></span><br><span class="line">    EnterI(THREAD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!ExitSuspendEquivalent(jt)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// we have acquired the contended monitor, but while we were</span></span><br><span class="line">    <span class="comment">// waiting another thread suspended us. We don't want to enter</span></span><br><span class="line">    <span class="comment">// the monitor while suspend because that would surprise the</span></span><br><span class="line">    <span class="comment">// thread that suspended us.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">      _recursions = <span class="number">0</span>;</span><br><span class="line">    _succ = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="keyword">false</span>, <span class="keyword">Self</span>);</span><br><span class="line"></span><br><span class="line">    jt-&gt;java_suspend_self();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">Self</span>-&gt;set_current_pending_monitor(<span class="keyword">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处省略<strong>锁的自旋优化</strong>等操作，统一放在后面<strong>synchronized优化</strong>中说。<br>以上代码的具体流程概括如下：</p><p><strong>1、</strong> 通过 CAS 尝试把monitor的 _owner字段设置为当前线程（即把monitor的_owner成员变量的属性取值设置为竞争的该线程；如果设置成功则说明该线程竞争到了锁）<br><strong>2、</strong> 如果设置之前的_owner指向当前线程，说明当前线程再次进入monitor，即重入锁，执行recursions++，记录重入的次数；（如果在这之前的上一次竞争当前线程获取得到了该锁，那么现在当次竞争当前线程又竞争到了该锁；两把锁一样；那么说明是锁重入；）<br><strong>3、</strong> 如果当前线程是第一次进入该monitor，设置recursions为1，_owner为当前线程，该线程成功获得锁并返回。<br><strong>4、</strong> 如果获取锁失败，则等待锁的释放(进入阻塞等待状态，即进入到monitor对象的成员变量_cxq单向列表队列)；</p><h2 id="深入JVM源码-monitor等待"><a href="#深入JVM源码-monitor等待" class="headerlink" title="深入JVM源码-monitor等待"></a>深入JVM源码-monitor等待</h2><h3 id="回顾并引入"><a href="#回顾并引入" class="headerlink" title="回顾并引入"></a>回顾并引入</h3><p>当前在竞争monitor对象锁的时候会发现；<br>有一个线程会竞争到monitor并且让线程接着往下执行；<br>但是有一些线程竞争不到monitor那么这个时候它会执行EnterI(THREAD)这个函数；<br>也就是说没有抢到锁的线程会进入等待处于阻塞状态；<br>那么接下来也就是学习monitor等待过程；也就是EnterI(THREAD)方法；</p><p>monitor等待</p><p>竞争失败等待调用的是 ObjectMonitor对象的EnterI(THREAD)方法<br>（位于：/src/share/vm/runtime/ObjectMonitor.cpp），<br>源码如下所示：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 截取部分代码分析</span></span><br><span class="line">void ATTR ObjectMonitor::EnterI(THREAD)&#123;</span><br><span class="line">  Thread * <span class="keyword">Self</span> = THREAD;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try the lock - TATAS</span></span><br><span class="line">  <span class="keyword">if</span>(TryLock (<span class="keyword">Self</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    assert (_succ        != <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">    assert (_owner       == <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">    assert (_Responsible != <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(TrySpin (<span class="keyword">Self</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    assert (_succ        == <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">    assert (_owner       != <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">    assert (_Responsible != <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ</span></span><br><span class="line">  ObjectWaiter node(<span class="keyword">Self</span>);</span><br><span class="line">  <span class="keyword">Self</span>-&gt;ParkEvent-&gt;reset();</span><br><span class="line">  node._prev  = (ObjectWaiter *) <span class="number">0xBAD</span>;</span><br><span class="line">  node.TState = ObjectWaiter::TS_CXQ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过CAS把node节点push到_cxq列表中</span></span><br><span class="line">  ObjectWaiter * nxt;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    node._next = next = _cxq;</span><br><span class="line">    <span class="keyword">if</span>(Atomic::cmpxchg_ptr(&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interference - the CAS failed because _cxq changed. Just retry.</span></span><br><span class="line">    <span class="comment">// As an optional optimization we retry the lock.</span></span><br><span class="line">    <span class="keyword">if</span>(TryLock(<span class="keyword">Self</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(TryLock (<span class="keyword">Self</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          assert (_succ        != <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">          assert (_owner       == <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">          assert (_Responsible != <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">      <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="comment">// 线程在挂起前做一下挣扎，看能不能获取到锁</span></span><br><span class="line">        <span class="keyword">if</span>(TryLock (<span class="keyword">Self</span>) &gt; <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        assert (_owner != <span class="keyword">Self</span>, <span class="string">"inveriant"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((SyncFlags &amp; <span class="number">2</span>) &amp;&amp; _Reponsible == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">          Atomic::cmpxchg_ptr (<span class="keyword">Self</span>, &amp;_Reponsible, <span class="keyword">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// park self</span></span><br><span class="line">        <span class="keyword">if</span>(_Responsible == <span class="keyword">Self</span> || (SynchFlags &amp; <span class="number">1</span>))&#123;</span><br><span class="line">          TEVENT (Inflated enter - park TIMED);</span><br><span class="line">          <span class="keyword">Self</span>-&gt;_ParkEvent-&gt;park((jlong)RecheckInterval);</span><br><span class="line">          <span class="comment">// Increase the RecheckInterval, but clamp the value.</span></span><br><span class="line">          RecheckInterval *= <span class="number">8</span>；</span><br><span class="line">          <span class="keyword">if</span>(RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          TEVENT (Inflated enter - park UNTIMED);</span><br><span class="line">          <span class="comment">// 通过park将当前线程挂起，等待被唤醒</span></span><br><span class="line">          <span class="keyword">Self</span>-&gt;_ParkEvent-&gt;park();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(TryLock(<span class="keyword">Self</span>) &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">java代码：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(String[] args)&#123;</span><br><span class="line">  synchronized(obj)&#123;</span><br><span class="line">    System.out.println(<span class="string">"1"</span>);</span><br><span class="line">    obj.wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">看图说话：</span><br><span class="line"></span><br><span class="line">假设t1线程没有竞争得到锁；则t1线程就将要去处于等待状态；</span><br><span class="line">那么这个处于等待这个动作是如何做的呢？</span><br><span class="line"></span><br><span class="line">首先这个t1线程会进入EnterI(THREAD)方法当中；</span><br><span class="line">进入EnterI(THREAD)方法之后；</span><br><span class="line">那么会先去进行执行TryLock(<span class="keyword">Self</span>)尝试获取锁操作；</span><br><span class="line">即t1线程虽然没有抢到锁但是它还会继续TryLock(THREAD)进行尝试一下，最后做一下挣扎；</span><br><span class="line">如果在这个挣扎过程中抢到了锁则后面接着执行；</span><br><span class="line">如果在这个挣扎过程中没有抢到锁那么就会继续往下走会执行函数TrySpin(<span class="keyword">Self</span>)函数；</span><br><span class="line">那么函数TrySpin(<span class="keyword">Self</span>)函数的作用就在于自旋；</span><br><span class="line">自旋即意味着进入一个循环当中多次进行抢一抢锁看能不能够抢到该锁；</span><br><span class="line">即再次挣扎一下看能不能再次抢救一下；</span><br><span class="line">如果经过TryLock尝试获取锁以及TrySpin自旋之后还是没有办法获取得到锁；</span><br><span class="line">那么这个时候就会走到下面来；</span><br><span class="line">就会将当前这个没有抢到锁且经过TryLock以及TrySpin后依然没有抢到锁的t1线程放到ObjectWaiter中来并进行封装起来；</span><br><span class="line">ObjectWaiter即一个等待的线程；</span><br><span class="line">并且会将当前这个没有抢到锁的线程状态设置为ObjectWaiter当中的TS_CXQ状态取值；</span><br><span class="line">接着通过CAS把即将要等待的线程t1线程push到_cxq单向列表当中去；</span><br><span class="line">但是可能有一个线程抢到也有其他很多线程没有抢到锁；</span><br><span class="line">那么这些很多没有抢到锁的线程都要被push到这个_cxq节点上面来；</span><br><span class="line">那么因此这个没有抢到锁的线程要被push到_cxq结点上去的这一操作也可能会成功也有可能会失败；</span><br><span class="line">所以这一操作即没有抢到锁的线程都要被push到_cxq结点上去也是使用到了一个<span class="keyword">for</span>循环加上Atomic::cmpxchg_ptr该内核函数；即CAS一次不行就再重试再重试；直到几个没有成功获取得到锁的线程都被挂在结点_cxq单向列表上；</span><br><span class="line">另外在每次重试的时候，都会再去进行重试挣扎一下即TryLock看能不能抢到锁；</span><br><span class="line">那么经过<span class="keyword">for</span>(;;)循环之后这几个没有获取得到锁的线程都会被挂在_cxq结点单向列表上；</span><br><span class="line">当没有获取得到锁的线程放到结点_cxq单向列表当中之后；那么还要将该线程进行挂起操作；即下面的代码；</span><br><span class="line">在挂起的时候首先它也还是会去进行TryLock尝试挣扎抢救一下去获取锁，看能不能获取得到锁；得不到锁则继续往下走；继续往下走存在<span class="keyword">if</span>()&#123;&#125;<span class="keyword">else</span>&#123;&#125;块但是无论走哪一块最终都会导致当前线程执行park()，park就是把当前线程进行挂起；</span><br><span class="line">那么在当前该线程被挂起之后那么该线程就不会再进行执行了，那么这个时候就只有等待别的线程来进行唤醒的时候才会进行继续执行；</span><br><span class="line">那么不管是从<span class="keyword">if</span>()&#123;&#125;或者是<span class="keyword">else</span>&#123;&#125;块当中的点开始进行被唤醒，当该线程被唤醒之后都会去进行尝试抢锁即TryLock(<span class="keyword">Self</span>)；看是否能够获取得到锁；</span><br></pre></td></tr></table></figure><p>当该线程被唤醒时，会从挂起的点继续执行，通过<code>ObjectMonitor::TryLock</code>尝试获取锁,TryLock方法实现如下：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 截取部分代码</span></span><br><span class="line"><span class="keyword">int</span> ObjectMonitor::TryLock(Thread * <span class="keyword">Self</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    void * own = _owner;</span><br><span class="line">    <span class="keyword">if</span>(own != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Atomic::cmpxchg_ptr (<span class="keyword">Self</span>, &amp;_owner, <span class="keyword">NULL</span>) == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">      <span class="comment">// Either guarantee _recursions == 0 or set _recursions = 0.</span></span><br><span class="line">      assert (_recursions == <span class="number">0</span>,    <span class="string">"invariant"</span>);</span><br><span class="line">      assert (_owner      == <span class="keyword">Self</span>, <span class="string">"invariant"</span>);</span><br><span class="line">      <span class="comment">// CONSIDER: set or assert that OwnerIsThread == 1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The lock had been freen momentarily, but we lost the race to the lock.</span></span><br><span class="line">    <span class="comment">// Interference -- the CAS faild.</span></span><br><span class="line">    <span class="comment">// we can either return -1 or retry.</span></span><br><span class="line">    <span class="comment">// Retry doesn't make as much sense because the lock was just acquired.</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">true</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">尝试锁也是使用的CAS操作去进行做一个判断；</span><br><span class="line">如果尝试获取得到锁那么就会返回<span class="number">1</span>；</span><br><span class="line">如果尝试没有获取得到锁那么就会返回<span class="number">-1</span>；</span><br></pre></td></tr></table></figure><h3 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h3><p>首先第一个；当线程没有抢到锁那么就将会被放到_cxq单向列表当中去；<br>那么该流程的第一步骤：<br>以上代码的具体流程如下：</p><p><strong>1、</strong> 当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ。<br><strong>2、</strong> 在for循环中（用CAS尝试把当前该线程放到_cxq的一个节点上去；因为同时有多个线程往单向列表_cxq当中放，所以使用了for循环，CAS多次尝试），通过CAS把node节点push到_cxq列表中，同一时刻可能有多个线程把自己的node节点push到_cxq列表中。<br><strong>3、</strong> （没有抢到锁的线程在放到_cxq节点上之前）node结点push到_cxq列表之后，通过自旋尝试获取锁，如果还是没有获取得到锁，则通过park将当前线程挂起（park内核函数，让当前线程进行挂起那么其实也就相当于阻塞状态需要别的线程进行唤醒才能够继续往下执行），等待被唤醒。<br><strong>4、</strong> 当该线程被唤醒时，会从挂起的点继续执行，通过<code>ObjectWaiter::TryLock</code>尝试获取锁。</p><h2 id="深入JVM源码-monitor释放"><a href="#深入JVM源码-monitor释放" class="headerlink" title="深入JVM源码-monitor释放"></a>深入JVM源码-monitor释放</h2><h3 id="目标-14"><a href="#目标-14" class="headerlink" title="目标"></a>目标</h3><p>分成两个部分来进行学习；<br>首先进行介绍什么时候monitor会进行释放；<br>接着进行介绍monitor的释放过程是什么样的；</p><h3 id="monitor释放分析"><a href="#monitor释放分析" class="headerlink" title="monitor释放分析"></a>monitor释放分析</h3><p>当某个持有锁的线程执行完同步代码块时，会进行锁的释放，给其他线程机会执行同步代码块。<br>在HotSpot中，通过推出monitor的方式实现锁的释放，并通知被阻塞的线程，具体实现位于ObjectMonitor的exit方法中。<br>（位于：/src/share/vm/runtime/ObjectMonitor.cpp），源码如下所示:</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 截取部分代码</span></span><br><span class="line">void ATTR ObjectMonitor::exit(<span class="keyword">bool</span> not_suspended, TRAPS)&#123;</span><br><span class="line">  Thread * <span class="keyword">Self</span> = THREAD;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  <span class="keyword">if</span>(_recursions != <span class="number">0</span>)&#123;</span><br><span class="line">    _recursions--;    <span class="comment">// this is simple recursive enter</span></span><br><span class="line">    TEVENT (Inflated <span class="keyword">exit</span> - recursive);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">  ObjectWaiter * w = <span class="keyword">NULL</span>;</span><br><span class="line">  <span class="keyword">int</span> QMode = Knob_QMode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// qmode = 2：直接绕过EntryList队列，从_cxq队列中获取线程用于竞争锁</span></span><br><span class="line">  <span class="keyword">if</span>(QMode == <span class="number">2</span> &amp;&amp; _cxq != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">    w = _cxq;</span><br><span class="line">  assert ( w != <span class="keyword">NULL</span>, <span class="string">"invariant"</span>);</span><br><span class="line">  assert ( w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"invariant"</span>);</span><br><span class="line">  ExitEpilog(<span class="keyword">Self</span>, w);</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// qmode=3：cxq队列插入EntryList尾部；</span></span><br><span class="line">  <span class="keyword">if</span>(QMode == <span class="number">3</span> &amp;&amp; _cxq != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">    w = _cxq;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      assert (w != <span class="keyword">NULL</span>, <span class="string">"Invariant"</span>);</span><br><span class="line">      ObjectWaiter * u = (ObjectWaiter *)Atomic::cmpxchg_ptr (<span class="keyword">NULL</span>, &amp;_cxq, w);</span><br><span class="line">      <span class="keyword">if</span>( u == w ) <span class="keyword">break</span>;</span><br><span class="line">      w = u;</span><br><span class="line">    &#125;</span><br><span class="line">    assert( w != <span class="keyword">NULL</span> , <span class="string">"invariant"</span>);</span><br><span class="line"></span><br><span class="line">    ObjectWaiter * q = <span class="keyword">NULL</span>;</span><br><span class="line">    ObjectWaiter * p;</span><br><span class="line">    <span class="keyword">for</span>( p = w ;  p != <span class="keyword">NULL</span> ; p = p-&gt;_next)&#123;</span><br><span class="line">      guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"Invariant"</span>);</span><br><span class="line">      p-&gt;TState = ObjectWaiter::TS_ENTER;</span><br><span class="line">      p-&gt;prev = q;</span><br><span class="line">      q = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectWaiter * Tail;</span><br><span class="line">    <span class="keyword">for</span> ( Tail = _EntryList; Tail != <span class="keyword">NULL</span> &amp;&amp; Tail-&gt;_next != <span class="keyword">NULL</span>; Tail = Tail-&gt;_next);</span><br><span class="line">    <span class="keyword">if</span>(Tail == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">      _EntryList = w;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      Tail-&gt;_next = w;</span><br><span class="line">      w-&gt;_prev = Tail;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// qmode=4: cxq队列插入到_EntryList头部</span></span><br><span class="line">  <span class="keyword">if</span>(QMode == <span class="number">4</span> &amp;&amp; _cxq != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">    w = _cxq;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      assert (w != <span class="keyword">NULL</span>, <span class="string">"Invariant"</span>);</span><br><span class="line">      ObjectWaiter * u = (ObjectWaiter *)Atomic::cmpxchg_ptr(<span class="keyword">NULL</span>, &amp;_cxq, w);</span><br><span class="line">      <span class="keyword">if</span>(u == w) <span class="keyword">break</span>;</span><br><span class="line">      w = u;</span><br><span class="line">    &#125;</span><br><span class="line">    assert (w != <span class="keyword">NULL</span> , <span class="string">"invariant"</span>);</span><br><span class="line"></span><br><span class="line">    ObjectWaiter * q = <span class="keyword">NULL</span>;</span><br><span class="line">    ObjectWaiter * p;</span><br><span class="line">    <span class="keyword">for</span>( p = w; p != <span class="keyword">NULL</span> ; p -&gt;_next)&#123;</span><br><span class="line">      guarantee(p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"Invariant"</span>);</span><br><span class="line">      p-&gt;TState = ObjectWaiter::TS_ENTER;</span><br><span class="line">      p-&gt;_prev = q;</span><br><span class="line">      q = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_EntryList != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">      q-&gt;_next = _EntryList;</span><br><span class="line">      _EntryList-&gt;_prev = q;</span><br><span class="line">    &#125;</span><br><span class="line">    _EntryList = w;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  w = _EntryList;</span><br><span class="line">  <span class="keyword">if</span>(w != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">    assert (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">"invariant"</span>);</span><br><span class="line">    ExitEpilog(<span class="keyword">Self</span>, w);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  w = _cxq;</span><br><span class="line">  <span class="keyword">if</span>(w == <span class="keyword">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    assert (w != <span class="keyword">NULL</span>, <span class="string">"Invariant"</span>);</span><br><span class="line">    ObjectWaiter * u = (ObjectWaiter *)Atomic::cmpxchg_ptr(<span class="keyword">NULL</span>, &amp;_cxq, w);</span><br><span class="line">    <span class="keyword">if</span>(u == w) <span class="keyword">break</span>;</span><br><span class="line">    w = u;</span><br><span class="line">  &#125;</span><br><span class="line">  TEVENT(Inflated <span class="keyword">exit</span> - drain cxq into EntryList);</span><br><span class="line"></span><br><span class="line">  assert( w          != <span class="keyword">NULL</span> , <span class="string">"invariant"</span>);</span><br><span class="line">  assert( _EntryList != <span class="keyword">NULL</span> , <span class="string">"invariant"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(QMode == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// QMode == 1: drain cxq to EntryList,reversing order</span></span><br><span class="line">    <span class="comment">// we also reverse the order of the list</span></span><br><span class="line">    ObjectWaiter * s = <span class="keyword">NULL</span>;</span><br><span class="line">    ObjectWaiter * t = w;</span><br><span class="line">    ObjectWaiter * u = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(t != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">      guarantee(t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"invariant"</span>);</span><br><span class="line">      t-&gt;TState = ObjectWaiter::TS_ENTER;</span><br><span class="line">      u = t-&gt;_next;</span><br><span class="line">      t-&gt;_prev = u;</span><br><span class="line">      t-&gt;_next = s;</span><br><span class="line">      s = t;</span><br><span class="line">      t = u;</span><br><span class="line">    &#125;</span><br><span class="line">    _EntryList = s;</span><br><span class="line">    assert(s != <span class="keyword">NULL</span>, <span class="string">"invariant"</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// QMode ==0 or QMode == 2</span></span><br><span class="line">    _EntryList = w;</span><br><span class="line">    ObjectWaiter * q = <span class="keyword">NULL</span>;</span><br><span class="line">    ObjectWaiter * p;</span><br><span class="line">    <span class="keyword">for</span>(p = w; p != <span class="keyword">NULL</span>; p = p-&gt;_next)&#123;</span><br><span class="line">      guarantee(p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"Invariant"</span>);</span><br><span class="line">      p-&gt;TState = ObjectWaiter::TS_ENTER;</span><br><span class="line">      p-&gt;_prev = q;</span><br><span class="line">      q = p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_succ != <span class="keyword">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  w = _EntryList;</span><br><span class="line">  <span class="keyword">if</span>(w != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">    guarantee(w -&gt; TState == ObjectWater::TS_ENTER, <span class="string">"invariant"</span>);</span><br><span class="line">    ExitEpilog(<span class="keyword">Self</span>, w);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">java代码：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(String[] args)&#123;</span><br><span class="line">  synchronized(obj)&#123;</span><br><span class="line">    System.out.println(<span class="string">"1"</span>);</span><br><span class="line">    obj.wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">第一部分：什么时候释放monitor分析：</span><br><span class="line">获得锁的线程t1执行完同步代码块当中的代码之后，</span><br><span class="line">那么就需要出同步代码块；</span><br><span class="line">在出同步代码块的时候就会进行monitor的释放操作；</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">第二部分：monitor释放的过程是怎么样的分析：</span><br><span class="line">在<span class="keyword">exit</span>的释放过程当中；</span><br><span class="line">如果_recursions计数器不等于<span class="number">0</span>；</span><br><span class="line">那么_recursions就会去做一个--即减一操作；再去<span class="keyword">return</span>；</span><br><span class="line">那么这个其实对应着的是重入锁；</span><br><span class="line">_recursions当不为<span class="number">0</span>的情况下会进行--即减一操作；</span><br><span class="line">如果_recursions等于<span class="number">0</span>的情况下那么就表示线程完全出了同步代码块，</span><br><span class="line">且把锁释放返回了；</span><br><span class="line">那么这个时候除了释放锁之外还需要做一个操作；</span><br><span class="line">即去唤醒之前正在等待阻塞中的线程；那么需要唤醒哪一个线程呢？</span><br><span class="line">这个时候就需要注意了；有两个链表当中都存放有需要被唤醒的线程；</span><br><span class="line">即一个是_cxq；另外一个是EntryList；</span><br><span class="line">那么是随机唤醒某一个线程即有可能合适唤醒_cxq列表当中的线程也有可能是唤醒_EntryList当中的线程；</span><br><span class="line"></span><br><span class="line">所以继续往下看；</span><br><span class="line">ObjectWaiter是之前被阻塞进行等待的一个线程的一个封装；</span><br><span class="line">需要记住的是w，找到了w即找到了需要被唤醒的线程；</span><br><span class="line"></span><br><span class="line">在<span class="keyword">exit</span>当中提供很多种模式；</span><br><span class="line">模式一：</span><br><span class="line">如果QMode等于<span class="number">2</span>；那么这个时候会让w等于_cxq的首节点即链表头；</span><br><span class="line">那么也就取到了这个要被唤醒的线程；</span><br><span class="line">那么这一种方法绕过了_EntryList当中被阻塞的线程直接取_cxq列表当中的线程作为要被唤醒的线程对象；</span><br><span class="line">另外方法ExitEpilog(<span class="keyword">Self</span>,w)方法就是去作为唤醒线程的方法；</span><br><span class="line">模式二：</span><br><span class="line">如果QMode等于<span class="number">3</span>；首先要被唤醒的线程w也是等于_cxq的首节点；</span><br><span class="line">并且会将_cxq的这些节点放到_EntryList的尾部去；</span><br><span class="line">模式三：</span><br><span class="line">如果QMode等于<span class="number">4</span>；则那么首先这个要被唤醒的线程也是等于_cxq的首节点；</span><br><span class="line">并且会将_cxq列表当中的元素插入到_EntryList列表的头部；</span><br><span class="line">etc...</span><br><span class="line"></span><br><span class="line">那么最后就找到了w，即需要被唤醒的线程；</span><br><span class="line">那么也会去调用到方法ExitEpilog(<span class="keyword">Self</span>, w);</span><br><span class="line">即唤醒w线程；</span><br><span class="line">ExitEpilog即为具体唤醒的过程；</span><br></pre></td></tr></table></figure><p><strong>1、</strong> 退出同步代码块时 会让_recursions减1，当_recursions的值减为0时，说明（线程完全退出了同步代码块中）线程释放了锁；<br><strong>2、</strong> （释放完锁之后需要唤醒线程）根据不停的策略（策略不同唤醒不同的线程）（由QMode指定），从_cxq或_EntryList中获取头节点，通过<code>ObjectMonitor::ExitEpilog</code>方法唤醒该节点封装的线程，唤醒操作最终由unpack完成（将之前park的线程进行唤醒），实现如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment"># 截取部分代码</span></span><br><span class="line">void ObjectMonitor::ExitEpilog(Thread * <span class="keyword">Self</span>, ObjectWaiter * wakee)&#123;</span><br><span class="line">  assert( _owner == <span class="keyword">Self</span>, <span class="string">"invariant"</span>);</span><br><span class="line"></span><br><span class="line">  _succ = Knob_SuccEnabled ? wakee-&gt;_thread : <span class="keyword">NULL</span>;</span><br><span class="line">  ParkEvent * Trigger = wakee-&gt;_event;</span><br><span class="line"></span><br><span class="line">  wakee = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop the lock</span></span><br><span class="line">  OrderAccess::release_store_ptr(&amp;_owner, <span class="keyword">NULL</span>);</span><br><span class="line">  OrderAccess::fence();           <span class="comment">// ST _owner vs LD in unpark()</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(SafepointSynchronize::do_call_back())&#123;</span><br><span class="line">    TEVENT(unpack before SAFEPOINT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DTRACE_MONITOR_PROBE(contended__exit, this, object(), <span class="keyword">Self</span>);</span><br><span class="line">  Trigger-&gt;unpark();  <span class="comment">// 唤醒之前被park()挂起的线程</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Maintain stats and report events to JVMTI</span></span><br><span class="line">  <span class="keyword">if</span> (ObjectMonitor::_synch_Parks != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">    ObjectMonitor::_sync_Parks-&gt;inc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">分析：</span><br><span class="line">最重要的代码在于Trigger-unpark();</span><br><span class="line">unpark的含义即代表：</span><br><span class="line">假设找到线程t1要被唤醒；</span><br><span class="line">那么找到这个线程t1之后；调用unpark()方法就会将线程t1进行唤醒；</span><br><span class="line">那么也就是说这个t1线程就又能够有有机会去获取竞争得到锁从而进入到同步代码块当中去；</span><br><span class="line">执行完unpark之后就会将需要唤醒的线程进行唤醒；</span><br><span class="line">唤醒完成之后就会进入到之前park()让该线程挂起的代码行中；</span><br><span class="line">那么后面当unpark()将该需要唤醒的线程唤醒之后，就又会去进行执行TryLock尝试获取锁的代码；抢到锁则进入到同步代码块当中去；</span><br></pre></td></tr></table></figure><p>被唤醒的线程，会回到void ATTR ObjectMonitor::EnterI(TRAPS)的第600行，继续执行monitor的竞争。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 截取部分代码</span></span><br><span class="line"><span class="comment">// park self</span></span><br><span class="line"><span class="keyword">if</span>(_REsponsible == <span class="keyword">Self</span> || (SynchFlags &amp; <span class="number">1</span>))&#123;</span><br><span class="line">  TEVENT (Inflated enter - park TIMED);</span><br><span class="line">  <span class="keyword">Self</span>-&gt;_ParkEvent-&gt;park((jlong) RecheckInterval);</span><br><span class="line">  <span class="comment">// Increase the RecheckInterval , but clamp the value.</span></span><br><span class="line">  RecheckInterval *= <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">if</span>(RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  TEVENT (Infalted enter - park UNTIMED);</span><br><span class="line">  <span class="keyword">Self</span>-&gt;_ParkEvent-&gt;park();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(TryLock(<span class="keyword">Self</span>) &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="深入JVM源码-monitor是重量级锁"><a href="#深入JVM源码-monitor是重量级锁" class="headerlink" title="深入JVM源码-monitor是重量级锁"></a>深入JVM源码-monitor是重量级锁</h2><p>synchronized代码块在代码执行的时候效率比较低；<br>因为synchronized所关联的锁对象monitor是一个重量级锁；</p><h3 id="目标-15"><a href="#目标-15" class="headerlink" title="目标"></a>目标</h3><p>monitor为什么属于一个重量级锁？<br>monitor为什么效率比较低？</p><p>可以看到 ObjectMonitor 的函数调用中 会涉及到 Atomic::cmpxchg_ptr，Atomic::inc_ptr等内核函数，执行同步代码块，没有竞争到锁的对象会执行调用park()被挂起，竞争到锁的线程执行完成退出同步代码块时（即当其他线程退出同步代码块时）会调用unpark()唤醒上次那些没有竞争到锁从而被park()挂起的线程；<br>（这个park和unpark也属于内核函数；即也就是说synchronized在执行的时候会涉及到大量的内核函数的执行，而内核函数的执行就会涉及到操作系统中用户态和内核态的一个切换；）<br>这个时候就会存在操作系统 用户态和内核态的转换，这种转换会消耗大量的系统资源。<br>所以synchronized是java语言中的一个重量级（Heavyweight）的操作。<br>用户态和内核态是什么东西呢？<br>要想了解用户态和内核态还需要先了解一下Linux系统的体系架构：</p><p>linux系统的体系架构由<br>内核（操作系统的内核，而内核本质上也是一种应用程序；作用是来控制计算机的硬件资源的，比如说控制硬盘、那么还有可能控制内存等控制网络等相关的一些硬件设备比如说网卡、声卡、键盘、鼠标等）；<br>系统调用、shell、公用函数库；<br>应用程序（用户空间）<br>（自己写的程序被称为普通的应用程序；用户空间其实指的是自己所编写的应用程序所运行的那一块内存空间就成为用户空间；而应用程序在用户空间进行运行的时候就有可能会涉及到一些硬件资源的调用；那么这个时候就需要靠内核来进行去操作硬件资源；那么用户空间去调用内核的时候，就需要通过系统调用才能够进行；那么系统调用的作用即在于让在用户空间的应用程序能够去调用内核的一些内核函数；那么系统调用可以看做是提供内核的接口供外层的应用程序来进行调用；）<br>这几个部分来进行组成；</p><p>从上图可以看出，linux操作系统的体系架构分为：用户空间（应用程序的活动空间）和内核。<br>内核：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境。<br>用户空间：上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。<br>系统调用：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用；<br>所有进程初始都运行于用户空间，此时即为用户运行状态（简称：用户态）；<br>（当应用程序需要用到键盘、需要去读取文件、需要通过网络去发送一些资源的时候那么说白了也就是需要用到计算机的一些硬件资源的时候；那么这个时候就需要通过系统调用到内核来帮助执行；普通的应用程序在用户空间当中运行那么就称之为用户态；当应用程序如果需要调用内核的一些功能，即通过系统调用来进行调用内核当中的一些功能；那么这个时候应用程序就会进入内核态；那么用户态与内核态的切换是需要系统调用来进行的；）<br>但是当它调用系统调用执行某些操作时，例如I/O调用，此时需要陷入内核中运行，就称之为 进程处于内核运行态（或简称为 内核态）。</p><p>系统调用的过程可以简单理解为：</p><p><strong>1、</strong> 用户态程序将一些数据值放在寄存器中，或者使用参数创建一个堆栈，以此表明需要操作系统提供的服务。<br><strong>2、</strong> 用户态程序执行系统调用。<br><strong>3、</strong> CPU切换到内核态，并跳到 位于内存指定位置 的指令。<br><strong>4、</strong> 系统调用处理器（system call handler）会读取程序放入内存的数据参数，并执行程序请求的服务。<br><strong>5、</strong> 系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果。</p><p>首先应用程序属于用户态；即将调用内核函数的时候，那么应用程序会把现在程序的一个运行状态主要是程序运行的一些运行数值进行保存可能会保存在寄存器当中也有可能使用参数创建一个堆栈来保存现在应用程序的一些运行信息运行参数；<br>那么接着用户态的应用程序就会来进行执行系统调用；<br>那么经过系统调用之后，CPU就会切换到内核态；然后到内存当中指定的位置去执行相关指令；<br>接下来系统调用处理器它会进行用户态当中应用程序保存在堆栈或者是保存在寄存器当中的一些运行信息运行数据，然后并且会执行相应的内核函数以及请求一些内核的服务；<br>那么这个时候系统就由用户态切换到了内核态；<br>那么接着内核函数的调用在系统调用中调用完毕之后；<br>操作系统会进行重置CPU又切换为用户态；并且将内核态当中调用的结果进行返回；那么应用程序就又回到了用户空间；得到了内核函数系统调用返回的结果数据；</p><p>由此可见，用户态切换至内核态 需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器值、变量等，以备内核态切换回用户态。<br>这种切换就带来了大量的系统资源消耗，这就是synchronized未优化之前，效率低的原因（属于重量级锁）。</p><h3 id="monitor是重量级锁"><a href="#monitor是重量级锁" class="headerlink" title="monitor是重量级锁"></a>monitor是重量级锁</h3><p>在虚拟机规范对 monitorenter 和 monitorexit 的行为描述中，<br>有两点是需要特别注意的。  </p><p>首先，synchronized同步块 对 同一条线程来说是可重入的，不会出现自己把自己锁死的问题。</p><p>其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。  </p><p>第12章讲过，java的线程 是 映射到 操作系统的 原生线程 之上的，<br>如果要 阻塞或唤醒 一个线程，都需要操作系统来帮忙完成， 这就需要从用户态转换到核心态中，因此 状态转换需要耗费很多的处理器时间。</p><p>对于代码简单的同步块（如被synchronized修饰的 getter()或setter()方法），<br>状态转换消耗的时间 有可能比 用户代码执行的时间还要长。</p><p>所以 synchronized 是java语言中一个重量级（Heavyweight）的操作，有经验的程序员都会在确实必要的情况下才使用这种操作。  </p><p>而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态之中。  </p><p>可以看到ObjectMonitor的函数调用中会涉及到 Atomic::cmpxchg_ptr，Atomic::inc_prt等内核函数，这个时候就会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。</p><p>用户态和内核态是什么东西呢？<br>要想了解用户态和内核态还需要先了解一下Linux系统的体系架构：</p><h2 id="synchronized优化-CAS-AtomicInteger使用"><a href="#synchronized优化-CAS-AtomicInteger使用" class="headerlink" title="synchronized优化_CAS_AtomicInteger使用"></a>synchronized优化_CAS_AtomicInteger使用</h2><blockquote><p>第六章：JDK6 synchronized优化</p></blockquote><ul><li>CAS<ul><li>JDK6当中对synchronized所做的优化处理；</li><li>在JDK6当中对synchronized做了大量的优化处理；</li><li>以及这些优化处理很多都涉及到了CAS操作；</li></ul></li><li>锁升级过程<ul><li>锁升级依赖java对象头；</li></ul></li><li>Java对象的布局</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li><li>锁消除</li><li>锁优化</li><li>平时写代码如何对synchronized优化</li></ul><h3 id="目标-16"><a href="#目标-16" class="headerlink" title="目标"></a>目标</h3><p>学习CAS的作用<br>学习CAS的原理</p><h3 id="CAS概述和作用"><a href="#CAS概述和作用" class="headerlink" title="CAS概述和作用"></a>CAS概述和作用</h3><p>CAS的全称是 Compare And Swap（比较再交换）。<br>（确切一点称之为：比较并且相同再做交换）<br>是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。</p><p>CAS的作用是：CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理器CPU保证。<br>CAS可以保证共享变量赋值时的原子操作；<br>CAS在操作时依赖三个值；内存中的值V、旧的预估值X、要修改的新值B，<br>如果旧的预估值X等于内存中的值V，就将新的值B保存到内存中；替换这个内存中的值V；</p><p>(可以看做是一个轻量级的synchronized，它能保证变量修改的原子操作)</p><h4 id="CAS和volatile实现无锁并发"><a href="#CAS和volatile实现无锁并发" class="headerlink" title="CAS和volatile实现无锁并发"></a>CAS和volatile实现无锁并发</h4><p>java当中已经提供好了一个类叫做AtomicInteger；<br>这个类其底层即使用的就是CAS；</p><blockquote><p>回顾代码</p></blockquote><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo05_cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)<span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    Runnable mr = ()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(mr);</span><br><span class="line">      t.start();</span><br><span class="line">      ts.<span class="built_in">add</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t:ts)&#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"number = "</span> + atomicInteger.<span class="built_in">get</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：演示原子性问题</span></span><br><span class="line"><span class="comment">    1. 定义一个共享变量</span></span><br><span class="line"><span class="comment">    2. 对number进行1000次的++操作</span></span><br><span class="line"><span class="comment">    3. 使用5个线程来进行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span>&#123;</span></span><br><span class="line">  <span class="comment">// 1. 定义一个共享变量</span></span><br><span class="line">  <span class="comment">//private static int number = 0;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">// 2. 对number进行1000的++操作</span></span><br><span class="line">    Runnable increment = ()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//number++;</span></span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Thread&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">    <span class="comment">// 3. 使用5个线程来进行</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">      t.start();</span><br><span class="line">      <span class="built_in">list</span>.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t: <span class="built_in">list</span>)&#123;</span><br><span class="line">      t.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//System.out.println("number = " + number);</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"atomicInteger = "</span> + atomicInteger.<span class="built_in">get</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">由于number++并不是原子操作；</span></span><br><span class="line"><span class="comment">所以就会导致原子性问题的产生；</span></span><br><span class="line"><span class="comment">即最后会导致number输出时number的值是小于5000的；</span></span><br><span class="line"><span class="comment">  private static int number = 0;</span></span><br><span class="line"><span class="comment">那么此时就不使用int类型的共享变量number了；</span></span><br><span class="line"><span class="comment">而是给共享变量number换一种类型叫做AtomicInteger类型；</span></span><br><span class="line"><span class="comment">  private static AtomicInteger atomicInteger = new AtomicInteger();</span></span><br><span class="line"><span class="comment">变量名number换为atomicInteger；</span></span><br><span class="line"><span class="comment">并且number++操作也要换成atomicInteger.incrementAndGet();</span></span><br><span class="line"><span class="comment">那么atomicInteger.incrementAndGet()也会去做一个自增操作；</span></span><br><span class="line"><span class="comment">其该自增操作是一个原子性的操作；</span></span><br><span class="line"><span class="comment">最后打印atomicInteger的最新值；通过atomicInteger.get()来进行获取atomicInteger的最新值；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">最后再怎么运行发现运行结果都是5000；</span></span><br><span class="line"><span class="comment">也就意味着 AtomicInteger的incrementAndGet()方法可以进行保证共享变量赋值的原子性；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">多次运行后的运行打印：</span><br><span class="line">atomicInteger = <span class="number">5000</span></span><br><span class="line">atomicInteger = <span class="number">5000</span></span><br><span class="line">atomicInteger = <span class="number">5000</span></span><br><span class="line">.....</span><br><span class="line">-------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="synchronized优化-CAS原理"><a href="#synchronized优化-CAS原理" class="headerlink" title="synchronized优化_CAS原理"></a>synchronized优化_CAS原理</h2><p>CAS 原理</p><p>通过刚才 AtomicInteger 的源码可以看到， Unsafe类提供了原子操作。<br>AtomicInteger类当中其内部会包含一个叫做UnSafe的类；<br>UnSafe该类可以进行保证变量在赋值时的原子操作；<br>也就是UnSafe类当中提供了CAS操作；</p><h3 id="Unsafe类介绍"><a href="#Unsafe类介绍" class="headerlink" title="Unsafe类介绍"></a>Unsafe类介绍</h3><p>java是无法去操作内存地址的（即也就是没有指针）；</p><p>Unsafe类使java拥有了像C语言的指针一样操作内存空间的能力（操作对象的内存空间即能够操作对象里面的内容；但是这个UnSafe类不太安全；如果使用不当会出现一些比较危险的事情；所以java官方并不推荐使用；并且在jdk当中也无法找到此类；只能够通过反射的方式才能够找到该类），同时也带来了指针的问题。<br>过渡的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。<br>Unsafe对象不能直接调用，只能通过反射获得。  </p><h3 id="Unsafe实现CAS"><a href="#Unsafe实现CAS" class="headerlink" title="Unsafe实现CAS"></a>Unsafe实现CAS</h3><blockquote><p>AtomicInteger.java源码</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">publlic <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="title">extends</span> <span class="title">Number</span> <span class="title">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">  <span class="keyword">private</span> static <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">  <span class="keyword">private</span> static <span class="keyword">final</span> long valueOffset;</span><br><span class="line">  static &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      valueOffset = unsafe.objectFieldOffset(</span><br><span class="line">        AtomicInteger<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclareField</span></span>(<span class="string">"value"</span>)</span><br><span class="line">      );</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception ex)&#123; <span class="keyword">throw</span> new Error(ex);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> int value;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">AtomicInteger内部具有一个成员变量unsafe，通过Unsafe.getUnsafe()得到；</span><br><span class="line">另外需要注意的还是AtomicInteger是用来进行保存数字的；</span><br><span class="line">该AtomicInteger数值保存在AtomicInteger类成员变量value当中；</span><br><span class="line">而且该value成员变量使用了<span class="keyword">volatile</span>关键字进行修饰；</span><br><span class="line"><span class="keyword">volatile</span>即保证了多线程操作时的可见性；</span><br><span class="line">另外AtomicInteger类中还有一个成员变量valueOffset；</span><br><span class="line">那么valueOffset的作用即用来找到<span class="keyword">volatile</span>关键字修饰的value变量的内存地址；</span><br><span class="line">到时候根据AtomicInteger类所生成的对象atomicInteger的内存地址再加上偏移量valueOffset就可以找到value所在的内存地址了；</span><br><span class="line">也就可以找到value的取值；也就可以对value进行修改等操作；</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"># java测试用例代码</span><br><span class="line">Demo01.java</span><br><span class="line">    <span class="keyword">private</span> static AtomicInteger atomicInteger =  new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    Runnable increment = ()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>( int i = <span class="number">0</span> ; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        atomicInteger.incrementAndGet();  <span class="comment">// 变量赋值的原子性</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"># AtomicInteger.incrementAndGet()方法中具体执行流程；分析源码；</span><br><span class="line">-------------------</span><br><span class="line">AtomicInteger.java</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> int incrementAndGet()&#123;</span><br><span class="line">      <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">------------------</span><br><span class="line">        ↓</span><br><span class="line">------------------</span><br><span class="line">Unsafe<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> int getAndAddInt(Object var1, long var2, int var4)&#123;</span><br><span class="line">      int var5;</span><br><span class="line">      <span class="keyword">do</span>&#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1 , var2);</span><br><span class="line">      &#125;<span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5+var4));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//compareAndSwapInt CAS操作</span></span><br><span class="line">------------------</span><br><span class="line">分析执行流程：</span><br><span class="line">当刚进行创建AtomicInteger对象（AtomicInteger atomicInteger=new AtomicInteger();）时其AtomicInteger.java当中通过<span class="keyword">volatile</span>修饰的value变量取值为<span class="number">0</span>；</span><br><span class="line">假设AtomicInteger当中的成员变量value取值为<span class="number">0</span>之后；</span><br><span class="line">那么当前来进行<span class="keyword">for</span>循环atomicInteger进行执行incrementAndGet()方法；</span><br><span class="line">即也就意味着会执行到AtomicInteger.java类当中的incrementAndGet()方法；</span><br><span class="line">那么AtomicInteger.java类当中的incrementAndGet方法中又会去通过unsafe成员变量去执行方法getAndAddInt(<span class="keyword">this</span> , valueOffset, <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">即就相当于调用到了Unsafe<span class="class">.<span class="keyword">class</span>当中的<span class="title">getAndAddInt</span></span>(Object var1, long var2, int var4)方法；</span><br><span class="line">最后Unsafe<span class="class">.<span class="keyword">class</span>就在<span class="title">getAndAddInt</span></span>(Object var1, long var2, int var4)当中进行CAS的操作即<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5+var4);</span><br><span class="line"></span><br><span class="line">当前假设有两个线程，分别是线程t1和线程t2；</span><br><span class="line">那么此时这两个线程同时来进行执行Runnable当中所实现的run()方法即去执行循环，循环中执行atomicInteger.incrementAndGet()方法；</span><br><span class="line">假设t2线程先走，那么t2线程就会走过</span><br><span class="line">Demo01.java当中的atomicInteger.incrementAndGet()</span><br><span class="line">                   ↓</span><br><span class="line">AtomicInteger.java当中的incrementAndget方法中的unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>)+<span class="number">1</span></span><br><span class="line">                   ↓</span><br><span class="line">UnSafe<span class="class">.<span class="keyword">class</span>当中的<span class="title">getAndAddInt</span></span>(Object var1, long var2, int var4)当中的代码</span><br><span class="line">---------------------</span><br><span class="line">在Unsafe<span class="class">.<span class="keyword">class</span>当中的<span class="title">getAndAddInt</span></span>(Object var1, long var2, int var4)当中的var5的含义代表的是：（可以理解为是）旧的预估值；</span><br><span class="line">此时t2线程即准备进入到代码层中的<span class="keyword">do</span>-<span class="keyword">while</span>循环；</span><br><span class="line">那么先执行<span class="keyword">do</span>&#123;&#125;块当中的内容进行获取var5的取值，即获取旧的预估值取值；</span><br><span class="line">获取var5取值是通过 <span class="keyword">this</span>.getIntVolatile(var1, var2)方法进行获取得到的；</span><br><span class="line">通过两个参数var1以及var2就能够获取得到一个int类型的取值即var5；</span><br><span class="line">这两个参数当中的var1即Object var1，</span><br><span class="line">该var1即AtomicInteger.java的incrementAndGet()方法当中的<span class="keyword">this</span>，</span><br><span class="line">也就是在Demo01.java当中new好的atomicInteger对象（AtomicInteger atomicInteger = new AtomicInteger();）；</span><br><span class="line">那么var2即为AtomicInteger.java的incrementAndGet()方法当中的valueOffset，是一个内存偏移值；</span><br><span class="line">那么也就是说 var1+var2 → <span class="keyword">this</span>+valueOffset 其目的也就是找到<span class="keyword">private</span> <span class="keyword">volatile</span> value的取值；找到AtomicInteger.java当中的成员变量value的取值；</span><br><span class="line">（即当前AtomicInteger要执行类似number++的操作；而AtomicInteger所存的自增数值被存放在其AtomicInteger成员变量value当中；在进行自增操作时首先就需要去获取原先该AtomicInteger当中value的取值为多少或者是找到value的内存地址等信息然后对该value进行一个重新赋值的一个操作，修改操作；）</span><br><span class="line">找到AtomicInteger当中value的取值来作为一个旧的预估值；</span><br><span class="line">那么当前在创建AtomicInteger atomicInteger对象的时候，AtomicInteger当中的成员变量属性value取值为<span class="number">0</span>；</span><br><span class="line">即现在通过var1+var2 → <span class="keyword">this</span>+valueOffset参数调用<span class="keyword">this</span>.getIntVolatile方法获取得到的取值为<span class="number">0</span>即赋值给var5；</span><br><span class="line">假设一种极端的情况；即t2线程找到旧的预估值之后即var5变量被赋值；</span><br><span class="line">此时CPU切换到了另外一个线程上面去了；</span><br><span class="line">切换到t1线程上来了；</span><br><span class="line">那么t1线程也会来进行执行AtomicInteger类当中的incrementAndGet方法；</span><br><span class="line">即t1线程也会进入到Unsafe<span class="class">.<span class="keyword">class</span>当中的<span class="title">getAndAddInt</span>方法中来；</span></span><br><span class="line">那么此时t1也会来进行寻找一个旧的预估值即也会进入<span class="keyword">do</span>&#123;&#125;块当中进行调用<span class="keyword">this</span>.getIntVolatile来进行给var5进行赋值；也是通过<span class="keyword">this</span>和valueOffset来进行找到value的取值；</span><br><span class="line">那么此时就会存在有两个线程t1、t2来竞争准备给var5进行赋值操作；(极端情况)</span><br><span class="line">那么此时假设仍然还是t1线程先进行执行；</span><br><span class="line">那么这个时候t1线程就会进入<span class="keyword">while</span>当中执行<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5+var4)方法（即比较如果相同的话则并且交换一个int类型的取值）；</span><br><span class="line">分析compareAndSwapInt当中的参数var1、var2、var5、var4；</span><br><span class="line">var1: 其实还是这个<span class="keyword">this</span>，即AtomicInteger atomicInteger对象；</span><br><span class="line">var2: 即其实还是valueOffset，即内存偏移量；var1与var2的目的还是用于来进行找到内存中value的最新取值；此时找到的是value值取值为<span class="number">0</span>；由于AtomicInteger对象创建value变量便会赋值为<span class="number">0</span>；</span><br><span class="line">var5: 即旧的预估值；</span><br><span class="line">      即value旧的预估值取值，即也是<span class="number">0</span>；即var1+var2所在内存中查找到的value最新值与当前var5旧的预估值是相等的此时；</span><br><span class="line">      如果var1+var2在内存当中查找得到的value最新值 与 当前var5旧的预估值的取值一致，即相等；</span><br><span class="line">      那么var5+var4所加获得的值就会被赋值到内存当中的value取值上来，成为内存当中value的最新值；</span><br><span class="line">      即这个内存当中value的最新值就会变成var5+var4的和值；</span><br><span class="line">      当前var5旧的预估值为<span class="number">0</span>；</span><br><span class="line">      var4即为AtomicInteger.java类当中的方法incrementAndGet方法中所传入的值<span class="number">1</span>；</span><br><span class="line">      所以即也就是自增一的操作；</span><br><span class="line">      当var5与var4一加法运算完成之后那么得到新值<span class="number">1</span>；</span><br><span class="line">      那么也就是该新的值<span class="number">1</span>也就会赋值给内存当中value变量的取值；</span><br><span class="line">      因为当前是比较compare成功即var1+var2所查询获取得到的内存最新值<span class="number">0</span>与旧的预估值var5 <span class="number">0</span>处于两者相等的情况所以匹配成功了（比较成功之后进行了替换内存中value取值的一个操作，替换的值为var5+var4；即CAS需要的三个取值：内存中的值V、旧的预估值X、要修改的新值B；这个时候就属于旧的预估值+var4=要修改的新值B并替换掉了内存中的值V）；</span><br><span class="line">      那么这个时候<span class="keyword">this</span>.compareAndSwapInt（var1, var2, var5, var5+var4）就会返回<span class="literal">true</span>；</span><br><span class="line">      由于返回的是<span class="literal">true</span>，而<span class="keyword">while</span>(! <span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5+var4))当中的<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5+var4)加了! 表示否定；</span><br><span class="line">      即<span class="keyword">while</span>(<span class="literal">false</span>)则表示<span class="keyword">do</span>&#123;&#125;whille()结束循环；</span><br><span class="line">      即t1线程一次性设置自增<span class="number">1</span>成功；</span><br><span class="line">      那么此时t1线程就完成了自增<span class="number">1</span>的操作，结束任务；</span><br><span class="line">var4: 常量<span class="number">1</span>；在AtomicInteger.java的incrementAndGet方法当中所赋值<span class="number">1</span>；</span><br><span class="line"></span><br><span class="line">假设现在切换到t2线程当中来了；</span><br><span class="line">而之前是当t2线程拿到旧的预估值，</span><br><span class="line">也就是<span class="keyword">this</span>.getIntVolatile(var1, var2)拿到取值之后并且赋值给了t2线程当中的工作内存中的var5旧的预估值变量之后才进行CPU的切换的，</span><br><span class="line">即CPU当时切换到了t1线程；</span><br><span class="line">需要注意的是在CPU切换到t1线程之前t2线程中获取得到var5旧的预估值为<span class="number">0</span>；</span><br><span class="line">且当CPU切换到t1线程之后完成了自增<span class="number">1</span>的操作即比较内存value取值与t1线程中的工作内存中的var5旧的预估值取值相同的时候完成了交换SwapInt的操作即var5+var4替换掉或者说重新赋值给了内存当中value的取值了，即<span class="number">1</span>；</span><br><span class="line">那么也就是说此时CPU切换回来线程t2，</span><br><span class="line">而t2线程的工作内存中var5的取值为<span class="number">0</span>；</span><br><span class="line">而此时内存当中的value取值为<span class="number">1</span>；</span><br><span class="line">也就是两者取值不相同；</span><br><span class="line">就无法进行compareAndSwapInt交换的操作即无法完成value自增的操作；</span><br><span class="line"></span><br><span class="line">t2线程之前的var5取值为<span class="number">0</span>；那么t2线程也会来进行执行<span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2. var5, var5+var4));当中的compareAndSwapInt(var1, var2. var5, var5+var4)方法；</span><br><span class="line">此时分析在t2线程中执行的时候compareAndSwapInt(var1, var2. var5, var5+var4)方法当中的四个参数；</span><br><span class="line">var1 与 var2: 即<span class="keyword">this</span>+valueOffset即找到内存当中最新的预估值value，即此时内存当中value取值为<span class="number">1</span>；</span><br><span class="line">而旧的预估值即var5；t2线程获取得到的其取值为<span class="number">0</span>；</span><br><span class="line">那么此时就发现 内存value的最新值<span class="number">1</span>与旧的预估值var5的取值不一样；</span><br><span class="line">不一样则此时就不会进行对内存当中的value进行更新取值；并且返回一个<span class="literal">false</span>；</span><br><span class="line">即对于compareAndSwapInt(var1, var2. var5, var5+var4)操作返回的<span class="literal">false</span>；</span><br><span class="line">而<span class="keyword">while</span>(!compareAndSwapInt(var1, var2. var5, var5+var4))中该方法前是!，即表示<span class="keyword">while</span>(!<span class="literal">false</span>) ---&gt; <span class="keyword">while</span>(<span class="literal">true</span>) 即继续执行<span class="keyword">do</span>-<span class="keyword">while</span>循环；</span><br><span class="line">这次虽然内存当中value的最新值与t2线程中var5旧的预估值的取值不一样；</span><br><span class="line">但是<span class="literal">false</span>前面加了一个非即!；那么就会变成<span class="literal">true</span>；也就是说<span class="keyword">while</span>(<span class="literal">true</span>)则将继续进行<span class="keyword">do</span>-<span class="keyword">while</span>循环；</span><br><span class="line">则此时t2循环会接着这个<span class="keyword">do</span>-<span class="keyword">while</span>循环又进入到<span class="keyword">do</span>&#123;&#125;块当中；进行执行通过var1与var2即<span class="keyword">this</span>+valueOffset调用方法<span class="keyword">this</span>.getIntVolatile()方法获取找到得到内存当中value的最新值<span class="number">1</span>并赋值给t2线程的工作内存中var5变量；即此时t2线程var5变量为<span class="number">1</span>；继续执行代码<span class="keyword">while</span>(!compareAndSwapInt(var1, var2. var5, var5+var4))中的compareAndSwapInt(var1, var2. var5, var5+var4)；</span><br><span class="line">那么这次需要注意的是此时内存当中value的最新值为<span class="number">1</span>；</span><br><span class="line">而t2线程刚刚所找的旧的预估值var5也是<span class="number">1</span>；</span><br><span class="line">那么这一次的时候t2线程当中的旧的预估值var5与内存当中value的最新值相同都为<span class="number">1</span>；</span><br><span class="line">即内存最新值与旧的预估值相同那么就需要完成交换操作，</span><br><span class="line">即对内存中的value取值进行重新赋值为var5+var4，</span><br><span class="line">对内存当中value取值赋值一个最新值，</span><br><span class="line">那么这个最新值就是var5+var4（var5即旧的预估值<span class="number">1</span>；var4为常量<span class="number">1</span>）；</span><br><span class="line">得到运算结果为<span class="number">2</span>并赋值给当前内存当中的value取值</span><br><span class="line">（也就是说需要进行修改的最新值为<span class="number">2</span>）；</span><br><span class="line">那么由于内存最新值与旧的预估值一样那么就会将var5+var4，即<span class="number">2</span> 最新取值赋值给当前内存value变量取值；</span><br><span class="line">即当前内存当中value的取值为<span class="number">2</span>；完成一次自增效果；</span><br><span class="line">当赋值成功之后；</span><br><span class="line">并且compareAndSwapInt(var1, var2. var5, var5+var4)方法会返回<span class="literal">true</span>；</span><br><span class="line">那么一旦compareAndSwapInt(var1, var2. var5, var5+var4)返回<span class="literal">true</span>，而<span class="keyword">while</span>(!compareAndSwapInt(var1, var2. var5, var5+var4))中存在有一个非!的操作；那么也就是<span class="keyword">while</span>(<span class="literal">false</span>)至此相对于t2线程来说整个<span class="keyword">do</span>-<span class="keyword">while</span>循环就结束了，完成一次自增操作；</span><br><span class="line">那么此时就明白了CAS的原理；</span><br><span class="line">CAS主要是靠三个变量的取值；</span><br><span class="line">一个是内存当中的最新值；一个是旧的预估值；还有一个即新的要修改的值；</span><br><span class="line">如果当前内存当中的最新值与旧的预估值取值一样那么就把新的要修改的值赋值给内存当中的该最新值；并且返回tue；以至于<span class="keyword">while</span>(!<span class="literal">true</span>)，即<span class="keyword">while</span>(<span class="literal">false</span>)导致该<span class="keyword">do</span>-<span class="keyword">while</span>循环不再继续；</span><br><span class="line">如果当前内存当中的值与旧的预估值不一样；那么就会返回<span class="literal">false</span>，以至于<span class="keyword">while</span>(!<span class="literal">false</span>)，即<span class="keyword">while</span>(<span class="literal">true</span>)继续执行<span class="keyword">do</span>-<span class="keyword">while</span>循环；重新再一次拿到旧的预估值var5；并且再一次进行compareAndSwapInt操作，拿到最新的内存取值去进行比较以及是否交换内存取值，如果成功就不再进行循环如果不成功就继续进行<span class="keyword">do</span>-<span class="keyword">while</span>循环再次拿到内存最新值与旧的预估值进行比较...............；</span><br><span class="line">那么以上即为CAS的原理；</span><br></pre></td></tr></table></figure><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>从思想角度进行区分；</p><p><strong>悲观锁</strong> 从悲观的角度出发：</p><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，（这样的话就只有一个线程进来别的线程没有锁无法进入，即别的线程会阻塞，那么也就保证数据操作没有问题）这样别人想拿这个数据就会阻塞。<br>因此synchronized也将其称之为<strong>悲观锁</strong>。<br>JDK中的ReentrantLock也是一种<strong>悲观锁</strong>。<br>性能较差！<br>（总有刁民想害朕）</p><p><strong>乐观锁</strong> 从乐观的角度出发：<br>总是假设最好的情况，每次去拿数据的会后都认为别人不会修改，就算改了也没关系，再重试即可。<br>所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如果没有人修改则更新，如果有人修改则重试。</p><p>（乐观锁在对数据进行操作的时候总是很乐观的认为：当前线程进行操作的时候没有其他的线程来进行修改即干扰到当前线程的操作；因此乐观锁的操作是不上锁；但是也不能什么也不管，以防万一；那么乐观锁虽然在设置取值的时候不加锁但是会进行一个判断，即旧值与新值的判断； 即在设置前稍微做一个判断即旧的预估值与内存当中的最新取值是否一致；如果一致则直接设置如果不一致则说明有别的线程已经修改过，那么没有关系，当前线程进行重新循环，重新去获取内存中的最新值；重新来进行设置一次或者多次即可，即也就是重新尝试重新尝试重新尝试….）</p><p><strong>CAS</strong>这种机制也可以将其称之为<strong>乐观锁</strong>，综合<strong>性能较好</strong>！<br>（在修改的时候不上锁；只是做一个判断，不行则再次判断一次即可）</p><p>CAS可以保证变量在设置取值的时候可以保证其操作的一个原子性；<br>为了使得在线程间变量取值状态变化可见，<br>那么需要给该变量添加volatile关键字进行修饰；<br>volatile可以结合CAS机制实现无锁并发；<br>保证变量在修改时的原子性；<br>需要注意的是CAS只适合在竞争并不太激烈、多核CPU的情况场景下进行使用；<br>CAS之所以效率高是因为在其内部没有使用synchronized关键字；<br>那么也就是说CAS不会让线程进入阻塞状态；<br>那么也就避免了synchronized当中用户态和内核态的切换所带来的的性能消耗问题也避免了线程挂起等资源的消耗问题；<br>如果竞争非常激烈，那么CAS就会出现线程大量重试，因为多线程来进行竞争，那么也就导致有可能很多的线程设置取值失败，那么又要进行while循环重试；即大量的线程进行重试操作；成功存的线程反而不多；那么这样的话反而会会浪费性能，即性能变低；<br>所以如果竞争太激烈还使用的是CAS机制那么就会导致其性能比synchronized还会低；</p><blockquote><p>CAS获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰，结合CAS和volatile可以实现无锁并发，适用于竞争不激烈，多核CPU的场景下。</p><ol><li>因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</li></ol></blockquote><h3 id="小结-13"><a href="#小结-13" class="headerlink" title="小结"></a>小结</h3><p>CAS指的是Compare And Swap；会拿旧的预估值与内存当中的最新值进行比较；如果相同就进行交换并且把最新的值赋值到内存当中的这个变量；<br>CAS的作用？Compare And Swap，CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理器保证（由CPU支持）。<br>CAS的原理？CAS需要三个值：内存地址V、旧的预期值A、要修改的新值B，如果内存地址V和旧的预期值A相等就修改内存地址的值为B（即新的值B赋值到内存当中去）；</p><p>CAS的作用是什么？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAS</span>可以将比较和交换转换为原子操作，这个原子操作直接由处理器保证。</span><br></pre></td></tr></table></figure><p>CAS的原理是什么？</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CAS需要<span class="number">3</span>个值：内存地址V，旧的预期值<span class="keyword">A</span>，要修改的新值B</span><br><span class="line">如果内存地址V和旧的预期值<span class="keyword">A</span>相等就修改内存地址值为B</span><br></pre></td></tr></table></figure><h2 id="synchronized优化锁升级过程"><a href="#synchronized优化锁升级过程" class="headerlink" title="synchronized优化锁升级过程"></a>synchronized优化锁升级过程</h2><p>在JDK1.5之前synchronized只包含有一种锁即monitor重量级锁；<br>所以在JDK1.5之前其效率是比较低的；<br>另外在JDK的源码当中大量的使用到了synchronized；<br>包括java开发的时候也会经常使用到synchronized；<br>虚拟机开发团队就意识到了这个问题；<br>因此在JDK1.6这个版本当中对synchronized做了重要改进；<br>在JDK1.6当中synchronized就不仅仅只有monitor这一种重量级的锁了；<br>包括偏向锁、轻量级锁、适应性自旋、锁消除、锁优化等机制；<br>另外到转变成重量级锁之前会有一个适应性自旋的过程进行抢救一下；<br>这些机制的目的就是为了能够让synchronized的效率得到提升；</p><p>高效并发是从JDK1.5到JDK1.6的一个重要改进。<br>HotSpot虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，<br>包括如偏向锁（Biased Locking）、轻量级锁（Lightweight Locking）和适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock、Coarsening）等，<br>这些技术都是为了在线程之间更高效地共享数据，<br>以及解决竞争问题，从而提高程序的执行效率。</p><p>无锁 —→ 偏向锁 —→ 轻量级锁 —→ 重量级锁<br>在JDK1.6之后不是说直接就会变成重量级锁了；<br>而是会有一个过程；<br>首先对象是无锁状态；然后如果需要进行加锁那么就会进行添加一个偏向锁；<br>如果偏向锁无法满足不行的话就会换成轻量级锁；<br>如果轻量级锁不行的话就有可能会进入适应性自旋的过程；<br>如果通过适应性自旋依然没有抢到锁则换成重量级锁；<br>即会有这样一个锁升级的过程；<br>还需要注意的是JDK1.6当中既然存在有这些不同的锁；<br>那么必然是这些锁有其存在的不同场景下才适用；<br>并不是说这个锁是万能的；</p><h2 id="synchronized优化-对象的布局"><a href="#synchronized优化-对象的布局" class="headerlink" title="synchronized优化-对象的布局"></a>synchronized优化-对象的布局</h2><h3 id="回顾并引入-1"><a href="#回顾并引入-1" class="headerlink" title="回顾并引入"></a>回顾并引入</h3><p>JDK1.6时对synchronized做了很多的优化；<br>锁升级过程为 无锁 —→ 偏向锁 —→ 轻量级锁 —→ 重量级锁<br>那么这个锁升级的过程当中就会遇到锁存在有很多的状态；<br>那么这些锁的状态存在在哪里呢？<br>那么这些锁的状态也就存在在java对象的布局当中；<br>以前认为java当中存在成员变量，也称之为实例数据；<br>那么其实在JVM当中对象不仅仅会存放实例数据；<br>对象总共由三部分组成：对象头、实例数据（成员变量等）和对齐数据；</p><p>Java对象的布局</p><h3 id="目标-17"><a href="#目标-17" class="headerlink" title="目标"></a>目标</h3><p>学习java对象的布局</p><p>术语参考：<code>http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</code></p><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头由两部分组成；<br>synchronized锁可能有很多的状态，那么这些状态都是靠对象头来进行存储的；</p><p>当一个线程尝试访问 synchronized修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？是存在在锁对象的对象头中的。</p><p>在Hotspot虚拟机当中对象头又分为两种；<br>一种是普通对象的对象头即instanceOopDesc；<br>另外一种是描述数组的对象头即arrayOopDesc；<br>那么当前仅关心普通对象的对象头即instanceOopDesc；</p><p>Hotspot采用 instanceOopDesc和arrayOopDesc来描述对象头；<br>arrayOopDesc对象用来描述数组类型。<br>instanceOopDesc的定义的在Hotspot源码的 instanceOop.hpp 文件中，<br>另外， arrayOopDesc的定义对应 arrayOop.hpp。</p><p>instanceOop.hpp记录了对象头的信息；<br>instanceOopDesc当中没有很多代码；<br>但是可以发现instanceOop继承了父类oopDesc；<br>那么这个时候可以去看下其父类oopDesc中的代码；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 截取部分代码</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">instanceOopDesc</span> :</span> <span class="keyword">public</span> oopDesc&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// aligned header size.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">header_size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">sizeof</span>(instanceOopDesc)/HeapWordSize; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If compressed. the offset of the fields of the instance may not be aligned.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">base_offset_in_bytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">/* offset computation code breaks if useCompressedClassPointers</span></span><br><span class="line"><span class="comment">         only is true</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> (UseCompressedOops &amp;&amp; UseCompressedClassPointers) ? klass_gap_offset_in_bytes() : <span class="keyword">sizeof</span>(instanceOopDesc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">contains_field_offset</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">int</span> nonstatic_field_size)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> base_in_bytes = base_offset_in_bytes();</span><br><span class="line">      <span class="keyword">return</span> (offset &gt;= base_in_bytes &amp;&amp; (offset-base_in_bytes) &lt; nonstatic_field_size = heapOopSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从instanceOopDesc代码中可以看到 instanceOopDesc继承自oopDesc，<br>oopDesc的定义在Hotspot源码中的 oop.hpp文件中；</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span>&#123;</span></span><br><span class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span><br><span class="line">  <span class="keyword">private</span> :</span><br><span class="line">    volatile markOop _mark;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">_metadata</span>&#123;</span></span><br><span class="line">      Klass*       _klass; <span class="comment"># 没有开启指针压缩时的类型指针</span></span><br><span class="line">      narrowKlass  _compressed_klass; <span class="comment"># 开启了指针压缩</span></span><br><span class="line">    &#125; _metadata;</span><br><span class="line"></span><br><span class="line">    /<span class="regexp">/ Fast access to barrier set. Must be initialized.</span></span><br><span class="line"><span class="regexp">    static BarrierSet* _bs;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 省略其他代码</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>在openjdk当中Klass*与narrowKlass有相关的介绍；</p><blockquote><p><strong>klass pointer</strong><br>The second word of every object header.<br>Points to another object(a metaobject) which<br>describes the layout and behavior of the original object.<br>For java objects, the “Klass” contains a C++ style “vtable”.</p></blockquote><blockquote><p><strong>mark word</strong><br>The first word of every object header.<br>Ususlly a set of bitfields including synchronization state<br>and identity hash code.<br>May also be a poiter(with characteristic low bit encoding)<br>to synchronization related infomation.<br>During GC,may contain GC state bits.</p></blockquote><blockquote><p><strong>object header</strong><br>Common structure at the beginning of every GC-managed heap object.<br>(Every oop points to an object header.)<br>Includes fundamental information about the heap object’s layout, type , GC state, synchronization state, and identity hash code.<br>Consists of two words.<br>In arrays it is immediately followed by a length field.<br>Note that both java objects and VM-internal objects have a common object header format.</p></blockquote><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------</span><br><span class="line">|<span class="string">                          Xxx 对象                               </span>|</span><br><span class="line">|<span class="string">                          -------------------                    </span>|</span><br><span class="line">|<span class="string">                       ---</span>|<span class="string">  Mark     Word  </span>|<span class="string">  markOop   _mark   </span>|</span><br><span class="line">|<span class="string">-------------------   </span>|<span class="string">   -------------------                    </span>|</span><br><span class="line">||<span class="string"> instanceOopDesc </span>|<span class="string">-------</span>|<span class="string">  Klass pointer  </span>|<span class="string">  Klass*    _klass  </span>|</span><br><span class="line">||<span class="string"> 对象头          </span>|<span class="string">       --------------------                   </span>|</span><br><span class="line">|<span class="string">-------------------       </span>|<span class="string">  实例      数据  </span>|<span class="string">                   </span>|</span><br><span class="line">|<span class="string">                          --------------------                   </span>|</span><br><span class="line">|<span class="string">                          </span>|<span class="string">  对齐      数据  </span>|<span class="string">                   </span>|</span><br><span class="line">|<span class="string">                          --------------------                   </span>|</span><br><span class="line">-----------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>在 普通示例对象 中，oopDesc的定义包含两个成员，分别是<code>_mark</code>和<code>_metadata</code>。</p><p>_mark表示对象标记、属于markOop类型，也就是接下来要讲解的Mark Word，它记录了对象和锁有关的信息；<br>_metadata表示类元信息，类元信息存储的是对象指向它的类元数据（Klass）的首地址，其中Klass表示普通指针；<br>_compressed_klass表示压缩类指针。</p><p>对象头由两部分组成；<br>一部分用于存储自身的运行时数据，称之为Mark Word；<br>另一部分是类型指针，即对象指向它的类元数据的指针。</p><h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。</p><p>Mark Word对应的类型是markOop。<br>源码位于 <code>markOop.hpp</code>中。</p><blockquote><p>在32位状态下以及64位状态下每一位分别代表什么；</p></blockquote><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------</span><br><span class="line">// Bit-format of an object header (most significant first , big endian layout below):</span><br><span class="line">//</span><br><span class="line">// 32 bits:</span><br><span class="line">// ---------</span><br><span class="line">//           hash:25 --------------&gt;|<span class="string"> age:4   biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="string">//           JavaThread*:23 epoch:2   age:4   biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="string">//           size；32 -------------------------------------------&gt;</span>|<span class="string"> (CMS free block)</span></span><br><span class="line"><span class="string">//           PromotedObject*:29 ------------&gt; promo_bits:3 ------&gt;</span>|<span class="string"> (CMS promoted object)</span></span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">// 64 bits:</span></span><br><span class="line"><span class="string">// ----------</span></span><br><span class="line"><span class="string">// unused:25 hash:31 --&gt;</span>|<span class="string"> unused:1    age:4   biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="string">// JavaThread*:54 epoch:2 unused:1    age:4   biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="string">// PromotedObject*:61 ---------------------&gt;</span>|<span class="string"> promo_bits:3-----&gt;</span>|<span class="string"> (CMS promoted object)</span></span><br><span class="line"><span class="string">// size:64 ----------------------------------------------------&gt;</span>|<span class="string"> (CMS free block)</span></span><br><span class="line"></span><br><span class="line"><span class="string"># 偏向锁的时候其第三位是1；（0、1、2、3的顺序）</span></span><br><span class="line"><span class="string">//   [JavaThread* </span>|<span class="string"> epoch </span>|<span class="string"> age </span>|<span class="string"> 1 </span>|<span class="string"> 01]   lock is biased toward given thread</span></span><br><span class="line"><span class="string">//   [0           </span>|<span class="string"> epoch </span>|<span class="string"> age </span>|<span class="string"> 1 </span>|<span class="string"> 01]   lock is anonymously biased</span></span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">// - the two lock bits are used to describe three states: locked/unlocked and monitor.</span></span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string"># 当第三位为0的时候则表示不是偏向锁；那么就看其后两位；00表示轻量级锁；01表示无锁；10即monitor表示重量级锁；</span></span><br><span class="line"><span class="string">//   [ptr             </span>|<span class="string"> 00]  locked         ptr points to real header on stack           # 轻量级锁</span></span><br><span class="line"><span class="string">//   [header      </span>|<span class="string"> 0 </span>|<span class="string"> 01]  unlocked       regular object header                        # 无锁</span></span><br><span class="line"><span class="string">//   [ptr             </span>|<span class="string"> 10]  monitor        inflated lock (header is wapped out)         # 重量级锁</span></span><br><span class="line"><span class="string">//   [ptr             </span>|<span class="string"> 11]  marked         used by markSweep to mark an object</span></span><br><span class="line"><span class="string">//                                          not valid at any other time</span></span><br><span class="line"><span class="string">--------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">|<span class="string">---------------------------------------------------------------------------------</span>|<span class="string">--------------------</span>|</span><br><span class="line">|<span class="string">                              Mark Word(64 bits)                                 </span>|<span class="string">        State       </span>|</span><br><span class="line">|<span class="string">---------------------------------------------------------------------------------</span>|<span class="string">--------------------</span>|</span><br><span class="line">|<span class="string"> unused:25 </span>|<span class="string"> identity_hashcoder:31 </span>|<span class="string"> unused:1 </span>|<span class="string"> age:4 </span>|<span class="string"> biased_lock:1 </span>|<span class="string"> lock:2   </span>|<span class="string">        Normal      </span>|</span><br><span class="line">|<span class="string">---------------------------------------------------------------------------------</span>|<span class="string">--------------------</span>|</span><br><span class="line">|<span class="string"> thread:54 </span>|<span class="string">        epoch:2        </span>|<span class="string"> unused:1 </span>|<span class="string"> age:4 </span>|<span class="string"> biased_lock:1 </span>|<span class="string"> lock:2   </span>|<span class="string">        Biased      </span>|</span><br><span class="line">|<span class="string">---------------------------------------------------------------------------------</span>|<span class="string">--------------------</span>|</span><br><span class="line">|<span class="string">                   ptr_to_lock__record:62                             </span>|<span class="string"> lock:2   </span>|<span class="string"> Lightweight Locked </span>|</span><br><span class="line">|<span class="string">---------------------------------------------------------------------------------</span>|<span class="string">--------------------</span>|</span><br><span class="line">|<span class="string">               ptr_to_heavyweight_monitor:62                          </span>|<span class="string"> lock:2   </span>|<span class="string"> Heavyweight Locked </span>|</span><br><span class="line">|<span class="string">---------------------------------------------------------------------------------</span>|<span class="string">--------------------</span>|</span><br><span class="line">|<span class="string">                                                                      </span>|<span class="string"> lock:2   </span>|<span class="string"> Marked  for  GC    </span>|</span><br><span class="line">|<span class="string">---------------------------------------------------------------------------------</span>|<span class="string">--------------------</span>|</span><br></pre></td></tr></table></figure><blockquote><p>在<strong>64位虚拟机</strong>下，<strong>Mark Word</strong>是<strong>64bit</strong>大小的，其存储结构如下：</p></blockquote><p>（在不同的锁情况下每一位的作用不一样）  </p><table>  <tr>    <td rowspan="2">锁状态</td>    <td>25bit</td>    <td>31bit</td>    <td>1bit</td>    <td>4bit</td>    <td>1bit</td>    <td>2bit</td>  </tr>  <tr>    <td> </td>    <td> </td>    <td>cms_free</td>    <td>分代年龄</td>    <td>偏向锁</td>    <td>锁标志位</td>  </tr>  <tr>    <td>无锁</td>    <td>unused（没有使用）</td>    <td>hashCode</td>    <td></td>    <td></td>    <td>0（是否是偏向锁；0表示非偏向锁；1表示是偏向锁）</td>    <td>01（锁的标志位；01代表无锁；00代表轻量级锁；10代表重量级锁）</td>  </tr>    <tr>    <td>偏向锁</td>    <td colspan="2">ThreadId(54bit)Epoch(2bit)</td>    <td></td>    <td></td>    <td>1</td>    <td>01</td>  </tr>  <tr>    <td>轻量级锁</td>    <td colspan="5">指向栈中锁记录的指针</td>    <td>00</td>  </tr>  <tr>    <td>重量级锁</td>    <td colspan="5">指向互斥量（重量级锁）的指针</td>    <td>10</td>  </tr></table><blockquote><p>在32位虚拟机下，Mark Word是32bit大小的，其存储结构如下：</p></blockquote><table>  <tr>    <td rowspan="2">锁状态</td>    <td colspan="2">25bit</td>    <td rowspan="2">4bit</td>    <td>1bit</td>    <td>2bit</td>  </tr>  <tr>    <td>23bit</td>    <td>2bit</td>    <td>是否是偏向锁</td>    <td>锁标志位</td>  </tr>    <td>轻量级锁</td>    <td colspan="4">指向栈中锁记录的指针</td>    <td>00</td>    <tr>    <td>重量级锁</td>    <td colspan="4">指向互斥量（重量级锁）的指针</td>    <td>10</td>  </tr></table><p>一般网络上是32位居多；<br>现在的虚拟机绝大多数使用的是64位虚拟机；<br>所以现下关注的是64位虚拟机MarkWord的存储结构；<br>关于上述32or64位虚拟机的mark word是多少bit的存储结构等信息在markOop.hpp当中有详细介绍；</p><p>Klass pointer 类型指针；</p><h3 id="Klass-pointer"><a href="#Klass-pointer" class="headerlink" title="Klass pointer"></a>Klass pointer</h3><p>java当中的对象肯定是由某个类所产生的；<br>那么Klass pointer就是用来表示该对象是哪一个类所产生的；<br>Klass pointer会保存这个类的元信息；<br>Klass pointer根据虚拟机大小其自身大小也不一样；<br>如果是32位虚拟机则其Klass pointer的大小为32位；<br>如果是64位虚拟机则其Klass pointer的大小为64位；<br>一般来说虚拟机都会开启指针压缩；<br>即也就是说在64位虚拟机情况下其Klass pointer也会被压缩成32位；</p><p>这一部分用于 存储对象的类型指针，<br>该指针 指向它的类元数据，<br>JVM通过这个指针确定对象是哪个类的实例。<br>该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位；</p><p>如果应用的对象过多，使用64位的指针将大量浪费内存，<br>统计而言，64位的JVM将会比32位的JVM多耗费50%的内存。<br>为了节约内存可以使用选项<code>-XX:+UseCompressedOops</code>开启指针压缩；<br>其中，oop即ordinary object pointer普通对象指针。<br>开启该选项后，下列指针将压缩至32位：</p><ol><li>每个Class的属性指针（即静态变量）</li><li>每个对象的属性指针（即对象变量）</li><li>普通对象数组的每个元素指针</li></ol><p>当然，也不是所有的指针都会压缩；<br>一些特殊类型的指针JVM不会优化，<br>比如执行PermGen的Class对象指针（JDK8中指向元空间的Class对象指针）、本地变量、堆栈元素、入参、返回值和NULL指针等。</p><p>对象头 = Mark Word + 类型指针（未开启指针压缩的情况下）<br>在32位系统中，Mark Word = 4 bytes， 类型指针 = 4bytes， 对象头 = 8bytes = 64 bits；<br>在64位系统中，Mark Word = 8 bytes， 类型指针 = 8bytes， 对象头 = 16bytes = 128 bits；</p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>就是类中定义的成员变量。</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>（可能有可能没有；如果java对象整体大小为8字节的整数倍那么这个时候就不需要对齐填充；如果java对象整体大小不为8字节的整数倍那么这个时候就需要对齐填充的一些填充数据使之对齐从而变成8字节的整数倍；那么这样是方便操作系统来进行寻址的）；<br>对齐填充并不是必然存在的，也没有什么特别的意义，它仅仅起着占位符的作用。<br>由于HotSpot VM的自动内存管理系统 要求 对象起始地址必须是8字节的整数倍。<br>换句话说，就是对象的大小必须是8字节的整数倍。<br>而对象头正好是8字节的整数倍，<br>因此，当对象实例数据没有对齐时，就需要通过对齐填充来补全。</p><h3 id="查看java对象布局"><a href="#查看java对象布局" class="headerlink" title="查看java对象布局"></a>查看java对象布局</h3><p>之前是通过观察JVM源码的方式来进行查看的接着来进行验证一下；<br>工具类；openjdk提供叫做jol；<br>java对象布局的工具；可以来查看java对象布局；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aratifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">aratifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------</span><br><span class="line">package com.xxx.demo06_object_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">LockObj</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> x;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line">package com.xxx.demo06_object_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo01</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123;</span><br><span class="line">    LockObj obj = new LockObj();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//parseInstance 解析实例对象；</span></span><br><span class="line">    <span class="comment">//toPrintable进行打印其解析的实例对象信息</span></span><br><span class="line">    ClassLayout.parseInstance(obj).toPrintable().;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------</span><br><span class="line">打印对象布局：</span><br><span class="line">com.xxx.demo06_object_layout.LockObj object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134168253</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line"> Instance size: <span class="number">16</span> bytes</span><br><span class="line"> Space losses: <span class="number">0</span> bytes <span class="built_in">int</span>ernal + <span class="number">0</span> bytes <span class="keyword">external</span> = <span class="number">0</span> bytes total</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">分析：</span><br><span class="line">从整个对象开始；</span><br><span class="line">OFFSET偏移<span class="number">0</span>；SIZE为<span class="number">4</span>表示用了<span class="number">4</span>个字节去进行描述DESCRIPTION对象头object header信息；</span><br><span class="line">OFFSET偏移<span class="number">4</span>；SIZE为<span class="number">4</span>表示用了<span class="number">4</span>个字节也是去进行描述DESCRIPTION与对象头object header相关的内容；</span><br><span class="line">OFFSET偏移<span class="number">8</span>；SIZE为<span class="number">4</span>表示用了<span class="number">4</span>个字节也是去进行描述DESCRIPTION与对象头object header相关的内容；</span><br><span class="line">那么此时来看对象头object header所占了<span class="number">3</span> * <span class="number">4</span> = <span class="number">12</span>个字节来进行描述与对象头object header相关信息；</span><br><span class="line">与之前所说：在<span class="number">64</span>位系统中，Mark Word = <span class="number">8</span> bytes，类型指针 = <span class="number">8</span>bytes，对象头 = <span class="number">16</span> bytes = <span class="number">128</span> bits；此处存在偏差；</span><br><span class="line">由于也是<span class="number">64</span>位操作系统但是打印得到其对象布局信息得到的对象头所占字节信息不一致；</span><br><span class="line">实际上打印出来对象头object header所占字节数并不是<span class="number">16</span>个字节而是<span class="number">12</span>个字节；</span><br><span class="line">那么为什么打印出来的对象布局信息中的object header对象头信息所占字节不是<span class="number">16</span>个字节而是<span class="number">12</span>个字节呢?</span><br><span class="line">那么这是因为JVM默认自动开启了指针压缩的选项参数；</span><br><span class="line">从而也就导致了JVM在默认情况下去进行打印对象布局当中的对象头信息所占字节为<span class="number">12</span>个字节而不是<span class="number">16</span>个字节；</span><br><span class="line">所以此时可以尝试进行关闭指针压缩进行尝试；</span><br><span class="line">选项-XX:+UseCompressedOops是用来进行开启指针压缩；</span><br><span class="line">所以此时可以用-XX:+UseCompressedOops拿过来来作为JVM的一个参数；</span><br><span class="line">即打开idea的Run/Debug Configurations中填入到VM options当中即可；</span><br><span class="line">那么此时要注意的是-XX:+UseCompressedOops是用来开启指针压缩的；</span><br><span class="line">而JVM默认就是开启指针压缩的；而此时要做的是让JVM关闭指针压缩；</span><br><span class="line">所以此时VM options当中填入的即为：-XX:-UseCompressedOops；</span><br><span class="line">-XX:-UseCompressedOops即 - 为关闭指针压缩了；</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">再次打印对象布局:</span><br><span class="line">com.xxx.demo06_object_layout.LockObj object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     d8 <span class="number">34</span> <span class="number">5</span>a <span class="number">25</span> (<span class="number">11011000</span> <span class="number">00110100</span> <span class="number">01011010</span> <span class="number">00100101</span>) (<span class="number">626668760</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>        （object header）     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">     <span class="number">16</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line">     <span class="number">20</span>      <span class="number">4</span>        （loss due to the next object alignment）</span><br><span class="line"> Instance size: <span class="number">24</span> bytes</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"> 此时就可以分析看到对象布局当中object header对象头所占字节为<span class="number">16</span>个字节；</span><br><span class="line"> 其中；后面<span class="number">8</span>个字节即第三排和第四排的object header是用来表示Klass pointer，也就是这个对象所对应的这个类的元信息；</span><br><span class="line"> LockObj.x在偏移OFFSET为<span class="number">16</span>的时候所占字节为<span class="number">4</span>个字节；</span><br><span class="line"> 那么此时所累加字节数为 <span class="number">16</span>个对象头信息所占字节数 + LockObject.x <span class="built_in">int</span>类型变量所占字节数为<span class="number">4</span>个字节 = 累计当前字节数为 <span class="number">20</span> 个字节；</span><br><span class="line"> （那么当前此时是不满足对象头信息总占字节数需要为<span class="number">8</span>个字节的整数倍这一限制条件的；）</span><br><span class="line">而<span class="number">20</span>个字节并不是<span class="number">8</span>字节的整数倍；</span><br><span class="line">所以此时就有了填充数据；即最后一排的<span class="number">4</span>个字节，加了<span class="number">4</span>个字节的填充数据；即:</span><br><span class="line"> <span class="number">20</span>      <span class="number">4</span>        （loss due to the next object alignment）</span><br><span class="line">那么将关闭指针压缩参数进行去掉再次分析原来的打印结果：</span><br><span class="line">VM options: -XX:+UseCompressedOops</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">再次打印对象布局：</span><br><span class="line">com.xxx.demo06_object_layout.LockObj object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134168253</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line"> Instance size: <span class="number">16</span> bytes</span><br><span class="line"> Space losses: <span class="number">0</span> bytes <span class="built_in">int</span>ernal + <span class="number">0</span> bytes <span class="keyword">external</span> = <span class="number">0</span> bytes total</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">从上面的分析可得此时Klass pointer的指针只占了<span class="number">4</span>个字节；即：</span><br><span class="line"><span class="number">8</span>      <span class="number">4</span>        （object header）     <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134168253</span>)</span><br><span class="line">整个对象布局当中对象头信息所占字节数为<span class="number">12</span>个字节；</span><br><span class="line">再加上LockObj当中的<span class="built_in">int</span>类型变量占有<span class="number">4</span>个字节；</span><br><span class="line">所以此时累计总共占有字节数为<span class="number">16</span>个字节；为<span class="number">8</span>字节的整数倍；</span><br><span class="line">所以此时并没有填充数据；</span><br><span class="line">那么再做测试在LockObj类当中再写一个变量<span class="keyword">private</span> <span class="built_in">bool</span>ean b；</span><br><span class="line">那么布尔类型的变量在java当中所占字节是为<span class="number">1</span>个字节；</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">package com.xxx.demo06_object_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">LockObj</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">bool</span>ean b;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">再次打印对象布局：</span><br><span class="line">com.xxx.demo06_object_layout.LockObj object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134168253</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line">     <span class="number">16</span>      <span class="number">1</span>  <span class="built_in">bool</span>ean LockObj.b           <span class="literal">false</span></span><br><span class="line">     <span class="number">17</span>      <span class="number">7</span>    <span class="built_in">int</span> （loss due to the next object alignment）</span><br><span class="line"> Instance size: <span class="number">24</span> bytes</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">此时分析到：<span class="built_in">bool</span>ean布尔类型在其中占用到了<span class="number">1</span>个字节数；</span><br><span class="line">那么此时累加到字节数即为：<span class="number">12</span>个对象头信息所占字节数 + LockObj当中<span class="built_in">int</span>类型变量所占字节数<span class="number">4</span>个字节 + LockObj当中<span class="built_in">bool</span>ean类型所占字节数为<span class="number">1</span>个字节 = 总计字节数为<span class="number">17</span>个字节；</span><br><span class="line">而<span class="number">17</span>个字节数显然是不满足<span class="number">8</span>字节的整数倍这一说法；</span><br><span class="line">所以就存在有最后一排的对齐填充数据占有<span class="number">7</span>个字节进行平衡；即：</span><br><span class="line"><span class="number">17</span>      <span class="number">7</span>    <span class="built_in">int</span> （loss due to the next object alignment）</span><br><span class="line">填充了<span class="number">7</span>个字节之后导致数据实例大小为<span class="number">24</span>个字节满足<span class="number">8</span>字节的整数倍这一说法；</span><br><span class="line">另外还有一个问题，在<span class="number">64</span>位虚拟机下，Mark Word是<span class="number">64</span>bit大小的；</span><br><span class="line">其中是存在有<span class="number">31</span>位导致hashCode的；但是根据上述的打印结果来看好像是并没有看到什么有关hashCode相关的内容；</span><br><span class="line"><span class="number">8</span>      <span class="number">4</span>        （object header）     <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134168253</span>)</span><br><span class="line">除了地址之外没有看到有关hashCode相关的内容；</span><br><span class="line"></span><br><span class="line">hashCode的取值不是一来就有的；</span><br><span class="line">而是先需要在代码层当中使用到了这个hashCode那么它才会去进行保存这个hashCode取值；</span><br><span class="line">也就是说生成LockObj obj对象之后，需要去代码层当中调用该obj对象的.hashCode()方法；那么在打印结果当中才能够看到有关hashCode的信息；</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">package com.xxx.demo06_object_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo01</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123;</span><br><span class="line">    LockObj obj = new LockObj();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用obj对象的hashCode()方法</span></span><br><span class="line">    obj.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//parseInstance 解析实例对象；</span></span><br><span class="line">    <span class="comment">//toPrintable进行打印其解析的实例对象信息</span></span><br><span class="line">    ClassLayout.parseInstance(obj).toPrintable().;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">再次打印对象布局：</span><br><span class="line">com.xxx.demo06_object_layout.LockObj object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">01</span> <span class="number">28</span> <span class="number">6</span>e <span class="number">6f</span> (<span class="number">00000001</span> <span class="number">00101000</span> <span class="number">01101110</span> <span class="number">01101111</span>) (<span class="number">1869490177</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">6</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01101101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">109</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134168253</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line">     <span class="number">16</span>      <span class="number">1</span>  <span class="built_in">bool</span>ean LockObj.b           <span class="literal">false</span></span><br><span class="line">     <span class="number">17</span>      <span class="number">7</span>    <span class="built_in">int</span> （loss due to the next object alignment）</span><br><span class="line"> Instance size: <span class="number">24</span> bytes</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">再次分析对象布局的打印信息当中此时存在VALUE当中的一些数据；</span><br><span class="line">那么这些数据就代表着hashCode；</span><br><span class="line">即：</span><br><span class="line"><span class="number">01</span> <span class="number">28</span> <span class="number">6</span>e <span class="number">6f</span> (<span class="number">00000001</span> <span class="number">00101000</span> <span class="number">01101110</span> <span class="number">01101111</span>) (<span class="number">1869490177</span>)</span><br><span class="line"><span class="number">6</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01101101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">109</span>)</span><br><span class="line">那么如何判断上述是否真的为hashCode呢？那么来进行一下验证；</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">package com.xxx.demo06_object_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo01</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123;</span><br><span class="line">    LockObj obj = new LockObj();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用obj对象的hashCode()方法</span></span><br><span class="line">    obj.hashCode();</span><br><span class="line">    <span class="comment">//该打印的为十进制的hashCode</span></span><br><span class="line">    System.<span class="keyword">out</span>.println(obj.hashCode());</span><br><span class="line">    <span class="comment">//换一种打印方式；使用Integer.toHexString()将十进制hashCode转换成十六进制的hashCode</span></span><br><span class="line">    System.<span class="keyword">out</span>.println(Integer.toHexString(obj.hashCode()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//parseInstance 解析实例对象；</span></span><br><span class="line">    <span class="comment">//toPrintable进行打印其解析的实例对象信息</span></span><br><span class="line">    ClassLayout.parseInstance(obj).toPrintable().;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">再次输出结果并打印对象布局：</span><br><span class="line"><span class="number">1836019240</span>    # <span class="number">10</span>进制hashCode</span><br><span class="line"><span class="number">6</span>d6f6e28      # <span class="number">16</span>进制hashCode</span><br><span class="line">com.xxx.demo06_object_layout.LockObj object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">01</span> <span class="number">28</span> <span class="number">6</span>e <span class="number">6f</span> (<span class="number">00000001</span> <span class="number">00101000</span> <span class="number">01101110</span> <span class="number">01101111</span>) (<span class="number">1869490177</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">6</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01101101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">109</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134168253</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line">     <span class="number">16</span>      <span class="number">1</span>  <span class="built_in">bool</span>ean LockObj.b           <span class="literal">false</span></span><br><span class="line">     <span class="number">17</span>      <span class="number">7</span>    <span class="built_in">int</span> （loss due to the next object alignment）</span><br><span class="line"> Instance size: <span class="number">24</span> bytes</span><br><span class="line"> -----------------------------------------------------------</span><br><span class="line"> 分析此时发现十六进制位的hashCode：<span class="number">6</span>d6f6e28与</span><br><span class="line"> <span class="number">01</span> <span class="number">28</span> <span class="number">6</span>e <span class="number">6f</span> (<span class="number">00000001</span> <span class="number">00101000</span> <span class="number">01101110</span> <span class="number">01101111</span>) (<span class="number">1869490177</span>)</span><br><span class="line"> <span class="number">6</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01101101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">109</span>)</span><br><span class="line"> 对比起来有些茫然；顺序不一致（尽管对象布局的对象头信息打印中出现了这些字符串）；</span><br><span class="line">这里需要稍微注意一下；有一个大端和小端的问题；</span><br><span class="line">比如说当前存在有<span class="number">64</span>位；</span><br><span class="line"><span class="number">64</span>位有大端和小端的区别；</span><br><span class="line">第一种情况</span><br><span class="line">    <span class="number">1</span>       <span class="number">2</span>        <span class="number">3</span>        <span class="number">4</span>        <span class="number">5</span>         <span class="number">6</span>        <span class="number">7</span>       <span class="number">8</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">第二种情况</span><br><span class="line">    <span class="number">8</span>       <span class="number">7</span>        <span class="number">6</span>        <span class="number">5</span>        <span class="number">4</span>         <span class="number">3</span>        <span class="number">2</span>       <span class="number">1</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">那么刚才在<span class="number">64</span>位JVM当中看到的是属于哪一种呢？</span><br><span class="line">即为下面第二种情况当中的；也就是说<span class="number">64</span>位的Mark Word</span><br><span class="line">    <span class="number">8</span>       <span class="number">7</span>        <span class="number">6</span>        <span class="number">5</span>        <span class="number">4</span>         <span class="number">3</span>        <span class="number">2</span>       <span class="number">1</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">前面<span class="number">25</span>位是没有进行使用的；中间的话存在<span class="number">31</span>位是被用来表示hashCode的；</span><br><span class="line">后面倒数第三位表示偏向锁；最后两位表示其他锁的标志位；</span><br><span class="line">但是java当中通过jol工具进行打印出来的对象布局当中的hashCode信息是反过来的；</span><br><span class="line">即所以需要反过来进行查看；即</span><br><span class="line"> <span class="number">01</span> <span class="number">28</span> <span class="number">6</span>e <span class="number">6f</span> (<span class="number">00000001</span> <span class="number">00101000</span> <span class="number">01101110</span> <span class="number">01101111</span>) (<span class="number">1869490177</span>)</span><br><span class="line"> <span class="number">6</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01101101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">109</span>)</span><br><span class="line"> 需要反过来看即</span><br><span class="line"> （忽略前面的<span class="number">00</span> <span class="number">00</span> <span class="number">00</span>前面的这<span class="number">25</span>位；中间的<span class="number">6</span>d <span class="number">6f</span> <span class="number">6</span>e <span class="number">28</span>这<span class="number">31</span>位才是用来表示hashCode的；）：</span><br><span class="line"> <span class="number">01</span> <span class="number">28</span> <span class="number">6</span>e <span class="number">6f</span> (<span class="number">00000001</span> <span class="number">00101000</span> <span class="number">01101110</span> <span class="number">01101111</span>) (<span class="number">1869490177</span>)</span><br><span class="line"> <span class="number">6</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01101101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">109</span>)</span><br><span class="line">即hashCode为<span class="number">6</span>d <span class="number">6f</span> <span class="number">6</span>e <span class="number">28</span>(<span class="number">01101101</span> <span class="number">01101111</span> <span class="number">01101110</span> <span class="number">00101000</span>)</span><br><span class="line">至此也是使用了java工具来进行验证了对象的布局；</span><br></pre></td></tr></table></figure><table>  <tr>    <td rowspan="2">锁状态</td>    <td>25bit</td>    <td>31bit</td>    <td>1bit</td>    <td>4bit</td>    <td>1bit</td>    <td>2bit</td>  </tr>  <tr>    <td> </td>    <td> </td>    <td>cms_free</td>    <td>分代年龄</td>    <td>偏向锁</td>    <td>锁标志位</td>  </tr>  <tr>    <td>无锁</td>    <td>unused（没有使用）</td>    <td>hashCode</td>    <td></td>    <td></td>    <td>0（是否是偏向锁；0表示非偏向锁；1表示是偏向锁）</td>    <td>01（锁的标志位；01代表无锁；00代表轻量级锁；10代表重量级锁）</td>  </tr>    <tr>    <td>偏向锁</td>    <td colspan="2">ThreadId(54bit)Epoch(2bit)</td>    <td></td>    <td></td>    <td>1</td>    <td>01</td>  </tr>  <tr>    <td>轻量级锁</td>    <td colspan="5">指向栈中锁记录的指针</td>    <td>00</td>  </tr>  <tr>    <td>重量级锁</td>    <td colspan="5">指向互斥量（重量级锁）的指针</td>    <td>10</td>  </tr></table><h3 id="小结-14"><a href="#小结-14" class="headerlink" title="小结"></a>小结</h3><p>java对象由三部分组成：对象头、实例数据、对齐数据；<br>对象头分为两部分：Mark Word + Klass pointer；</p><h2 id="synchronized优化-偏向锁"><a href="#synchronized优化-偏向锁" class="headerlink" title="synchronized优化-偏向锁"></a>synchronized优化-偏向锁</h2><h3 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h3><p>高效并发是从JDK1.5到JDK1.6的一个重要改进。<br>HotSpot虚拟机开发团队在这个版本上花费了大量的精力趋实现各种锁优化技术，<br>如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，<br>这些技术都是为了 在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p><p>无锁–→偏向锁–→轻量级锁–→重量级锁</p><p>无锁并不会直接进入到重量级锁当中去；而是先进入偏向锁；</p><p>偏向锁</p><h3 id="目标-18"><a href="#目标-18" class="headerlink" title="目标"></a>目标</h3><p>学习偏向锁的原理和好处</p><h3 id="什么是偏向锁"><a href="#什么是偏向锁" class="headerlink" title="什么是偏向锁"></a>什么是偏向锁</h3><p>偏向锁是JDK6中的重要引进，因为HotSpot作者经过研究实践发现，<br>（代码）在大多数情况下，锁不仅不存在多线程竞争而且总是由同一线程多次获得（即由同一个线程反复的得到锁释放锁得到锁释放锁；如果一上来就是重量级锁的话那么得到锁就需要花费性能释放锁也需要花费性能），为了让线程获得锁的代价更低，引进了偏向锁。<br>减少不必要的CAS操作。</p><p>偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及ThreadID即可。</p><p>不过一旦出现多个线程竞争时，必须撤销偏向锁，<br>所以撤销偏向锁消耗的性能必须小于之前节省下来的CAS原子操作的性能消耗，<br>不然就得不偿失了。</p><p>如果是偏向锁则倒数第三个字节会变成1；另外由前面56个字节当中的前54个字节会来保存偏向锁的id；另外56个字节当中其余两个字节用来保证Epoch即时间；</p><table>  <tr>    <td rowspan="2">锁状态</td>    <td>25bit</td>    <td>31bit</td>    <td>1bit</td>    <td>4bit</td>    <td>1bit</td>    <td>2bit</td>  </tr>  <tr>    <td> </td>    <td> </td>    <td>cms_free</td>    <td>分代年龄</td>    <td>偏向锁</td>    <td>锁标志位</td>  </tr>  <tr>    <td>无锁</td>    <td>unused（没有使用）</td>    <td>hashCode</td>    <td></td>    <td></td>    <td>0（是否是偏向锁；0表示非偏向锁；1表示是偏向锁）</td>    <td>01（锁的标志位；01代表无锁；00代表轻量级锁；10代表重量级锁）</td>  </tr>    <tr>    <td>偏向锁</td>    <td colspan="2">ThreadId(54bit)Epoch(2bit)</td>    <td></td>    <td></td>    <td>1</td>    <td>01</td>  </tr>  <tr>    <td>轻量级锁</td>    <td colspan="5">指向栈中锁记录的指针</td>    <td>00</td>  </tr>  <tr>    <td>重量级锁</td>    <td colspan="5">指向互斥量（重量级锁）的指针</td>    <td>10</td>  </tr></table><p>但是需要注意的是这个偏向锁仅限用于没有竞争的状态；<br>也就是说反复是同一个线程获得锁释放锁；</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo07_biased_lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环5次并且进出同步代码块就只有一个线程；</span></span><br><span class="line"><span class="comment">// 那么这种情况就适合使用偏向锁；</span></span><br><span class="line"><span class="comment">// 即反复是同一个线程进入同步代码块的情况；</span></span><br><span class="line"><span class="comment">// 但是如果遇到有线程来进行竞争那么即立即要撤销掉偏向锁从而升级到轻量级锁；</span></span><br></pre></td></tr></table></figure><h3 id="偏向锁原理"><a href="#偏向锁原理" class="headerlink" title="偏向锁原理"></a>偏向锁原理</h3><p>当线程第一次访问同步代码块并获取锁时，偏向锁处理流程如下：</p><blockquote><ol><li>检测Mark Word是否为 可偏向状态，即是否为偏向锁1，锁标识为为01。</li><li>若为 可偏向状态，则测试线程ID是否为当前线程ID，如果是，执行同步代码块，否则执行步骤（3）</li><li>如果测试线程ID不为当前线程ID，则通过CAS操作将Mark Word的线程ID替换为当前线程，执行同步代码块</li></ol></blockquote><blockquote><ol><li>虚拟机将会把对象头中的标志位设为“01”，即偏向模式</li><li>同时使用 CAS操作 把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步代码块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</li></ol></blockquote><p>首先虚拟机会进行检查这个偏向锁的状态即倒数第三位取值是否为0；<br>是0的话那么也就代表着可以进行偏向，将倒数第三位修改成1表示偏向锁；那么虚拟机也就会将其倒数两位数改成01；即变成偏向锁；<br>那么还会通过CAS操作将对象的Mark Word当中的前54位修改为当前获取得到偏向锁的线程的Thread ID；那么到此时这个偏向锁就设置成功了；<br>那么以后的话线程退出同步代码块的时候并不需要做任何操作而下一次循环当中重新进入同步代码块时，只需要进行判定一下THREAD ID即Mark Word当中的前54位当中的取值即THREAD ID与当前该要获取锁的线程的THREAD ID是否相同；<br>如果是一样的话那么则进入同步代码块当中；无需其他操作；<br>所以偏向锁它在一个线程的情况下其效率还是很高的；</p><table>  <tr>    <td rowspan="2">锁状态</td>    <td>25bit</td>    <td>31bit</td>    <td>1bit</td>    <td>4bit</td>    <td>1bit</td>    <td>2bit</td>  </tr>  <tr>    <td> </td>    <td> </td>    <td>cms_free</td>    <td>分代年龄</td>    <td>偏向锁</td>    <td>锁标志位</td>  </tr>  <tr>    <td>无锁</td>    <td>unused（没有使用）</td>    <td>hashCode</td>    <td></td>    <td></td>    <td>0（是否是偏向锁；0表示非偏向锁；1表示是偏向锁）</td>    <td>01（锁的标志位；01代表无锁；00代表轻量级锁；10代表重量级锁）</td>  </tr>    <tr>    <td>偏向锁</td>    <td colspan="2">ThreadId(54bit)Epoch(2bit)</td>    <td></td>    <td></td>    <td>1</td>    <td>01</td>  </tr>  <tr>    <td>轻量级锁</td>    <td colspan="5">指向栈中锁记录的指针</td>    <td>00</td>  </tr>  <tr>    <td>重量级锁</td>    <td colspan="5">指向互斥量（重量级锁）的指针</td>    <td>10</td>  </tr></table><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo07_biased_lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo01</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123;</span><br><span class="line">    MyThread mt = new MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">MyThread</span> <span class="symbol">extends</span> <span class="symbol">Thread</span>&#123;</span><br><span class="line">  static Object obj = new Object();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> run()&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      synchronized(obj)&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">线程进过5次循环每一次循环都进入到同步代码块当中；</span></span><br><span class="line"><span class="comment">对象锁为obj；此时只有一个线程按道理应该是使用的偏向锁；</span></span><br><span class="line"><span class="comment">另外在同步代码块当中进行打印的对象的对象布局信息；以此用来检查是否存在偏向锁的标记；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">打印结果：</span><br><span class="line">com.lang.Object object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     d8 ed <span class="number">44</span> <span class="number">29</span> (<span class="number">11011000</span> <span class="number">11101101</span> <span class="number">01000100</span> <span class="number">00101001</span>) (<span class="number">692383192</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134217243</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line"> Instance size: <span class="number">16</span> bytes</span><br><span class="line"> Space losses: <span class="number">0</span> bytes <span class="built_in">int</span>ernal + <span class="number">4</span> bytes <span class="keyword">external</span> = <span class="number">4</span> bytes total</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">分析：</span><br><span class="line"><span class="number">0</span>      <span class="number">4</span>        （object header）     d8 ed <span class="number">44</span> <span class="number">29</span> (<span class="number">11011000</span> <span class="number">11101101</span> <span class="number">01000100</span> <span class="number">00101001</span>) (<span class="number">692383192</span>)</span><br><span class="line">当中的</span><br><span class="line">d8 ed <span class="number">44</span> <span class="number">29</span> (<span class="number">11011000</span> <span class="number">11101101</span> <span class="number">01000100</span> <span class="number">00101001</span>) (<span class="number">692383192</span>)</span><br><span class="line">当中的</span><br><span class="line">d8 <span class="number">11011000</span> 即最终的第<span class="number">8</span>个字节即</span><br><span class="line">    <span class="number">8</span>       <span class="number">7</span>        <span class="number">6</span>        <span class="number">5</span>        <span class="number">4</span>         <span class="number">3</span>        <span class="number">2</span>       <span class="number">1</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">其实就是</span><br><span class="line">    <span class="number">1</span></span><br><span class="line"><span class="number">00000000</span></span><br><span class="line">显示到前面去了即</span><br><span class="line">    <span class="number">1</span>       <span class="number">2</span>        <span class="number">3</span>        <span class="number">4</span>        <span class="number">5</span>         <span class="number">6</span>        <span class="number">7</span>       <span class="number">8</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">这个样子；</span><br><span class="line">即d8 <span class="number">11011000</span>代表的就是是否是偏向锁，即锁的标志位；</span><br><span class="line">那么d8其<span class="number">8</span>位当中的最后三位即<span class="number">000</span>；那么<span class="number">000</span>是属于偏向锁吗；不是；</span><br><span class="line">那么为什么不是偏向锁呢？原因在于：偏向锁虽然在jdk1<span class="number">.6</span>的时候偏向锁是开启的；</span><br><span class="line">但是这个默认开启的偏向锁并不是立马可以进行使用的；</span><br><span class="line">所以这个时候又需要添加一个JVM参数即在VM options处填入参数：-XX:BiasedLockingStartupDelay=<span class="number">0</span>；</span><br><span class="line">让其原始值为<span class="number">0</span>即程序一启动那么偏向锁就生效；</span><br><span class="line">那么再次运行尝试：</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">再次运行打印结果：</span><br><span class="line">com.lang.Object object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">05</span> <span class="number">90</span> <span class="number">61</span> <span class="number">27</span> (<span class="number">00000101</span> <span class="number">10010000</span> <span class="number">01100001</span> <span class="number">00100111</span>) (<span class="number">660705285</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134217243</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line"> Instance size: <span class="number">16</span> bytes</span><br><span class="line"> Space losses: <span class="number">0</span> bytes <span class="built_in">int</span>ernal + <span class="number">4</span> bytes <span class="keyword">external</span> = <span class="number">4</span> bytes total</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">分析：</span><br><span class="line">程序首先由主线程从main方法开始进行执行并在main方法当中创建一个新线程叫做mt并启动它；用t1表示新线程mt；</span><br><span class="line">那么新线程t1就会执行到run方法当中去进行<span class="number">5</span>次循环并在每次循环当中进入同步代码块且打印其对象布局中对象头等对象布局信息；</span><br><span class="line">此时只有一个线程没有其他线程来进行竞争操作；</span><br><span class="line">那么此时t1第一次来进行执行同步代码块synchronized的时候就会去看这个对象头obj当中它的锁标记是什么；</span><br><span class="line">那么一开始的时候该对象头是属于无锁状态即倒数第二位为<span class="number">0</span>（表示不为偏向锁状态；即无锁状态）；</span><br><span class="line">那么这个时候由于要将无锁状态改为偏向锁状态那么此时就会将倒数第三位改成<span class="number">1</span>（即偏向锁状态；表示转成偏向锁状态）；</span><br><span class="line">另外前<span class="number">56</span>位当中的前<span class="number">54</span>位会被用来保存这个偏向锁的id；以及前<span class="number">56</span>位当中的后两位用来进行保存Epoch即相关时间；</span><br><span class="line">那么这个时候就让t1线程进入了同步代码块当中（其实也就表示设置好了偏向锁，要进入同步代码块当中进行执行；然后进行打印对象布局信息中即<span class="number">101</span>；</span><br><span class="line">也就是<span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">05</span> <span class="number">90</span> <span class="number">61</span> <span class="number">27</span> (<span class="number">00000101</span> <span class="number">10010000</span> <span class="number">01100001</span> <span class="number">00100111</span>) (<span class="number">660705285</span>)中的<span class="number">05</span> <span class="number">00000101</span>其<span class="number">8</span>位的倒数三位<span class="number">101</span>；也就表示转变成了偏向锁状态）；</span><br><span class="line">当执行完成打印对象布局信息即也就是完成同步代码块中的任务要出同步代码块时，退出同步代码块时这个偏向锁就并不用做什么事情；</span><br><span class="line">那么当下一次循环时（总共有<span class="number">5</span>次循环），该线程t1又要从同步代码块当中来进行获取锁；</span><br><span class="line">它就会发现对象锁obj当中即为一个偏向锁的状态；</span><br><span class="line">并且只要去进行对比一下这个线程Id即前<span class="number">56</span>位当中的<span class="number">54</span>位的值是否取值相等即THREAD id是否与当前这个要获取锁的线程的THREAD id相同；</span><br><span class="line">如果是，那么就直接进入到同步代码块当中；</span><br><span class="line">即有了偏向锁之后，那么后面的循环中当前该线程再次去获取锁就变得很简单了只需要（对比一下THREAD ID是否一致即可）两个动作</span><br><span class="line">（<span class="number">1</span>: 检查倒数第三位是否是偏向锁标志，如果是则执行第二个动作；如果不是则将倒数第三位的数值改为<span class="number">1</span>即表示偏向锁；<span class="number">2</span>: 首先检查前<span class="number">56</span>位当中的前<span class="number">54</span>位的THREAD ID是否有取值；如果没有取值则设置为当前的该线程ID；如果存在取值THREAD ID则将当前要获取锁的线程进行与前<span class="number">54</span>位中的THREAD ID进行比较，如果相同则直接可以进入到同步代码块当中）；</span><br><span class="line">退出循环之后每次再次进行循环需要进入同步代码块时之前对比一下THREAD ID是否一致即可；</span><br><span class="line">所以偏向锁可以看到在一个线程执行同步代码块的情况下其效率是非常高的（较之重量级锁要高很多）；</span><br></pre></td></tr></table></figure><h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><h4 id="什么时候撤销偏向锁"><a href="#什么时候撤销偏向锁" class="headerlink" title="什么时候撤销偏向锁"></a>什么时候撤销偏向锁</h4><p>一旦存在有两个线程来进行锁的时候那么就会撤销偏向锁；</p><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo07_biased_lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line"></span><br><span class="line">    MyThread mt2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">假设在这当中存在有两个线程；</span></span><br><span class="line"><span class="comment">也就意味着有两个线程会去进行run()当中的synchronized；</span></span><br><span class="line"><span class="comment">那么两个线程来进行执行的时候就需要将该偏向锁给进行撤销；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="偏向锁撤销过程"><a href="#偏向锁撤销过程" class="headerlink" title="偏向锁撤销过程"></a>偏向锁撤销过程</h3><ol><li>偏向锁的撤销动作必须等待<strong>全局安全点</strong></li><li>暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态</li><li>撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态；</li></ol><blockquote><p>TIPS: 全局安全点<br>假设当前需要进行统计超市在9点的时候超市当中有多少人；<br>那么应该如何统计？<br>即在9点的时候，让在超市当中的所有人都停下来；不要有人进入超市也不要有人出超市；那么这个时候才来进行统计；<br>那么这个线程安全点指的就是在这个点的时候所有的线程都会进行停下来；那么也就叫做全局安全点；那么只有到了全局安全点的时候才能来进行撤销偏向锁；</p></blockquote><p>偏向锁 在 java1.6 之后是默认启用的；<br>但是在应用程序启动几秒钟才激活，可以使用<code>-XX:BiasedLockingStartupDelay=0</code>参数关闭延迟，<br>如果确定应用程序所有锁通常情况下处于竞争状态，<br>可以通过<code>-XX:-UseBiasedLocking=false</code>参数关闭偏向锁</p><h3 id="偏向锁好处"><a href="#偏向锁好处" class="headerlink" title="偏向锁好处"></a>偏向锁好处</h3><p>偏向锁适合使用在只有一个线程来获取锁的时候进行使用；<br>即没有竞争情况；那么在这种情况下一个线程反复进入同步代码块退出同步代码块的效率是很高的；只要进行判断对象头当中的线程id即THREAD ID跟现在要获取锁的线程的THREAD ID是否相同即可；如果相同则进入同步代码块；退出同步代码块时也不需要做什么事情；所以性能高；<br>但是这个偏向锁不一定总是好的；<br>如果存在有很多的线程来竞争锁；那么这个时候偏向锁就起不到什么作用了反而会影响效率；因为每次撤销一次偏向锁都必须要等待全局安全点所有线程都会停下来才能够进行撤销偏向锁，所以反而还会影响性能；<br>比如说使用线程池来执行代码的时候，那么这个时候知道线程池当中肯定有多个线程反复去执行同样的任务，同样的代码即反复的去竞争同一把锁；那么在这个时候偏向锁就是多余的了；<br>注意在JDK1.5的时候偏向锁是默认关闭的；而在JDK1.6的时候偏向锁是默认开启的；如果不需要偏向锁可以通过启动参数<code>-XX:-UseBiasedLocking=false</code>来进行关闭偏向锁；让其直接进入重量级锁；</p><p>偏向锁是在 只有一个线程执行同步块时 进一步提高性能，适用于一个线程反复获得同一把锁的情况。<br>偏向锁可以提高带有同步但无竞争的程序性能。</p><p>它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利。<br>如果程序中大多数的锁总是被多个不同的线程访问比如线程池，那偏向模式就是多余的。  </p><p>在JDK1.5中偏向锁默认是关闭的，而到了JDK6中偏向锁已经默认开启。<br>但在应用程序启动几秒钟之后才激活，可以使用<code>-XX:BiasedLockingStartupDelay=0</code>参数关闭延迟，<br>如果确定应用中所有锁通常情况下处于竞争状态，可以通过<code>-XX:-UseBiasedLocking=false</code>参数关闭偏向锁；</p><h3 id="小结-15"><a href="#小结-15" class="headerlink" title="小结"></a>小结</h3><blockquote><p>偏向锁的原理是什么？</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当锁对象第一次被线程获取的时候，</span><br><span class="line">虚拟机将会把对象头中的锁标志位设置为“<span class="number">01</span>”，即偏向模式。</span><br><span class="line">同时使用<span class="built_in">CAS</span>操作把获取得到的这个锁的线程的ID记录在对象的Mark Word之中，</span><br><span class="line">如果<span class="built_in">CAS</span>操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</span><br></pre></td></tr></table></figure><table>  <tr>    <td rowspan="2">锁状态</td>    <td>25bit</td>    <td>31bit</td>    <td>1bit</td>    <td>4bit</td>    <td>1bit</td>    <td>2bit</td>  </tr>  <tr>    <td> </td>    <td> </td>    <td>cms_free</td>    <td>分代年龄</td>    <td>偏向锁</td>    <td>锁标志位</td>  </tr>  <tr>    <td>无锁</td>    <td>unused（没有使用）</td>    <td>hashCode</td>    <td></td>    <td></td>    <td>0（是否是偏向锁；0表示非偏向锁；1表示是偏向锁）</td>    <td>01（锁的标志位；01代表无锁；00代表轻量级锁；10代表重量级锁）</td>  </tr>    <tr>    <td>偏向锁</td>    <td colspan="2">ThreadId(54bit)Epoch(2bit)</td>    <td></td>    <td></td>    <td>1</td>    <td>01</td>  </tr>  <tr>    <td>轻量级锁</td>    <td colspan="5">指向栈中锁记录的指针</td>    <td>00</td>  </tr>  <tr>    <td>重量级锁</td>    <td colspan="5">指向互斥量（重量级锁）的指针</td>    <td>10</td>  </tr></table><p>当线程第一次来获取锁的时候，<br>那么虚拟机就会把对象头设置为01，且偏向锁设置为1；<br>那么这个时候就记录了偏向模式；同时通过CAS操作将前面的54位设置为获取了偏向锁的线程的THREAD ID；那么如果设置成功则说明该线程获取得到了该偏向锁；<br>那么后续的进入同步代码块时效率就会变高了；</p><blockquote><p>偏向锁的好处是什么？</p></blockquote><p>偏向锁适用于一个线程反复进入同步代码块的情况；<br>即没有锁竞争的情况下；那么这个时候是可以提高一个线程进入同步代码块时的效率的；但是如果存在竞争那就不行了；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">偏向锁是在 只有一个线程 执行同步代码块时 进一步提高性能，</span><br><span class="line">适用于 一个线程反复获得同一个锁的情况。</span><br><span class="line">偏向锁可以提高带有同步但是无竞争的程序性能。</span><br></pre></td></tr></table></figure><h2 id="synchronized优化-轻量级锁"><a href="#synchronized优化-轻量级锁" class="headerlink" title="synchronized优化-轻量级锁"></a>synchronized优化-轻量级锁</h2><h3 id="目标-19"><a href="#目标-19" class="headerlink" title="目标"></a>目标</h3><p>学习轻量级锁的原理和好处</p><h3 id="什么是轻量级锁"><a href="#什么是轻量级锁" class="headerlink" title="什么是轻量级锁"></a>什么是轻量级锁</h3><p>当偏向锁出现竞争的时候，会撤下偏向锁从而升级到轻量级锁；<br>轻量级锁是JDK1.6当中为了优化synchronized而引入的一种新型锁机制；<br>需要注意的是轻量级锁不是任何情况下其开销比较的小而是在特定的情况下才开销比较小；所以轻量级锁并不能够用来代替重量级锁；轻量级锁只是在一定的情况下来进行减少消耗；</p><p>轻量级锁是 JDK1.6之中加入的 新型锁机制，<br>它名字中的“轻量级”是相对于使用monitor的传统锁而言的，<br>因此传统的锁机制就称为“重量级”锁。<br>首先需要强调的一点是，轻量级锁并不是用来代替重量级锁的；</p><p>引入轻量级锁的目的： 在多线程交替执行同步块的情况下，（引入轻量级锁）尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要代替重量级锁。</p><p>（也就是说在多线程交替执行同步块的时候轻量级的性能才是比较好的）<br>假设在餐厅当中，有多个桌椅以便于用来用户用餐；<br>假设现在有第一个人来进行到一号座当中用餐，用餐完毕之后离开一号座；<br>那么当一号座的用户离开之后现在又来了第二个用户又坐到了一号座当中进行用餐，同样用餐完毕之后离开一号座；紧接着第二个用户离开之后第三个用户又来了且也是坐在一号座的位置上进行用餐；可以看到的是这三个用户是分别不同时刻来进行用餐的；即也就是交替进行的没有竞争的状况；那么如果说一号座的风景比较好又处于下班用餐的高峰期，同一时刻三个用户同时来进行竞争一号座的用餐；那么这个时候就出现了竞争；也就不适合使用轻量级锁了；</p><h3 id="轻量级锁原理"><a href="#轻量级锁原理" class="headerlink" title="轻量级锁原理"></a>轻量级锁原理</h3><p>当关闭偏向锁功能 或者 多个线程竞争偏向锁导致偏向锁升级为轻量级锁，<br>则会尝试获取轻量级锁，其获取锁步骤如下：</p><ol><li><p>判断当前对象 是否处于无锁状态（hashcode、0、01）；<br>如果是，则JVM首先将在当前线程的栈帧中建立一个所记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word），将对象的Mark Word赋值到栈帧中的Lock Record中，将Lock Record的owner指向当前对象。</p></li><li><p>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针；如果成功表示竞争到锁，则将锁标志位变成00，执行同步操作。</p></li><li><p>如果失败则判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象</p></li></ol><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p>写一个方法时那么到时候这个方法运行时就将会进入到栈当中来进行执行；<br>那么该方法进入到栈中的该方法就称作是栈帧；<br>栈帧：一个进入栈中的方法就是一个栈帧；<br>那么这个栈帧是用来执行方法的所以这个栈帧也具有空间，也能够存储一些变量；</p><table>  <tr>    <td rowspan="2">锁状态</td>    <td>25bit</td>    <td>31bit</td>    <td>1bit</td>    <td>4bit</td>    <td>1bit</td>    <td>2bit</td>  </tr>  <tr>    <td> </td>    <td> </td>    <td>cms_free</td>    <td>分代年龄</td>    <td>偏向锁</td>    <td>锁标志位</td>  </tr>  <tr>    <td>无锁</td>    <td>unused（没有使用）</td>    <td>hashCode</td>    <td></td>    <td></td>    <td>0（是否是偏向锁；0表示非偏向锁；1表示是偏向锁）</td>    <td>01（锁的标志位；01代表无锁；00代表轻量级锁；10代表重量级锁）</td>  </tr>    <tr>    <td>偏向锁</td>    <td colspan="2">ThreadId(54bit)Epoch(2bit)</td>    <td></td>    <td></td>    <td>1</td>    <td>01</td>  </tr>  <tr>    <td>轻量级锁</td>    <td colspan="5">指向栈中锁记录的指针</td>    <td>00</td>  </tr>  <tr>    <td>重量级锁</td>    <td colspan="5">指向互斥量（重量级锁）的指针</td>    <td>10</td>  </tr></table><p>轻量级锁分析</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">java代码：</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">MyThread</span> <span class="symbol">extends</span> <span class="symbol">Thread</span>&#123;</span><br><span class="line">  static Object obj = new Object();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> run()&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      synchronized(obj)&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">分析：</span><br><span class="line">synchronized当中的obj即为锁对象（对象锁）</span><br><span class="line">当前具有两个线程，分别是A线程以及B线程</span><br><span class="line">（创建这两个线程并启动他们，那么他们都会将去执行run()方法当中的代码）；</span><br><span class="line">可以看到的是进入synchronized同步代码块之前需要一个obj对象锁；</span><br><span class="line">假设线程A来先进行执行run()方法；</span><br><span class="line">即，即将执行的run()方法运行就会进入到栈中去，那么进入到栈中执行的方法即一个栈帧，即此时运行的run()方法即为一个栈帧；</span><br><span class="line">假设此时线程A要进入到同步代码块之中；那么这个时候就要升级为轻量级锁；因为存在有多个锁竞争；所以未使用偏向锁；</span><br><span class="line">那么此时如何进行升级为轻量级锁?</span><br><span class="line">首先在栈中运行执行run()方法的该栈帧当中会创建一个叫做Lock Record的锁记录空间（这块空间内存放displaced hdr以及owner）；</span><br><span class="line">那么接着就会将锁对象即obj升级为轻量级锁；</span><br><span class="line">那么其当前obj锁对象的状态为无锁状态；</span><br><span class="line">即会将对象当中的无锁状态当中的hashCode、分代年龄以及锁标记赋值到栈帧当中Lock record中创建的displaced hdr当中；</span><br><span class="line">另外还会将栈帧当中的Lock record当中还会进行创建的owner指向obj，即也就是synchronized的锁对象（对象锁）；</span><br><span class="line">另外还需要做的事情有升级为轻量级锁的时候会将锁标志位的数值修改成“<span class="number">00</span>”；</span><br><span class="line">并且存在前<span class="number">25</span>bit+<span class="number">31</span>bit+<span class="number">1</span>bit+<span class="number">4</span>bit+<span class="number">1</span>bit来进行保存栈帧中Lock Record的地址；</span><br><span class="line">那么这些操作都是通过CAS来进行操作的；</span><br><span class="line">这就是轻量级锁的原理；</span><br><span class="line">笔记小结-轻量级锁的原理：</span><br><span class="line">当关闭了偏向锁或者说偏向锁出现了竞争的情况那么都会导致偏向锁升级为轻量级锁；</span><br><span class="line">轻量级锁步骤如下：</span><br><span class="line">首先判断对象头当中的倒数两位即标志位是否为<span class="number">01</span>,<span class="number">01</span>即代表无锁状态；</span><br><span class="line">如果确实无锁；那么JVM就会在当前的栈帧当中建立一个Lock Record这样一个空间；</span><br><span class="line">这块空间用来存储对象头；即用来存储displaced hdr(displaced hdr即Displaced Mark Word)以及owner；</span><br><span class="line">displaced hdr也就是指的Displaced Mark Word（会将分代年龄、锁标志、锁标志等放到displaced hdr当中去）；</span><br><span class="line">并且owner会执行当前的对象即synchronized当中的obj；</span><br><span class="line">接着还会使用CAS操作把对象头当中的Mark Word进行保存栈帧中创建的Lock record的地址；</span><br><span class="line">最后会将对象头当中的标志位改成<span class="number">00</span>即代表的是轻量级锁；</span><br><span class="line">如果在这个当中升级轻量级锁失败那么就会膨胀为重量级锁；</span><br></pre></td></tr></table></figure><h3 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h3><p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p><ol><li>取出在获取轻量级锁 保存在Displaced Mark Word中的数据；</li><li>用CAS操作 将取出的数据 替换当前对象的Mark Word中，如果成功，则说明释放锁成功；</li><li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级锁。</li></ol><p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，<br>如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</p><p>轻量级锁的释放即将栈帧当中的Lock Record当中的displaced hdr当中的hashCode重新放回到对象头原有的位置上即无锁状态上31bit处；以及displaced hdr当中的分代年龄以及锁标志位等都放回原位；<br>撤销轻量级锁也是一个CAS操作；即如果将hashCode、分代年龄以及锁标志位都还原归位了那么也就说明轻量级锁已经被撤销了；</p><p>需要注意的是，对于轻量级锁而言：轻量级锁的性能之所以高，是因为在绝大部分情况下，这个同步代码块不存在有竞争的状况；线程之间交替执行；<br>如果是多线程同时来进行竞争这个锁的话，那么这个轻量级锁的开销也就会更大；</p><h3 id="轻量级锁好处"><a href="#轻量级锁好处" class="headerlink" title="轻量级锁好处"></a>轻量级锁好处</h3><p>在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</p><h3 id="小结-16"><a href="#小结-16" class="headerlink" title="小结"></a>小结</h3><p>轻量级锁的原理是什么？</p><p>轻量级锁即会在栈帧中创建一个叫做Lock record锁记录的空间；<br>那么在Lock Record锁记录空间内的displaced hdr会去进行保存对象头当中的hashCode、分代年龄以及锁标志等；另外Lock record锁记录空间当中的owner即指向的是这个锁对象；并且在对象头当中会来进行保存Lock Record锁记录的空间地址；然后将对象头当中的锁标志改成00以表示轻量级锁；</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将对象的Mark <span class="keyword">Word</span>赋值到栈帧中的Lock <span class="keyword">Record</span>中，Mark <span class="keyword">Word</span>更新为指向Lock <span class="keyword">Record</span>的指针。</span><br></pre></td></tr></table></figure><p>轻量级锁的好处是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</span><br></pre></td></tr></table></figure><h2 id="synchronized优化-自旋锁"><a href="#synchronized优化-自旋锁" class="headerlink" title="synchronized优化-自旋锁"></a>synchronized优化-自旋锁</h2><h3 id="回顾并引入-2"><a href="#回顾并引入-2" class="headerlink" title="回顾并引入"></a>回顾并引入</h3><p>当轻量级锁发生竞争的时候会膨胀升级为重量级锁；<br>但是重量级锁相对于性能开销的消耗是比较大的；<br>因此应该尽量避免升级为重量级锁；<br>所以JVM在轻量级锁在升级为重量级锁的时候的这个过程当中还会再挣扎一下；<br>尽量避免升级为重量级锁；<br>这个挣扎的过程就是自旋锁；</p><p>重量级锁回顾：重量级锁是由monitor来进行实现的；当一个线程来进行竞争monitor锁如果没有竞争到那么线程就会进入阻塞状态；当其他线程将锁释放的时候会来进行唤醒那些处于阻塞状态的线程有机会去竞争锁；</p><p>举个例子：假设第一个线程，线程A来进行执行同步代码块；<br>那么线程A竞争得到锁从而进入同步代码块当中进行执行；<br>与此同时又来了第二个线程，即线程B；第二个线程，线程B也来进行执行同步代码块；但是线程A由于没有释放锁；从而线程B就没有办法获取得到锁从而无法进入同步代码块从而进入阻塞状态；只有第一个线程即线程A退出同步代码块并且将锁释放之后才会去唤醒阻塞状态的线程B；从而第二个线程线程B才能够有机会再次获取锁从而进入同步代码块中；<br>线程的阻塞和唤醒是需要CPU从用户态切换至内核态的；<br>频繁的状态切换对于CPU的开销来说也是比较大的；<br>并且虚拟机开发团队也发现其实大部分情况下线程对共享资源的操作所持续的时间是比较短的；即也就是说进入同步代码块到退出同步代码块释放锁的时间也是比较短的；<br>那么之前都是执行执行同步代码块而让其他没有获取得到锁的线程进行等待阻塞状态；那么这样其实是不划算的；</p><p>具体来说是这样的：<br>假设第一个线程A获取得到锁并进入同步代码块当中去执行，很快就可以执行完成；<br>但是与此同时来了第二个线程线程B；而此时线程A并没有释放锁；所以线程B没有获得锁从而进入阻塞状态；可能在线程B还没有进入到阻塞状态时这个线程A就已经执行完并且将锁进行释放了；<br>那么对于外面陷入等待阻塞的线程B来说就开销较大并且比较耗费资源；<br>其实这个时候只要让外面这个线程B在同步代码块外面多循环几次多尝试一下就有可能获取得到锁；就不必要让外面这个线程B进入阻塞状态；以及后面还要去唤醒它，浪费资源；</p><p>举个例子：<br>在火车上的一间卫生间当中；<br>假设有两个人分别是叫做A用户和B用户；<br>那么此时A用户先进入到火车的这一间卫生间当中；并且将卫生间的门给锁上了；<br>后面来了的第二个人即用户B，从他的位置上走过来到卫生间，表示也想要上厕所；<br>但是用户B发现此时卫生间的门已经被锁上了；所以用户B又从卫生间回到了他自己的位置上去了；<br>那么此时就有这样一种情况发生：<br>当用户A进行上卫生间只需要花费10秒钟的时间；<br>而用户B从位置上到达卫生间可能需要花费30秒的时间；<br>当用户A进入到卫生间并将卫生间的门锁上的时候；10秒钟还没有执行完；<br>与此同时用户B从位置上走到卫生间花费了30秒的时间，发现卫生间的门被锁上了；所以又从卫生间返回到其位置上去花费了30秒钟的时间；<br>其实用户A也许10秒钟之后就可以从卫生间中出来了；那么即用户B就浪费了一部分的时间资源；<br>这个例子其实就相当于是重量级锁；<br>那么其实也还可以这么做，当用户A进入卫生间并将门锁上的时候；用户B从位置上走到卫生间来看到卫生间的门被锁住，第一时间并不是又返回到位置上面去这样花费的时间太长了；而是在卫生间的门口进行等待；而且可以每隔一秒敲一下门看门内的用户A是否用完了卫生间可以出来；即如果用户A没有出门则可以再隔一秒钟再次敲一下门，如果用户A仍然还没有出来那么这个时候用户B又过一秒再次敲一下门，如果用户A出来了那么这个时候卫生间外的用户B就可以进去了；<br>那么可以看到卫生间外的用户B只要在门口等多尝试几次就可以获取得到锁；<br>就避免了从卫生间又走到位置上花了30秒的时间；</p><p>要让外面的线程不进行阻塞；而是循环几次来进行抢锁；<br>那么就需要保证本机是一个多核CPU，能够让两个或以上的线程来进行并行执行；<br>这样就可以线程A在同步代码块内进行执行代码；而另外其他的线程B则在同步代码块外进行尝试的来进行获取锁；<br>即同步代码块外面的线程B就不会进入到阻塞状态中去；<br>这样的话可能性能开销就小一点；<br>那么让同步代码块外面的线程B进行多次尝试抢锁的这个过程就叫做自旋；<br>那么支持这种自旋的锁就称之为自旋锁；<br>另外还需要注意的是循环是很快的所以就需要让这个循环尽量慢一点；即让这个循环锁花费的时间尽量长一点；<br>那么也就知道了自旋锁在一定情况下是可以减小性能开销的；</p><h3 id="目标-20"><a href="#目标-20" class="headerlink" title="目标"></a>目标</h3><p>学习自旋锁的原理</p><h3 id="自旋锁原理"><a href="#自旋锁原理" class="headerlink" title="自旋锁原理"></a>自旋锁原理</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(<span class="module-access"><span class="module"><span class="identifier">Demo01</span>.</span></span><span class="keyword">class</span>)&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面讨论 monitor实现锁 的时候，知道 monitor会阻塞和唤醒线程，<br>线程的阻塞和唤醒 需要CPU从用户态转化为核心态，<br>频繁的阻塞和唤醒对CPU来说 是一件负担很重的工作。<br>这些操作给系统的并发性能 带来了很大的压力。<br>同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间阻塞和唤醒线程并不值得。<br>如果物理机器有一个以上的处理器，能让两个或两个以上的线程同时并发执行，<br>就可以让后面请求锁的那个线程 “稍等一下”，<br>但不放弃处理器的执行时间，看看持有锁的线程 是否很快就会释放锁。<br>为了让线程等待，只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p><p><strong>自旋锁</strong>在<strong>JDK 1.4.2</strong>中就已经引入，只不过<strong>默认是关闭</strong>的，<br>可以使用<code>-XX:+UseSpinning</code>参数来开启，<br>在<strong>JDK 6</strong>中就已经改为<strong>默认开启</strong>了。<br>自旋等待不能代替阻塞，且先不说处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的；<br>因此，如果锁被占用的时间很短，自旋等待的效果就会非常好；<br>反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费；<br>因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。<br>自旋次数的默认值是10次，用户可以使用参数-XX:PreBlockSpin来更改；</p><p>通过前面的学习中可以知道自旋锁不一定是最好的，而是在（某些情况下比较好）特定一定的条件下；<br>即同步代码块执行的时间较短，从而能够很快的抢到锁；<br>另外还有就是硬件要能够支持两个或两个以上的线程进行并行执行；<br>即一个线程在同步代码块内进行执行，而另一个线程则在同步代码块外进行自旋即尝试获取锁；<br>但是自旋也是会消耗CPU的性能的；<br>因为要在同步代码块外层不断的进行循环重试获取锁；<br>因此这个自旋锁需要去控制这个自旋的时间或者是说自旋尝试获取锁的次数；<br>如果自旋的次数太多了那么对于CPU的开销也是很大的；<br>如果自旋的次数太少了又有可能抢不到锁导致白白自旋了；<br>自旋锁默认的自旋次数是<strong>10次</strong>，可以通过手动的修改JVM的启动参数来修改默认自旋的次数（改变自旋锁的自旋次数）；</p><p>但是又有一个问题：这个自旋锁的自旋次数改成多少合适呢？那么这就很难判定了；<br>改多了浪费资源；改少了又没有抢到锁也是浪费资源；所以这个自旋的次数就很难来判断了；因此在JDK6中引入了自适应自旋锁；</p><h3 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h3><p>在JDK 6中引入了 自适应的自旋锁。<br>自适应 意味着 自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。<br>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机 就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100次循环。<br>另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。<br>有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序搜的状况预测就会越来越准确，虚拟机就会变得越来越“聪明”了。</p><p>（自适应自旋锁中自旋的次数或者是自旋的时间就不再固定了，而是由前一次自旋的效果来进行决定）</p><p>举个例子：<br>假设一个线程A在同步代码块上，自旋了10次并且获得了锁；那么就会认为这个同步代码块通过自旋是比较容易获得锁的；所以在后续的执行过程中也会进行自旋；并且还允许自旋的时间稍微长一点；因为之前得到过所以感觉现在也能得到；所以自旋的时间还允许更长一点；<br>再举一个例子：<br>假设有一个同步代码块，但是自旋从来就没有在这个同步代码块上成功获取过锁过；所以jvm就会认为这个同步代码块很难通过自旋来获取得到锁；干脆就不再进行自旋了；那么这样就可以避免性能的浪费；即所以自旋锁也是越来越”聪明”了；<br>monitor在进入竞争的时候会进入ObjectMonitor::enter(TRAPS)来进行竞争；<br>该方法中前一部分是抢到锁的情况；后一部分是没有抢到锁的情况；<br>当没有抢到锁的时候会进入到EnterI(THREAD)方法来进行线程的阻塞以及挂起等操作；<br>在EnterI(THREAD)当中就准备让线程进行阻塞，但是在阻塞之前首先还是会去进行尝试获取锁；如果还是获取不到锁则进入TrySpin(Self)，即就是去进行自旋；<br>那么接着看TrySpin(Self)进行了什么操作；</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#define TrySpin TrySpin_VaryDuration</span><br><span class="line"><span class="comment">// 恒定义对于另外一个函数即TrySpin_VaryDuration；</span></span><br><span class="line">------------------------------------------------</span><br><span class="line"><span class="comment">//TrySpin_VaryDuration时间不固定的尝试自旋锁</span></span><br><span class="line"><span class="built_in">int</span> ObjectMonitor::TrySpin_VaryDuration(Thread * Self)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dumb , brutal spin, Good for comparative measurements against adaptive spinning.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  Knob_FixedSpin自旋固定的次数</span></span><br><span class="line"><span class="comment">  如自旋固定的次数不等于0那么就会进入循环来进行自旋；</span></span><br><span class="line"><span class="comment">  然后每次循环一次就让数量减去一；</span></span><br><span class="line"><span class="comment">  每次自旋一下就要去TryLock一下尝试一下去获取锁；</span></span><br><span class="line"><span class="comment">  尝试获取不到锁则自旋的时候稍微花点时间等待一下即调用SpinPause()方法；</span></span><br><span class="line"><span class="comment">  再接着下一次自旋；</span></span><br><span class="line"><span class="comment">  那么这个就属于之前所说的固定的自旋次数以及固定的自旋时间；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">int</span> ctr = Knob_FixedSpin ;</span><br><span class="line">  <span class="keyword">if</span>( ctr != <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">while</span>( --ctr &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(TryLock(Self) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">      SpinPause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  以下的这个循环就是所推出的适应性自旋锁；</span></span><br><span class="line"><span class="comment">  首先来进行看到适应性自旋锁的自旋次数是多少；</span></span><br><span class="line"><span class="comment">  在objectMonitor.cpp当中给Knob_PreSpin设置了默认值为10次：</span></span><br><span class="line"><span class="comment">  static int Knob_PreSpin = 10; // 20 - 100 likely better</span></span><br><span class="line"><span class="comment">  并且注释推荐20到100次的自旋次数是比较合适的；</span></span><br><span class="line"><span class="comment">  自旋次数是10次，每次自旋一次就会去进行尝试一次看能不能抢得到锁；</span></span><br><span class="line"><span class="comment">  如果抢到了锁那么就回去修改自旋的时间，它就会去允许自旋的时间比以前自旋的时间稍微长一点；</span></span><br><span class="line"><span class="comment">  因为这次通过自旋抢到了那么下一次也有可能抢到；</span></span><br><span class="line"><span class="comment">  所以它允许自旋所花的时间加长一点；</span></span><br><span class="line"><span class="comment">  那么如果没有在一次自旋当中即循环的一次尝试当中没有获取得到锁；</span></span><br><span class="line"><span class="comment">  那么这个时候就会去调用SpinPause()即进入自旋的一个等待；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span>( ctr = Knob_PreSpin + <span class="number">1</span>; --ctr &gt;= <span class="number">0</span> ; )&#123;</span><br><span class="line">    <span class="keyword">if</span>( TryLock(Self) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// Increase _SpinDuration ...</span></span><br><span class="line">      <span class="comment">// Note that we don't clamp SpinDuration precisely at SpinLimit.</span></span><br><span class="line">      <span class="comment">// Raising _SpurDuration to the poverty line is key.</span></span><br><span class="line">      <span class="built_in">int</span> x = _SpinDuration ;</span><br><span class="line">      <span class="keyword">if</span>(x &lt; Knob_SpinLimit)&#123;</span><br><span class="line">        <span class="keyword">if</span>( x &lt; Knob_Poverty) x = Knob_Poverty ;</span><br><span class="line">        _SpinDuration = x + Knob_BonusB ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    SpinPause();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized优化-锁消除"><a href="#synchronized优化-锁消除" class="headerlink" title="synchronized优化-锁消除"></a>synchronized优化-锁消除</h2><h3 id="回顾并引入-3"><a href="#回顾并引入-3" class="headerlink" title="回顾并引入"></a>回顾并引入</h3><p>在JDK6中，对synchronized做了一个优化，即会有一个锁升级（无锁-偏向锁-轻量级锁-重量级锁）的过程；<br>那么在JDK6当中除了这个锁升级的优化之后还会有一个锁消除的优化；</p><h3 id="目标-21"><a href="#目标-21" class="headerlink" title="目标"></a>目标</h3><p>学习锁消除的原理</p><p>锁消除 是指 虚拟机 即时编译器（JIT）在 运行时，<br>对一些代码上要求同步，但是被检测到 不可能存在共享数据竞争的锁 进行消除。</p><p>锁消除 的主要判定依据 来源于 逃逸分析的数据支持，<br>如果判断在一段代码中，堆上的所有数据 都不会逃逸出去 从而被其他线程 访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，<br>同步加锁 自然就无需进行。</p><p>变量是否逃逸，对于虚拟机来说 需要使用 数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在 明知道不存在数据争用的情况下 要求同步呢？</p><p>实际上有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的想象。<br>下面这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    concatString(<span class="string">"aa"</span> , <span class="string">"bb"</span> , <span class="string">"cc"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> concatString(<span class="keyword">String</span> s1, <span class="keyword">String</span> s2, <span class="keyword">String</span> s3)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer().<span class="built_in">append</span>(s1).<span class="built_in">append</span>(s2).<span class="built_in">append</span>(s3).toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">代码分析concatString()该方法：</span><br><span class="line">StringBuffer.<span class="built_in">append</span>()方法是同步的；</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">StringBuffer.java</span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="built_in">append</span>(<span class="keyword">String</span> <span class="built_in">str</span>)&#123;</span><br><span class="line">  toStringCache = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">super</span>.<span class="built_in">append</span>(<span class="built_in">str</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">那么此时可以看到StringBuffer的<span class="built_in">append</span>()方法使用了<span class="keyword">synchronized</span>进行了同步处理；</span><br><span class="line">而concatString当中进行调用了三次<span class="built_in">append</span>()方法，也就是表明会进行执行三次的这个同步方法；</span><br><span class="line">实际上再来仔细观察一下concatString()方法；</span><br><span class="line">三个<span class="built_in">append</span>()方法调用者是谁？</span><br><span class="line">即<span class="keyword">new</span> StringBuffer 该对象进行调用的<span class="built_in">append</span>()方法；</span><br><span class="line">也就是StringBuffer的<span class="built_in">append</span>()方法即普通的同步方法它所使用的对象锁即为<span class="keyword">this</span>；</span><br><span class="line">而这个<span class="keyword">this</span>对象其实也就是这个<span class="built_in">append</span>()方法的调用者，也就是<span class="keyword">new</span> StringBuffer()，即对象锁就是这个<span class="keyword">new</span> StringBuffer()；</span><br><span class="line">而接着分析concatString()方法当中的<span class="keyword">new</span> StringBuffer()是concatString()方法当中所<span class="keyword">new</span>出来的局部变量；</span><br><span class="line">并没有逃逸出concatString()这个方法；</span><br><span class="line">那么就算现在有多线程来进行执行；即当前了存在两个线程，线程A和线程B；</span><br><span class="line">假设线程A先来进行执行concatString()方法；</span><br><span class="line">那么这个时候线程A就会进入到concatString()方法当中<span class="keyword">new</span> StringBuffer()对象作为锁来进行来锁住StringBuffer类当中的<span class="built_in">append</span>()方法；</span><br><span class="line">那么假设CPU切换到线程B上来，那么此时线程B也会进入到concatString()方法当中来也进行<span class="keyword">new</span> StringBuffer()对象作为锁来进行锁住StringBuffer类的<span class="built_in">append</span>()方法；</span><br><span class="line">锁就是另外一个对象了；</span><br><span class="line">也就是说concatString()方法内部的<span class="keyword">new</span> StringBuffer()对象没有逃逸出concatString()这个方法；</span><br><span class="line">就算有不同的线程来进行执行，那么每个线程也都是获取拿到的不同的锁；</span><br><span class="line">即每个线程拿到的都是不同的<span class="keyword">new</span> StringBuffer()对象即不同的锁；</span><br><span class="line">所以根本不存在有竞争；</span><br><span class="line">那么既然不存在有竞争那么这个StringBuffer类当中的<span class="built_in">append</span>()方法的同步代码块<span class="keyword">synchronized</span>就没有必要了；</span><br><span class="line">所以会自动进行消除掉这个同步代码块<span class="keyword">synchronized</span>；知道此处没有竞争；即转变成</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> StringBuffer <span class="built_in">append</span>(<span class="keyword">String</span> <span class="built_in">str</span>)&#123;</span><br><span class="line">  toStringCache = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">super</span>.<span class="built_in">append</span>(<span class="built_in">str</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">即线程A与线程B两者之间锁住StringBuffer类当中的<span class="built_in">append</span>()方法使用的不同的锁；</span><br><span class="line">很明显线程A所<span class="keyword">new</span> StringBuffer()对象与线程B所<span class="keyword">new</span> StringBuffer()对象显然不是同一个对象，</span><br><span class="line">而这个<span class="keyword">new</span> StringBuffer()对象也就是调用StringBuffer类当中的<span class="built_in">append</span>()方法的<span class="keyword">this</span>，</span><br><span class="line">也就是这个同步<span class="keyword">synchronized</span>方法<span class="built_in">append</span>()的对象锁；</span><br><span class="line">即线程A与线程B所获取的锁不是同一把锁；</span><br><span class="line"></span><br><span class="line">那么这就是锁消除；</span><br></pre></td></tr></table></figure><p>那么这个锁消除是谁来进行完成这一职责的呢？<br>锁消除是虚拟机 即时编译器JIT在对代码执行之前也会对代码进行一个编译操作；<br>最终即时编译器会根据对象的逃逸分析来判断，如果对象逃逸不出这个方法，那么这个锁是不存在竞争的，即那么就会取消这个同步代码块；</p><p>StringBuffer的append()是一个同步方法，<br>锁就是this也就是(new StringBuffer())。<br>虚拟机发现它的 动态作用于被限制在 concatString()方法内部。<br>也就是说，new StringBuffer()对象的引用永远不会“逃逸”到concatString()方法之外，其他线程无法访问到它，<br>因此，虽然这里有锁，但是可以被安全地消除掉；<br>在即时编译之后，这段代码就会忽略掉所有的同步而执行了；</p><h2 id="synchronized优化-锁粗化"><a href="#synchronized优化-锁粗化" class="headerlink" title="synchronized优化-锁粗化"></a>synchronized优化-锁粗化</h2><h3 id="回顾并引入-4"><a href="#回顾并引入-4" class="headerlink" title="回顾并引入"></a>回顾并引入</h3><p>锁粗化</p><p>JDK1.6在对synchronized进行优化的时候除了锁升级、锁消除；<br>还会做一个锁粗化的操作；</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="keyword">package</span> com.xxx.demo10_lock_coarsing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    建议同步代码块当中的代码尽量的少；</span></span><br><span class="line"><span class="comment">    执行的时间尽量的短；</span></span><br><span class="line"><span class="comment">    如果同步代码块当中的代码少且时间短那么偏向锁就有可能满足要求；</span></span><br><span class="line"><span class="comment">    或者说轻量级锁就能够满足要求；</span></span><br><span class="line"><span class="comment">    或者说在自旋的时候就能够满足要求；</span></span><br><span class="line"><span class="comment">    就不会进入到重量级锁的状态；</span></span><br><span class="line"><span class="comment">    但是往往可能情况又比较特殊；</span></span><br><span class="line"><span class="comment">    比如说下面的情况；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//synchronized(Demo01.class)&#123;</span></span><br><span class="line">    <span class="comment">//  System.out.println("aaa");</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     在循环外层new StringBuffer()；</span></span><br><span class="line"><span class="comment">     在循环内存调用append()即执行了100次的append()</span></span><br><span class="line"><span class="comment">     而StringBuffer.append()是一个同步方法；</span></span><br><span class="line"><span class="comment">     那么这也就意味着在调用100次StringBuffer.append()方法时，</span></span><br><span class="line"><span class="comment">     那么就会进入同步代码块append()100次；</span></span><br><span class="line"><span class="comment">     出来同步代码块append()100次；</span></span><br><span class="line"><span class="comment">     那么这个性能消耗也是比较大的；</span></span><br><span class="line"><span class="comment">     它可能会做这样一个处理；</span></span><br><span class="line"><span class="comment">     将StringBuffer.append()方法当中的synchronized进行消除掉；</span></span><br><span class="line"><span class="comment">     然后再将synchronized加入到100次for循环的外面；</span></span><br><span class="line"><span class="comment">     即：</span></span><br><span class="line"><span class="comment">     ------------------------------------</span></span><br><span class="line"><span class="comment">     StringBuffer.java</span></span><br><span class="line"><span class="comment">     public StringBuffer append(String str)&#123;</span></span><br><span class="line"><span class="comment">      toStringCache = null;</span></span><br><span class="line"><span class="comment">      super.append(str);</span></span><br><span class="line"><span class="comment">      return this;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     ------------------------------------</span></span><br><span class="line"><span class="comment">     Demo01.java</span></span><br><span class="line"><span class="comment">      public static void main(String[] args)&#123;</span></span><br><span class="line"><span class="comment">        StringBuffer sb = new StringBuffer();</span></span><br><span class="line"><span class="comment">        synchronized&#123;</span></span><br><span class="line"><span class="comment">          for(int i = 0; i&lt; 100 ; ++)&#123;</span></span><br><span class="line"><span class="comment">            sb.append("aa");</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(sb.toString());</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">     ------------------------------------</span></span><br><span class="line"><span class="comment">     那么此时再来看就只需要进入一次同步代码块然后再for循环100次即可；</span></span><br><span class="line"><span class="comment">     那么这就是锁粗化；</span></span><br><span class="line"><span class="comment">     由之前for循环零散的调用很多次的同步代码块到现在将其放到同步代码块里面来做一次进入同步代码块即可，把很多小锁去掉了变成一个大锁；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">      sb.<span class="built_in">append</span>(<span class="string">"aa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(sb.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">StringBuffer.java</span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="built_in">append</span>(<span class="keyword">String</span> <span class="built_in">str</span>)&#123;</span><br><span class="line">  toStringCache = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">super</span>.<span class="built_in">append</span>(<span class="built_in">str</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="目标-22"><a href="#目标-22" class="headerlink" title="目标"></a>目标</h3><p>学习锁粗化的原理</p><p>原则上，在编写代码的时候，总是推荐将 同步亏啊的作用范围 限制得尽量小，<br>只在共享数据的实际作用域中 才进行同步，<br>这样是为了使得需要同步的操作数量 尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p><p>大部分情况下，上面的原则都是正确地，但是如果一些列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能消耗。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">new</span> StringBuffer()</span><br><span class="line">          .<span class="built_in">append</span>(<span class="string">"aa"</span>).<span class="built_in">append</span>(<span class="string">"bb"</span>).<span class="built_in">append</span>(<span class="string">"cc"</span>).toString();</span><br><span class="line">    </span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"aa"</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"bb"</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"cc"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果虚拟机检测到有这样一串 零碎小的操作 都是用一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，这样只需要加锁一次就可以了。</p><h3 id="小结-17"><a href="#小结-17" class="headerlink" title="小结"></a>小结</h3><p>什么是锁粗化？<br>JVM会探测到一连串细小的操作都是用同一个对象加锁，<br>将同步代码块的范围放大；<br>放到这串操作的外面；<br>那么这样只需要加一次锁即可；</p><h2 id="平时写代码如何对synchronized优化"><a href="#平时写代码如何对synchronized优化" class="headerlink" title="平时写代码如何对synchronized优化"></a>平时写代码如何对synchronized优化</h2><ul><li>synchronized的原理；</li><li>JDK1.6对synchronized所做的优化；</li><li>偏向锁、轻量级锁、自旋锁、锁消除、锁粗化等；</li></ul><h3 id="减少synchronized的范围"><a href="#减少synchronized的范围" class="headerlink" title="减少synchronized的范围"></a>减少synchronized的范围</h3><p>同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争。</p><p>尽量让synchronized同步代码块当中的代码少一点这样执行的时间也就会少一点；<br>那么在单位时间内所执行的线程也就多一点；等待的线程也就少一点；<br>另外由于执行比较短，由轻量级锁就有可能搞得定；或者通过自旋锁就可以搞得定；<br>避免升级到重量级锁；</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(<span class="module-access"><span class="module"><span class="identifier">Demo01</span>.</span></span><span class="keyword">class</span>)&#123;</span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="降低synchronized锁的粒度"><a href="#降低synchronized锁的粒度" class="headerlink" title="降低synchronized锁的粒度"></a>降低synchronized锁的粒度</h3><p>将一个锁拆分为多个锁提高并发度</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------</span><br><span class="line"><span class="keyword">package</span> com.xxx.demo11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    Hashtable hs = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    hs.put(<span class="string">"aa"</span>,<span class="string">"bb"</span>);</span><br><span class="line">    hs.put(<span class="string">"xx"</span>,<span class="string">"yy"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------</span><br><span class="line"># 截取部分代码 Hashtable.java</span><br><span class="line"><span class="keyword">public</span> class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    The hash table data/</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    The total number of entries in the hash table.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="built_in">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//省略一些代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//对put整个方法进行加锁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> V put(K <span class="built_in">key</span>, V value)&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NUllPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is  not already in the hashtable</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="built_in">int</span> hash = <span class="built_in">key</span>.hashCode();</span><br><span class="line">    <span class="built_in">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    /unchecked/</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next)&#123;</span><br><span class="line">      <span class="keyword">if</span>((entry.hash==hash) &amp;&amp; entry.<span class="built_in">key</span>.equlas(<span class="built_in">key</span>))&#123;</span><br><span class="line">        <span class="comment">//省略一些代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//对get整个方法进行加锁</span></span><br><span class="line">  /unchecked/</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="built_in">int</span> hash = <span class="built_in">key</span>.hashCode();</span><br><span class="line">    <span class="built_in">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e=e.next)&#123;</span><br><span class="line">      <span class="keyword">if</span>((e.hash == hash) &amp;&amp; e.<span class="built_in">key</span>.equals(<span class="built_in">key</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> (V)e.value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对remove整个方法进行加锁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> V remove(<span class="keyword">Object</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="built_in">int</span> hash = <span class="built_in">key</span>.hashCode();</span><br><span class="line">    <span class="built_in">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    /unchecked/</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev=<span class="keyword">null</span> ; e != <span class="keyword">null</span>; prev = e, e=e.next)&#123;</span><br><span class="line">      <span class="keyword">if</span>((e.hash==hash) &amp;&amp; e.<span class="built_in">key</span>.equals(<span class="built_in">key</span>))&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="keyword">null</span>)&#123;</span><br><span class="line">          prev.next = e.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          tab[index] = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略一些代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line">由此可以看到Hashtable对增删改查的方法全部添加了<span class="keyword">synchronized</span>，</span><br><span class="line">使之成为同步方法；</span><br><span class="line">那么同步方法的锁对象是什么？是<span class="keyword">this</span>；</span><br><span class="line">也就意味着Hashtable其增删改查这几个方法使用的都是同一把锁；</span><br><span class="line">那么这样会造成什么问题？</span><br><span class="line">因为Hashtable的方法全部加了<span class="keyword">synchronized</span>从而变成了同步方法；</span><br><span class="line">那么意味着对于Hashtable这个对象；</span><br><span class="line">如果有一个线程在往这个Hashtable对象当中的一个桶当中进行添加；</span><br><span class="line">那么就没有办法存在另外一个线程往同样的这个Hashtable这个对象当中的另外一个桶中进行添加了；</span><br><span class="line">肯定是不行的；因为put()方法加锁<span class="keyword">synchronized</span>了；</span><br><span class="line">且锁对象为<span class="keyword">this</span>即所操作的Hashtable对象；</span><br><span class="line">由于put()方法加锁了；</span><br><span class="line">所以只允许一个线程A进行往Hashtable对象的一个桶中添加；</span><br><span class="line">而另外的其他线程B则必须等待线程A添加完成，才能往相同的该Hashtable对象当中的其他桶中添加；</span><br><span class="line">而事实上并没有必要这样操作；</span><br><span class="line">即A线程操作Hashtable对象的第一个桶进行添加操作；</span><br><span class="line">线程B操作与线程A操作的同一个Hashtable对象，其当中的另外一个桶进行添加操作；实则并不影响；</span><br><span class="line">另外Hashtable还存在一个问题；</span><br><span class="line">即当有一个线程A在对Hashtable对象的第一个桶进行添加的时候；</span><br><span class="line">此时存在有另外一个线程B对同样的Hashtable对象的其他桶进行读取<span class="built_in">get</span>()或者是remove()方法的时候是不可以的；只能等待线程A操作完对第一个桶进行添加的这个操作；</span><br><span class="line">因为其方法都是<span class="keyword">synchronized</span>同步方法；且加的锁都是同一把锁即<span class="keyword">this</span>；</span><br><span class="line">那么这样就导致了效率的低下；</span><br><span class="line">因此jdk又推出了一个新的类叫做ConcurrentHashMap；</span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="keyword">package</span> com.xxx.demo11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    Hashtable hs = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    hs.put(<span class="string">"aa"</span>,<span class="string">"bb"</span>);</span><br><span class="line">    hs.put(<span class="string">"xx"</span>,<span class="string">"yy"</span>);</span><br><span class="line">    hs.<span class="built_in">get</span>(<span class="string">"a"</span>);</span><br><span class="line">    hs.remove(<span class="string">"b"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line"># 截取部分代码 ConcurrentHashMap.java</span><br><span class="line"><span class="keyword">public</span> class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">724906924676318397</span>L;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//ConcurrentHashMap对于get没有加锁</span></span><br><span class="line">  <span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">    Node&lt;K,V&gt;p[] tab; Node&lt;K,V&gt; e, p; <span class="built_in">int</span> n , eh; K ek;</span><br><span class="line">    <span class="built_in">int</span> h = spread(<span class="built_in">key</span>.hashCode());</span><br><span class="line">    <span class="keyword">if</span>((tab==table) != <span class="keyword">null</span> &amp;&amp; (n=tab.length) &gt; <span class="number">0</span> &amp;&amp; (e=tabAt(tab, (n<span class="number">-1</span>)&amp; h)) != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>((eh=e.hash) == h)&#123;</span><br><span class="line">        <span class="keyword">if</span>((ek=e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))&#123;</span><br><span class="line">          <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ek &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> (p = e.find(h, <span class="built_in">key</span>)) != <span class="keyword">null</span> ? p.val:<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((e=e.next) != <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(e.hash == h &amp;&amp; ((ek=e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equlas(ek))))</span><br><span class="line">          <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V put(@NotNUll K <span class="built_in">key</span>, @NotNull V value)&#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(<span class="built_in">key</span> , value , <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Implementation for put and putIfAbsent */</span></span><br><span class="line">    <span class="keyword">final</span> V putVal(K <span class="built_in">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">key</span> == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="built_in">int</span> hash = spread(<span class="built_in">key</span>.hashCode());</span><br><span class="line">        <span class="built_in">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node&lt;K,V&gt;[] tab = table;;)&#123;</span><br><span class="line">          Node&lt;K,V&gt; f;<span class="built_in">int</span> n,i,fh;</span><br><span class="line">          <span class="keyword">if</span>(tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>((f = tabAt(tab, i = (n<span class="number">-1</span>) &amp; hash)) == <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//casTabAt 此处即为CAS操作去进行添加一个结点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash,<span class="built_in">key</span>,value,<span class="keyword">null</span>)))</span><br><span class="line">              <span class="keyword">break</span>;  <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            另外下面还有synchronized来进行添加一个结点</span></span><br><span class="line"><span class="comment">            而且该synchronized所用的锁并不是一把锁；</span></span><br><span class="line"><span class="comment">            synchronized所用的锁是桶中的第一个元素；</span></span><br><span class="line"><span class="comment">            也就意味着是这样：</span></span><br><span class="line"><span class="comment">            ConcurrentHashMap在进行添加元素的时候;</span></span><br><span class="line"><span class="comment">            如果该桶当中一个元素也没有,那么就是用CAS操作来进行添加第一个元素；</span></span><br><span class="line"><span class="comment">            如果该桶当中有存在元素往后面加元素呢?</span></span><br><span class="line"><span class="comment">            那么这个时候在锁的时候会使用该桶当中的第一个元素第一个节点作为锁对象，那么也就意味着只会锁住这一个桶；</span></span><br><span class="line"><span class="comment">            即这一个线程往这一个桶当中进行添加，只会对这一个桶进行锁；</span></span><br><span class="line"><span class="comment">            另外再来一个线程往同一个ConcurrentHashMap对象中的其他桶当中进行添加那么这个时候就是可以进行的；</span></span><br><span class="line"><span class="comment">            因为另外一个线程所要进行添加的是该同一个ConcurrentHashMap对象当中的其他桶，那么锁的对象即为其他桶当中的第一个结点对象；</span></span><br><span class="line"><span class="comment">            即这两个线程之间所操作的同一个ConcurrentHashMap对象的桶不一样其锁也不一样；</span></span><br><span class="line"><span class="comment">            由于锁不一样所以线程往其他桶当中进行添加是没有问题的；</span></span><br><span class="line"><span class="comment">            也就是说ConcurrentHashMap只要是不同的桶那么是可以进行同时添加的；</span></span><br><span class="line"><span class="comment">            除此之外还看到ConcurrentHashMap的get()方法是没有加synchronized变成同步方法的；</span></span><br><span class="line"><span class="comment">            这也就意味着当一个线程A在对该ConcurrentHashMap当中的一个桶进行添加的时候，另外一个线程还可以对该同一个ConcurrentHashMap对象当中的同一个桶进行读取操作；那么这样的话也不会受到锁的影响；</span></span><br><span class="line"><span class="comment">            其性能也就更高一点；</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span>(f)&#123;</span><br><span class="line">              <span class="keyword">if</span>(tabAt(tab, i) == f)&#123;</span><br><span class="line">                <span class="keyword">if</span>(fh &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                  binCount = <span class="number">1</span>;</span><br><span class="line">                  <span class="keyword">for</span>(Node&lt;K,V&gt; e = f;; ++binCount)&#123;</span><br><span class="line">                    K ek;</span><br><span class="line">                    <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek!=<span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek))))&#123;</span><br><span class="line">                      oldVal = e.val;</span><br><span class="line">                      <span class="keyword">if</span>(!onlyIfAbsent)&#123;</span><br><span class="line">                        e.val=value;</span><br><span class="line">                        <span class="comment">//省略部分代码</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="keyword">package</span> com.xxx.demo11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    Hashtable hs = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    hs.put(<span class="string">"aa"</span>,<span class="string">"bb"</span>);</span><br><span class="line">    hs.put(<span class="string">"xx"</span>,<span class="string">"yy"</span>);</span><br><span class="line">    hs.<span class="built_in">get</span>(<span class="string">"a"</span>);</span><br><span class="line">    hs.remove(<span class="string">"b"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> test01()&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Demo01.class)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> test02()&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Demo01.class)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  写代码的时候千万注意不要这么去做：</span></span><br><span class="line"><span class="comment">  这两个方法test01()以及test02()没有任何业务关联；</span></span><br><span class="line"><span class="comment">  且很多时候一般使用 类名.class来作为锁；</span></span><br><span class="line"><span class="comment">  觉得这样很简单有可以锁住；</span></span><br><span class="line"><span class="comment">  如果使用类名.class作为锁的话；</span></span><br><span class="line"><span class="comment">  如果一个线程A在进行执行test01()当中的同步代码块时；</span></span><br><span class="line"><span class="comment">  而对于另外一个线程B执行毫无业务关联的test02()方法时，</span></span><br><span class="line"><span class="comment">  也就意味着线程A抢了线程B的锁并且线程A还没有释放锁；</span></span><br><span class="line"><span class="comment">  所以线程B无法进入test02()方法中的同步代码块从而阻塞只能等待线程A释放锁；</span></span><br><span class="line"><span class="comment">  那么这样的话并发效率就很低了；</span></span><br><span class="line"><span class="comment">  所以尽量不要使用类名.class这样的锁；</span></span><br><span class="line"><span class="comment">  建议是降低锁的粒度；这样使得其并发效率可以更高一点；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br></pre></td></tr></table></figure><p><strong>HashTable：锁定整个哈希表，一个操作正在进行时，其他操作也同时锁定，效率低下</strong>：</p><p><strong>ConcurrentHashMap：局部锁定，只锁定桶，当对当前元素锁定时，其他元素不锁定</strong>。</p><p>HashTable与ConcurrentHashMap这两个容器都实现了Map接口，并且都能够保证线程安全；</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------</span><br><span class="line">|<span class="string"> 元素1 </span>|<span class="string"> 元素2 </span>|<span class="string"> 元素3 </span>|<span class="string"> 元素4 </span>|<span class="string"> 元素5 </span>|</span><br><span class="line">----↑------------------------------↑-----</span><br><span class="line">    |<span class="string">            objA              </span>|</span><br><span class="line">take添加元素使用一把锁objA          put添加元素使用一把锁objA</span><br><span class="line"></span><br><span class="line">/<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">往其头部进行获取元素；往尾部进行添加元素；</span><br><span class="line">为了保证队列的线程安全，就有可能加一把锁；</span><br><span class="line">届时获取和添加都是用这同一把锁；</span><br><span class="line">这样也就导致了在获取的时候没有办法进行添加；</span><br><span class="line">所以效率就会更低；</span><br><span class="line">因此就有了LinkedBlockingQueue的存在；</span><br><span class="line"><span class="symbol">*</span>/</span><br></pre></td></tr></table></figure><p>LinkedBlockingQueue入队和出队使用不同的锁，相对于读写只有一个锁效率要高。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------</span><br><span class="line">|<span class="string"> 元素1 </span>|<span class="string"> 元素2 </span>|<span class="string"> 元素3 </span>|<span class="string"> 元素4 </span>|<span class="string"> 元素5 </span>|</span><br><span class="line">----↑------------------------------↑-----</span><br><span class="line">    |<span class="string">                              </span>|</span><br><span class="line">take添加元素使用一把锁objB          put添加元素使用一把锁objA</span><br><span class="line"></span><br><span class="line">/<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">添加元素的时候使用objA锁</span><br><span class="line">获取元素的时候使用objB锁</span><br><span class="line">即两把锁；</span><br><span class="line">当在获取的时候；那么添加元素则不受影响；</span><br><span class="line">另外在添加的时候，也可以使用另外一把锁来进行获取元素；</span><br><span class="line">这就可以保证同时又可以添加又可以获取；</span><br><span class="line"><span class="symbol">*</span>/</span><br></pre></td></tr></table></figure><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>ConcurrentHashMap<br>（在写的时候为了保证线程安全上锁，但是在读的时候不会修改数据所以没有加锁，这样即保证多个线程来进行读取；写的时候加锁保证在写的过程中的线程安全；读的时候不会改变数据可以让多个线程来进行读取）， CopyOnWriteArrayList和ConyOnWriteSet<br>（都是读的时候不加锁，写的时候才加锁；）</p><p>读取时不加锁，写入和删除时加锁</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看笔记：&lt;code&gt;https://www.bilibili.com/video/BV1aJ411V763?from=search&amp;amp
      
    
    </summary>
    
    
      <category term="面试" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="锁" scheme="https://fengshana.github.io/tags/%E9%94%81/"/>
    
      <category term="synchronized" scheme="https://fengshana.github.io/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>Modern Java IN ACTION01</title>
    <link href="https://fengshana.github.io/2020/06/09/%E3%80%90Modern%20Java%20IN%20ACTION%E3%80%91/Modern%20Java%20IN%20ACTION01/"/>
    <id>https://fengshana.github.io/2020/06/09/%E3%80%90Modern%20Java%20IN%20ACTION%E3%80%91/Modern%20Java%20IN%20ACTION01/</id>
    <published>2020-06-08T18:50:05.976Z</published>
    <updated>2020-06-16T15:51:01.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过实例全面讲解<strong>Java 8新特性</strong>为Java程序员开启<strong>函数式编程</strong>的大门<br>Java8实战（<strong>Java 8 in Action</strong>）<br><strong>Lambdas</strong>，<strong>streams</strong>，and <strong>functional-style programming</strong>  </p><p>[英]Raoul-Gabriel Urma<br>[意]Mario Fusco 著</p><p>[英]Alan Mycroft<br>      陆明刚 劳佳 译</p><p>Raoul-Gabriel Urma</p><p>剑桥大学计算机科学博士，软件工程师，演讲者，培训师，Cambridge Coding Academy联合创始人、CEO。<br>曾与谷歌、eBay、甲骨文和高盛集团等大公司合作，并参与过多个创业项目。<br>撰写过十余篇经同行审阅的技术文章，并在国际会议上发表过40多篇演讲。</p><p>Mario Fusco</p><p>Red Hat高级软件工程师，负责JBoss规则引擎Drools的核心开发。<br>拥有丰富的Java开发经验，<br>曾领导媒体公司、金融部门等多个行业的企业级项目开发。<br>对函数式编程和领域特定语言等有浓厚兴趣，并创建了开放源码库lambdaj。</p><p>Alan Mycroft</p><p>剑桥大学计算机实验室计算学教授，<br>剑桥大学罗宾逊学院研究员，<br>欧洲编程语言和系统协会联合创始人，<br>树莓派基金会联合创始人和理事。<br>发表过大约100篇研究论文，执导过20多篇博士论文。<br>他的研究主要关注编程语言及其语义、优化和实施。<br>他与业界练习紧密，曾于学术休假期间在AT&amp;T实验室和英特尔工作，<br>还创立了Codemist公司，该公司设计了最初的ARMC编译器Nocroft。</p><p>陆明刚</p><p>毕业于四川大学，目前在EMC中国卓越研发集团任首席工程师，<br>曾任趋势科技中国软件研发中心技术经理，<br>在信息科技和工程领域有十余年的时间和研究经验，<br>拥有多项中国及美国专利。<br>关注JVM性能调优和大数据及其实践，喜欢挖掘技术背后的内幕并乐此不疲。</p><p>劳佳</p><p>硕士毕业于上海交通大学，现在SAP美国任高级软件支持顾问。<br>业余爱好语言、数学、设计，近年翻译出版了《咨询的奥秘》《卓越程序员密码》等书。</p><h2 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h2><p>本书全面介绍来了 java 8 这个里程碑版本的新特性，包括Lambdas、流和函数式编程。<br>有了函数式的编程特性，<br>可以让代码更简洁，同时也能自动化地利用多核硬件。<br>全书分为四个部分：基础知识、函数式数据处理、高效java 8编程和超越java 8，<br>清晰明了地向读者展现一幅Java与时俱进的现代化画卷。<br>本书适合广大Java开发人员阅读。</p><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>略</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>略</p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;通过实例全面讲解&lt;strong&gt;Java 8新特性&lt;/strong&gt;为Java程序员开启&lt;strong&gt;函数式编程&lt;/strong&gt;的大门&lt;
      
    
    </summary>
    
    
      <category term="jdk8" scheme="https://fengshana.github.io/categories/jdk8/"/>
    
    
      <category term="jdk8" scheme="https://fengshana.github.io/tags/jdk8/"/>
    
      <category term="java" scheme="https://fengshana.github.io/tags/java/"/>
    
      <category term="笔记" scheme="https://fengshana.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spring技术内幕01</title>
    <link href="https://fengshana.github.io/2020/06/02/%E3%80%90Spring%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%91/Spring%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%9501/"/>
    <id>https://fengshana.github.io/2020/06/02/%E3%80%90Spring%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%91/Spring%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%9501/</id>
    <published>2020-06-02T09:28:52.500Z</published>
    <updated>2020-06-05T18:32:48.183Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Spring Internals</p></blockquote><h2 id="Spring-技术内幕"><a href="#Spring-技术内幕" class="headerlink" title="Spring 技术内幕"></a>Spring 技术内幕</h2><h3 id="深入解析-Spring架构-与-设计原理"><a href="#深入解析-Spring架构-与-设计原理" class="headerlink" title="深入解析 Spring架构 与 设计原理"></a>深入解析 Spring架构 与 设计原理</h3><p>（第2版）  计文柯 著  </p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="为什么要写这本书"><a href="#为什么要写这本书" class="headerlink" title="为什么要写这本书"></a>为什么要写这本书</h3><p>本书探讨了 <strong>Spring框架的设计原理、架构和运行机制</strong>。<br>作为在 Java领域 最为成功的 开源软件之一，<br>Sprign在Java EE开发中，使用者众多。<br>本书以 Spring的源代码 为依托，<br>结合 Spring的设计思路，<br>从内部实现的角度，对Spring的实现进行了翔实的分析，<br>希望能够通过这种分析，使读者在开发者的层面掌握Spring，为开发Spring应用提供更扎实的框架基础。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Spring Internals&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Spring-技术内幕&quot;&gt;&lt;a href=&quot;#Spring-技术内幕&quot; class=&quot;headerlink&quot; title=&quot;Spring 技术内幕&quot;&gt;&lt;/a&gt;Sp
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://fengshana.github.io/categories/Spring/"/>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Spring" scheme="https://fengshana.github.io/tags/Spring/"/>
    
      <category term="Spring技术内幕" scheme="https://fengshana.github.io/tags/Spring%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"/>
    
  </entry>
  
  <entry>
    <title>全面深入讲解MySQL数据库优化03</title>
    <link href="https://fengshana.github.io/2020/05/29/%E3%80%90MYSQL%E3%80%91/%E3%80%90MYSQL%E3%80%91%E5%85%A8%E9%9D%A2%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%9603/"/>
    <id>https://fengshana.github.io/2020/05/29/%E3%80%90MYSQL%E3%80%91/%E3%80%90MYSQL%E3%80%91%E5%85%A8%E9%9D%A2%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%9603/</id>
    <published>2020-05-29T11:23:31.802Z</published>
    <updated>2020-06-05T17:56:02.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：<code>https://www.bilibili.com/video/BV1fJ41127Rj?from=search&amp;seid=13531213796559959972</code>  </p><p>本课程作为MySQL高级课程，主要讲解了：  </p><ul><li><strong>MySQL</strong>中的<strong>视图</strong>/<strong>存储过程</strong>/<strong>触发器</strong>/<strong>索引</strong>等对象的使用</li><li>常见的<strong>SQL</strong>语句<strong>优化</strong>的技巧</li><li><strong>应用优化</strong></li><li><strong>数据库优化</strong></li><li><strong>数据库日志</strong></li></ul><p>等方面的知识，并通过综合案例，对课程中的知识进行一个整合应用。  </p><p>本课程旨在通过MySQl高级部分内容，可以在满足现有业务需求基础上，对<strong>MySQL底层的体系结构</strong>，及<strong>底层的优化</strong>有一个深入的理解，对<strong>系统的整体性能</strong>进行提升。  </p><h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><ul><li><strong>应用优化</strong></li><li><strong>MySQL中查询缓存优化</strong></li><li><strong>MySQL内存管理以及优化</strong></li><li><strong>MySQL并发参数</strong>调整</li><li><strong>MySQL锁</strong>问题</li><li>常用SQL技巧</li></ul><h2 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h2><p>前面章节，介绍了很多<strong>数据库的优化措施</strong>，但是在实际生产环境中，由于<strong>数据库 本身的性能 局限</strong>，就必须对前台的应用进行一些优化，来<strong>降低 数据库的 访问压力</strong>。  </p><h3 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h3><p>对于<strong>访问数据库</strong>来说，<strong>建立连接的代价</strong>是比较<strong>昂贵</strong>的，因为<strong>频繁的 创建关闭连接</strong>，是比较<strong>耗费资源</strong>的，有必要<strong>建立数据库连接池</strong>，以<strong>提高访问的性能</strong>。  </p><h3 id="减少对MySQL的访问"><a href="#减少对MySQL的访问" class="headerlink" title="减少对MySQL的访问"></a>减少对MySQL的访问</h3><h4 id="减少对数据进行重复检索"><a href="#减少对数据进行重复检索" class="headerlink" title="减少对数据进行重复检索"></a>减少对数据进行重复检索</h4><p>在编写应用代码时，需要能够<strong>理解 对 数据库的 访问逻辑</strong>。  </p><p><strong>能够 一次连接 就 获取得到结果的，就 不用两次连接</strong>，这样可以<strong>大大减少 对 数据库 无用的重复请求</strong>。  </p><p>比如，需要获取书籍的id和name字段，则查询如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure><p>之后，在业务逻辑中有需要获取得到书籍状态信息，则查询如下：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> ,<span class="keyword">status</span> <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure><p>这样，就需要向数据库提交两次请求，数据库就要做两次查询操作。<br>其实完全可以用一条SQL语句得到想要的结果。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> ,<span class="keyword">status</span> <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure><h4 id="增加cache层"><a href="#增加cache层" class="headerlink" title="增加cache层"></a>增加cache层</h4><p>在应用中，可以在应用中<strong>增加 缓存 层</strong> 来达到<strong>减轻数据库负担</strong>的目的。  </p><p>缓存层有很多种，也有很多实现方式，只要达到<strong>降低数据库的负担</strong>又能<strong>满足应用需求</strong>就可以。  </p><p>因此可以部分数据从数据库中抽取出来放到应用端以<strong>文本方式存储</strong>，或者使用<strong>框架（Mybatis，Hibernate）提供的一级缓存、二级缓存</strong>，或者使用<strong>redis数据库</strong>来<strong>缓存数据</strong>。  </p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p><strong>负载均衡</strong>是应用中使用非常<strong>普遍</strong>的一种<strong>优化方式</strong>。  </p><p><strong>负载均衡的机制</strong>就是利用<strong>某种均衡算法</strong>，将<strong>固定的负载量</strong> <strong>分到 不同的 服务器</strong>上，一次来<strong>降低 单台服务器的 负载</strong>，达到<strong>优化</strong>的效果。  </p><h4 id="利用MySQL复制分流查询"><a href="#利用MySQL复制分流查询" class="headerlink" title="利用MySQL复制分流查询"></a>利用MySQL复制分流查询</h4><p>通过<strong>MySQL的 主从复制</strong>，实现<strong>读写分离</strong>，使得<strong>增删改操作 走 主节点</strong>，<strong>查询操作 走 从结点</strong>，从而可以<strong>降低 单台服务器的读写压力</strong>。  </p><h4 id="采用分布式数据库架构"><a href="#采用分布式数据库架构" class="headerlink" title="采用分布式数据库架构"></a>采用分布式数据库架构</h4><p><strong>分布式数据库</strong>架构适合<strong>大数据量、负载高</strong>的情况，它有<strong>良好的 拓展性 和 高可用性</strong>。<br>通过在<strong>多台服务器</strong>之间<strong>分布数据</strong>，可以实现在<strong>多台服务器</strong>之间的<strong>负载均衡</strong>，<strong>提高访问效率</strong>。  </p><h2 id="查询缓存-概述及流程"><a href="#查询缓存-概述及流程" class="headerlink" title="查询缓存 - 概述及流程"></a>查询缓存 - 概述及流程</h2><h3 id="Mysql中查询缓存优化-概述"><a href="#Mysql中查询缓存优化-概述" class="headerlink" title="Mysql中查询缓存优化-概述"></a>Mysql中查询缓存优化-概述</h3><p><strong>开启mysql的 查询缓存</strong>，当<strong>执行完全相同的SQL语句</strong>的时候，<strong>服务器</strong>就会直接<strong>从缓存中读取结果</strong>；<br>当<strong>数据被修改</strong>，之前的<strong>缓存就会失效</strong>，<strong>修改比较频繁的 表 不适合 做 查询缓存</strong>。  </p><h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><ol><li><strong>客户端</strong> <strong>发送一条查询SQL</strong> 给 <strong>服务器</strong></li><li><strong>服务器</strong>先会 <strong>检查查询缓存</strong>，如果<strong>命中</strong>了<strong>缓存</strong>，则<strong>立即返回存储在缓存中的结果</strong>。否则进入下一阶段。</li><li><strong>服务器端</strong>进行<strong>SQL解析</strong>、<strong>预处理</strong>，再由<strong>优化器</strong>生成对应的<strong>执行计划</strong>；</li><li><strong>MySQL</strong>根据<strong>优化器生成的执行计划</strong>，调用<strong>存储引擎的API</strong>来<strong>执行查询</strong>；</li><li>将结果<strong>缓存</strong>并<strong>返回给客户端</strong>；</li></ol><h2 id="查询缓存-配置参数"><a href="#查询缓存-配置参数" class="headerlink" title="查询缓存 - 配置参数"></a>查询缓存 - 配置参数</h2><h3 id="查询缓存配置"><a href="#查询缓存配置" class="headerlink" title="查询缓存配置"></a>查询缓存配置</h3><ol><li>查看当前的<strong>MySQL数据库 是否 支持 查询缓存</strong>：  </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p  </span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'have_query_cache'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>have_query_cache</td>    <td>YES</td>  </tr></table><ol start="2"><li>查看当前<strong>MySQL 是否 开启了 查询缓存</strong>：  </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'query_cache_type'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>query_cache_type</td>    <td>OFF(关闭)</td>  </tr></table><ol start="3"><li>查看 <strong>查询缓存 的 占用大小</strong>（建议按照1024倍数进行增大）：  </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'query_cache_size'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>query_cache_size</td>    <td>1048576（单位为字节，占用内存空间约为：1048576/1024/1024约为 1M的内存空间）</td>  </tr></table><ol start="4"><li>查看<strong>查询缓存 的 状态变量</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr>    <td>Qcache_hits</td>    <td>13</td>  </tr>  <tr>    <td>Qcache_inserts</td>    <td>6</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>16</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>4</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> demo_02; <span class="comment"># 切换数据库也算是一次查询mysql底层当中</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item; <span class="comment"># 耗费时间2.76 second</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item; <span class="comment"># 耗费时间2.53 second</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks（可用的内存块的个数）</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory（可用的内存空间）</td>    <td>1038344</td>  </tr>  <tr>    <td>Qcache_hits（查询缓存的命中次数）</td>    <td>13</td>  </tr>  <tr>    <td>Qcache_inserts（添加到缓存当中的次数）</td>    <td>6</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes（如果内存空间不足，将内存中数据移出缓存空间次数）</td>    <td>0</td>  </tr>  <tr>    <td style="color:red;font-weight:bolder;">Qcache_not_cached(当前查询没有进行缓存次数)</td>    <td style="color:red;font-weight:bolder;">19</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>4</td>  </tr></table><table>  <tr>    <th>参数</th>    <th>含义</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>查询缓存中的可用内存块数</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>查询缓存的可用内存量</td>  </tr><tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>查询缓存命中数</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts</td>    <td>添加到查询缓存的查询数</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>由于内存不足而从查询缓存中删除的查询数</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached</td>    <td>非缓存查询的数量（由于query_cache_type设置而无法缓存或者未缓存）</td>  </tr>  <tr>    <td>Qcache_queries_in_cache</td>    <td>查询缓存中注册的查询数</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>查询缓存中的块总数</td>  </tr></table><h2 id="查询缓存-开启查询缓存"><a href="#查询缓存-开启查询缓存" class="headerlink" title="查询缓存 - 开启查询缓存"></a>查询缓存 - 开启查询缓存</h2><p>MySQL的查询缓存默认是关闭的，需要手动配置参数 query_cache_type，来开启查询缓存。  </p><p>query_cache_type 该参数的可取值有三个：  </p><table>  <tr>    <th>值</th>    <th>定义</th>  </tr>  <tr>    <td>OFF 或 0</td>    <td>查询缓存功能关闭</td>  </tr>    <tr>    <td>ON 或 1</td>    <td>查询缓存功能打开，SELECT的结果符合缓存条件即会缓存；否则不予缓存；显式指定SQL_NO_CACHE，则不予缓存</td>  </tr>    <tr>    <td> DEMAND 或 2</td>    <td>查询缓存功能按需进行，<span style="color:red;font-weight:bolder;">显式指定 SQL_CACHE 的SELECT语句才会缓存</span>；其他均不予缓存</td>  </tr></table><p>在 /usr/my.cnf配置中，增加以下配置：  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在开启mysql的查询缓存</span></span><br><span class="line"><span class="attr">query_cache_type</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>配置完毕之后，重启服务即可生效；  </p><p>然后就可以在命令行执行SQL语句进行验证，执行一条比较耗时的SQL语句，然后再执行多次，查看后面几次的执行时间；  </p><p>获取通过查看查询缓存的缓存命中数，来判定是否走了查询缓存。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/my.cnf</span><br><span class="line">query_cache_type:1</span><br><span class="line"></span><br><span class="line">service mysql restart<span class="comment">#重启mysql</span></span><br><span class="line"></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> demo_02;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 2.58 second</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 0.00 second</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 0.00 second</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 0.00 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="string">'Qcache'</span>%;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>4</td>  </tr>  <tr>    <td>Qcache_inserts</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr>    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>2</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>4</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 0.00 second</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_inserts</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr>    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>2</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>4</td>  </tr></table><h2 id="查询缓存-SELECT选项"><a href="#查询缓存-SELECT选项" class="headerlink" title="查询缓存 - SELECT选项"></a>查询缓存 - SELECT选项</h2><p>可以在SELECT语句中指定两个与查询缓存相关的选项：  </p><ul><li>SQL_CACHE：如果查询结果是可缓存的，并且query_cache_type 系统变量的值为ON或者DEMAND，则缓存查询结果；  </li><li>SQL_NO_CACHE: 服务器不使用查询缓存，它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。  </li></ul><p>例子：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_CACHE id, name <span class="keyword">FROM</span> customer;</span><br><span class="line">SELECT SQL_NO_CACHE id,name <span class="keyword">FROM</span> customer;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item  <span class="keyword">limit</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span>  <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>5</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr>    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>2</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>8</td>  </tr></table><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_NO_CACHE <span class="built_in">title</span>, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> id=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>6</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts（添加到缓存的数量）</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>2</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>8</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_NO_CACHE title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>6</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts（添加到缓存的数量）</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>8</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_NO_CACHE title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> SQL_NO_CACHE title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1035936</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>6</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts（添加到缓存的数量）</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>3</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>8</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_CACHE</span> title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_CACHE</span> title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>7</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts（添加到缓存的数量）</td>    <td>4</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>4</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>10</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_CACHE</span> title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_CACHE</span> title, sellerid <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1038344</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>9</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts（添加到缓存的数量）</td>    <td>4</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>4</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>10</td>  </tr></table><h2 id="查询缓存-失效场景"><a href="#查询缓存-失效场景" class="headerlink" title="查询缓存 - 失效场景"></a>查询缓存 - 失效场景</h2><table>  <tr>    <th>值</th>    <th>定义</th>  </tr>  <tr>    <td>OFF 或 0</td>    <td>查询缓存功能关闭</td>  </tr>    <tr>    <td>ON 或 1</td>    <td>查询缓存功能打开，<span style="color:red;font-weight:bolder;">SELECT的结果符合缓存条件即会缓存</span>；否则不予缓存；显式指定SQL_NO_CACHE，则不予缓存</td>  </tr>    <tr>    <td> DEMAND 或 2</td>    <td>查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其他均不予缓存</td>  </tr></table><p>开启mysql的查询缓存，当执行<strong>完全相同的SQL语句</strong>的时候，服务器就会直接从缓存中读取结果；当数据被修改，之前的缓存就会失效，修改比较频繁的表不适合做查询缓存。</p><ol><li>SQL语句不一致的情况，要想命中查询缓存，查询的SQL语句必须一致。  </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#SQL1：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#3000000 耗时0.00 second</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#SQL2：</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#3000000 耗时2.79 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1033888</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>11</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr>    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>12</td>  </tr></table><ol start="2"><li>当查询语句中有一些不确定的时候，则不会缓存。如：now()、current_date()、curdate()、curtime()、rand()、uuid()、user()、database()；  </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>(); <span class="comment"># 耗时 0.01 second</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>(); <span class="comment"># 耗时 0.01 second；时间是发生了变化的；即不会走缓存</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1033888</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>11</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>7</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>12</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#SQL1：</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> updatetime &lt; <span class="keyword">now</span>() <span class="keyword">limit</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#SQL2：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">#SQL3：</span></span><br><span class="line"><span class="keyword">select</span> databse();</span><br></pre></td></tr></table></figure><ol start="3"><li>不适用任何表查询语句。  </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1033888</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>11</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>8</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>12</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'A'</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>查询mysql、information_schema 或者 performance_schema 数据库中的表时，不会走查询缓存。  </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"><span class="comment">#information_schema</span></span><br><span class="line"><span class="comment">#mysql</span></span><br><span class="line"><span class="comment">#performance_schema</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.engines;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1033888</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>11</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>9</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>12</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.engines;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Qcache_free_blocks</td>    <td>1</td>  </tr>  <tr>    <td>Qcache_free_memory</td>    <td>1033888</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_hits</td>    <td>11</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_inserts</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_lowmen_prunes</td>    <td>0</td>  </tr>  <tr style="color:red;font-weight:bolder;">    <td>Qcache_not_cached(当前查询没有进行缓存)</td>    <td>10</td>  </tr>  <tr>    <td>Qcache_queryies_in_cache</td>    <td>5</td>  </tr>  <tr>    <td>Qcache_total_blocks</td>    <td>12</td>  </tr></table><ol start="5"><li><p>在存储的函数，触发器或者时间的主体内执行的查询；</p></li><li><p>如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。这包括使用<strong>MERGE</strong>映射到已更改表的查询。一个表可以被许多类型的语句，如被改变INSERT、UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE 或者 DROP DATABASE。  </p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 0.00 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> tb_item <span class="keyword">set</span> title=<span class="string">'test1'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 2.67 second；该SQL失效；但是失效的同时又去进行了缓存；当前查询时并未缓存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;<span class="comment">#耗时 0.00 second；此时再去查询；即查询的缓存区内的内容</span></span><br></pre></td></tr></table></figure><h2 id="内存优化-优化原则"><a href="#内存优化-优化原则" class="headerlink" title="内存优化 - 优化原则"></a>内存优化 - 优化原则</h2><h3 id="内存优化原则"><a href="#内存优化原则" class="headerlink" title="内存优化原则"></a>内存优化原则</h3><ol><li>将尽量多的内存分配给MySQL做缓存(提高mysql的访问效率)，但要给操作系统和其他程序预留足够内存；</li><li>MyISAM存储引擎的数据文件读取依赖于操作系统自身的I/O缓存，因此，如果有MyISAM表，就要预留更多的内存给操作系统做I/O缓存。</li><li>排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。</li></ol><h2 id="内存优化-MyISAM内存优化"><a href="#内存优化-MyISAM内存优化" class="headerlink" title="内存优化 - MyISAM内存优化"></a>内存优化 - MyISAM内存优化</h2><p>MyISAM的缓存机制：  </p><p>MyISAM存储引擎使用key_buffer缓存索引块（没有缓存数据块），加速MyISAM索引的读写速度，对于MyISAM表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的I/O缓存。  </p><p><strong>key_buffer_size</strong>  </p><p>key_buffer_size决定MyISAM索引块缓存区的大小，直接影响到MyISAM表的存取效率。  </p><p>可以在mysql参数文件中设置key_buffer_size的值，对于一般MyISAM数据库，建议至少将1/4可用内存分配给key_buffer_size。  </p><p>在/usr/my.cnf 中做如下配置：  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key_buffer_size</span>=<span class="number">512</span>M</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'key_buffer_size'</span>;<span class="comment">#mysql 命令行</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>key_buffer_size</td>    <td>8388608(单位为字节；默认大小)</td>  </tr></table><p><strong>read_buffer_size</strong>  </p><p>如果需要经常顺序扫描MyISAM表，可以通过增大read_buffer_size的值来改善性能。  </p><p>但是需要注意的是read_buffer_size是每个session独占的，如果默认值设置太大，就会造成内存浪费。  </p><p><strong>read_rnd_buffer_size</strong>  </p><p>对于需要做排序的MyISAM表的查询，如带有 order by 子句的SQL，适当增加read_rnd_buffer_size的值，可以改善此类的SQL性能。  </p><p>但是需要注意的是read_rnd_buffer_size 是每个session独占的，如果默认值设置太大，就会造成内存浪费。  </p><h2 id="内存优化-InnoDB内存优化"><a href="#内存优化-InnoDB内存优化" class="headerlink" title="内存优化 - InnoDB内存优化"></a>内存优化 - InnoDB内存优化</h2><p>innodb的缓存机制：<br>InnoDB用一块内存区做IO缓存池，该缓存池不仅用来缓存InnoDB的索引块，而且也用来缓存InnoDB的数据块。  </p><p><strong>innodb_buffer_pool_size</strong>  </p><p>该变量决定了innodb存储引擎表数据和索引数据的最大缓存区大小。<br>在保证操作系统以及其他程序有足够内存可用的情况下，innodb_buffer_pool_size的值越大，缓存命中率越高，访问innodb表的需要的磁盘I/O就越少，性能也就越高。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_buffer_pool_size'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>innodb_buffer_pool_size</td>    <td>134217728(单位为字节；默认大小128M；134217728/1024-->131072（换算成B），134217728/1024/1024-->128（换算成M）；)</td>  </tr></table><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/<span class="keyword">my</span>.cnf</span><br><span class="line"><span class="comment"># innodb_buffer_pool_size=512M #修改内容</span></span><br></pre></td></tr></table></figure><p><strong>innodb_log_buffer_size</strong>  </p><p>决定了innodb重做日志缓存的大小，对于避免产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/my.cnf</span><br><span class="line"><span class="comment"># innodb_log_buffer_size=10M #修改内容</span></span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><h2 id="并发参数调整"><a href="#并发参数调整" class="headerlink" title="并发参数调整"></a>并发参数调整</h2><h3 id="mysql并发参数调整"><a href="#mysql并发参数调整" class="headerlink" title="mysql并发参数调整"></a>mysql并发参数调整</h3><p>从实现上来说，MySQL Server是多线程结构，包括后台线程和客户服务线程。  </p><p>多线程可以有效利用服务器资源，提高数据库的并发性能。  </p><p>在mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_size；  </p><h4 id="max-connections（最大连接数）"><a href="#max-connections（最大连接数）" class="headerlink" title="max_connections（最大连接数）"></a>max_connections（最大连接数）</h4><p>采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是151。  </p><p>如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已经达到允许最大值而失败，这时可以考虑增大max_connections的值。  </p><p>MySQL最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。  </p><p>在Linux平台下，性能好的服务器，支持500-1000个连接都不是难事，需要根据服务器性能进行评估设定。  </p><h4 id="back-log"><a href="#back-log" class="headerlink" title="back_log"></a>back_log</h4><p>back_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。  </p><p>如果mysql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。  </p><p>5.6.6版本之前默认值为50，之后的版本默认为50+（max_connections/5），但最大不超过900。  </p><p>如果需要数据库在较短的时间内处理大量连接请求，可以考虑适当增大back_log的值。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'back_log'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>back_log</td>    <td>80(默认个数)</td>  </tr></table><h4 id="table-open-cache"><a href="#table-open-cache" class="headerlink" title="table_open_cache"></a>table_open_cache</h4><p>该参数用来控制所有SQL语句执行线程可打开表缓存的数量，而在执行SQL语句时，每一个SQL执行线程至少要打开一个表缓存，该参数的值应该根据设置的最大连接数max_connections 以及每个连接执行关联查询中涉及的白鸥的最大数量来决定。  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_connections x N<span class="comment">;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'table_open_cache'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>table_open_cache</td>    <td>2000(默认大小)</td>  </tr></table><h4 id="thread-cache-size（线程缓存大小）"><a href="#thread-cache-size（线程缓存大小）" class="headerlink" title="thread_cache_size（线程缓存大小）"></a>thread_cache_size（线程缓存大小）</h4><p>为了加快连接数据库的速度，MySQL会缓存一定数量的客户服务线程（线程池）以备重用，通过参数 thread_cache_size 可控制MySQL缓存客户服务线程的数量（线程池的大小）。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'thread_cache_size'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>thread_cache_size</td>    <td>9(默认大小9个线程)</td>  </tr></table><h4 id="innodb-lock-wait-timeout（innodb行锁的等待时间）"><a href="#innodb-lock-wait-timeout（innodb行锁的等待时间）" class="headerlink" title="innodb_lock_wait_timeout（innodb行锁的等待时间）"></a>innodb_lock_wait_timeout（innodb行锁的等待时间）</h4><p>该参数是用来设置InnoDB事务等待行锁的时间，默认值时候50ms。  </p><p>可以根据需要进行动态设置。  </p><p>对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起；  </p><p>对于后台运行的批量处理程序来说，可以将行锁的等待时间调大，以避免发生大的回滚操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_lock_wait_timeout'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>innodb_lock_wait_timeout</td>    <td>50</td>  </tr></table><h2 id="锁-锁的概述及分类"><a href="#锁-锁的概述及分类" class="headerlink" title="锁 - 锁的概述及分类"></a>锁 - 锁的概述及分类</h2><h3 id="锁概述"><a href="#锁概述" class="headerlink" title="锁概述"></a>锁概述</h3><p>锁是计算机协调多个进程 或者 线程 并发访问某一资源的机制（避免争抢）。  </p><p>在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。  </p><p>如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。  </p><p>从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。  </p><h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><p>从对数据操作的粒度分为：  </p><ol><li>表锁：操作时，会锁定整个表</li><li>行锁：操作时，会锁定当前操作行</li></ol><p>从对数据操作的类型分：  </p><ol><li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响</li><li>写锁（排它锁）：当前操作没有完成之前，他会阻断其他写锁和读锁</li></ol><h2 id="锁-MySQL对锁的支持"><a href="#锁-MySQL对锁的支持" class="headerlink" title="锁 - MySQL对锁的支持"></a>锁 - MySQL对锁的支持</h2><p>相对其他数据库而言，MySQL的锁机制比较简单。  </p><p>其最显著的特点是不同的存储引擎支持不同的锁机制。  </p><p>下标罗列出了各个存储引擎对锁的支持情况。  </p><table>  <tr>    <th>存储引擎</th>    <th>表级锁</th>    <th>行级锁</th>    <th>页面锁</th>  </tr>  <tr>    <td>MyISAM</td>    <td>支持</td>    <td>不支持</td>    <td>不支持</td>  </tr>    <tr>    <td>InnoDB</td>    <td>支持</td>    <td>支持</td>    <td>不支持</td>  </tr>    <tr>    <td>MEMORY</td>    <td>支持</td>    <td>不支持</td>    <td>不支持</td>  </tr>    <tr>    <td>BDB</td>    <td>支持</td>    <td>不支持</td>    <td>支持</td>  </tr></table><p>MySQL这三种锁的特性可大致归纳如下：  </p><table>  <tr>    <th>锁类型</th>    <th>特定</th>  </tr>  <tr>    <td>表级锁</td>    <td>偏向MyISAM存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</td>  </tr>    <tr>    <td>行级锁</td>    <td>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</td>  </tr>    <tr>    <td>页面锁</td>    <td>开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。</td>  </tr></table><p>从上述特点可见，很难笼统的说哪种锁更好，只能就具体应用的特点来说哪种锁更合适。  </p><p>仅从锁的角度来说：<br>  表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；<br>  而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统；  </p><h2 id="锁-MyISAM表锁-读锁"><a href="#锁-MyISAM表锁-读锁" class="headerlink" title="锁 - MyISAM表锁 - 读锁"></a>锁 - MyISAM表锁 - 读锁</h2><p>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</p><p>MyISAM存储引擎支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。  </p><h3 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h3><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等），会自动给涉及的表加写锁，这个过程并不需要用户干预。  </p><p>因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。  </p><p>显示加表锁语法：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加读锁：  </span></span><br><span class="line"><span class="keyword">lock</span> <span class="keyword">table</span> table_name <span class="keyword">read</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#加写锁：  </span></span><br><span class="line"><span class="keyword">lock</span> <span class="keyword">table</span> table_name write;</span><br></pre></td></tr></table></figure><h3 id="读锁案例"><a href="#读锁案例" class="headerlink" title="读锁案例"></a>读锁案例</h3><p>准备环境  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">create database demo_03<span class="built_in"> default </span><span class="attribute">charset</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line">use demo_03;</span><br><span class="line"></span><br><span class="line">CREATE TABLE <span class="string">'tb_book'</span>(</span><br><span class="line">  <span class="string">'id'</span> INT(11) AUTO_INCREMENT,</span><br><span class="line">  <span class="string">'name'</span> VARCHAR(50)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'publish_name'</span> DATE<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'status'</span> CHAR(1)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">'id'</span>)</span><br><span class="line">)<span class="attribute">ENGINE</span>=myisam<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入tb_book 基础数据</span></span><br><span class="line"></span><br><span class="line">CREATE TABLE <span class="string">'tb_user'</span>(</span><br><span class="line">  <span class="string">'id'</span> INT(11) AUTO_INCREMENT,</span><br><span class="line">  <span class="string">'name'</span> VARCHAR(50)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY(<span class="string">'id'</span>)</span><br><span class="line">)<span class="attribute">ENGINE</span>=myisam<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入tb_user 基础数据</span></span><br><span class="line"></span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">lock table tb_book read;</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> tb_books;</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> tb_user;# Table <span class="string">'tb_user'</span> was <span class="keyword">not</span> locked with LOCK TABLES 锁定tb_book表途中无法去操作其他表；除非当前tb_book表锁释放；</span><br><span class="line"></span><br><span class="line">update tb_book <span class="builtin-name">set</span> name =<span class="string">'solr'</span> where <span class="attribute">id</span>=2;#当前对tb_book表进行的锁是读锁，而不是写锁；所以当前无法进行更新；Table <span class="string">'tb_book'</span> was locked with a READ lock <span class="keyword">and</span> can<span class="string">'t be updated.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">unlock tables;#只有当当前的tb_book表当中的读锁进行解锁，其他客户端连接mysql的该表时才能够进行写锁；否则将一直等待当前该tb_book的读锁释放；</span></span><br></pre></td></tr></table></figure><p>如果对MyISAM表进行操作了读锁，其不会阻塞其他线程的读操作，但是会阻塞其他线程的写操作。  </p><h2 id="锁-MyISAM表锁-写锁"><a href="#锁-MyISAM表锁-写锁" class="headerlink" title="锁 - MyISAM表锁 - 写锁"></a>锁 - MyISAM表锁 - 写锁</h2><p>写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当前客户端</span></span><br><span class="line"><span class="keyword">lock</span> <span class="keyword">table</span> tb_book write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> tb_book <span class="keyword">set</span> <span class="keyword">name</span> =<span class="string">'solr'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_book(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'es'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#其他客户端</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_book;<span class="comment">#其他客户端将一直处于等待状态，除非当前客户端的写锁释放（即当前客户端的业务操作完成），否则其他客户端一直处于等待状态。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当前客户端</span></span><br><span class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#其他客户端</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_book;<span class="comment">#当 当前客户端释放锁之后，该其他客户端即立刻能查询到数据。</span></span><br></pre></td></tr></table></figure><h2 id="锁-MyISAM表锁-小结"><a href="#锁-MyISAM表锁-小结" class="headerlink" title="锁 - MyISAM表锁 - 小结"></a>锁 - MyISAM表锁 - 小结</h2><p>锁模式的互相兼容性如表所示：  </p><table>  <tr>    <th>当前锁模式/请求锁模式</th>    <th>None（理解为当前客户端获取得到的锁）</th>    <th>读锁（其他客户端对于读操作是否可行）</th>    <th>写锁（其他客户端对于写操作是否可行）</th>  </tr>  <tr>    <th>读锁</th>    <td>是（当前客户端获取得到的读锁）</td>    <td>是（其他客户端可以进行读操作）</td>    <td>否（其他客户端无法进行写操作）</td>  </tr>    <tr>    <th>写锁</th>    <td>是（当前客户端获取得到的写锁）</td>    <td>否（其他客户端无法进行读操作）</td>    <td>否（其他客户端无法进行写操作）</td>  </tr></table><p>由上表可见：  </p><ol><li>对MyISAM表的读操作，不会阻塞其他用户对同一张表的读请求，但是会阻塞对同一张表的写请求。</li><li>对MyISAM表的写操作，则会阻塞其他用户对同一张表的读和写操作。</li></ol><p>简而言之，就是读锁会阻塞写，但是不会阻塞读；而写锁，则既会阻塞读，又会阻塞写。  </p><p>此外，MyISAM的读写锁调度是写操作优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。<br>因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p><h2 id="锁-MyISAM表锁-查看锁争用情况"><a href="#锁-MyISAM表锁-查看锁争用情况" class="headerlink" title="锁 - MyISAM表锁 - 查看锁争用情况"></a>锁 - MyISAM表锁 - 查看锁争用情况</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><p>Database: 数据库  </p><p>Table: 数据表  </p><p>In_use: 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。  </p><p>Name_locked: 表名称是否被锁定。名称锁定用于取消表或者对表进行重命名等操作。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">table</span> tb_book write;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;<span class="comment">#database: demo_03; table: tb_book ; In_use(正在使用):1；Name_locked:0</span></span><br><span class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Table_locks%'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Table_lockes_immediate</td>    <td>70</td>  </tr>    <tr>    <td>Table_locks_waited</td>    <td>0</td>  </tr></table><p>Table_locks_immediate: 指的是能够立即获得表级锁的次数，每次立即获取锁，值加1；  </p><p>Table_locks_waited: 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。</p><h2 id="锁-InnoDB行锁-介绍及背景知识"><a href="#锁-InnoDB行锁-介绍及背景知识" class="headerlink" title="锁 - InnoDB行锁 - 介绍及背景知识"></a>锁 - InnoDB行锁 - 介绍及背景知识</h2><h3 id="行锁介绍"><a href="#行锁介绍" class="headerlink" title="行锁介绍"></a>行锁介绍</h3><p>InnoDB默认支持行锁，也支持表锁；  </p><p>行锁特点：偏向InnoDB存储迎请，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>（由于锁定粒度最小，所以发生锁冲突的概率最低，二者存在关联）  </p><p>InnoDB与MyISAM的最大不同有两点：一是支持事务；二是采用了行级锁；<br>(事务和行级锁之间存在关联，支持事务的原因即在于InnoDB采用的是行级锁)</p><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p><strong>事务及其ACID属性</strong>  </p><p>事务是由一组SQL语句组成的逻辑处理单元。<br>事务具有以下4个特性，简称为事务ACID属性。  </p><table>  <tr>    <th>ACID属性</th>    <th>含义</th>  </tr>  <tr>    <td>原子性（Atomic）</td>    <td>事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败</td>  </tr>  <tr>    <td>一致性（Consistent）</td>    <td>在事务开始和完成时，数据都必须保持一致状态</td>  </tr>  <tr>    <td>隔离性（Isolation）</td>    <td>数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境下运行</td>  </tr>  <tr>    <td>持久性（Durable）</td>    <td>事务完成之后，对于数据的修改是永久的</td>  </tr></table><p><strong>并发事务处理带来的问题</strong>  </p><table>  <tr>    <th>问题</th>    <th>含义</th>  </tr>  <tr>    <td>丢失更新（Lost Update）</td>    <td>当两个或者多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖</td>  </tr>  <tr>    <td>脏读（Dirty Reads）</td>    <td>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据（一个事务读取到了另外一个事务还未提交的数据）</td>  </tr>  <tr>    <td>不可重复度（Non_repeatable Reads）</td>    <td>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前独处的数据不一致</td>  </tr>  <tr>    <td>幻读（Phantom Reads）</td>    <td>一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。</td>  </tr></table><p><strong>事务隔离级别</strong>  </p><p>为了解决上述提到的事务并发问题，数据库提供一定的事务隔离机制来解决这个问题。  </p><p>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大(性能越低)，因为事务隔离实质上就是使用事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。  </p><p>数据库的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable ，这四个界别可以逐个解决脏写、脏读、不可重复度、幻读这几类问题。  </p><table>  <tr>    <th>隔离级别</th>    <th>丢失更新</th>    <th>脏读</th>    <th>不可重复读</th>    <th>幻读</th>  </tr>  <tr>    <td>Read uncommitted</td>    <td>x</td>    <td>√</td>    <td>√</td>    <td>√</td>  </tr>    <tr>    <td>Read committed</td>    <td>x</td>    <td>x</td>    <td>√</td>    <td>√</td>  </tr>   <tr>    <td>Repeatable read(默认)</td>    <td>x</td>    <td>x</td>    <td>x</td>    <td>√</td>  </tr>    <tr>    <td>Serializable</td>    <td>x</td>    <td>x</td>    <td>x</td>    <td>x</td>  </tr></table><p>备注： √ 代表可能出现， x 代表不会出现。  </p><p>MySQL的数据库的默认隔离级别是 Repeatable read，查看方式：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'tx_isolation'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>tx_isolation</td>    <td>REPEATABLE-READ</td>  </tr></table><h2 id="锁-InnoDB行锁-类型"><a href="#锁-InnoDB行锁-类型" class="headerlink" title="锁 - InnoDB行锁 - 类型"></a>锁 - InnoDB行锁 - 类型</h2><h3 id="InnoDB的行锁模式"><a href="#InnoDB的行锁模式" class="headerlink" title="InnoDB的行锁模式"></a>InnoDB的行锁模式</h3><p><strong>InnoDB</strong>实现了以下<strong>两种类型的行锁</strong>：  </p><ul><li><p><strong>共享锁（S）</strong>： 又称为<strong>读锁</strong>，<br>简称<strong>S锁</strong>，</p></li><li><p><em>共享锁*</em>就是<strong>多个事务</strong> 对于 <strong>同一数据</strong> 可以 <strong>共享一把锁</strong>，都能 <strong>访问到 数据</strong>，<br>但是 <strong>只能读 不能修改</strong>。  </p></li><li><p><strong>排它锁（X）</strong>：又称为<strong>写锁</strong>，<br>简称<strong>X锁</strong>，</p></li><li><p><em>排它锁*</em>就是<strong>不能与其他锁 并存</strong>。<br>如果<strong>一个事务 获取了 一个数据行的排它锁</strong>，</p></li><li><p><em>其他事务*</em>就<strong>不能再获取</strong> <strong>该行的其他锁</strong>，<br>包括<strong>共享锁和排它锁</strong>，<br>但是 <strong>获取排它锁的事务</strong> 可以<strong>对数据 进行 读取 和 修改</strong>。  </p></li></ul><p>对于<strong>UPDATE、DELETE和INSERT</strong>语句，<strong>InnoDB</strong>会<strong>自动</strong>给涉及数据集 加 <strong>排它锁（X）</strong>；<br>对于<strong>普通SELECT语句</strong>，<strong>InnoDB不会加任何锁</strong>；  </p><p>可以通过以下语句<strong>显式</strong>给记录集加<strong>共享锁或者排它锁</strong>：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#共享锁（S）</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ...... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#排它锁（X）</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ....... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure><h3 id="案例准备工作"><a href="#案例准备工作" class="headerlink" title="案例准备工作"></a>案例准备工作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_innodb_lock(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>),</span><br><span class="line">  sex <span class="built_in">varchar</span>(<span class="number">1</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">#插入基础数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建单列索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_test_innodb_lock_id <span class="keyword">on</span> test_innodb_lock(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_test_innodb_lock_name <span class="keyword">on</span> test_innodb_lock(<span class="keyword">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><h3 id="行锁基本演示"><a href="#行锁基本演示" class="headerlink" title="行锁基本演示"></a>行锁基本演示</h3><table>  <tr>    <th>Session-1</th>    <th>Session-2</th>  </tr>  <tr>    <td>关闭自动提交功能（set autocommit=0;）</td>    <td>关闭自动提交功能（set autocommit=0;）</td>  </tr>  <tr>    <td>可以正常的查询出全部的数据（select * from test_innodb_lock;）</td>    <td>可以正常的查询出全部的数据（select * from test_innodb_lock;）</td>  </tr>  <tr>    <td>查询id为3的数据；（select * from test_innodb_lock where id=3;）</td>    <td>查询id为3的数据；（select * from test_innodb_lock where id=3;）</td>  </tr>   <tr>    <td>更新id为3的数据，但是不提交（update test_innodb_lock set name='AI' where id=3;）</td>    <td>更新id为3的数据，在Session-1的更新提交完成之前一直处于等待状态；（update test_innodb_lock set name='AII' where id=3;）</td>  </tr><tr>    <td>通过commit，提交事务（commit;）</td>    <td>接触阻塞，更新正常进行（update test_innodb_lock set name='AII' where id=3;）</td>  </tr>  <tr>    <td colspan="2">以上，操作的都是同一行的数据，接下来，演示不同行的数据；</td>  </tr>  <tr>    <td>更新id为3的数据，正常的获取到行锁，执行更新；(update test_innodb_lock set name='a1' where id =3;)</td>    <td>由于与Session-1操作不是同一行，获取当前行锁，执行更新；（update test_innodb_lock set name ="C1" where id=5;）</td>  </tr></table><h2 id="锁-InnoDB行锁-行锁升级为表锁"><a href="#锁-InnoDB行锁-行锁升级为表锁" class="headerlink" title="锁 - InnoDB行锁 - 行锁升级为表锁"></a>锁 - InnoDB行锁 - 行锁升级为表锁</h2><p>如果不通过索引条件检索数据，那么innodb将对表中的所有记录加锁，实际效果跟表锁一样。  </p><p>查看当前表的索引：show index from test_innodb_lock;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> test_innodb_lock\G;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Session-1</th>    <th>Session-2</th>  </tr>  <tr>    <td>关闭事务的自动提交（set autocommit=0;）</td>    <td>关闭事务的自动提交（set autocommit=0;）</td>  </tr>  <tr>    <td>执行更新语句（update test_innodb_lock set sex='2' where <span style="color:red;font-weight:bolder;">name=400</span>; ）</td>    <td>执行更新语句，但是出于阻塞状态（update test_innodb_lock set sex='2' where id=9;）</td>  </tr>   <tr>    <td>提交事务（commit;）</td>    <td>解除阻塞，执行更新成功（update test_innodb_lock set sex='2' where id=9;）</td>  </tr>  <tr>    <td></td>    <td>执行提交操作（commit;）</td>  </tr></table><p>由于执行更新时，name字段本来为varchar类型，但是Session-1当中name作为数字类型来使用，所以存在类型转换，索引失效，最终行锁变为表锁；  </p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> test_innodb_lock;<span class="meta">#查看表结构</span></span><br></pre></td></tr></table></figure><p>索引失效：name字段本来的类型为varcahr类型；如果是varchar类型但是在使用的时候，没有给其name字段的取值加上单引号，那么这个时候索引就将失效；索引失效，行锁升级为表锁；</p><h2 id="锁-InnoDB行锁-间隙锁危害"><a href="#锁-InnoDB行锁-间隙锁危害" class="headerlink" title="锁 - InnoDB行锁 - 间隙锁危害"></a>锁 - InnoDB行锁 - 间隙锁危害</h2><p>当用 <strong>范围条件</strong>，而不是使用相等条件检索数据，并请求共享或者排它锁的时候，InnoDB会给符合条件的已有数据进行加锁；<br>对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁）；  </p><p>ID &lt; 10 ：  </p><ul><li>1,2,3,4,5,6,7,8,9</li><li>1,2,3,4,6,9(此时当中的5 和 7、8 则称之为间隙)</li></ul><p>示例：  </p><table>  <tr>    <th>Session-1</th>    <th>Session-2</th>  </tr>  <tr>    <td>关闭事务自动提交（set autocommit=0;）</td>    <td>关闭事务自动提交（set autocommit=0;）</td>  </tr>  <tr>    <td>根据id范围更新数据（update test_innodb_lock set name='332423' where id < 4 ;）</td>    <td>插入id为2的记录，处于阻塞状态（insert into test_innodb_lock values(2,'1001','1'); ）</td>  </tr>    <tr>    <td>提交事务（commit;）</td>    <td>解除阻塞，执行插入操作（insert into test_innodb_lock values(2,'1001','1'); ）</td>  </tr>   <tr>    <td></td>    <td>提交事务（commit;）</td>  </tr></table><h2 id="锁-InnoDB行锁-争用情况查看"><a href="#锁-InnoDB行锁-争用情况查看" class="headerlink" title="锁 - InnoDB行锁 - 争用情况查看"></a>锁 - InnoDB行锁 - 争用情况查看</h2><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">show status like <span class="string">'innodb_row_lock%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#Innodb_row_lock_current_waits: 当前正在等待锁定的数量；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#Innodb_row_lock_time： 从系统启动到现在锁定总时间长度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#Innodb_row_lock_time_avg: 每次等待所花平均时长</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#Innodb_row_lock_time_max: 从系统启动到现在等待最长的一次所花时间</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#Innodb_row_lock_waits： 系统启动后到现在总共等待的次数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#当等待的次数很高，而且每次等待的时长也不小的时候，就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</span></span><br></pre></td></tr></table></figure><h2 id="锁-InnoDB行锁-总结"><a href="#锁-InnoDB行锁-总结" class="headerlink" title="锁 - InnoDB行锁 - 总结"></a>锁 - InnoDB行锁 - 总结</h2><p><strong>Innodb存储引擎</strong> 由于实现了 <strong>行级锁定</strong> ，<br>虽然在 <strong>锁定机制</strong> 的实现方面带来了 <strong>性能损耗</strong> 可能比表锁会更高一些，<br>但是在 <strong>整体并发处理能力方面</strong>要远远 <strong>优于</strong> <strong>MyISAM的表锁</strong> 的。  </p><p>当 <strong>系统并发量较高</strong> 的时候，<strong>InnoDB的整体性能</strong> 和 <strong>MyISAM</strong> 相比就会有比较<strong>明显的优势</strong>。  </p><p>但是，<strong>InnoDB的行级锁</strong> 同样也有其脆弱的一面，但<strong>使用不当</strong>的时候，可能会让<strong>InnoDB的整体性能</strong>不仅<strong>不能比MyISAM高</strong>，甚至<strong>可能</strong>会<strong>更差</strong>。  </p><p><strong>优化建议</strong>：  </p><ul><li>尽可能让所有 <strong>数据检索</strong> 都能通过 <strong>索引</strong> 来完成，<strong>避免 无索引 行锁</strong> <strong>升级</strong>为<strong>表锁</strong></li><li><strong>合理设计索引</strong>，尽量 <strong>缩小锁的范围</strong></li><li>尽可能<strong>减少索引条件</strong>，以及<strong>索引范围</strong>，<strong>避免间隙锁</strong></li><li>尽量<strong>控制事务大小</strong>，<strong>减少锁定资源量和时间长度</strong></li><li>尽可能使用<strong>低级别事务隔离</strong>（前提：但是需要<strong>业务层面满足需求</strong>）</li></ul><h2 id="SQL技巧-SQL执行顺序及正则表达式"><a href="#SQL技巧-SQL执行顺序及正则表达式" class="headerlink" title="SQL技巧 - SQL执行顺序及正则表达式"></a>SQL技巧 - SQL执行顺序及正则表达式</h2><h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><p>编写顺序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">  &lt;<span class="keyword">select</span> <span class="keyword">list</span>&gt;</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  &lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">  &lt;right_table&gt; <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">  &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">  &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">  &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span></span><br><span class="line">  &lt;limit_params&gt;</span><br></pre></td></tr></table></figure><p>执行顺序  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;left_table&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line"></span><br><span class="line">&lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> &lt;<span class="keyword">select</span> list&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_params&gt;</span><br></pre></td></tr></table></figure><h3 id="正则表达式使用"><a href="#正则表达式使用" class="headerlink" title="正则表达式使用"></a>正则表达式使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_book;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式 regexp</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_book <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'^j'</span>;<span class="comment">#查询name字段取值以 “j” 字符开头的记录行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_book <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'S$'</span>;<span class="comment">#查询name字段取值以 “S” 字符结尾的记录行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_book <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'[uvw]'</span>;<span class="comment">#查询name字段取值包含 “u”、“v”、“w” 字符的记录行</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>符号</th>    <th>含义</th>  </tr>  <tr>    <td>^</td>    <td>在字符串开始处进行匹配</td>  </tr>    <tr>    <td>$</td>    <td>在字符串末尾处进行匹配</td>  </tr>    <tr>    <td>.</td>    <td>匹配任意单个字符，包括换行符</td>  </tr>  <tr>    <td>[...]</td>    <td>匹配出括号内的任意字符</td>  </tr>  <tr>    <td>[^...]</td>    <td>匹配不出括号内的任意字符</td>  </tr>  <tr>    <td>a*</td>    <td>匹配零个或者多个a（包括空串）</td>  </tr>  <tr>    <td>a+</td>    <td>匹配一个或者多个a（不包括空串）</td>  </tr>  <tr>    <td>a?</td>    <td>匹配零个或者一个a</td>  </tr>    <tr>    <td>a1|a2</td>    <td>匹配a1或者a2</td>  </tr>    <tr>    <td>a(m)</td>    <td>匹配m个a</td>  </tr>      <tr>    <td>a(m,)</td>    <td>至少匹配m个a</td>  </tr>      <tr>    <td>a(m,n)</td>    <td>匹配m个a 到n个a</td>  </tr>      <tr>    <td>a(,n)</td>    <td>匹配0到n个a</td>  </tr>      <tr>    <td>(...)</td>    <td>将模式元素组成单一元素</td>  </tr></table><h2 id="SQL技巧-数字函数与字符串函数"><a href="#SQL技巧-数字函数与字符串函数" class="headerlink" title="SQL技巧 - 数字函数与字符串函数"></a>SQL技巧 - 数字函数与字符串函数</h2><h3 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h3><table>  <tr>    <th>函数名称</th>    <th>作用</th>  </tr>  <tr>    <td>ABS</td>    <td>求绝对值</td>  </tr>    <tr>    <td>SQRT</td>    <td>求二次方根</td>  </tr>    <tr>    <td>MOD</td>    <td>求余数</td>  </tr>    <tr>    <td>CEIL和CEILING</td>    <td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td>  </tr>  <tr>    <td>FLOOR</td>    <td>向下取整，返回值转化为一个BIGINT</td>  </tr>  <tr>    <td>RAND</td>    <td>生成一个0-1之间的随机数，传入整数参数是，用来产生重复序列</td>  </tr>  <tr>    <td>ROUND</td>    <td>对所传入参数进行四舍五入</td>  </tr>    <tr>    <td>SIGN</td>    <td>返回参数的符号</td>  </tr>    <tr>    <td>POW和POWER</td>    <td>两个函数的功能相同，都是所传参数的次方的结果值</td>  </tr>  <tr>    <td>SIN</td>    <td>求正弦值</td>  </tr>  <tr>    <td>COS</td>    <td>求余弦值</td>  </tr>  <tr>    <td>ACOS</td>    <td>求反余弦值，与函数COS互为反函数</td>  </tr>    <tr>    <td>TAN</td>    <td>求正切值</td>  </tr>  <tr>    <td>ATAN</td>    <td>求反正切值，与函数TAN互为反函数</td>  </tr>  <tr>    <td>COT</td>    <td>求余切值</td>  </tr></table><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table>  <tr>    <th>函数名称</th>    <th>作用</th>  </tr>  <tr>    <td>LENGTH</td>    <td>计算字符串长度函数，返回字符串的字节长度</td>  </tr>    <tr>    <td>CONCAT</td>    <td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使用一个或者多个</td>  </tr>    <tr>    <td>INSERT</td>    <td>替换字符串函数</td>  </tr>    <tr>    <td>LOWER</td>    <td>将字符串中的字母转换为小写</td>  </tr>    <tr>    <td>UPPER</td>    <td>将字符串中的字母转换为大写</td>  </tr>    <tr>    <td>LEFT</td>    <td>从左侧截取字符串，返回字符串左边的若干个字符</td>  </tr>    <tr>    <td>RIGTH</td>    <td>从右侧截取字符串，返回字符串右边的若干个字符</td>  </tr>    <tr>    <td>TRIM</td>    <td>删除字符串左右两侧的空格</td>  </tr>    <tr>    <td>REPLACE</td>    <td>字符串替换函数，返回替换后的新字符串</td>  </tr>    <tr>    <td>SUBSTRING</td>    <td>截取字符串，返回从指定位置开始的指定长度的字符串</td>  </tr>    <tr>    <td>REVERSE</td>    <td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td>  </tr></table><h2 id="SQL技巧-日期函数与聚合函数"><a href="#SQL技巧-日期函数与聚合函数" class="headerlink" title="SQL技巧 - 日期函数与聚合函数"></a>SQL技巧 - 日期函数与聚合函数</h2><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table>  <tr>    <th>函数名称</th>    <th>作用</th>  </tr>  <tr>    <td>CURDATE和CURRENT_DATE</td>    <td>两个函数作用相同，返回当前系统的日期值</td>  </tr>  <tr>    <td>CURTIME和CURRENT_TIME</td>    <td>两个函数作用相同，返回当前系统的时间值</td>  </tr>  <tr>    <td>NOW和SYSDATE</td>    <td>两个函数作用相同，返回当前系统的日期和时间值</td>  </tr>  <tr>    <td>MONTH</td>    <td>获取指定日期中的月份</td>  </tr>  <tr>    <td>MONTHNAME</td>    <td>获取指定日期中的月份英文名称</td>  </tr>  <tr>    <td>DAYNAE</td>    <td>获取指定日期对应的星期几的英文名称</td>  </tr>  <tr>    <td>DAYOFWEEK</td>    <td>获取指定日期对应的一周的索引位置值</td>  </tr>  <tr>    <td>WEEK</td>    <td>获取指定日期是一年中的第几周，返回值的范围是否为0~52或者1~53</td>  </tr>  <tr>    <td>DAYOFYEAR</td>    <td>获取指定日期是一年中的第几天，返回值范围是1~366</td>  </tr>  <tr>    <td>DAYOFMONTH</td>    <td>获取指定日期是一个月中的第几天，返回值是1~31</td>  </tr>  <tr>    <td>YEAR</td>    <td>获取年份，返回值范围是1970~2069</td>  </tr>  <tr>    <td>TIME_TO_SEC</td>    <td>将时间参数转换为秒数</td>  </tr>  <tr>    <td>SEC_TO_TIME</td>    <td>将秒数转换为时间，与TIME_TO_SEC互为反函数</td>  </tr>  <tr>    <td>DATE_ADD和ADDDATE</td>    <td>两个函数功能相同，都是向日期添加指定的时间间隔</td>  </tr>  <tr>    <td>DATE_SUB和SUBDATE</td>    <td>两个函数功能相同，都是向日期减去指定的时间间隔</td>  </tr>  <tr>    <td>ADDTIME</td>    <td>时间加法运算，在原始时间上添加指定的时间</td>  </tr>  <tr>    <td>SUBTIME</td>    <td>时间减法运算，在原始时间上减去指定时间</td>  </tr>  <tr>    <td>DATEDIFF</td>    <td>获取两个日期之间间隔，返回参数1减去参数2的值</td>  </tr>  <tr>    <td>DATE_FORMAT</td>    <td>格式化指定的日期，根据参数返回指定格式的值</td>  </tr>  <tr>    <td>WEEKDAY</td>    <td>获取指定日期在一周内的对应的工作日索引</td>  </tr></table><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><table>  <tr>    <th>函数名称</th>    <th>作用</th>  </tr>  <tr>    <td style="color:red;font-weight:bolder;">MAX</td>    <td>查询 <span style="color:red;font-weight:bolder;">指定列的最大值</span></td>  </tr>  <tr>    <td style="color:red;font-weight:bolder;">MIN</td>    <td>查询 <span style="color:red;font-weight:bolder;">指定列的最小值</span></td>  </tr>  <tr>    <td style="color:red;font-weight:bolder;">COUNT</td>    <td><span style="color:red;font-weight:bolder;">统计查询结果的行数</span></td>  </tr>  <tr>    <td style="color:red;font-weight:bolder;">SUM</td>    <td>求和，返回 <span style="color:red;font-weight:bolder;">指定列的总和</span></td>  </tr>  <tr>    <td style="color:red;font-weight:bolder;">AVG</td>    <td>求平均值，返回 <span style="color:red;font-weight:bolder;">指定列数据的平均值</span></td>  </tr></table><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><h2 id="常用工具-mysql"><a href="#常用工具-mysql" class="headerlink" title="常用工具 - mysql"></a>常用工具 - mysql</h2><h2 id="常用工具-mysqladmin"><a href="#常用工具-mysqladmin" class="headerlink" title="常用工具 - mysqladmin"></a>常用工具 - mysqladmin</h2><h2 id="常用工具-mysqlbinlog与mysqldump"><a href="#常用工具-mysqlbinlog与mysqldump" class="headerlink" title="常用工具 - mysqlbinlog与mysqldump"></a>常用工具 - mysqlbinlog与mysqldump</h2><h2 id="常用工具-mysqlimport与source"><a href="#常用工具-mysqlimport与source" class="headerlink" title="常用工具 - mysqlimport与source"></a>常用工具 - mysqlimport与source</h2><h2 id="常用工具-mysqlshow"><a href="#常用工具-mysqlshow" class="headerlink" title="常用工具 - mysqlshow"></a>常用工具 - mysqlshow</h2><h2 id="日志-错误日志"><a href="#日志-错误日志" class="headerlink" title="日志 - 错误日志"></a>日志 - 错误日志</h2><h2 id="日志-二进制日志（statement）"><a href="#日志-二进制日志（statement）" class="headerlink" title="日志 - 二进制日志（statement）"></a>日志 - 二进制日志（statement）</h2><h2 id="日志-二进制日志（row及日志删除）"><a href="#日志-二进制日志（row及日志删除）" class="headerlink" title="日志 - 二进制日志（row及日志删除）"></a>日志 - 二进制日志（row及日志删除）</h2><h2 id="日志-查询日志"><a href="#日志-查询日志" class="headerlink" title="日志 - 查询日志"></a>日志 - 查询日志</h2><h2 id="日志-慢查询日志"><a href="#日志-慢查询日志" class="headerlink" title="日志 - 慢查询日志"></a>日志 - 慢查询日志</h2><h2 id="复制-原理"><a href="#复制-原理" class="headerlink" title="复制 - 原理"></a>复制 - 原理</h2><h2 id="案例-需求及环境准备"><a href="#案例-需求及环境准备" class="headerlink" title="案例 - 需求及环境准备"></a>案例 - 需求及环境准备</h2><h2 id="案例-基本工程导入"><a href="#案例-基本工程导入" class="headerlink" title="案例 - 基本工程导入"></a>案例 - 基本工程导入</h2><h2 id="案例-AOP记录日志"><a href="#案例-AOP记录日志" class="headerlink" title="案例 - AOP记录日志"></a>案例 - AOP记录日志</h2><h2 id="案例-日志查询后端-mapper接口"><a href="#案例-日志查询后端-mapper接口" class="headerlink" title="案例 - 日志查询后端 - mapper接口"></a>案例 - 日志查询后端 - mapper接口</h2><h2 id="案例-日志查询后端-Service-amp-Controller"><a href="#案例-日志查询后端-Service-amp-Controller" class="headerlink" title="案例 - 日志查询后端 - Service&amp;Controller"></a>案例 - 日志查询后端 - Service&amp;Controller</h2><h2 id="案例-日志查询-前端"><a href="#案例-日志查询-前端" class="headerlink" title="案例 - 日志查询 - 前端"></a>案例 - 日志查询 - 前端</h2><h2 id="案例-系统性能优化分析"><a href="#案例-系统性能优化分析" class="headerlink" title="案例 - 系统性能优化分析"></a>案例 - 系统性能优化分析</h2><h2 id="案例-系统性能优化-分页优化"><a href="#案例-系统性能优化-分页优化" class="headerlink" title="案例 - 系统性能优化 - 分页优化"></a>案例 - 系统性能优化 - 分页优化</h2><h2 id="案例-系统性能优化-索引优化"><a href="#案例-系统性能优化-索引优化" class="headerlink" title="案例 - 系统性能优化 - 索引优化"></a>案例 - 系统性能优化 - 索引优化</h2><h2 id="案例-系统性能优化-读写分离概述"><a href="#案例-系统性能优化-读写分离概述" class="headerlink" title="案例 - 系统性能优化 - 读写分离概述"></a>案例 - 系统性能优化 - 读写分离概述</h2><h2 id="案例-系统性能优化-数据源配置"><a href="#案例-系统性能优化-数据源配置" class="headerlink" title="案例 - 系统性能优化 - 数据源配置"></a>案例 - 系统性能优化 - 数据源配置</h2><h2 id="案例-系统性能优化-AOP切换数据源"><a href="#案例-系统性能优化-AOP切换数据源" class="headerlink" title="案例 - 系统性能优化 - AOP切换数据源"></a>案例 - 系统性能优化 - AOP切换数据源</h2><h2 id="案例-系统性能优化-AOP切换数据源-测试"><a href="#案例-系统性能优化-AOP切换数据源-测试" class="headerlink" title="案例 - 系统性能优化 - AOP切换数据源 - 测试"></a>案例 - 系统性能优化 - AOP切换数据源 - 测试</h2><h2 id="案例-系统性能优化-AOP切换数据源-原理解析"><a href="#案例-系统性能优化-AOP切换数据源-原理解析" class="headerlink" title="案例 - 系统性能优化 - AOP切换数据源 - 原理解析"></a>案例 - 系统性能优化 - AOP切换数据源 - 原理解析</h2><h2 id="案例-系统性能优化-应用优化"><a href="#案例-系统性能优化-应用优化" class="headerlink" title="案例 - 系统性能优化 - 应用优化"></a>案例 - 系统性能优化 - 应用优化</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看笔记：&lt;code&gt;https://www.bilibili.com/video/BV1fJ41127Rj?from=search&amp;amp
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="MySQL" scheme="https://fengshana.github.io/tags/MySQL/"/>
    
      <category term="数据库优化" scheme="https://fengshana.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>全面深入讲解MySQL数据库优化02</title>
    <link href="https://fengshana.github.io/2020/05/29/%E3%80%90MYSQL%E3%80%91/%E3%80%90MYSQL%E3%80%91%E5%85%A8%E9%9D%A2%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%9602/"/>
    <id>https://fengshana.github.io/2020/05/29/%E3%80%90MYSQL%E3%80%91/%E3%80%90MYSQL%E3%80%91%E5%85%A8%E9%9D%A2%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%9602/</id>
    <published>2020-05-29T11:23:12.998Z</published>
    <updated>2020-06-05T17:55:53.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：<code>https://www.bilibili.com/video/BV1fJ41127Rj?from=search&amp;seid=13531213796559959972</code>  </p><p>本课程作为MySQL高级课程，主要讲解了：  </p><ul><li><strong>MySQL</strong>中的<strong>视图</strong>/<strong>存储过程</strong>/<strong>触发器</strong>/<strong>索引</strong>等对象的使用</li><li>常见的<strong>SQL</strong>语句<strong>优化</strong>的技巧</li><li><strong>应用优化</strong></li><li><strong>数据库优化</strong></li><li><strong>数据库日志</strong></li></ul><p>等方面的知识，并通过综合案例，对课程中的知识进行一个整合应用。  </p><p>本课程旨在通过MySQl高级部分内容，可以在满足现有业务需求基础上，对<strong>MySQL底层的体系结构</strong>，及<strong>底层的优化</strong>有一个深入的理解，对<strong>系统的整体性能</strong>进行提升。  </p><h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><blockquote><p>Mysql高级-day02</p></blockquote><p>1） MySql的体系结构概览（MySQL内部原理，内部执行流程有一个认识）<br>2） <strong>存储引擎</strong>（InnoDB以及MyISAM）<br>3） <strong>优化SQL</strong>步骤（从哪些方面以及参考指标）<br>4） <strong>索引的使用</strong>（在<strong>SQL优化</strong>中如何使用）<br>5） <strong>SQL优化</strong>  </p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="MySQL的体系结构概览"><a href="#MySQL的体系结构概览" class="headerlink" title="MySQL的体系结构概览"></a>MySQL的体系结构概览</h3><p><strong>MySQL的体系结构</strong>图和在进行<strong>Web开发的三层架构</strong>是相类似的；  </p><p><strong>Web开发时的三层架构</strong>：<br><strong>（1）</strong> 前端发起请求先到达controller；<br><strong>（2）</strong> controller调service；service调用dao;<br><strong>（3）</strong> dao再去访问数据库；  </p><p>mysql的体系结构当中，首先最上面的部分<strong>Connectors</strong>实际上代表的就相当于是<strong>客户端</strong>；<br>在客户端连接当中Natice C API，JDBC，ODBC,.NET，PHP,Perl，Python，Ruby，Cobol这些个；<br>JDBC就很熟悉了；在Java程序当中可以通过JDBC来进行操作mysql；<br>所以最上面部分即mysql连接的客户端通过JDBC来进行操作；<br>然后紧接着中层即MySQL Server；  </p><p>MySQL Server当中最上面一层即<strong>Connection Pool连接池</strong>；<br>在连接池当中有很多的组件模块Authentication、Thread Reuse、Connection Limits、Check Memory、Caches；<br>也就是客户端发起一个连接；<br>这个连接就会到<strong>MySQL Server的这个Connection Pool连接池当中</strong>来进行<strong>获取一个连接 来 执行 对应的请求</strong>；<br>当然，在MySQL Server的Connection Pool进行获取连接的时候还需要进行认证、连接最大数、缓存等相关操作；<br>此为MySQL Server的第一层连接层；<br>连接层主要负责的就是客户端发起一个请求，<br>MySQL Server接收到这个请求之后，开启一段线程进行与客户端请求相关的操作；<br>这是连接层；  </p><p>MySQL Server当中的第二层即Management Services &amp; Utillties、SQL Interface、Parser、Optimizer、Caches &amp; Buffers 这一部分；<br>MySQL Server第二层当中有很多的组件；<br>其中第一个（第一个模块）即MySQL的管理服务以及一些工具；管理层Management Services当中可以进行数据的备份与恢复以及集群安全以及系统配置相关的内容（Backup &amp; Recovery，Security，Replication，Cluster，Administrator，Configuration，Migration &amp; Metadata）<br>第二层的第二个模块：SQL Interface即SQL的一个接口，在此当中可以去进行执行或者是去封装DML、DDL语句以及存储过程、存储函数、视图、触发器等等相关数据库对象（DML、DDL、Stored Procedures，Views ，Triggers ，etc.）</p><p>第二层的第三个模块即：Parser，Parser就是一个解析器，这个解析器解析的是客户端发起的一个请求，客户端发起的这个请求就是SQL语句，SQL语句需要经过这个解析器Parser的解析，解析之后并且在这一块进行相关的过滤（Query Translation,Object Privilege）  </p><p>解析完成之后，在MySQL的内部还需要几个过程；<br>第二层的第四个模块：Optimizer，这个过程实际上称作优化器；即在解析完成了前端请求过来的SQL语句并进行相关的过滤之后，MySQL内部还须要通过其内部的一个优化器，对前端请求来的SQL语句解析并过滤后进行一个优化处理；MySQL内部会按照其内部自己的一个优化体系来进行优化（Access Paths，Statistics）  </p><p>当优化完成之后，接下来还需要进行缓存的一个操作：<br>第二程的第五个模块：Caches &amp; Buffers，即查询在缓存当中有没有要查询的数据；如果存在有对应的树据信息，那么这个时候可能就直接返回给前端客户端了；（Global and Engine ，Specific Caches &amp; Buffers）  </p><p>所以第二层当中的这五个模块就是MySQL的服务层操作；即将前端请求的SQL语句进行封装起来并且进行解析以及相关过滤，以及对其进行优化，最终还需要操作MySQL当中的缓存区的信息；  </p><p>MySQL Server的第三层：Pluggable Storage Engines(Memory，Index &amp; Storage Management)，此处实际指的是存储引擎；<br>Pluggable插件式的存储引擎；<br>以下是MySQL当中的存储引擎:<br>（MyISAM、InnoDB、NDB、Archive、Federated、Memory、Merge、Partner、Community、Custom ….）<br>MySQL版本5.5之后默认的存储引擎即为InnoDB；<br>引擎：发动机；<br>存储引擎是什么？（与飞机上的引擎比较类似，比如客机则有客机的引擎，客机即运送乘客、旅客；但是还有对应的货机，那么货机即对应的即运输货物的；还有直升机等等；不同的飞机有不同的飞机引擎；不同的飞机引擎在相对应的机型当中都发挥着不同的作用；在操作的时候需要考虑到，用户是什么，然后去考虑更适合哪一种引擎，对应的发动机；同样对于mysql的存储引擎是一个道理；存储引擎则需要根据存储的数据不同或者是需求不同而选择不同的存储引擎来进行存储不同的数据；）<br>MySQL Server的第三层为存储引擎层；  </p><p>MySQL Server的第四层即存储层：File system（NTFS，ufs，ext2/3，NFS，SAN，NAS）<br>Files &amp; Logs（Redo，Undo，Data，Index，Binary，Error，Query and Slow）<br>在操作MySQL数据库中表当中的数据的时候，不管是插入还是查询或者修改删除等操作；实际上最终都是操作的File system即文件系统；最终操作的都是文件系统当中的文件；而这个文件系统即就处于磁盘当中；所以最下面一层就文件系统；最重要操作的也就是文件系统；除了在表结构当中的数据，还有对应的索引信息、二进制错误、查询、慢查询日志等；  </p><p>此为MySQL体系结构当中的四层；  </p><p>第一层连接层；负责接收客户端的发送的请求；然后MySQL Server开启一段线程进行相关的认证授权之后再来进行请求的处理；<br>第二层服务层：服务层在主要起到备份恢复、SQL封装、解析过滤、SQL语句优化、缓存查询等相关操作；<br>第三层存储引擎层，选择合适的存储引擎对相关数据进行相关的处理；<br>第四层文件系统：当第三层的数据进行相关的处理完成之后，则需要将数据最终写入文件系统当中，即实际的物理磁盘当中；</p><p>整个MySQL由以下组成：  </p><ul><li>Connection Pool：连接池组件</li><li>Management Service &amp; Utillties: 管理服务和工具组件</li><li>SQL Interface: SQL接口组件</li><li>Parser: 查询分析器组件</li><li>Optimizer: 优化器组件</li><li>Caches &amp; Buffers: 缓冲池组件</li><li>Pluggable Storage Engines: 存储引擎</li><li>File System: 文件系统</li></ul><ol><li>连接层<br>最上层是一些客户和连接服务，包含本地socket通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。<br>主要完成一些类似于连接处理、授权认证、以及相关的安全方案。<br>在该层上引入了线程池的概念，未通过认证安全接入的客户端提供线程。<br>同样在该层上可以实现基于SSL的安全连接，服务器也会为安全接入的每个客户端验证它所具有的的操作权限；  </li><li>服务层<br>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。<br>所有跨存储引擎的功能也在这一层实现，如过程、函数等。<br>在该层，服务器会解析查询并创建相应的内部解析树，并对其完成响应的优化如确定表的查询顺序，是否利用索引等，最后生成响应的执行操作。<br>如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。  </li><li>引擎层<br>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。<br>不同的存储引擎具有不同的功能，这样可以根据自己的需要，来选取合适的存储引擎；  </li><li>存储层<br>数据存储层，主要是将数据存储在文件系统之上，并完成与存储引擎的交互；  </li></ol><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。<br>主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。<br>这种架构可以根据业务的需求和实际需要选择合适的存储引擎；  </p><h2 id="存储引擎-概述"><a href="#存储引擎-概述" class="headerlink" title="存储引擎 - 概述"></a>存储引擎 - 概述</h2><p>和大多数的数据库不同，MySQL中有一个存储引擎的概念，针对不同的存储需求可以选择最优的存储引擎；<br>存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式。<br>存储引擎是基于表的，而不是基于库的。<br>索引存储引擎也可被称为表类型。<br>Oracle、SQLServer等数据库只有一种存储引擎。<br>MySQL提供了插件式的存储引擎架构。<br>索引MySQl存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。<br>MySQL5.0支持的存储引擎包含：InnoDB、MyISAM、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供食物安全表，其他存储引擎是非事务安全表；<br>可以通过指定 show engines，来进行查询当前数据库支持的存储引擎；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br></pre></td></tr></table></figure><p>创建新表时，如果不指定存储引擎，那么系统就会使用默认的存储引擎。<br>MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为InnoDB；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p <span class="comment">#连接mysql</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br><span class="line"><span class="comment"># Engine 存储引擎的名字</span></span><br><span class="line"><span class="comment"># Support 是否支持该存储引擎，YES/NO/DEFAULT，DEFAULT默认，默认支持的存储引擎InnoDB</span></span><br><span class="line"><span class="comment"># comment 注释</span></span><br></pre></td></tr></table></figure><blockquote><p>Comment注释</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyISAM : MyISAM <span class="keyword">storage</span> engines</span><br><span class="line">MRG_MYISAM : COLLECTION <span class="keyword">OF</span> IDENTICAL MyISAM <span class="keyword">tables</span></span><br><span class="line">MEMORY : Hash based,stored <span class="keyword">in</span> memory,useful <span class="keyword">for</span> <span class="keyword">temporary</span> <span class="keyword">tables</span></span><br><span class="line">BLACKHOLE : /dev/<span class="keyword">null</span> <span class="keyword">storage</span> engine (anything you wirte <span class="keyword">to</span> it disappears)</span><br><span class="line">CSV : CSV <span class="keyword">storage</span> engine</span><br><span class="line">PERFIRMANCE_SCHEMA : Performance <span class="keyword">Schema</span></span><br><span class="line">ARCHIVE : Archive <span class="keyword">storage</span> engine</span><br><span class="line">FEDERATED ： Federated MySQL <span class="keyword">storage</span> engine</span><br><span class="line">InnoDB ： Support <span class="keyword">transaction</span>,<span class="keyword">row</span>-<span class="keyword">level</span> locking, <span class="keyword">and</span> <span class="keyword">foreign</span> keys # 支持事务，支持行级锁并且支持外键</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看数据库当中的词汇？</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%storage_engine%'</span>;</span><br><span class="line"></span><br><span class="line">default_storage_engine InnoDB</span><br><span class="line">default_tmp_storage_engine InnoDB</span><br><span class="line">storage_engine InnoDB</span><br></pre></td></tr></table></figure><h2 id="存储引擎-特性"><a href="#存储引擎-特性" class="headerlink" title="存储引擎 - 特性"></a>存储引擎 - 特性</h2><p>下面重点介绍几种常用的存储引擎，并对比各个存储引擎之间的区别，如下表所示：  </p><table>    <tr>      <th>特点</th>      <th style="background-color:lightblue;color:red;font-weight:bolder;">InnoDB</th>      <th style="background-color:lightblue;color:red;font-weight:bolder;">MyISAM</th>      <th>MEMORY</th>      <th>MERGE</th>      <th>NDB</th>    </tr>    <tr>      <td>存储限制</td>      <td>64TB</td>      <td>有</td>      <td>有</td>      <td>没有</td>      <td>有</td>    </tr>    <tr>      <td style="background-color:lightblue;color:red;font-weight:bolder;">事务安全</td>      <td>支持</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td style="background-color:lightblue;color:red;font-weight:bolder;">锁机制</td>      <td style="background-color:lightgreen;color:red;font-weight:bolder;">行锁（适合高并发）</td>      <td style="background-color:lightgreen;color:red;font-weight:bolder;">表锁</td>      <td>表锁</td>      <td>表锁</td>      <td>行锁</td>    </tr>    <tr>      <td>B树索引</td>      <td>支持</td>      <td>支持</td>      <td>支持</td>      <td>支持</td>      <td>支持</td>    </tr>    <tr>      <td>哈希索引</td>      <td>（当前我看到的是支持的）</td>      <td></td>      <td>支持</td>      <td></td>      <td></td>    </tr>    <tr>      <td>全文索引</td>      <td>支持（5.6版本之后）</td>      <td>支持</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>集群索引</td>      <td>支持</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>数据索引</td>      <td>支持</td>      <td></td>      <td>支持</td>      <td></td>      <td>支持</td>    </tr>     <tr>      <td>索引缓存</td>      <td>支持</td>      <td>支持</td>      <td>支持</td>      <td>支持</td>      <td>支持</td>    </tr> <tr>      <td>数据可压缩</td>      <td></td>      <td>支持</td>      <td></td>      <td></td>      <td></td>    </tr> <tr>      <td>空间使用</td>      <td>高</td>      <td>低</td>      <td>N/A</td>      <td>低</td>      <td>低</td>    </tr> <tr>      <td>内存使用</td>      <td>高</td>      <td>低</td>      <td>中等</td>      <td>低</td>      <td>高</td>    </tr>     <tr>      <td>批量插入速度</td>      <td>低</td>      <td>高</td>      <td>高</td>      <td>高</td>      <td>高</td>    </tr>     <tr>      <td style="background-color:lightblue;color:red;font-weight:bolder;">支持外键</td>      <td style="background-color:lightgreen;color:red;font-weight:bolder;">支持</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr></table><p>下面将重点介绍最常使用的两种存储引擎：InnoDB、MyISAM，另外两种MEMORY、MERGE，了解即可；  </p><h2 id="存储引擎-InnoDB特性"><a href="#存储引擎-InnoDB特性" class="headerlink" title="存储引擎 - InnoDB特性"></a>存储引擎 - InnoDB特性</h2><p>InnoDB存储引擎是MySQL的默认存储引擎。<br>InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。<br>但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引；  </p><p>InnoDB存储引擎不同于其他存储引擎的特点：  </p><p><strong>事务控制</strong></p><p>MySQL 当中事务默认自动提交；  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create database demo_02<span class="built_in"> default </span><span class="attribute">charset</span>=utf8mb4;  </span><br><span class="line">use demo_01;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table goods_innodb(</span><br><span class="line">  id int(11) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  name varchar(20) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  primary key(id)</span><br><span class="line">)<span class="attribute">ENGINE</span>=innodb<span class="built_in"> default </span><span class="attribute">charset</span>=utf8;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods_innodb(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'Meta20'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;<span class="comment"># 如不提交，则其他客户端无法查看得到插入的数据；</span></span><br><span class="line"><span class="comment"># MySQL默认的隔离级别为可重复读</span></span><br></pre></td></tr></table></figure><p><strong>外键约束</strong></p><p>MySQL支持外键的存储引擎只有InnoDB，在创建外键的时候，要求父表必须有对应的索引，子表在创建索引的时候，也会自动的创建对应的索引；<br>下面两张表中，<br>1） country_innodb是父表，country_id为主键索引；<br>2） city_innodb是子表，country_id字段为外键，对应于country_innodb表中的主键country_id；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> country_innodb(</span><br><span class="line">  country_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  counry_name <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span> ,</span><br><span class="line">  primary <span class="keyword">key</span> (country_id)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> city_innodb(</span><br><span class="line">  city_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  city_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  country_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  primary <span class="keyword">key</span> (city_id),</span><br><span class="line">  <span class="keyword">key</span> idx_fk_country_id(country_id),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">'fk_city_contry'</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(country_id) <span class="keyword">REFERENCES</span> country_innodb(country_id) <span class="keyword">ON</span> DFLETE RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ON DELETE RESTRICT 在删除主表数据时，如果有关联记录则不删除</span></span><br><span class="line"><span class="comment"># ON UPDATE CASCADE 更新主表时，如果子表有关联记录，则更新子表记录  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> country_innodb <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'China'</span>),(<span class="literal">null</span>,<span class="string">'America'</span>),(<span class="literal">null</span>,<span class="string">'Japan'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> city_innodb <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'Xian'</span>,<span class="number">1</span>),(<span class="literal">null</span>,<span class="string">'NewYork'</span>,<span class="number">2</span>),(<span class="literal">null</span>,<span class="string">'BeiJing'</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在创建索引时，可以指定在删除、更新父表时，对子表进行的相应操作，包括RESTRICT、CASCADE、SET NULL和NO ACTION。<br>RESTRICT和NO ACTION相同，是指限制在子表有关联记录的情况下，父表不能更新；<br>CASCADE表示父表在更新或者删除时，更新或者删除子表对应的记录；<br>SET NULL则表示父表在更新或者删除的时候，子表对应字段被SET NULL。<br>针对上面创建的两个表，子表在外键指定是ON DELETE RESTRICT ON UPDATE CASCADE方式的，那么在主表删除记录的时候，如果子表有对应记录，则不允许删除。主表在更新记录的时候，如果子表有对应记录，则子表也会对应更新；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> country_innodb;<span class="comment">#主表</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> city_innodb;<span class="comment">#子表；子表当中的外键country_id指向主表country_innodb当中的主键country_id</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> country_innodb <span class="keyword">where</span> country_id=<span class="number">2</span>;</span><br><span class="line"><span class="comment">#此处由于外键关联，所以导致删除报错，无法更新；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> country_innodb <span class="keyword">set</span> country_id=<span class="number">100</span> <span class="keyword">where</span> country_id=<span class="number">1</span>;</span><br><span class="line"><span class="comment">#此时子表当中关联有1；那么说则刚才的子表当中对应country_id也为1 的记录将会进行相应的更新；  </span></span><br><span class="line">查看主表以及子表：  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> country_innodb;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> city_innodb;</span><br></pre></td></tr></table></figure><p><strong>存储方式</strong></p><p>存储方式实际上指的是InnoDB这个存储引擎对应的表在数据库当中以数据文件的存储方式；<br>InnoDB存储表和索引有以下两种方式：  </p><ol><li>使用共享表空间存储，这种方式创建的表的表结构保存在.frm文件中，数据和索引保存在 innodb_data_home_dir和innodb_data_file_path定义的表空间中，可以是多个文件；  </li><li>使用多表空间存储，这种方式存储的表的表结构仍然存在.frm文件中，但是每个表的数据和索引单独保存在.ibd中；</li></ol><h2 id="存储引擎-MyISAM特性"><a href="#存储引擎-MyISAM特性" class="headerlink" title="存储引擎 - MyISAM特性"></a>存储引擎 - MyISAM特性</h2><p>MyISAM不支持事务，也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表，有以下两个比较重要的特点：  </p><p><strong>不支持事务</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> goods_myisam(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">engine</span>=myisam <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods_myisam <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'电脑3'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><p>通过测试可以发现，在MyISAM存储引擎中，是没有事务控制的；  </p><p><strong>文件存储方式</strong></p><p>每个MyISAM在磁盘上存储成3个文件，其文件名都和表明相同，但拓展名称分别是：</p><ul><li><strong>.frm</strong> (<strong>存储表定义</strong>)</li><li><strong>.MYD</strong> (MYData，<strong>存储数据</strong>)</li><li><strong>.MYI</strong> (MYIndex，<strong>存储索引</strong>)</li></ul><h2 id="存储引擎-Memory与Merge特性"><a href="#存储引擎-Memory与Merge特性" class="headerlink" title="存储引擎 - Memory与Merge特性"></a>存储引擎 - Memory与Merge特性</h2><p>Memory（内存）存储引擎将表的数据放在内存中。<br>每个MEMORY表实际对应一个磁盘文件，格式是.frm，改文件中只存储表的数据结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表达效率。<br>MEMORY类型的表访问非常的快，因为他的数据是存放在内存中的，并且默认使用HASH索引，但是服务一旦关闭，表中的数据就会丢失；  </p><p>MERGE（合并）存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的；  </p><p>对于MERGE类型表的插入操作是通过INSERT_METHOD子句定义插入的表，可以有三个不同的值，使用FIRST或者LAST值使得插入操作被相应的作用在第一或者是最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作；  </p><p>可以对MERGE表进行DROP操作，但是这个操作知识删除MERGE表的定义，对内部的表是没有任何影响的；  </p><p>MERGE存储引擎与view视图有些类似；  </p><p>下面是一个创建和使用MERGE表的示例：<br>1）创建三个测试表 payment_2006、payment_2007、payment_all，其中payment_all是前两个表的MERGE表；</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">create table order_1990(</span><br><span class="line">  order_id int,</span><br><span class="line">  order_money double(10,2),</span><br><span class="line">  order_address varchar(50),</span><br><span class="line">  primary key (order_id)</span><br><span class="line">)<span class="attribute">engine</span>=myisam<span class="built_in"> default </span><span class="attribute">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line">create table order_1991(</span><br><span class="line">  order_id int,</span><br><span class="line">  order_money double(10,2),</span><br><span class="line">  order_address varchar(50),</span><br><span class="line">  primary key (order_id)</span><br><span class="line">)<span class="attribute">engine</span>=myisam<span class="built_in"> default </span><span class="attribute">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line">create table order_all(</span><br><span class="line">  order_id int,</span><br><span class="line">  order_money double(10,2),</span><br><span class="line">  order_address varchar(50),</span><br><span class="line">  primary key (order_id)</span><br><span class="line">)<span class="attribute">engine</span>=merge  </span><br><span class="line">union = ( order_1990, order_1991 )  </span><br><span class="line"><span class="attribute">INSERT_METHOD</span>=LAST  </span><br><span class="line">default <span class="attribute">charset</span>=utf8;</span><br></pre></td></tr></table></figure><p>2） 分别向两张表中插入记录  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1990 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">100.0</span>,<span class="string">'上海'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1990 <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">100.0</span>,<span class="string">'北京'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1991 <span class="keyword">values</span>(<span class="number">10</span>,<span class="number">100.0</span>,<span class="string">'北京'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1991 <span class="keyword">values</span>(<span class="number">11</span>,<span class="number">100.0</span>,<span class="string">'上海'</span>);</span><br></pre></td></tr></table></figure><p>3） 查询三张表当中的数据：<br>order_1990表中的数据：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> order_1990;</span><br></pre></td></tr></table></figure><p>order_1991表中的数据：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> order_1991;</span><br></pre></td></tr></table></figure><p>order_all表中的数据：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> order_all;</span><br></pre></td></tr></table></figure><h2 id="存储引擎-选择原则"><a href="#存储引擎-选择原则" class="headerlink" title="存储引擎 - 选择原则"></a>存储引擎 - 选择原则</h2><p>在选择存储引擎时，应该选择根据应用系统的特点选择合适的存储引擎。<br>对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合；<br>以下是几种常用的存储引擎的使用环境：  </p><ul><li>InnoDB<ul><li>是MySQL的默认存储引擎，用于事务处理应用程序，支持外键。</li><li>如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。  </li><li>InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定，还可以确保事务的完整提交和回滚，对于类似于计费系统或者是财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择；  </li></ul></li><li>MyISAM<ul><li>如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的；  </li></ul></li><li>MEMORY<ul><li>将所有的数据保存在内存当中RAM，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。</li><li>MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。  </li><li>MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。  </li></ul></li><li>MERGE<ul><li>用于将一些列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。</li><li>MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率，这对于存储诸如数据仓库等VLDB环境十分合适。  </li></ul></li></ul><p>有一个点：就是有没有类似emm，MERGE然后内部基层的表的存储引擎是InnoDB这种的；如果是这种的话；不是有那个什么分库分表什么的？（我不太了解分库分表，乱说的）  </p><h2 id="优化SQL步骤-SQL执行频率"><a href="#优化SQL步骤-SQL执行频率" class="headerlink" title="优化SQL步骤 - SQL执行频率"></a>优化SQL步骤 - SQL执行频率</h2><p>在应用的开发过程中，由于初期数据量小，开发人员写SQL语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据的急剧增长，很多SQL语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的SQL语句就成为整个系统性能的瓶颈，因此必须要对它们进行优化，本章将详细介绍MySQL中优化SQL语句的方法。  </p><p>当面对一个有SQL性能问题的数据库时，应该从何处入手来进行系统的分析，使得能够尽快定位问题SQL并尽快解决问题。  </p><h3 id="查看SQL执行频率"><a href="#查看SQL执行频率" class="headerlink" title="查看SQL执行频率"></a>查看SQL执行频率</h3><p>MySQL客户端连接成功后，通过 <strong>show [ session | global ] status</strong> 命令可以提供<strong>服务器状态信息</strong>。<br><strong>show [ session | global ] status</strong> 可以根据需要加上参数 <strong>“session”</strong> 或者 <strong>“global”</strong> 来显示 <strong>session级</strong>（当前连接）的统计结果和 <strong>global级</strong>（自数据库上次启动至今）的统计结果。<br>如果不写，<strong>默认使用参数是“session”</strong>。  </p><p>下面的命令显示了当前session中所有统计参数的值：</p><blockquote><p>针对<strong>数据库</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Com_______'</span>; <span class="comment"># _ 占位字符，匹配的模糊字符 查询级别为session会话级别</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Com_______'</span>; <span class="comment"># _ 匹配的模糊字符 查询级别为global全局级别</span></span><br><span class="line"></span><br><span class="line">Com_binlog</span><br><span class="line">Com_commit</span><br><span class="line">Com_delete <span class="comment">#删除的次数</span></span><br><span class="line">Com_insert <span class="comment">#插入的次数</span></span><br><span class="line">Com_repair</span><br><span class="line">Com_select <span class="comment">#查询的次数</span></span><br><span class="line">Com_revoke</span><br><span class="line">Com_signal</span><br><span class="line">Com_update <span class="comment">#修改的次数</span></span><br><span class="line">Com_xa_end</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时查询的为当前连接session的信息，并非为整个数据库全局的统计参数</span></span><br><span class="line"><span class="comment">#如果需要查询全局则：show global status like 'Com_______';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过知道当前数据库当中是以查询为主还是增删改为主；为SQL优化提供借鉴性指标</span></span><br></pre></td></tr></table></figure><p>Com_xxx表示每个xxx语句<strong>执行的次数</strong>，通常比较关心的是以下几个统计参数</p><table>  <tr>    <th>参数</th>    <th>含义</th>  </tr>  <tr>    <td>Com_select</td>    <td>执行select操作的次数，一次查询只累加1</td>  </tr>  <tr>    <td>Com_insert</td>    <td>执行INSERT操作的次数，对于批量插入的INSERT操作，只累加一次</td>  </tr>  <tr>    <td>Com_update</td>    <td>执行UPDATE操作的次数</td>  </tr>  <tr>    <td>Com_delete</td>    <td>执行DELETE操作的次数</td>  </tr>  <tr>    <td>Innodb_rows_read</td>    <td>select查询返回的行数</td>  </tr>  <tr>    <td>Innodb_rows_inserted</td>    <td>执行INSERT操作插入的行数</td>  </tr>  <tr>    <td>Innodb_rows_updated</td>    <td>执行UPDATE操作更新的行数</td>  </tr>  <tr>    <td>Innodb_rows_deleted</td>    <td>执行DELETE操作删除的行数</td>  </tr>  <tr>    <td>Connections</td>    <td>视图连接MySQL服务器的次数</td>  </tr>  <tr>    <td>Uptime</td>    <td>服务器工作时间</td>  </tr>  <tr>    <td>Slow_queries</td>    <td>慢查询的次数</td>  </tr></table><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Com_*** : 这些参数对于所有存储引擎的表操作都会进行累计</span><br><span class="line">Innodb_** : 这几个参数只是针对<span class="type">Innodb</span>存储引擎的，累加的算法也略有不同。</span><br></pre></td></tr></table></figure><blockquote><p>针对<strong>InnoDB存储引擎</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">针对于InnoDB：  </span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Innodb_rows_%'</span>;<span class="comment"># 此时查询出来的为InnoDB的各个操作所影响的行，数量</span></span><br><span class="line"></span><br><span class="line">Innodb_rows_deleted 2 <span class="comment"># 该存储引擎中删去的行数</span></span><br><span class="line">Innodb_rows_inserted 49<span class="comment"># 该存储引擎中插入的行数</span></span><br><span class="line">Innodb_rows_read 380<span class="comment"># 该存储引擎中读取的行数</span></span><br><span class="line">Innodb_rows_updated 15<span class="comment"># 更新的行数</span></span><br><span class="line"></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="keyword">use</span> demo_01l</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> goods_innodb; <span class="comment"># Innodb_rows_read此时会增加，查询出来的结果集有n条记录，则Innodb_rows_read增加n</span></span><br><span class="line"></span><br><span class="line">Innodb_rows_deleted 2 <span class="comment"># 该存储引擎中删去的行数</span></span><br><span class="line">Innodb_rows_inserted 49<span class="comment"># 该存储引擎中插入的行数</span></span><br><span class="line">Innodb_rows_read 382<span class="comment"># 该存储引擎中读取的行数</span></span><br><span class="line">Innodb_rows_updated 15<span class="comment"># 更新的行数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> goods_innodb <span class="keyword">set</span> <span class="keyword">name</span> =<span class="string">'Meta30'</span>; <span class="comment"># Innodb_rows_update此时会增加；修改影响n条记录，则Innodb_rows_update增加n;</span></span><br><span class="line"></span><br><span class="line">Innodb_rows_deleted 2 <span class="comment"># 该存储引擎中删去的行数</span></span><br><span class="line">Innodb_rows_inserted 49<span class="comment"># 该存储引擎中插入的行数</span></span><br><span class="line">Innodb_rows_read 382<span class="comment"># 该存储引擎中读取的行数</span></span><br><span class="line">Innodb_rows_updated 17<span class="comment"># 更新的行数</span></span><br></pre></td></tr></table></figure><h2 id="优化SQL步骤-定位低效SQL"><a href="#优化SQL步骤-定位低效SQL" class="headerlink" title="优化SQL步骤 - 定位低效SQL"></a>优化SQL步骤 - 定位低效SQL</h2><p>可以通过以下<strong>两种方式</strong>定位执行效率较低的SQL语句。  </p><ul><li><strong>慢查询日志</strong>：通过慢查询日志定位那些执行效率较低的SQL语句，用 <strong>–log-slow-queries[ =file_name ]</strong> 选项启动时，mysqld写一个包含所有执行时间超过 <strong>long_query_time</strong> 秒的SQL语句的<strong>日志文件</strong>。</li><li><strong>show processlist</strong> ：<strong>慢查询日志</strong>在 查<strong>询结束以后才记录</strong>，所以在应该 用反映执行效率出现问题的时候 查询慢日志 并不能定位问题，可以使用 <strong>show processlist</strong> 命令查看当前MySQL在进行的线程，包括<strong>线程的状态、是否锁表</strong>等，可以<strong>实时地查看SQL的执行情况</strong>，同时<strong>对一些 锁表操作 进行 优化</strong>。(<strong>实时</strong>)  </li></ul><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">show processlist;</span><br><span class="line"></span><br><span class="line"><span class="meta">#（1）id列：用户登录mysql时，系统分配的“connection_id”，可以使用函数connection_id()查看；</span></span><br><span class="line"><span class="meta">#（2）user列：显示当前用户，如果不是root，这个命令就只显示用户权限范围的sql语句；</span></span><br><span class="line"><span class="meta">#（3）host列：显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户；</span></span><br><span class="line"><span class="meta">#（4）db列：显示这个进程目前连接的是哪个数据库；</span></span><br><span class="line"><span class="meta">#（5）command列：显示当前连接的执行命令，一般取值为休眠（sleep）、查询（query）、连接（connect）等；</span></span><br><span class="line"><span class="meta">#（6）time列，显示这个状态持续的时间，单位是秒；</span></span><br><span class="line"><span class="meta">#（7）state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table， sorting result， sending data等状态才可以完成。  </span></span><br><span class="line"><span class="meta">#（8）info列，显示这个sql语句，是判断问题语句的一个重要依据。</span></span><br></pre></td></tr></table></figure><h2 id="优化SQL步骤-explain指令介绍"><a href="#优化SQL步骤-explain指令介绍" class="headerlink" title="优化SQL步骤 - explain指令介绍"></a>优化SQL步骤 - explain指令介绍</h2><p>通过以上步骤查询到效率低的SQL语句后，<br>可以通过 <strong>EXPLAIN</strong> 或者 <strong>DESC</strong> <strong>命令</strong> 获取MySQL如何执行SELECT语句的信息，包括SELECT语句执行过程中表<strong>如何 连接 和 连接 的顺序</strong>。  </p><p>查询SQL语句的执行计划：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_item</td>    <td>const</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>4</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr></table><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="built_in">title</span>=<span class="string">'阿尔卡特（OT-979）冰川白 联通3G手机3'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_item</td>    <td>ALL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>9816098</td>    <td>Using where</td>  </tr></table><table>  <tr>    <th>字段</th>    <th>含义</th>  </tr>  <tr>    <td>id</td>    <td>select查询的序列号，是一组数字，表示的是查询中select子句或者是操作表的顺序。（与表结构执行的顺序有关系）</td>  </tr>  <tr>    <td>select_type</td>    <td>表示SELECT的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者是子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个SELECT）等</td>  </tr>  <tr>    <td>table</td>    <td>输出结果集的表（当前输出的数据与哪一张表有关）</td>  </tr>  <tr>    <td>type</td>    <td>表示表的连接类型，性能由好到差的连接类型为（system---->const---->eq_ref------>ref------->ref_or_null------>index_merge------>index_subquery------->range------>index------>all）</td>  </tr>  <tr>    <td>possible_keys</td>    <td>表示查询时，可能使用的索引。</td>  </tr>  <tr>    <td>key</td>    <td>表示实际使用的索引</td>  </tr>  <tr>    <td>key_len</td>    <td>索引字段的长度</td>  </tr>  <tr>    <td>ref</td>    <td>引用</td>  </tr>  <tr>    <td>rows</td>    <td>扫描行的数量</td>  </tr>  <tr>    <td>extra</td>    <td>执行情况的说明和描述，额外的内容，前面几个字段当中没有表述清楚的，在这个字段当中表述出来</td>  </tr></table><blockquote><p><strong>explain</strong> 用来 <strong>查看 SQL语句 的 执行计划</strong>。</p></blockquote><h2 id="优化SQL步骤-explain之id"><a href="#优化SQL步骤-explain之id" class="headerlink" title="优化SQL步骤 - explain之id"></a>优化SQL步骤 - explain之id</h2><p><strong>环境准备</strong></p><p>用户表、角色表、用户角色表（多对多关系）  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">'t_role'</span>(</span><br><span class="line">  <span class="string">'id'</span> varchar(32) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'role_name'</span> varchar(255)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'role_code'</span> varchar(255)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'description'</span> varchar(255)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">'id'</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">'union_role_name'</span> (<span class="string">'role_name'</span>)</span><br><span class="line">)<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE <span class="string">'t_user'</span>(</span><br><span class="line">  <span class="string">'id'</span> varchar(32) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'username'</span> varchar(45)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'name'</span> varchar(45)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'password'</span> varchar(96)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">'id'</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">'union_user_username'</span> (<span class="string">'user_name'</span>)</span><br><span class="line">)<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE <span class="string">'user_role'</span>(</span><br><span class="line">  <span class="string">'id'</span> int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> autoincrement,</span><br><span class="line">  <span class="string">'user_id'</span> varchar(32)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'role_id'</span> varchar(32)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">'id'</span>),</span><br><span class="line">  KEY <span class="string">'fk_ur_user_id'</span>(<span class="string">'user_id'</span>),</span><br><span class="line">  KEY <span class="string">'fk_ur_role_id'</span>(<span class="string">'role_id'</span>),</span><br><span class="line">  CONSTRAINT <span class="string">'fk_ur_role_id'</span> FOREIGN KEY (<span class="string">'role_id'</span>) REFERENCES <span class="string">'t_role'</span> (<span class="string">'id'</span>) ON DELETE <span class="literal">NO</span> ACTION ON UPDATE <span class="literal">NO</span> ACTION,</span><br><span class="line">  CONSTRAINT <span class="string">'fk_ur_user_id'</span> FOREIGN KEY (<span class="string">'user_id'</span>) REFERENCES <span class="string">'t_user'</span> (<span class="string">'id'</span>) ON DELETE <span class="literal">NO</span> ACTION ON UPDATE <span class="literal">NO</span> ACTION</span><br><span class="line">)<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入用戶数据</span></span><br><span class="line">insert into <span class="string">'t_user'</span>(<span class="string">'id'</span>,<span class="string">'username'</span>,<span class="string">'password'</span>,<span class="string">'name'</span>) values(<span class="string">'1'</span>,<span class="string">'老王'</span>,<span class="string">'xxxxxyyyyyyy'</span>,<span class="string">'超级管理员'</span>);</span><br><span class="line">insert into <span class="string">'t_user'</span>(<span class="string">'id'</span>,<span class="string">'username'</span>,<span class="string">'password'</span>,<span class="string">'name'</span>) values(<span class="string">'2'</span>,<span class="string">'老李'</span>,<span class="string">'xxxxxyyyyyyyzzzzz'</span>,<span class="string">'系统管理员'</span>);</span><br><span class="line">insert into <span class="string">'t_user'</span>(<span class="string">'id'</span>,<span class="string">'username'</span>,<span class="string">'password'</span>,<span class="string">'name'</span>) values(<span class="string">'3'</span>,<span class="string">'老头子'</span>,<span class="string">'xxxxxyyyytyyyzzzzz'</span>,<span class="string">'学生1'</span>);</span><br><span class="line">insert into <span class="string">'t_user'</span>(<span class="string">'id'</span>,<span class="string">'username'</span>,<span class="string">'password'</span>,<span class="string">'name'</span>) values(<span class="string">'4'</span>,<span class="string">'老婆子'</span>,<span class="string">'xxxxxyywyyyyyzzzzz'</span>,<span class="string">'学生2'</span>);</span><br><span class="line">insert into <span class="string">'t_user'</span>(<span class="string">'id'</span>,<span class="string">'username'</span>,<span class="string">'password'</span>,<span class="string">'name'</span>) values(<span class="string">'5'</span>,<span class="string">'super'</span>,<span class="string">'xxxxxyyfyyyyyzzzzz'</span>,<span class="string">'学生3'</span>);</span><br><span class="line">insert into <span class="string">'t_user'</span>(<span class="string">'id'</span>,<span class="string">'username'</span>,<span class="string">'password'</span>,<span class="string">'name'</span>) values(<span class="string">'6'</span>,<span class="string">'admin'</span>,<span class="string">'xxxxxyyyyyyyzzzzze'</span>,<span class="string">'学生4'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入角色数据</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"><span class="comment"># 插入用户角色数据</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><p><strong>explain当中的id字段</strong></p><p>id字段是select查询的序号(并不是自增，控制表结构的执行顺序)，是一组数字，表示是的是处查询中执行select子句或者是操作表的顺序，id情况有三种：<br><strong>（1）</strong> <strong>id相同表示加载表的顺序是从上到下</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_role r,t_user u,user_role ur <span class="keyword">where</span> r.id=ur.role_id <span class="keyword">and</span> u.id=ur.user_id;<span class="comment"># 多表联查</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>r</td>    <td>PRIMARY</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>5</td>    <td>NULL</td>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>ur</td>    <td>ref</td>    <td>fk_ur_user_id,fk_ur_role_id</td>    <td>fk_ur_role_id</td>    <td>99</td>    <td>db03.r.id</td>    <td>1</td>    <td>Using where</td>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>u</td>    <td>eq_ref</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>98</td>    <td>db.ur.user_id</td>    <td>1</td>    <td>NULL</td>  </tr></table><p><strong>（2）</strong> <strong>id不同id值越大，优先级越高，越先被执行</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_role <span class="keyword">WHERE</span> <span class="keyword">id</span>=</span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> role_id <span class="keyword">FROM</span> user_role <span class="keyword">WHERE</span> user_id=</span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> username=<span class="string">'stu1'</span></span><br><span class="line">  )</span><br><span class="line">)<span class="comment"># 嵌套子查询</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>t_role</td>    <td>const</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>98</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>2</td>    <td>SUBQUERY</td>    <td>user_role</td>    <td>ref</td>    <td>fk_ur_user_id</td>    <td>fk_ur_user_id</td>    <td>99</td>    <td>const</td>    <td>1</td>    <td>Using where</td>  </tr>  <tr>    <td>3</td>    <td>SUBQUERY</td>    <td>t_user</td>    <td>const</td>    <td>unique_user_username</td>    <td>unique_user_username</td>    <td>137</td>    <td>const</td>    <td>1</td>    <td>Using index</td>  </tr></table><p><strong>（3）</strong> <strong>id有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_role r,</span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_role ur <span class="keyword">WHERE</span> ur.<span class="string">'user_id'</span>=<span class="string">'2'</span></span><br><span class="line">) a  </span><br><span class="line"><span class="keyword">WHERE</span> r.id=a.role_id;  </span><br><span class="line"><span class="comment">#三表查询又连接了一个子查询</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>< derived2></td>    <td>ALL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>2</td>    <td>Using where</td>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>r</td>    <td>eq_ref</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>98</td>    <td>a.role_id</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>2</td>    <td>DERIVED</td>    <td>ur</td>    <td>ref</td>    <td>fk_ur_user_id</td>    <td>fk_ur_user_id</td>    <td>99</td>    <td>const</td>    <td>1</td>    <td>Using index condition</td>  </tr></table><h2 id="优化SQL步骤-explain之select-type"><a href="#优化SQL步骤-explain之select-type" class="headerlink" title="优化SQL步骤 - explain之select_type"></a>优化SQL步骤 - explain之select_type</h2><p><strong>explain之select_type</strong><br>表示<strong>SELECT的类型</strong>，常见的取值，如下表所示（<strong>从上往下</strong>，<strong>效率越来越低</strong>）：  </p><table>  <tr>    <th>select_type</th>    <th>含义</th>  </tr>  <tr>    <td>SIMPLE</td>    <td>简单的select查询，查询中不包含子查询或者UNION。</td>  </tr>  <tr>    <td>PRIMARY</td>    <td>查询中若包含任何复杂的子查询，最外层查询标记为该标识。</td>  </tr>  <tr>    <td>SUBQUERY</td>    <td>在SELECT或者WHERE列表中包含了子查询。</td>  </tr>  <tr>    <td>DERIVED</td>    <td>在FROM列表中包含的子查询，被标记为DERIVED（衍生）MYSQL或递归执行这些子查询，把结果放在临时表中。</td>  </tr>  <tr>    <td>UNION</td>    <td>若第二个SELECT出现在UNION之后，则标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将标记为：DERIVED</td>  </tr>  <tr>    <td>UNION RESULT</td>    <td>从UNION表获取结果的SELECT</td>  </tr></table><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item;</span><br><span class="line"># SIMPLE  </span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=(<span class="keyword">select</span> id <span class="keyword">from</span> user_role <span class="keyword">where</span> role_id=<span class="string">'9'</span>);  </span><br><span class="line"># <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id： <span class="keyword">PRIMARY</span> ；  </span><br><span class="line">#(<span class="keyword">select</span> id <span class="keyword">from</span> user_role <span class="keyword">where</span> role_id=<span class="string">'9'</span>)：SUBQUERY  </span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> a.* <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="string">'1'</span>,<span class="string">'2'</span>)) a;</span><br><span class="line"># <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="string">'1'</span>,<span class="string">'2'</span>): <span class="keyword">DERIVED</span>；存储至衍生的临时表</span><br><span class="line"># <span class="keyword">select</span> a.* <span class="keyword">from</span> ： <span class="keyword">PRIMARY</span>  derived2指的是<span class="keyword">derived</span>指的是衍生的表a，<span class="number">2</span>则指的是id，执行操作表顺序字段；</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=<span class="string">'1'</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=<span class="string">'2'</span>;</span><br><span class="line">#<span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=<span class="string">'1'</span>: <span class="keyword">PRIMARY</span></span><br><span class="line">#<span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=<span class="string">'2'</span> ： <span class="keyword">UNION</span></span><br><span class="line"># <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=<span class="string">'1'</span>的结果  &amp;&amp;  <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=<span class="string">'2'</span>的结果联合起来： <span class="keyword">UNION</span> RESULT</span><br></pre></td></tr></table></figure><h2 id="优化SQL步骤-explain之table-、type"><a href="#优化SQL步骤-explain之table-、type" class="headerlink" title="优化SQL步骤 - explain之table 、type"></a>优化SQL步骤 - explain之table 、type</h2><p><strong>explain之table</strong><br>展示这一行的数据是<strong>关于哪一张表</strong>的；  </p><p><strong>explain之type</strong><br><strong>type</strong>显示的是<strong>访问类型</strong>，是较为重要的一个指标，可取值为：  </p><table>  <tr>    <th>type</th>    <th>含义</th>  </tr>  <tr>    <td>NULL</td>    <td>MySQL不访问任何表，索引，直接返回结果</td>  </tr>  <tr>    <td>system</td>    <td>表只有一行记录（等同于系统表），这是const类型的特例，一般不会出现</td>  </tr>  <tr>    <td>const</td>    <td>表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，索引很快。如将主键置于where列表中，MySQL就能将该查询转换成一个常量。(根据主键或者唯一索引进行查询)</td>  </tr>  <tr>    <td>eq_ref</td>    <td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描</td>  </tr>  <tr>    <td>ref</td>    <td>非唯一性索引扫描，返回皮诶某个单独值的所有行。本质上也是野种索引访问，返回所有匹配某个单独值的所有行（多个）</td>  </tr>  <tr>    <td>range</td>    <td>只检索给定返回的行，使用一个索引来选择行。where之后出现between，<，>，in等操作</，></td>  </tr>  <tr>    <td>index</td>    <td>index与ALL的区别为index类型只是遍历了索引树，通常比ALL快，ALL是遍历数据文件。</td>  </tr>  <tr>    <td>all</td>    <td>将遍历全表以找到匹配的行</td>  </tr></table><p><strong>type为NULL</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> now(); # 查询当前时间(查询效率非常高) ： <span class="keyword">type</span>-&gt;<span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>No tables used</td>  </tr></table><p><strong>type为system</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id=<span class="string">'1'</span>) a;： <span class="keyword">type</span>-&gt;<span class="keyword">system</span></span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>< derived2></td>    <td>system</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>2</td>    <td>DERIVED</td>    <td>t_user</td>    <td>const</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>98</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr></table><p><strong>type为const</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">'1'</span>;<span class="comment"># 根据主键查询返回一条记录：type-&gt;const</span></span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>t_user</td>    <td>const</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>98</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr></table><p><strong>type为const</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> username=<span class="string">'stu1'</span>;<span class="comment">#根据唯一索引查询返回一条记录：type-&gt;const</span></span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>t_user</td>    <td>const</td>    <td>unique_user_username</td>    <td>unique_user_username</td>    <td>137</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr></table><p><strong>type为eq_ref</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user;//id有1、2、3、4、5、6</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_role;//id有10、5、7、8、9</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user u ,t_role r <span class="keyword">where</span> u.id=r.id;<span class="comment">#业务逻辑层面不符合，只是数据库硬性查询（强行关联）出一个type为eq_ref的示例而已</span></span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>r</td>    <td>ALL</td>    <td>PRIMARY</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>5</td>    <td>NULL</td>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>u</td>    <td>eq_ref</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>98</td>    <td>demo_02.r.id</td>    <td>1</td>    <td>NULL</td>  </tr></table><p><strong>type为ref</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> t_user;<span class="comment">#查询t_user表当中的索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_user_name <span class="keyword">on</span> t_user(<span class="string">'name'</span>);</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'a'</span>;<span class="comment">#根据非唯一性索引进行查询，返回的记录只有一条</span></span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_keys</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>t_user</td>    <td>ref</td>    <td>idx_user_name</td>    <td>idx_user_name</td>    <td>137</td>    <td>const</td>    <td>1</td>    <td>Using index condition</td>  </tr></table><p><strong>type为range(范围查询)</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.（between <span class="keyword">and</span>）、（&gt;、&lt;、&gt;=、&lt;=）<span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><p><strong>type为index(指的即索引)</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user;//查询所有数据，进行全表扫描，即到数据文件当中进行读取；<span class="keyword">type</span>为<span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id <span class="keyword">from</span> t_user;//此时<span class="keyword">type</span>为<span class="keyword">index</span>；因为id为主键，主键则走主键索引；</span><br></pre></td></tr></table></figure><p>结果值从最好到最坏依次是：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NULL</span> &gt;<span class="built_in"> system </span>&gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; all</span><br></pre></td></tr></table></figure><h2 id="优化SQL步骤-explain之key-rows-extra"><a href="#优化SQL步骤-explain之key-rows-extra" class="headerlink" title="优化SQL步骤 - explain之key rows extra"></a>优化SQL步骤 - explain之key rows extra</h2><p><strong>explain之key</strong>  </p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">possible_keys:</span>显示可能应用在这张表的索引，一个或者多个；</span><br><span class="line"><span class="symbol">key:</span>实际使用的索引，如果为NULL，则没有使用索引；</span><br><span class="line">key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好（越短执行效率越高）；</span><br></pre></td></tr></table></figure><p><strong>explain之rows</strong>  </p><p>扫描行的数量。  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="type">name</span> =<span class="string">'a'</span>;#<span class="type">name</span>建了索引，所以查询<span class="keyword">rows</span>为<span class="number">1</span>行</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">password</span>=<span class="string">'aaa'</span>;# <span class="keyword">password</span>没有建立索引，整表扫描；<span class="keyword">rows</span>即<span class="keyword">SQL</span>语句查询时所查询的行数；</span><br></pre></td></tr></table></figure><p><strong>explain之extra</strong>  </p><p><strong>其他的额外的执行计划信息</strong>，在该列展示。<br>（using_filesort以及using_temporary非常耗性能；<br>需要优化using_filesort以及using_temporary；保持using_index）</p><table>  <tr>    <th>extra</th>    <th>含义</th>  </tr>  <tr>    <td>using_filesort</td>    <td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，称为“文件排序”</td>  </tr>  <tr>    <td>using_temporary</td>    <td>使用了临时表保存中间结果，MySQL对查询结果排序时使用临时表。常见于order by 和group by</td>  </tr>  <tr>    <td>using_index</td>    <td>表示相应的select操作使用了覆盖索引，避免访问表的数据行，效率不错。</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>;<span class="comment">#按照id进行排序</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">password</span>;<span class="comment">#根据文件进行排序；即需要扫描文件当中的内容，然后再去进行排序；效率非常低；这个时候如果需要进行优化的话，可以在password字段上与name一样建立索引；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>; <span class="comment">#此时依然是using_filesort根据文件排序</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> t_user <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span>;<span class="comment">#此时则使用的是using_index根据索引排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;<span class="comment">#此时extra为null，原因是根据name字段建立了索引</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">password</span>;<span class="comment">#此时password字段没有建立索引；extra为using temporary；using filesort效率低；</span></span><br></pre></td></tr></table></figure><h2 id="优化SQL步骤-show-profile"><a href="#优化SQL步骤-show-profile" class="headerlink" title="优化SQL步骤 - show profile"></a>优化SQL步骤 - show profile</h2><p>MySQL从5.0.37版本开始增加了对 <strong>show profiles</strong> 和 <strong>show profile</strong> 语句的支持。  </p><p><strong>show profiles</strong> 能够在做SQL优化时帮助了解时间都耗费到哪里去了；  </p><p>通过 <strong>have_profiling</strong> 参数，能够看到 <strong>当前MySQL 是否支持 profile</strong>；  </p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">select</span> <span class="comment">@@</span>have_profiling;<span class="meta">#系统变量；YES/NO</span></span><br></pre></td></tr></table></figure><p>默认 profiling 是关闭的，可以通过set语句在Session级别开启profiling：  </p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="symbol">@profiling</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span> <span class="attribute">profiling</span>=1;# 开启profiling开关；0:未开启；1：开启</span><br></pre></td></tr></table></figure><p>通过profile，能够更清楚的了解SQL执行的过程；<br>首先，可以执行一系列的操作，如下图所示：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> db01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> title=<span class="string">'abc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;<span class="comment">#查看之前每一个操作的耗时情况 query_id(当前查询的id)、duration（执行的耗时时间）、query（查询的sql）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use db01;其实底层即select database();</span></span><br></pre></td></tr></table></figure><p>执行完上述命令之后，再执行show profiles指令，来查看SQL语句执行的耗时：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;<span class="comment"># query_id、duration、query</span></span><br></pre></td></tr></table></figure><p>通过 show profile for query query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间；  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show<span class="built_in"> profile </span><span class="keyword">for</span> query 6;#6即通过show profiles查询出来的query_id;  status、duration</span><br></pre></td></tr></table></figure><table>  <tr>    <th>status（经历的每一个阶段）</th>    <th>duration（每一个阶段的耗时情况）</th>  </tr>  <tr>    <td>starting（开启）</td>    <td>0.000046</td>  </tr>  <tr>    <td>checking permissions（校验权限）</td>    <td>...</td>  </tr>  <tr>    <td>opening tables（打开表）</td>    <td>...</td>  </tr>    <tr>    <td>init（初始化）</td>    <td>...</td>  </tr>    <tr>    <td>system lock（系统锁）</td>    <td>...</td>  </tr>    <tr>    <td>optimizing（优化器）</td>    <td>...</td>  </tr>    <tr>    <td>statistics（统计）</td>    <td>...</td>  </tr>    <tr>    <td>perparing（准备）</td>    <td>...</td>  </tr>    <tr>    <td>executing（执行）</td>    <td>...</td>  </tr>    <tr>    <td>sending data（发送数据）</td>    <td>...</td>  </tr>    <tr>    <td>end（结束）</td>    <td>...</td>  </tr>    <tr>    <td>query end（查询结束）</td>    <td>...</td>  </tr>    <tr>    <td>closing tabls（关闭表）</td>    <td>...</td>  </tr>    <tr>    <td>freeing itmes（释放其他项）</td>    <td>...</td>  </tr>    <tr>    <td>cleaning up（清除）</td>    <td>...</td>  </tr></table><p>（select count(*) from tb_item；该sql语句的时间都耗费在sending data上了；）  </p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">TIP:  </span></span><br><span class="line"><span class="code">    Sending data 状态表示MySQL线程开始访问数据行并把结果放回给客户端，而不仅仅是返回给客户端。  </span></span><br><span class="line"><span class="code">    由于Sending data 状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整个查询中耗时最长的状态。</span></span><br></pre></td></tr></table></figure><p>在获取到最耗时时间的线程状态后，MySQL支持进一步选择all、cpu、block io、context switch、page faults 等明细类型等查看MySQL在使用什么资源上耗费了过高的时间。<br>例如，选择查看CPU的耗费时间：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select<span class="built_in"> profile </span>cpu <span class="keyword">for</span> query 6;# status、duration、CPU_user、CPU_System查询到的是id为6的该条sql语句在各个阶段当中cpu的耗费情况；</span><br><span class="line"></span><br><span class="line">select<span class="built_in"> profile </span>all <span class="keyword">for</span> query 6;# status、duration、CPU_user、CPU_system、context_voluntary、context_involuntary、block_ops_in、block_ops_out、<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><blockquote><p>通过 <strong>show profile</strong> 可以 <strong>分析SQL语句 各个阶段的 耗时情况</strong></p></blockquote><h2 id="优化SQL步骤-trace工具"><a href="#优化SQL步骤-trace工具" class="headerlink" title="优化SQL步骤 - trace工具"></a>优化SQL步骤 - trace工具</h2><p>mysql的服务端server有一个步骤就是optimizer，优化sql部分；按照mysql当中具体对应的规则对SQL进行优化处理；trace即分析优化器</p><p><strong>trace分析优化器执行计划</strong><br>MySQL5.6提供了对SQL的跟踪 trace，通过trace文件能够进一步了解为什么优化器选择A计划，而不是B计划。  </p><p>打开trace，设置格式为JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">SET</span> optimizer_trace =<span class="string">'enabled=on'</span>, <span class="attribute">end_markers_in_json</span>=on;# optimizer_trace =<span class="string">'enabled=on'</span>进行开启；<span class="attribute">end_markers_in_json</span>=on 设置格式为JSON</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">optimizer_trace_max_mem_size</span>=1000000;# 日志文件占用内存大小</span><br></pre></td></tr></table></figure><p>执行SQL语句：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>最后，检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> infomation_schema.optimizer_trace\G;# infomation_schema系统库；optimizer_trace系统库当中的日志表</span><br><span class="line"></span><br><span class="line"># QUERY 查询的SQL语句；<span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> id&lt;<span class="number">4</span>;</span><br><span class="line"># TRACE 跟踪信息；在跟踪信息当中最终<span class="keyword">select</span> * 当中的* 最终解析为tb_item表当中的每一个具体的字段</span><br></pre></td></tr></table></figure><h2 id="索引的使用-验证索引提升查询效率"><a href="#索引的使用-验证索引提升查询效率" class="headerlink" title="索引的使用 - 验证索引提升查询效率"></a>索引的使用 - 验证索引提升查询效率</h2><p><strong>索引的使用</strong><br>索引时候数据库优化最常用也是最重要的手段之一，通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题；  </p><p><strong>验证索引提升查询效率</strong><br>在准备的表结构tb_item中，一共存储了300万条记录；  </p><p><strong>A.</strong> 根据ID查询  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_items;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1888</span>;<span class="comment">#id字段具有主键索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1999</span>\G;</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据title进行精确查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> title=<span class="string">'阿尔卡特'</span>;<span class="comment">#查询速度慢，因为title字段没有索引，查询效率低，创建主键即自动生成主键索引；</span></span><br><span class="line"><span class="comment">#查看SQL语句的执行计划：  </span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> title=<span class="string">'阿尔卡特'</span>\G;</span><br></pre></td></tr></table></figure><p>处理方案，针对title字段，创建索引：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_item_title <span class="keyword">on</span> tb_item(<span class="built_in">title</span>);</span><br></pre></td></tr></table></figure><p>索引创建完成之后，再次查询：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> title=<span class="string">'阿尔卡特'</span>\G;</span><br><span class="line"><span class="comment"># 创建索引的过程中，mysql在做什么？表tb_item中有300万条记录，那么在创建索引的时候就会对这300万条记录重建索引；所以此时即数据库底层在重建索引；创建完索引之后再进行查询效率则变快；索引是优化查询最有效的方式之一；</span></span><br></pre></td></tr></table></figure><p>查询速度很快，接近0s，主要的原因是因为id为主键，有索引；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1999</span>\G;</span><br></pre></td></tr></table></figure><p><strong>准备环境</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'tb_seller'</span>(</span><br><span class="line">  <span class="string">'sellerid'</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="string">'name'</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="string">'nickname'</span> <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  <span class="string">'password'</span> <span class="built_in">varchar</span>(<span class="number">60</span>),</span><br><span class="line">  <span class="string">'status'</span> <span class="built_in">varchar</span>(<span class="number">1</span>),</span><br><span class="line">  <span class="string">'address'</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="string">'createtime'</span> datetime,</span><br><span class="line">  primary <span class="keyword">key</span>(<span class="string">'sellerid'</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">#插入记录 导入基本数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_seller <span class="keyword">values</span> ......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建联合索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_name_sta_addr <span class="keyword">on</span> tb_seller(<span class="keyword">name</span>,<span class="keyword">status</span>,address);</span><br></pre></td></tr></table></figure><p>创建了索引并不是一定会提高效率；创建了索引并且需要合理运用索引才能够提高查询效率；  </p><h2 id="索引的使用-全值匹配"><a href="#索引的使用-全值匹配" class="headerlink" title="索引的使用 - 全值匹配"></a>索引的使用 - 全值匹配</h2><p><strong>避免索引失效</strong>  </p><p><strong>(1)</strong> <strong>全值匹配</strong>，<strong>对索引中所有列都指定具体值</strong>。<br>该情况下，索引生效，执行效率提高。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span>\G;</span><br></pre></td></tr></table></figure><h2 id="索引的使用-最左前缀法则"><a href="#索引的使用-最左前缀法则" class="headerlink" title="索引的使用 - 最左前缀法则"></a>索引的使用 - 最左前缀法则</h2><p><strong>避免索引失效</strong>  </p><p><strong>(2)</strong> <strong>最左前缀法则</strong><br>tb_seller创建了一个复合索引即name、status、address这三个字段；<br>如果索引了多列，要遵守<strong>最左前缀法则</strong>。<br>指的是查询<strong>从 索引的最左前列 开始</strong>，<strong>并且 不跳过 索引中的列</strong>。<br><strong>匹配最左前缀法则</strong>，走索引：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'小米科技'</span>;<span class="comment"># key:idx_name_sta_addr； key_len：403</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="string">'1'</span>;<span class="comment"># key:idx_name_sta_addr； key_len：410</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span>;<span class="comment"># key:idx_name_sta_addr； key_len：813</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">status</span>=<span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span>;<span class="comment"># key:NULL key_len：NULL 此时则不再走索引；因为不再符合最左前缀法则，没有以最左边的列开始；  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">status</span>=<span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span> <span class="keyword">and</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;<span class="comment"># key:idx_name_sta_addr； key_len：813 此时是走索引的；与where列表当中字段的先后顺序无关；会检查where条件列表中包不包含最左列；而是与复合索引当中的是否存在有复合索引当中的最左字段；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span> ;<span class="comment">#跳过索引列不走索引; key:idx_sellter_name_sta_addr；key_len: 403；此时索引的长度是403；也就是这是执行 explain select * from tb_seller where name ='小米科技'; 时所走的索引；即后面的 and address='北京市' 并未走索引；</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>违反最左前缀法则，索引失效</strong>；<br><strong>需要包含 复合索引当中的最左列</strong>，并且<strong>不能跳过</strong> <strong>复合索引当中的某一列</strong>进行查询否则复合索引失效；</p></blockquote><h2 id="索引的使用-索引失效情况（范围查询、字段运算）"><a href="#索引的使用-索引失效情况（范围查询、字段运算）" class="headerlink" title="索引的使用 - 索引失效情况（范围查询、字段运算）"></a>索引的使用 - 索引失效情况（范围查询、字段运算）</h2><p><strong>避免索引失效</strong>  </p><p><strong>（3）</strong> <strong>范围查询右边的列</strong>，<strong>不能使用索引</strong>；<br>根据前面的两个字段name、status查询是走索引的，但是最后一个条件address没有用到索引。  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">explain select * <span class="keyword">from</span> tb_seller where <span class="attribute">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="attribute">status</span>=<span class="string">'1'</span> <span class="keyword">and</span> <span class="attribute">address</span>=<span class="string">'北京市'</span>;# key:idx_name_sta_addr； key_len：813；此时三个字段name、status、address三个字段都走了索引；  </span><br><span class="line"></span><br><span class="line">explain select * <span class="keyword">from</span> tb_seller where name =<span class="string">'小米科技'</span> <span class="keyword">and</span> status &gt;<span class="string">'1'</span> <span class="keyword">and</span><span class="built_in"> address </span>=<span class="string">'北京市'</span>;# key:idx_name_sta_addr； key_len：410;此时走的索引是name和status字段的索引；而范围查询status&gt;<span class="string">'1'</span>之后的address并没有走索引；  </span><br><span class="line"><span class="comment"># 范围查询之后的索引字段将失效</span></span><br></pre></td></tr></table></figure><p><strong>（4）</strong> 不要在<strong>索引列</strong>上<strong>进行运算操作</strong>，索引将失效；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller  <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;<span class="comment">#此时走索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">3</span>,<span class="number">2</span>)=<span class="string">'科技'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">3</span>,<span class="number">2</span>)=<span class="string">'科技'</span>;<span class="comment">#此时key为null以及key_len为null；而type为ALL则说明了进行了全表扫描；没有走索引</span></span><br></pre></td></tr></table></figure><p><strong>（5）</strong> <strong>字符串不加单引号</strong>，会造成索引失效；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="string">'0'</span>;<span class="comment"># 此时key:idx_name_sta_addr；key_len：410；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="number">0</span>;<span class="comment"># 此时key：idx_name_sta_addr；key_len：403；索引长度为403；则说明走的索引为name字段的索引；而status字段的索引并没有走；造成了status=0 该索引字段的失效；当status字段取值没有加单引号时，mysql底层检测到status字段为varchar类型所以会对其没有加单引号的取值进行隐式类型转换；隐式类型转换了之后该status索引字段就失效了；因为底层对该字段进行了运算操作；</span></span><br></pre></td></tr></table></figure><h2 id="索引的使用-覆盖索引"><a href="#索引的使用-覆盖索引" class="headerlink" title="索引的使用 - 覆盖索引"></a>索引的使用 - 覆盖索引</h2><p><strong>避免索引失效</strong>  </p><p><strong>（6）</strong> <strong>尽量使用覆盖索引</strong>，<strong>避免使用 select *</strong>  </p><p><strong>尽量使用覆盖索引</strong>（只访问索引的查询（索引列完全包含查询列））， <strong>减少select *</strong> ；  </p><p>如果查询列，<strong>超出索引列</strong>，也会<strong>降低性能</strong>；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'小米科技'</span>;</span><br><span class="line"><span class="comment"># extra为using index condition指的是：在查询的时候确实用到了name这个字段的索引；</span></span><br><span class="line"><span class="comment">#但是用到了name这个字段的索引信息之后，在返回数据的时候还需要进行索引回调查询；  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span> , <span class="keyword">status</span> ,address <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;</span><br><span class="line"><span class="comment"># 此时extra为using where ;using index；</span></span><br><span class="line"><span class="comment"># 此时表示的是：可以通过索引进行查询；但是此时并不需要进行回调查询了；</span></span><br><span class="line"><span class="comment"># 原因就在于查询的字段在索引结构当中已经被记录了；</span></span><br><span class="line"><span class="comment"># 所以并不需要去进行回调查询；  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span> , <span class="keyword">status</span>  <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>; <span class="comment">#同上</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span> ,  address <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>; <span class="comment">#同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span> ,  address ,<span class="keyword">password</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;</span><br><span class="line"><span class="comment"># 复合索引当中并未包括password字段则此时name索引字段以及address索引字段当中并没有包括password字段的信息，</span></span><br><span class="line"><span class="comment"># 则此时需要去回调查询password字段的信息；</span></span><br><span class="line"><span class="comment"># 即extra为using index_condition</span></span><br></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">TIP:  </span></span><br><span class="line">索引回调查询指的是：  </span><br><span class="line"><span class="code">    using index : 使用覆盖索引的时候就会出现</span></span><br><span class="line"><span class="code">    using where : 在查找使用索引的情况下，需要回表去查询所需的数据</span></span><br><span class="line"><span class="code">    using index condition ：查找使用了索引，但是需要回表查询数据（从索引当中拿到了数据，然后再到表结构当中去拿到该数据对应的一整行数据，因为该name索引字段并没有记录所有的数据，只是记录了那么字段的数据；所以需要回表查询数据；即用了索引还需要回调查询）</span></span><br><span class="line"><span class="code">    using index ; using where : 查找使用了索引，但是需要的数据都在索引列中能找到，索引不需要回表查询数据</span></span><br></pre></td></tr></table></figure><p><strong>（7）</strong> <strong>in走索引，not in 索引失效</strong></p><h2 id="索引的使用-or索引失效情况"><a href="#索引的使用-or索引失效情况" class="headerlink" title="索引的使用 - or索引失效情况"></a>索引的使用 - or索引失效情况</h2><p><strong>避免索引失效</strong><br>（7）用or分隔开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到；  </p><p>示例：name字段是索引列，而createtime不是索引列，中间是or进行连接是不走索引的；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> createtime=<span class="string">'2088-01-01 12:00:00'</span>\G;<span class="comment">#key:idx_name_sta_addr； key_len: 403;此时走索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">or</span> createtime=<span class="string">'2088-01-01 12:00:00'</span>\G;<span class="comment">#key:idx_name_sta_addr； key_len: NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> nickname=<span class="string">'小米官方旗舰店'</span>;<span class="comment">#此时走索引；key_len:403;走的是name字段的索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">or</span> nickname=<span class="string">'小米官方旗舰店'</span>;<span class="comment">#换成or之后，nickname字段非索引字段；所以此时将全表扫描；不会走索引；key_len:NULL；以及type为ALL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or之后的字段如果没有索引的话；那么整个where列表当中即便有索引字段也将都失效，不再走索引；</span></span><br></pre></td></tr></table></figure><h2 id="索引的使用-like模糊匹配"><a href="#索引的使用-like模糊匹配" class="headerlink" title="索引的使用 - like模糊匹配"></a>索引的使用 - like模糊匹配</h2><p><strong>避免索引失效</strong>  </p><p><strong>（8）</strong> <strong>以%开头的Like模糊查询</strong>，索引失效。  </p><p>如果仅仅是尾部模糊查询，索引不会失效。<br>如果是头部模糊查询匹配，则索引失效。  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">like</span> <span class="string">'小米科技'</span>;#key: idx_name_sta_addr； key_len: <span class="number">403</span>; 此时走索引；索引走的是<span class="type">name</span>字段</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">like</span> <span class="string">'%小米科技'</span>;#key: <span class="keyword">NULL</span>； key_len: <span class="keyword">NULL</span>; 此时不走索引；且<span class="keyword">type</span>为<span class="keyword">ALL</span>；全表扫描</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">like</span> <span class="string">'%小米科技%'</span>;#key: <span class="keyword">NULL</span>； key_len: <span class="keyword">NULL</span>; 此时不走索引；且<span class="keyword">type</span>为<span class="keyword">ALL</span>；全表扫描</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">like</span> <span class="string">'科技%'</span>;#key: idx_name_sta_addr； key_len: <span class="number">403</span>; 此时走索引；索引走的是<span class="type">name</span>字段</span><br></pre></td></tr></table></figure><p>类似 “%科技%” 这种情况在业务逻辑处理当中还是比较多的；但是这样效率将十分低下；所以针对这种情况的处理方式为：<br>覆盖索引：覆盖索引指的是，尽量不要使用select * 这种方式进行查询；而是使用复合索引当中的那些索引列，即索引字段；即复合索引为idx_name_sta_addr，当中包含的索引字段为name、status、address；所以select 查询列名称的时候尽量查询的列名称为复合索引当中的索引列，或者是其他索引的字段（例如唯一索引的索引字段、主键索引的索引字段等）；<br>即通过覆盖索引就可以解决 “%科技%” like模糊查询效率低下的情况（条件是select 查询的字段都需要是索引字段，如果出现了查询非索引字段则将不再走索引）；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> sellerid <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%科技%'</span>;<span class="comment"># 则此时是走索引的；key:idx_seller_name_sta_addr；key_len：813；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> sellerid,<span class="keyword">name</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%科技%'</span>;<span class="comment"># 则此时是走索引的；key:idx_seller_name_sta_addr；key_len：813；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> sellerid,<span class="keyword">name</span>,<span class="keyword">status</span>,address <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%科技%'</span>;<span class="comment"># 则此时是走索引的；key:idx_seller_name_sta_addr；key_len：813；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> sellerid,<span class="keyword">name</span>,<span class="keyword">status</span>,address,<span class="keyword">password</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%科技%'</span>;<span class="comment"># 则此时是不走索引的，由于password字段并不是索引字段，所以将造成不会走索引的局面；key:NULL；key_len：NULL；</span></span><br></pre></td></tr></table></figure><h2 id="索引的使用-全表扫描更快"><a href="#索引的使用-全表扫描更快" class="headerlink" title="索引的使用 - 全表扫描更快"></a>索引的使用 - 全表扫描更快</h2><p><strong>避免索引失效</strong>  </p><p><strong>（9）</strong> 如果<strong>MySQL评估</strong>使用索引比全表更慢，则不使用索引；  </p><p>如果发现走全表扫描比走索引要快，这个时候mysql就会走全表扫描；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address=<span class="string">'北京市'</span>;<span class="comment">#此时key:NULL 以及key_len: NULL；由于address是复合索引当中的索引字段但是又不满足最左前缀法则；所以不走索引；  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_address <span class="keyword">on</span> tb_seller(address);<span class="comment">#在tb_seller表中的address字段上建立索引；单列索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address=<span class="string">'北京市'</span>;<span class="comment"># 但是此时仍然没有走索引；possible_key出现有idx_seller_address；但是key为NULL；以及key_len为NULL；type为ALL；即走的还是全表扫描</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address=<span class="string">'西安市'</span>;<span class="comment">#此时是走索引的，key为idx_address；key_len为403;索引走的是address字段；extra为using index condition</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#同样一条SQL语句，只是传入的参数不同；也就导致了是否走索引的不同；一个是全表扫描没有走索引；而另外一个是走了索引idx_seller_address；  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#原因就在于：这个与数据库当中的数据是存在一定的关系的；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller; <span class="comment">#该表当中一共有12条记录；这12条记录当中出现有address为“北京市”的记录行数就有11条记录；只有一条是1条是“西安市”；  </span></span><br><span class="line"><span class="comment">#如果数据量大，且精确查询的内容又在表中占比大；此时就极有可能走的是全表扫描而非走索引了；速度更快</span></span><br></pre></td></tr></table></figure><h2 id="索引的使用-NULL值的判定"><a href="#索引的使用-NULL值的判定" class="headerlink" title="索引的使用 - NULL值的判定"></a>索引的使用 - NULL值的判定</h2><p><strong>避免索引失效</strong>  </p><p><strong>（10）</strong> <strong>is NULL，is  NOT NULL</strong>  <strong><span style="color:red;">有时</span></strong> 索引失效；  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> tb_seller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"># 此时是走索引的；key：idx_seller_address ;key_len：<span class="number">403</span> 走的索引字段为address</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"># 此时是没有走索引的；key：<span class="keyword">null</span> ;key_len:<span class="keyword">null</span>;<span class="keyword">type</span>:<span class="keyword">all</span> 走的是全表扫描</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;</span><br><span class="line"># 当前该表当中每一条记录都address字段记录取值都是 <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"># 当前<span class="keyword">explain</span> <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">null</span>时走了索引，</span><br><span class="line"># 即address <span class="keyword">is</span> <span class="keyword">null</span>这样的记录在表当中占比较少此时则走索引；</span><br><span class="line"># 而<span class="keyword">explain</span> <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>时没有走索引；</span><br><span class="line"># 而此时 address <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>则在表当中占比较多；</span><br><span class="line"># 所以就不会去走索引而是全表扫描；</span><br><span class="line"># 这个与前面所说的全表扫描更快是一个道理；</span><br><span class="line"># 全表扫描与走索引的这两种方式哪一种更快就选择哪一种方式；</span><br><span class="line"># 也就是说mysql底层会去自动的判断如果走全表扫描更快就走全表扫描；</span><br><span class="line"># 如果走索引更快就走索引的这种方式；  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"># 此时走索引；key:idx_name_sta_addr；key_len：<span class="number">403</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"># 此时不走索引；key:<span class="keyword">null</span>； key_len：<span class="keyword">null</span>; <span class="keyword">type</span>：<span class="keyword">ALL</span> 走的是全表扫描</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"># 此时不走索引；key：<span class="keyword">null</span>；key_len: <span class="keyword">null</span> ; <span class="keyword">type</span>:<span class="keyword">all</span> 走的是全表扫描</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"># 此时走了索引；key:idx_name; key_len:<span class="number">138</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t_user <span class="keyword">set</span> <span class="type">name</span> =<span class="keyword">null</span> <span class="keyword">where</span> id &lt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user;</span><br><span class="line"># 则此时除了id为<span class="number">1</span>的记录其余的记录的<span class="type">name</span>字段就变成了<span class="keyword">null</span>；</span><br><span class="line"># 所以如果此时查询t_user表当中<span class="type">name</span>字段为<span class="keyword">is</span> <span class="keyword">null</span>则走全表扫描；</span><br><span class="line"># 而查询<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>则走索引；</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> t_user;#此时在t_user表当中<span class="type">name</span>字段是存在索引的；</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"># key:<span class="keyword">null</span> ; key_len:<span class="keyword">null</span>;<span class="keyword">type</span>:<span class="keyword">all</span> 走的是全表扫描（原因就在于此时在表当中记录<span class="type">name</span>字段为<span class="keyword">null</span>占比大于<span class="type">name</span>字段<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>；</span><br><span class="line"># 所以全表扫描与走索引的方式这两者相比较之下，全表扫描更快；）</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"># 此时是走索引的；key:idx_user_name;key_len:<span class="number">138</span>;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 也就是说<span class="keyword">is</span> <span class="keyword">null</span>与<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>；</span><br><span class="line"># 有时是会走索引的有时又不会走索引；</span><br><span class="line"># 这要分情况而定；</span><br><span class="line"># 这个根据数据库当中的数据量来决定的；</span><br><span class="line"># 如果查询的字段在数据量当中的<span class="keyword">null</span>值占比较多,那么这个时候<span class="keyword">is</span> <span class="keyword">null</span>将会走全表扫描而<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>则走索引；</span><br><span class="line"># 如果查询的字段在数据量当中绝大部分都是存在有值的也就是说<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>占据较多；</span><br><span class="line"># 则此时<span class="keyword">is</span> <span class="keyword">null</span>就会走索引；而<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>则走全表扫描；</span><br></pre></td></tr></table></figure><h2 id="索引的使用-in和not-in"><a href="#索引的使用-in和not-in" class="headerlink" title="索引的使用 - in和not in"></a>索引的使用 - in和not in</h2><p><strong>避免索引失效</strong>  </p><p><strong>（11）</strong> <strong>in 走索引； not in 索引失效</strong>；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> sellerid <span class="keyword">in</span> (<span class="string">'oppo'</span>,<span class="string">'xiaomi'</span>,<span class="string">'sina'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> sellerid <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'oppo'</span>,<span class="string">'xiaomi'</span>,<span class="string">'sina'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> sellerid <span class="keyword">in</span> (<span class="string">'oppo'</span>,<span class="string">'xiaomi'</span>,<span class="string">'sina'</span>);</span><br><span class="line"><span class="comment"># 此时使用了索引；key:PRIMARY；key_len:402;  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> sellerid <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'oppo'</span>,<span class="string">'xiaomi'</span>,<span class="string">'sina'</span>);</span><br><span class="line"><span class="comment"># 此时未走索引；索引失效；key:NULL；key_len:NULL；type:ALL 全表扫描</span></span><br></pre></td></tr></table></figure><h2 id="索引的使用-单列索引与复合索引选择"><a href="#索引的使用-单列索引与复合索引选择" class="headerlink" title="索引的使用 - 单列索引与复合索引选择"></a>索引的使用 - 单列索引与复合索引选择</h2><p><strong>避免索引失效</strong>  </p><p><strong>（12）</strong> <strong>单列索引 和 复合索引</strong>  </p><p><strong>尽量使用 复合索引，而少量使用 单列索引</strong>；  </p><p>创建复合索引：  </p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create <span class="built_in">index</span> idx_name_sta_address on tb_seller(<span class="keyword">name</span>,<span class="keyword">status</span>,address);</span><br><span class="line"></span><br><span class="line">就相当于创建了三个索引：  </span><br><span class="line">* <span class="keyword">name</span></span><br><span class="line">* <span class="keyword">name</span> + <span class="keyword">status</span></span><br><span class="line">* <span class="keyword">name</span> + <span class="keyword">status</span> + address</span><br></pre></td></tr></table></figure><p>创建单列索引：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_name <span class="keyword">on</span> tb_seller(<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_status <span class="keyword">on</span> tb_seller(<span class="keyword">status</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br></pre></td></tr></table></figure><p>当对name、status、address字段进行搜索的时候，数据库只会选择一个索引；<br>所以此时在这种情况下单列索引并不占优势；  </p><p>数据库会选择一个最优的索引来使用，并不会使用全部索引；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> tb_seller;<span class="comment">#查看tb_seller表当中的索引</span></span><br><span class="line"><span class="comment"># PRIMARY 主键索引</span></span><br><span class="line"><span class="comment"># idx_name_sta_address name</span></span><br><span class="line"><span class="comment"># idx_name_sta_address status</span></span><br><span class="line"><span class="comment"># idx_name_sta_address address</span></span><br><span class="line"><span class="comment"># idx_seller_address address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除单列索引</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> <span class="keyword">from</span> idx_seller_address <span class="keyword">on</span> tb_seller;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看tb_seller表的索引</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> tb_seller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span>  <span class="keyword">status</span>=<span class="string">'0'</span> <span class="keyword">and</span> address=<span class="string">'西安市'</span>;<span class="comment">#此时使用复合索引；key:idx_name_sta_addr；key_len：813</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除复合索引</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> idx_name_sta_address <span class="keyword">on</span> tb_seller;</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建单列索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_name <span class="keyword">on</span> tb_seller(<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_status <span class="keyword">on</span> tb_seller(<span class="keyword">status</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看单列索引</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> tb_seller;</span><br><span class="line"><span class="comment">#PRIMARY 主键索引</span></span><br><span class="line"><span class="comment"># idx_seller_name 单列索引name字段</span></span><br><span class="line"><span class="comment"># idx_seller_status 单列索引status字段</span></span><br><span class="line"><span class="comment"># idx_seller_address 单列索引address字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="string">'0'</span> <span class="keyword">and</span> address=<span class="string">'西安市'</span>;</span><br><span class="line"><span class="comment"># 此时走索引但是；key:idx_seller_name; key_len:403;</span></span><br><span class="line"><span class="comment"># 只走了name字段的索引；</span></span><br><span class="line"><span class="comment"># 而status字段以及address字段的索引未走；</span></span><br><span class="line"><span class="comment"># 相当于白创建了status以及address字段的索引了；</span></span><br><span class="line"><span class="comment"># 即此时possible_key：idx_seller_name、idx_seller_status、idx_seller_address；这三个索引可能都会用到；</span></span><br><span class="line"><span class="comment"># 但是实际上只用到了idx_seller_name索引；即name字段的索引；</span></span><br><span class="line"><span class="comment"># 为什么选择了name字段来作为该SQL的索引；</span></span><br><span class="line"><span class="comment"># 原因在于：数据库会选择一个最优的索引来使用；并不会使用全部索引；也就意味着name该字段的索引在这三个索引当中最优；</span></span><br><span class="line"><span class="comment"># 为什么name该字段的索引idx_seller_name最优，</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;</span><br><span class="line"><span class="comment"># 因为在此表当中，name查询的精确值为“小米科技”辨识度最高，记录行为1；</span></span><br><span class="line"><span class="comment"># 而status字段取值为0的记录行超过1；</span></span><br><span class="line"><span class="comment"># address字段取值为“西安市”记录行也只有1；</span></span><br><span class="line"><span class="comment"># 也应该是遵循了从左到右的一个判断；所以此时idx_seller_name索引最优；</span></span><br><span class="line"><span class="comment"># 从而走了idx_seller_name索引；  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">status</span>=<span class="string">'0'</span> <span class="keyword">and</span> address=<span class="string">'西安市'</span>;</span><br><span class="line"><span class="comment"># 此时没有name字段；</span></span><br><span class="line"><span class="comment"># 而address在数据表当中辨识度最高；</span></span><br><span class="line"><span class="comment"># 即记录行为1；所以此时走的索引自然即为idx_seller_address；</span></span><br><span class="line"><span class="comment"># key:idx_seller_address;key_len:403;possible_key:idx_seller_status,idx_seller_address;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">status</span>=<span class="string">'0'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span>;</span><br><span class="line"><span class="comment"># 如果此时address取精确值为“北京市”；</span></span><br><span class="line"><span class="comment"># 而在数据库当中address取值为“北京市”的记录行辨识度并不高；</span></span><br><span class="line"><span class="comment"># 也就是取值为“北京市”的address字段其记录行有很多超过1，即总共12条记录，有11条记录当中的address都是“北京市”，从而其辨识度并不高；</span></span><br><span class="line"><span class="comment"># 而此时status字段相比较之下，取值为0的记录行数，总行数12行，而status取值为0的记录行数为3行，那么此时较之address的辨识度自然是要高一些；</span></span><br><span class="line"><span class="comment"># 所以将走status字段的索引，即idx_seller_status索引；</span></span><br><span class="line"><span class="comment"># possible_key:idx_seller_status,idx_seller_address；key:idx_seller_status;key_len:7；</span></span><br></pre></td></tr></table></figure><p>也就是说：数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部的索引；  </p><h2 id="索引的使用-查看索引使用情况"><a href="#索引的使用-查看索引使用情况" class="headerlink" title="索引的使用 - 查看索引使用情况"></a>索引的使用 - 查看索引使用情况</h2><p><strong>查看索引使用情况</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Handler_read%'</span>;<span class="comment">#查看的是当前会话中索引的使用情况</span></span><br><span class="line"><span class="comment">#Variable_name  Value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Handler_read%'</span>;<span class="comment">#查看的是全局中索引的使用情况</span></span><br></pre></td></tr></table></figure><table border="1">  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>Handler_read_first</td>    <td>0</td>  </tr>  <tr>    <td>Handler_read_key</td>    <td>2</td>  </tr>  <tr>    <td>Handler_read_last</td>    <td>0</td>  </tr>    <tr>    <td>Handler_read_next</td>    <td>0</td>  </tr>    <tr>    <td>Handler_read_prev</td>    <td>0</td>  </tr>    <tr>    <td>Handler_read_rnd</td>    <td>0</td>  </tr>    <tr>    <td>Handler_read_rnd_next</td>    <td>22</td>  </tr></table><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Handler_read_first</span>: 索引中第一条被读的次数。如果较高，表示服务器正在自行大量全索引扫描（这个值越低越好）；</span><br><span class="line"></span><br><span class="line"><span class="attribute">Handler_read_key</span>: 如果索引正在工作，这个值代表一个行被索引值读取的次数；如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）；</span><br><span class="line"></span><br><span class="line"><span class="attribute">Handler_read_next</span>: 按照键顺序读下一行的请求数。如果用范围约束或者如果执行索引扫描来查询索引列，该值增加；  </span><br><span class="line"></span><br><span class="line"><span class="attribute">Handler_read_prev</span>: 按照键顺序读前一行的请求数，该读方法主要用于优化ORDER BY.....DESC；</span><br><span class="line"></span><br><span class="line"><span class="attribute">Handler_read_rnd</span>: 根据固定位置读一行的请求数。如果正执行大量查询并需要对结果进行排序该值较高。可能使用了大量需要MySQL扫描整个表的查询或者连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救；  </span><br><span class="line"></span><br><span class="line"><span class="attribute">Handler_read_rnd_next</span>: 在数据文件中读下一行的请求数。如果正进行大量的表扫描，该值要求较高。通常说明表索引不正确或者是写入的查询没有利用索引；</span><br></pre></td></tr></table></figure><h2 id="SQL优化-大批量插入数据"><a href="#SQL优化-大批量插入数据" class="headerlink" title="SQL优化 - 大批量插入数据"></a>SQL优化 - 大批量插入数据</h2><p><strong>大批量插入数据</strong>  </p><p>环境准备：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">'tb_user_1'</span>(</span><br><span class="line">  <span class="string">'id'</span> int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">'username'</span> varchar(45) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'password'</span> varchar(96) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'name'</span> varchar(45) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'birthday'</span> datetime<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'sex'</span> char(1)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'email'</span> varchar(45)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'phone'</span> varchar(45)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'qq'</span> varchar(32)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'status'</span>  varchar(32)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span> comment <span class="string">'用户状态'</span>,</span><br><span class="line">  <span class="string">'create_time'</span>  datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'update_time'</span> datetime<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY(<span class="string">'id'</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">'unique_user_username'</span>(<span class="string">'username'</span>)</span><br><span class="line">)<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE <span class="string">'tb_user_2'</span>(</span><br><span class="line">  <span class="string">'id'</span> int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">'username'</span> varchar(45) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'password'</span> varchar(96) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'name'</span> varchar(45) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'birthday'</span> datetime<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'sex'</span> char(1)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'email'</span> varchar(45)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'phone'</span> varchar(45)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'qq'</span> varchar(32)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'status'</span>  varchar(32)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span> comment <span class="string">'用户状态'</span>,</span><br><span class="line">  <span class="string">'create_time'</span>  datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'update_time'</span> datetime<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY(<span class="string">'id'</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">'unique_user_username'</span>(<span class="string">'username'</span>)</span><br><span class="line">)<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>当使用load命令导入数据的时候，适当的设置可以提高导入的效率。  </p><p>引擎使用的是Innodb，Innodb底层使用的索引是B+树索引；而B+树索引当中的数据有顺序的；  </p><p>对于Innodb类型的表，有以下集中方式可以提高导入的效率：  </p><p><strong>（1）</strong> <strong>主键顺序插入</strong>  </p><p>因为<strong>InnoDB类型</strong>的表是<strong>按照主键的顺序</strong>保存的，所以将导入的数据<strong>按照主键的顺序排列</strong>，可以<strong>有效的提高 导入数据的 效率</strong>。  </p><p>如果<strong>InnoDB表 没有主键</strong>，那么系统会<strong>自动默认创建一个内部列</strong>作为<strong>主键</strong>，所以如果可以给表创建一个主键，将可以利用这点，来<strong>提高导入数据的效率</strong>。  </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">脚本文件介绍：  </span><br><span class="line">  <span class="function"><span class="title">sql1</span>.<span class="built_in">log</span> -----&gt;</span> 主键有序</span><br><span class="line">  <span class="function"><span class="title">sql2</span>.<span class="built_in">log</span> -----&gt;</span> 主键无序</span><br></pre></td></tr></table></figure><p>插入ID顺序排列数据：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> <span class="keyword">infile</span> <span class="string">'/root/sql1.log'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">'tb_user_1'</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment"># 耗费时长：20.58 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_user_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> <span class="keyword">infile</span> <span class="string">'/root/sql2.log'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">'tb_user_2'</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">#耗费时长：1min 59.29 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_user_2;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sql1.log当中数据有序进行排列；sql2.log当中数据无序进行排列；</span></span><br><span class="line"><span class="comment">#而sql1.log当中的数据将插入到tb_user_1表；sql2.log当中的数据将插入到tb_user_2表当中；</span></span><br><span class="line"><span class="comment">#sql1.log与sql2.log当中数据量完全一致；只数据排列分布顺序不一致；</span></span><br><span class="line"></span><br><span class="line">head sql1.log <span class="comment">#linux 查看sql1.log前一部分的数据内容，id主键数据有序</span></span><br><span class="line">head sql2.log <span class="comment">#linux 查看sql2.log前一部分的数据内容，主键数据无序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> <span class="keyword">infile</span> <span class="string">'/root/sql1.log'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">'tb_user_1'</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment"># load data 加载数据  </span></span><br><span class="line"><span class="comment">#local infile 从本地文件系统当中加载数据；</span></span><br><span class="line"><span class="comment">#'/root/sql1.log' 数据文件在linux当中的位置</span></span><br><span class="line"><span class="comment"># into table 'tb_user_1' 加载数据到具体表tb_user_1当中</span></span><br><span class="line"><span class="comment"># fields terminated by ',' 每一个域之间使用逗号,进行分隔</span></span><br><span class="line"><span class="comment"># lines terminated by '\n' 每一行之间使用\n进行分隔,也就是换行</span></span><br><span class="line"><span class="comment"># 回车之后，在导入数据的过程当中，还需要去进行维护索引，维护唯一索引；unique；</span></span><br><span class="line"><span class="comment"># sql1.log导入到tb_user_1表当中耗费时间为19.37 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_user_1;<span class="comment"># 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> <span class="keyword">infile</span> <span class="string">'/root/sql2.log'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">'tb_user_2'</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">#回车之后，耗费的时间为 1min 51.42 second；和sql1.log导入tb_user_1时差距很大；  </span></span><br><span class="line"><span class="comment">#所以这样就验证了大批量导入数据时，有序数据导入表当中时耗费的时间小于无序数据导入表当中的时间；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_user_2;<span class="comment"># 1000000</span></span><br></pre></td></tr></table></figure><p><strong>（2）</strong> <strong>关闭唯一性校验</strong>  </p><p>在<strong>导入数据前</strong>执行 <strong>SET UNIQUE_CHECKS=0</strong> ，<strong>关闭唯一性校验</strong>，<br>在<strong>导入结束后</strong>执行 <strong>SET UNIQUE_CHECKS=1</strong>，<strong>恢复唯一性校验</strong>，可以<strong>提高导入的效率</strong>。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在tb_user_1表结构当中存在username字段的唯一性索引；如果存在唯一性索引则在插入数据的时候是需要对唯一性字段数据的取值进行校验的；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> infiles <span class="string">'/root/sql1.log'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">'tb_user_1'</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">#耗费时长为 19.39 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>（3）</strong> <strong>手动提交事务</strong>  </p><p>如果应用使用<strong>自动提交</strong>的方式，<br>建议在<strong>导入前</strong>执行 <strong>SET AUTOCOMMIT=0</strong>，<strong>关闭自动提交</strong>，<br><strong>导入结束后</strong>再执行 <strong>SET AUTOCOMMIT=1</strong>；<strong>打开自动提交</strong>，也可以<strong>提高导入的效率</strong>。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> infiles <span class="string">'/root/sql1.log'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">'tb_user_1'</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">#耗费时长为 19.58 second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_user_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="SQL优化-insert优化"><a href="#SQL优化-insert优化" class="headerlink" title="SQL优化 - insert优化"></a>SQL优化 - insert优化</h2><p><strong>优化insert语句</strong>  </p><p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。  </p><ul><li><p>如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。<br>使得效率比分开执行的单个insert语句块。<br>示例，原始方式为：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'cat'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Jerry'</span>);</span><br></pre></td></tr></table></figure><p>优化后的方案为：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'tom'</span>),(<span class="number">2</span>,<span class="string">'cat'</span>),(<span class="number">3</span>,<span class="string">'Jerry'</span>);</span><br></pre></td></tr></table></figure></li><li><p>在<strong>事务中</strong>进行数据插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'cat'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Jerry'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li><p>数据<strong>有序插入</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'Tim'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'cat'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'Rose'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Jerry'</span>);</span><br></pre></td></tr></table></figure><p>优化后：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'Tim'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'cat'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'Rose'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'Jerry'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="SQL优化-orderby优化"><a href="#SQL优化-orderby优化" class="headerlink" title="SQL优化 - orderby优化"></a>SQL优化 - orderby优化</h2><p><strong>优化 order by 语句</strong>  </p><p><strong>环境准备</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">'emp'</span>(</span><br><span class="line">  <span class="string">'id'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">'name'</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'age'</span> <span class="built_in">int</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">'salary'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="string">'id'</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> DEAFULT <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">#基础数据插入</span></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_emp_age_salary <span class="keyword">on</span> emp(age,salary);<span class="comment">#建立age、salary字段的复合索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">#PRIMARY 主键索引</span></span><br><span class="line"><span class="comment">#idx_emp_age_salary age 复合索引</span></span><br><span class="line"><span class="comment">#idx_emp_age_salary salary 复合索引</span></span><br></pre></td></tr></table></figure><p><strong>两种排序方式</strong>  </p><p><strong>（1）</strong> <strong>第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫做 FileSort排序</strong>。  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age;#key:<span class="keyword">NULL</span>；key_len:<span class="keyword">NULL</span>；Extra：<span class="keyword">Using</span> filesort;<span class="keyword">type</span>:<span class="keyword">ALL</span> 没有走索引，全表扫描（升序）</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age,salary;#key:<span class="keyword">NULL</span>；key_len:<span class="keyword">NULL</span>；Extra：<span class="keyword">Using</span> filesort;<span class="keyword">type</span>:<span class="keyword">ALL</span> 没有走索引，全表扫描（升序）</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;#key:<span class="keyword">NULL</span>；key_len:<span class="keyword">NULL</span>；Extra：<span class="keyword">Using</span> filesort;<span class="keyword">type</span>:<span class="keyword">ALL</span> 没有走索引，全表扫描（降序）</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>,salary <span class="keyword">desc</span>;#key:<span class="keyword">NULL</span>；key_len:<span class="keyword">NULL</span>；Extra：<span class="keyword">Using</span> filesort;<span class="keyword">type</span>:<span class="keyword">ALL</span> 没有走索引，全表扫描（降序）</span><br><span class="line"></span><br><span class="line">#通过file sort 文件系统进行排序，效率较低</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;#<span class="keyword">type</span>：<span class="keyword">ALL</span>，key：<span class="keyword">NULL</span>；key_len:<span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;#<span class="keyword">type</span>：<span class="keyword">ALL</span>，key：<span class="keyword">NULL</span>；key_len:<span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><p><strong>（2）</strong> <strong>第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</strong>。  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;#走索引；key：idx_age_salary；key_len:<span class="number">9</span>；Extra：<span class="keyword">Using</span> <span class="keyword">index</span> 走索引</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id,age <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;#走索引；key：idx_age_salary；key_len:<span class="number">9</span>；Extra：<span class="keyword">Using</span> <span class="keyword">index</span> 走索引</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id,age,salary <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;#走索引；key：idx_age_salary；key_len:<span class="number">9</span>；Extra：<span class="keyword">Using</span> <span class="keyword">index</span> 走索引</span><br><span class="line">#覆盖索引的用法；查询<span class="keyword">select</span> 的字段都是覆盖索引则这个时候使用的即为<span class="keyword">using</span> <span class="keyword">index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id,age,salary,<span class="type">name</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;#走索引；key：<span class="keyword">NULL</span>；key_len:<span class="keyword">NULL</span>；<span class="keyword">type</span>:<span class="keyword">ALL</span>；Extra：<span class="keyword">Using</span> filesort 全表扫描；由于查询的字段当中包含了非索引字段；即并未覆盖索引；所以走全表扫描的方式；id、age、salary这三个字段都有索引；而<span class="type">name</span>字段没有索引；</span><br></pre></td></tr></table></figure><p><strong>多字段排序</strong>  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id ,age,salary <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age,salary;#key:idx_age_salary;key_len:<span class="number">9</span>;Extra:<span class="keyword">Using</span> <span class="keyword">index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id ,age,salary <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>,salary <span class="keyword">asc</span>;#key:idx_age_salary;key_len:<span class="number">9</span>;Extra:<span class="keyword">Using</span> <span class="keyword">index</span>(<span class="keyword">order</span> <span class="keyword">by</span> 如不标明<span class="keyword">desc</span>或者<span class="keyword">asc</span>;默认为<span class="keyword">asc</span>升序排序)</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id,age,salary <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>,salary <span class="keyword">desc</span>;#key:idx_age_salary;key_len:<span class="number">9</span>;Extra:<span class="keyword">Using</span> <span class="keyword">index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id,age,salary <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>,salary <span class="keyword">desc</span>;#key:idx_age_salary;key_len:<span class="number">9</span>;Extra:<span class="keyword">Using</span> <span class="keyword">index</span>;<span class="keyword">Using</span> filesort此时就会出现Filesort</span><br><span class="line"></span><br><span class="line"># 即在使用<span class="keyword">order</span> <span class="keyword">by</span>进行多字段排序的时候，如果想要效率较高；那么此时最好这些多字段统一排序方式；要么都是升序要么都是降序；如果出现一升一降那么就会出现Filesort；文件系统排序造成效率低；</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id,age,salary <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">asc</span>,age <span class="keyword">asc</span>;#key:idx_age_salary;key_len:<span class="number">9</span>;Extra:<span class="keyword">Using</span> <span class="keyword">index</span>;<span class="keyword">Using</span> filesort；此时将age <span class="keyword">asc</span>进行了调后处理；也出现了Filesort</span><br><span class="line">#原因在于：</span><br><span class="line">#按照多字段进行排序，要么统一进行升序<span class="keyword">asc</span>要么统一进行降序排序；</span><br><span class="line">#如果按照多字段进行排序，那么排序的顺序需要和复合索引当中的字段顺序要保持一致；</span><br><span class="line">#复合索引为idx_emp_age_salary（age，salary）复合索引当中age字段的索引顺序先于salary字段的顺序；</span><br><span class="line">#而此时<span class="keyword">SQL</span>当中<span class="keyword">order</span> <span class="keyword">by</span>语句多字段排序salary字段先于age字段；所以此时Extra当中就出现了<span class="keyword">using</span> <span class="keyword">index</span>；也出现了<span class="keyword">using</span> filesort;</span><br></pre></td></tr></table></figure><p>了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。  </p><p>where条件和Order by 使用相同的索引并且Order by 的顺序和索引顺序相同，并且Order by的字段都是升序，或者都是降序。  </p><p>否则肯定需要额外的操作，这样就会出现FileSort排序；  </p><h3 id="Filesort的优化"><a href="#Filesort的优化" class="headerlink" title="Filesort的优化"></a>Filesort的优化</h3><p><strong>尽可能避免Filesort</strong>的出现，但是无法完全避免Filesort的出现；  </p><p>通过创建合适的索引，能够减少Filesort的出现。  </p><p>但是在某些情况下，条件限制不能让Filesort小时，那就需要加快Filesort的排序操作，对于Filesort，MySQL有两种排序算法：  </p><p>（1）两次扫描算法：MySQL4.1之前，使用该方式排序。<br>    首先，根据条件取出排序字段和行指针信息，然后在排序区 sort buffer中排序；<br>    如果sort buffer不够，则在临时表 temporary table中存储排序结果。<br>    完成排序之后，再根据航指针回表读取记录，该操作可能会导致大量随机I/O操作。  </p><p>（2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区sort buffer中排序后直接输出结果集。<br>    排序时内存开销较大，但是排序效率比两次扫描算法要高；  </p><p>MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query 语句取出的字段总大小，来判定合适哪一种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种；  </p><p>可以适当提高 sort_buffer_size和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'max_length_for_sort_data'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>max_length_for_sort_data</td>    <td>1024</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'sort_buffer_size'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>Variable_name</th>    <th>Value</th>  </tr>  <tr>    <td>sort_buffer_size</td>    <td>262144</td>  </tr></table><h2 id="SQL优化-group-by优化"><a href="#SQL优化-group-by优化" class="headerlink" title="SQL优化 - group by优化"></a>SQL优化 - group by优化</h2><p>由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY相比，GROUP BY主要只是多了排序字后的分组操作。  </p><p>当然如果在分组的时候还是用了其他的一些聚合函数，那么还需要一些聚合函数的计算。  </p><p>所以，在GROUP BY的实现过程中，与ORDER BY一样也可以利用到索引。  </p><p>如果查询包含GROUP BY，但是用户想要避免排序结果的消耗，则可以执行order by null 禁止排序。  </p><p>如下：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> idx_emp_age_salary <span class="keyword">on</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> age,count(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age;#key:<span class="keyword">NULL</span>,key_len:<span class="keyword">NULL</span>;<span class="keyword">type</span>:<span class="keyword">ALL</span>;Extra:<span class="keyword">Using</span> <span class="keyword">temporary</span>;<span class="keyword">Using</span> filesort; 由此可以看出<span class="keyword">GROUP</span> <span class="keyword">BY</span> 底层进行了排序操作；<span class="keyword">Using</span> filesort</span><br><span class="line"><span class="meta">#Using temporary与Using Filesort都是比较耗时的操作；</span></span><br></pre></td></tr></table></figure><p>优化后：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> age,count(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span>;#key:<span class="keyword">null</span>;key_len:<span class="keyword">null</span>;<span class="keyword">type</span>:<span class="keyword">All</span>;Extra:<span class="keyword">Using</span> <span class="keyword">temporary</span>;此时就没有<span class="keyword">Using</span> filesort了</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出，第一个SQL语句需要进行“Filesort”，而第二个SQL语句由于order by null不需要进行“Filesort”，而上文提过FileSort往往非常耗费时间。  </p><p> 创建索引：  </p> <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_emp_age_salary  <span class="keyword">on</span> emp(age,salary);</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> age,<span class="built_in">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">order</span> <span class="keyword">by</span> <span class="literal">null</span>;#key:idx_emp_age_salary;key_len:9;extra:using <span class="keyword">index</span> 此时走索引；</span><br><span class="line">#<span class="keyword">group</span> <span class="keyword">by</span>语句也是可以通过索引来提高效率的；</span><br></pre></td></tr></table></figure><h2 id="SQL优化-子查询优化"><a href="#SQL优化-子查询优化" class="headerlink" title="SQL优化 - 子查询优化"></a>SQL优化 - 子查询优化</h2><p><strong>优化嵌套查询</strong>  </p><p>MySQL4.1 版本之后，开始支持SQL的子查询。  </p><p>这个技术可以使用select语句来创建一个单列的查询结果，然后吧这个结果来作为过滤条件用在另一个查询当中。  </p><p>使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。  </p><p>但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。(使用多表连接查询来替换子查询)  </p><p>示例，查找有角色的所有用户信息：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;<span class="comment"># t_user 用户表 , t_role 角色表 , user_role 用户角色中间表 ；</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> ( <span class="keyword">select</span> user_id <span class="keyword">from</span> user_role);</span><br></pre></td></tr></table></figure><p>执行计划为：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> user_id <span class="keyword">from</span> user_role);</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>t_user</td>    <td>ALL</td>    <td>PRIMARY</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>6</td>    <td>Using where</td>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>< subquery2></td>    <td>eq_ref</td>    <td>< auto_key></td>    <td>< auto_key></td>    <td>99</td>    <td>demo_02.t_user.id</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>2</td>    <td>MATERIALIZED</td>    <td>user_role</td>    <td>index</td>    <td>fk_ur_user_id</td>    <td>fk_ur_user_id</td>    <td>99</td>    <td>NULL</td>    <td>6</td>    <td>Using index</td>  </tr></table><p>优化后：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user u,user_role ur <span class="keyword">where</span> u.id=ur.user_id;<span class="comment">#多表联查替代子查询</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>u</td>    <td>ALL</td>    <td>PRIMARY</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>6</td>    <td>NULL</td>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>ur</td>    <td>ref(ref的效率比index效率高)</td>    <td>fk_ur_user_id</td>    <td>fk_ur_user_id</td>    <td>99</td>    <td>demo_02.u.id</td>    <td>1</td>    <td>NULL</td>  </tr></table><h2 id="SQL优化-or优化"><a href="#SQL优化-or优化" class="headerlink" title="SQL优化 - or优化"></a>SQL优化 - or优化</h2><p><strong>对于包含 OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引，而且不能使用到复合索引；如果没有索引，则应该考虑增加索引</strong>。  </p><p>获取emp表中的所有的索引；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">show</span> index <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line">explain <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="built_in">where</span> id=<span class="number">1</span> <span class="built_in">or</span> name='Tom;#id为主键，即存在主键索引；而name字段没有设置索引；所以此时用<span class="built_in">or</span>来连接两个条件时，当中包含有一个非索引字段；所以不会走索引,索引失效，采用的是全表扫描；<span class="built_in">key</span>:NULL;key_len:NULL;<span class="built_in">type</span>:ALL;extra:Using <span class="built_in">where</span>；<span class="built_in">or</span>关键字如果想要走索引则<span class="built_in">or</span>连接的条件列字段需要是索引列；从而能够走索引否则全表扫描不走索引；</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="built_in">where</span> age=<span class="number">20</span> <span class="built_in">or</span> salary=<span class="number">3500</span>;#<span class="built_in">key</span>:NULL,key_len:NULL;<span class="built_in">type</span>;All;extra:Using <span class="built_in">where</span>;此时未走索引；age与salary为复合索引当中的索引列；而<span class="built_in">or</span>关键字所连接的条件列当中字段的索引不能为复合索引列；可以为主键索引列、唯一索引列、单列索引等；就是不能为复合索引列其他皆可；</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="built_in">where</span> id=<span class="number">1</span> <span class="built_in">or</span> age=<span class="number">30</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>t_user</td>    <td>ALL</td>    <td>PRIMARY</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>6</td>    <td>Using where</td>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>emp</td>    <td>index_merge</td>    <td>PRIMARY,idx_emp_age_salary</td>    <td>PRIMARY,idx_emp_age_salary</td>    <td>4,4</td>    <td>NULL</td>    <td>2</td>    <td>Using sort_union(idx_emp_age_salary,PRIMARY);Using where</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">or</span> <span class="keyword">id</span>=<span class="number">10</span> \G;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>emp</td>    <td>range</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>4</td>    <td>NULL</td>    <td>2</td>    <td>Using where</td>  </tr></table><p>建议使用 union 替换 or；  </p><p>优化：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">10</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>emp</td>    <td>const(const效率远高于range)</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>4</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>2</td>    <td>UNION</td>    <td>emp</td>    <td>const</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>4</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>NULL</td>    <td>UNION RESULT</td>    <td>< union1,2></td>    <td>ALL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>Using temporary</td>  </tr></table><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">explain select * from emp where id=<span class="number">1</span> or age=<span class="number">20</span>;</span><br><span class="line"><span class="meta">#id 1</span></span><br><span class="line"><span class="meta">#select_type SIMPLE</span></span><br><span class="line"><span class="meta">#table emp</span></span><br><span class="line"><span class="meta">#possible_key PRIMARY,idx_emp_age_salary</span></span><br><span class="line"><span class="meta">#key idx_emp_age_salary,PRIMARY</span></span><br><span class="line"><span class="meta">#key_len 4,4</span></span><br><span class="line"><span class="meta">#ref NULL</span></span><br><span class="line"><span class="meta">#rows 2</span></span><br><span class="line"><span class="meta">#extra Using sort_union(idx_emp_age_salary,PRIMARY)</span></span><br><span class="line"><span class="meta">#type index_merge</span></span><br></pre></td></tr></table></figure><p>优化：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> age=<span class="number">20</span>;</span><br><span class="line"><span class="comment">#union即为一个求并集的一个操作；</span></span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>emp</td>    <td>const(const效率远高于range)</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>4</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>2</td>    <td>UNION</td>    <td>emp</td>    <td>ref(ref比index_merge效率高)</td>    <td>idx_emp_age_salary</td>    <td>idx_emp_age_salary</td>    <td>4</td>    <td>const</td>    <td>1</td>    <td>NULL</td>  </tr>  <tr>    <td>NULL</td>    <td>UNION RESULT</td>    <td>< union1,2></td>    <td>ALL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>Using temporary</td>  </tr></table><p>建议通过union替换or；<br>来比较下重要指标，发现主要差别是type和ref这两项；<br>type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="keyword">ref</span> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; uniqe_subquery &gt; index_subquery &gt; range &gt; <span class="keyword">index</span> &gt; <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><p>UNION语句的type值为ref，OR语句的type值为range，可以看到这是一个很明显的差距  </p><p>UNION语句的ref值为const，OR语句的type值为NULL，const表示是常量值引用，非常快  </p><p>这两项的差距就说明了UNION要优于OR；</p><h2 id="SQL优化-limit优化"><a href="#SQL优化-limit优化" class="headerlink" title="SQL优化 - limit优化"></a>SQL优化 - limit优化</h2><h3 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h3><p>一般分页查询时，通过创建覆盖索引能够比较好的提高性能。  </p><p>一个常见又非常头疼的问题就是 limit 2000000,10;   此时需要MySQL排序前2000010记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大。  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">limit</span> <span class="number">2000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_item</td>    <td>ALL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>9816098</td>    <td>NULL</td>  </tr></table><h3 id="优化思路一"><a href="#优化思路一" class="headerlink" title="优化思路一"></a>优化思路一</h3><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slect count(*) from tb_item;#3000000</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">limit</span> <span class="number">10</span>,<span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">limit</span> <span class="number">20</span>,<span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">limit</span> <span class="number">2000000</span>,<span class="number">10</span>;#查询效率低 此时为全表扫描没有使用得到索引；</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item t, (<span class="keyword">select</span> id <span class="keyword">from</span> tb_item <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">limit</span> <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">where</span> t.id=a.id;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>< derived2></td>    <td>ALL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>NULL</td>    <td>2000010</td>    <td>NULL</td>  </tr>  <tr>    <td>1</td>    <td>PRIMARY</td>    <td>t</td>    <td>eq_ref</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>4</td>    <td>a.id</td>    <td>1</td>    <td>NULL</td>  </tr>    <tr>    <td>2</td>    <td>DERIVED</td>    <td>tb_item</td>    <td>index</td>    <td>NULL</td>    <td>PRIMARY</td>    <td>4</td>    <td>NULL</td>    <td>2903274</td>    <td>Using index</td>  </tr></table><h3 id="优化思路二"><a href="#优化思路二" class="headerlink" title="优化思路二"></a>优化思路二</h3><p>该方案适用于<strong>主键自增的表(且主键自增的列不能够出现断层)</strong>，可以把limit 查询转换成某个位置的查询；  </p><p><strong>断层</strong>：即指的是当在查询数据时，id主键自增列当中可能会有出现修改或者删除的操作，那么这个时候数据就不一定准确了；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">1000000</span> <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_item</td>    <td>range</td>    <td>PRIMARY</td>    <td>PRIMARY</td>    <td>4</td>    <td>NULL</td>    <td>4908049</td>    <td>Using where</td>  </tr></table><h2 id="SQL优化-索引提示"><a href="#SQL优化-索引提示" class="headerlink" title="SQL优化 - 索引提示"></a>SQL优化 - 索引提示</h2><p><strong>使用SQL提示</strong>  </p><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。  </p><h3 id="USE-INDEX"><a href="#USE-INDEX" class="headerlink" title="USE INDEX"></a>USE INDEX</h3><p>在查询语句中 表名称的后面 ，添加 use index 来提供希望MySQL去<strong>参考</strong>的索引列表，就可以让MySQL不再考虑其他可用的索引。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> tb_seller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_name <span class="keyword">on</span> tb_seller(<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_status <span class="keyword">on</span> tb_seller(<span class="keyword">status</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_name_sta_addr <span class="keyword">on</span> tb_seller(<span class="keyword">name</span>,<span class="keyword">status</span>,address);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_seller</td>    <td>ref</td>    <td>idx_seller_name_sta_address,idx_seller_name</td>    <td>idx_seller_name(数据库选择使用idx_seller_name索引)</td>    <td>403</td>    <td>const</td>    <td>1</td>    <td>Using index condition</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">use</span> <span class="keyword">index</span>(idx_seller_name_sta_address) <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'小米科技'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_seller</td>    <td>ref</td>    <td>idx_seller_name_sta_address</td>    <td>idx_seller_name_sta_address</td>    <td>403</td>    <td>const</td>    <td>1</td>    <td>Using index condition</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">use</span> <span class="keyword">index</span>(idx_seller_name) <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'小米科技'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_seller</td>    <td>ref</td>    <td>idx_seller_name</td>    <td>idx_seller_name</td>    <td>403</td>    <td>const</td>    <td>1</td>    <td>Using index condition</td>  </tr></table><h3 id="IGNORE-INDEX"><a href="#IGNORE-INDEX" class="headerlink" title="IGNORE INDEX"></a>IGNORE INDEX</h3><p>如果用户只是单纯的想让MySQL<strong>忽略</strong>一个或者多个索引，则可以使用 ignore index 作为 hint；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">ignore</span> <span class="keyword">index</span>(idx_seller_name) <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'小米科技'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_seller</td>    <td>ref</td>    <td>idx_seller_name_sta_address</td>    <td>idx_seller_name_sta_address</td>    <td>403</td>    <td>const</td>    <td>1</td>    <td>Using index condition</td>  </tr></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">ignore</span> <span class="keyword">index</span>(idx_seller_name_sta_address) <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_seller</td>    <td>ref</td>    <td>idx_seller_name</td>    <td>idx_seller_name</td>    <td>403</td>    <td>const</td>    <td>1</td>    <td>Using index condition</td>  </tr></table><h3 id="FORCE-INDEX"><a href="#FORCE-INDEX" class="headerlink" title="FORCE INDEX"></a>FORCE INDEX</h3><p>为了<strong>强制</strong>MySQL使用一个特定的索引，可在查询中使用 force index 来作为 hint;</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address=<span class="string">'北京市'</span>;#实际没有使用到索引；<span class="keyword">type</span>:<span class="keyword">all</span>;key:<span class="keyword">null</span>;key_len:<span class="keyword">null</span>;extra:<span class="keyword">using</span> <span class="keyword">where</span>使用的是全表扫描；原因在于address为北京市时在表当中占比较多所以由mysql底层判断决定不走索引即全表扫描会快于走索引；所以此处没有使用得到索引；</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller use <span class="keyword">index</span>(idx_seller_address) <span class="keyword">where</span> address=<span class="string">'北京市'</span>;#此时则走索引</span><br></pre></td></tr></table></figure><table>  <tr>    <th>id</th>    <th>select_type</th>    <th>table</th>    <th>type</th>    <th>possible_key</th>    <th>key</th>    <th>key_len</th>    <th>ref</th>    <th>rows</th>    <th>Extra</th>  </tr>  <tr>    <td>1</td>    <td>SIMPLE</td>    <td>tb_seller</td>    <td>ALL</td>    <td>idx_seller_address</td>    <td>idx_seller_address</td>    <td>NULL</td>    <td>NULL</td>    <td>12</td>    <td>Using where</td>  </tr></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看笔记：&lt;code&gt;https://www.bilibili.com/video/BV1fJ41127Rj?from=search&amp;amp
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="MySQL" scheme="https://fengshana.github.io/tags/MySQL/"/>
    
      <category term="数据库优化" scheme="https://fengshana.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>史上最好~精通Spring Boot Cloud - 圣思园</title>
    <link href="https://fengshana.github.io/2020/05/29/%E3%80%90Spring%E3%80%91/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%A5%BD~%E7%B2%BE%E9%80%9ASpring%20Boot%20Cloud%20-%20%E5%9C%A3%E6%80%9D%E5%9B%AD/"/>
    <id>https://fengshana.github.io/2020/05/29/%E3%80%90Spring%E3%80%91/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%A5%BD~%E7%B2%BE%E9%80%9ASpring%20Boot%20Cloud%20-%20%E5%9C%A3%E6%80%9D%E5%9B%AD/</id>
    <published>2020-05-29T11:04:48.100Z</published>
    <updated>2020-06-05T17:53:31.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：<code>https://www.bilibili.com/video/BV1Eg4y187XT</code>  </p><h2 id="学习方法谈心"><a href="#学习方法谈心" class="headerlink" title="学习方法谈心"></a>学习方法谈心</h2><h2 id="SpringBoot与Cloud整体介绍"><a href="#SpringBoot与Cloud整体介绍" class="headerlink" title="SpringBoot与Cloud整体介绍"></a>SpringBoot与Cloud整体介绍</h2><h2 id="课程大纲深入解读与剖析"><a href="#课程大纲深入解读与剖析" class="headerlink" title="课程大纲深入解读与剖析"></a>课程大纲深入解读与剖析</h2><h2 id="微服务重要概念与权威解读"><a href="#微服务重要概念与权威解读" class="headerlink" title="微服务重要概念与权威解读"></a>微服务重要概念与权威解读</h2><h2 id="解读微服务重要论文"><a href="#解读微服务重要论文" class="headerlink" title="解读微服务重要论文"></a>解读微服务重要论文</h2><h2 id="深刻解读Martin-Fowler微服务经典文章"><a href="#深刻解读Martin-Fowler微服务经典文章" class="headerlink" title="深刻解读Martin Fowler微服务经典文章"></a>深刻解读Martin Fowler微服务经典文章</h2><h2 id="微服务数据治理与去中心化解读"><a href="#微服务数据治理与去中心化解读" class="headerlink" title="微服务数据治理与去中心化解读"></a>微服务数据治理与去中心化解读</h2><h2 id="微服务演进式设计与优缺点剖析"><a href="#微服务演进式设计与优缺点剖析" class="headerlink" title="微服务演进式设计与优缺点剖析"></a>微服务演进式设计与优缺点剖析</h2><h2 id="微服务宏观把控与深度剖析"><a href="#微服务宏观把控与深度剖析" class="headerlink" title="微服务宏观把控与深度剖析"></a>微服务宏观把控与深度剖析</h2><h2 id="SOA理论与概念深入剖析"><a href="#SOA理论与概念深入剖析" class="headerlink" title="SOA理论与概念深入剖析"></a>SOA理论与概念深入剖析</h2><h2 id="服务定义概念与原则"><a href="#服务定义概念与原则" class="headerlink" title="服务定义概念与原则"></a>服务定义概念与原则</h2><h2 id="SOA实现方式与模式"><a href="#SOA实现方式与模式" class="headerlink" title="SOA实现方式与模式"></a>SOA实现方式与模式</h2><h2 id="SOA的缺陷及其与微服务的关系"><a href="#SOA的缺陷及其与微服务的关系" class="headerlink" title="SOA的缺陷及其与微服务的关系"></a>SOA的缺陷及其与微服务的关系</h2><h2 id="SOA与微服务本质比较与透彻分析"><a href="#SOA与微服务本质比较与透彻分析" class="headerlink" title="SOA与微服务本质比较与透彻分析"></a>SOA与微服务本质比较与透彻分析</h2><h2 id="SpringBoot应用起步与配置"><a href="#SpringBoot应用起步与配置" class="headerlink" title="SpringBoot应用起步与配置"></a>SpringBoot应用起步与配置</h2><h2 id="SpringBoot应用配置分析与拆解"><a href="#SpringBoot应用配置分析与拆解" class="headerlink" title="SpringBoot应用配置分析与拆解"></a>SpringBoot应用配置分析与拆解</h2><h2 id="SpringBoot打包文件内容与结构深入分析"><a href="#SpringBoot打包文件内容与结构深入分析" class="headerlink" title="SpringBoot打包文件内容与结构深入分析"></a>SpringBoot打包文件内容与结构深入分析</h2><h2 id="使用Gradle构建SpringBoot应用"><a href="#使用Gradle构建SpringBoot应用" class="headerlink" title="使用Gradle构建SpringBoot应用"></a>使用Gradle构建SpringBoot应用</h2><h2 id="SpringBoot参数自动装配与loader机制详细分析"><a href="#SpringBoot参数自动装配与loader机制详细分析" class="headerlink" title="SpringBoot参数自动装配与loader机制详细分析"></a>SpringBoot参数自动装配与loader机制详细分析</h2><h2 id="SpringBootLoader源码分析及自定义类加载器作用分析"><a href="#SpringBootLoader源码分析及自定义类加载器作用分析" class="headerlink" title="SpringBootLoader源码分析及自定义类加载器作用分析"></a>SpringBootLoader源码分析及自定义类加载器作用分析</h2><h2 id="LaunchedURLClassLoader在FatJar中的重要作用分析及反射的经典应用"><a href="#LaunchedURLClassLoader在FatJar中的重要作用分析及反射的经典应用" class="headerlink" title="LaunchedURLClassLoader在FatJar中的重要作用分析及反射的经典应用"></a>LaunchedURLClassLoader在FatJar中的重要作用分析及反射的经典应用</h2><h2 id="JDWP远程调试详解"><a href="#JDWP远程调试详解" class="headerlink" title="JDWP远程调试详解"></a>JDWP远程调试详解</h2><h2 id="调试spring-boot-loader的启动与加载全流程"><a href="#调试spring-boot-loader的启动与加载全流程" class="headerlink" title="调试spring-boot-loader的启动与加载全流程"></a>调试spring-boot-loader的启动与加载全流程</h2><h2 id="SpringBootApplication注解深度解析"><a href="#SpringBootApplication注解深度解析" class="headerlink" title="@SpringBootApplication注解深度解析"></a>@SpringBootApplication注解深度解析</h2><h2 id="Configuration注解深入讲解"><a href="#Configuration注解深入讲解" class="headerlink" title="@Configuration注解深入讲解"></a>@Configuration注解深入讲解</h2><h2 id="SpringApplication源码分析与作用详解"><a href="#SpringApplication源码分析与作用详解" class="headerlink" title="SpringApplication源码分析与作用详解"></a>SpringApplication源码分析与作用详解</h2><h2 id="SpringBoot应用启动流程源码分析"><a href="#SpringBoot应用启动流程源码分析" class="headerlink" title="SpringBoot应用启动流程源码分析"></a>SpringBoot应用启动流程源码分析</h2><h2 id="SpringBoot启动流程分析"><a href="#SpringBoot启动流程分析" class="headerlink" title="SpringBoot启动流程分析"></a>SpringBoot启动流程分析</h2><h2 id="SpringApplication泛化与具体模式剖析"><a href="#SpringApplication泛化与具体模式剖析" class="headerlink" title="SpringApplication泛化与具体模式剖析"></a>SpringApplication泛化与具体模式剖析</h2><h2 id="工厂加载机制详尽分析"><a href="#工厂加载机制详尽分析" class="headerlink" title="工厂加载机制详尽分析"></a>工厂加载机制详尽分析</h2><h2 id="工厂缓存源码深度解析"><a href="#工厂缓存源码深度解析" class="headerlink" title="工厂缓存源码深度解析"></a>工厂缓存源码深度解析</h2><h2 id="Spring工厂Bean加载过程深度解析"><a href="#Spring工厂Bean加载过程深度解析" class="headerlink" title="Spring工厂Bean加载过程深度解析"></a>Spring工厂Bean加载过程深度解析</h2><h2 id="SpringApplication构造过程全景分析"><a href="#SpringApplication构造过程全景分析" class="headerlink" title="SpringApplication构造过程全景分析"></a>SpringApplication构造过程全景分析</h2><h2 id="ApplicationContext中央化组件作用详解"><a href="#ApplicationContext中央化组件作用详解" class="headerlink" title="ApplicationContext中央化组件作用详解"></a>ApplicationContext中央化组件作用详解</h2><h2 id="SpringApplicationRunListeners监听器容器详解"><a href="#SpringApplicationRunListeners监听器容器详解" class="headerlink" title="SpringApplicationRunListeners监听器容器详解"></a>SpringApplicationRunListeners监听器容器详解</h2><h2 id="观察着模式在SpringBoot中的经典应用"><a href="#观察着模式在SpringBoot中的经典应用" class="headerlink" title="观察着模式在SpringBoot中的经典应用"></a>观察着模式在SpringBoot中的经典应用</h2><h2 id="Environment组件的重要作用详解"><a href="#Environment组件的重要作用详解" class="headerlink" title="Environment组件的重要作用详解"></a>Environment组件的重要作用详解</h2><h2 id="Banner信息输出与定制内幕分析"><a href="#Banner信息输出与定制内幕分析" class="headerlink" title="Banner信息输出与定制内幕分析"></a>Banner信息输出与定制内幕分析</h2><h2 id="SpringBoot完整启动流程系统化总结"><a href="#SpringBoot完整启动流程系统化总结" class="headerlink" title="SpringBoot完整启动流程系统化总结"></a>SpringBoot完整启动流程系统化总结</h2><h2 id="SpringBoot重要模块详解"><a href="#SpringBoot重要模块详解" class="headerlink" title="SpringBoot重要模块详解"></a>SpringBoot重要模块详解</h2><h2 id="SpringBoot日志处理详解"><a href="#SpringBoot日志处理详解" class="headerlink" title="SpringBoot日志处理详解"></a>SpringBoot日志处理详解</h2><h2 id="SpringBoot整合JSP详解"><a href="#SpringBoot整合JSP详解" class="headerlink" title="SpringBoot整合JSP详解"></a>SpringBoot整合JSP详解</h2><h2 id="SpringBoot整合WebSocket详解"><a href="#SpringBoot整合WebSocket详解" class="headerlink" title="SpringBoot整合WebSocket详解"></a>SpringBoot整合WebSocket详解</h2><h2 id="SpringBoot整合SockJS详解"><a href="#SpringBoot整合SockJS详解" class="headerlink" title="SpringBoot整合SockJS详解"></a>SpringBoot整合SockJS详解</h2><h2 id="SpringBoot开发者工具与单元测试详解"><a href="#SpringBoot开发者工具与单元测试详解" class="headerlink" title="SpringBoot开发者工具与单元测试详解"></a>SpringBoot开发者工具与单元测试详解</h2><h2 id="Apache-Kafka介绍与面向MQ编程模式详解"><a href="#Apache-Kafka介绍与面向MQ编程模式详解" class="headerlink" title="Apache Kafka介绍与面向MQ编程模式详解"></a>Apache Kafka介绍与面向MQ编程模式详解</h2><h2 id="Apache-Kafka核心API与设计理念详解"><a href="#Apache-Kafka核心API与设计理念详解" class="headerlink" title="Apache Kafka核心API与设计理念详解"></a>Apache Kafka核心API与设计理念详解</h2><h2 id="Apache-Kafka分区副本与消费者组详解"><a href="#Apache-Kafka分区副本与消费者组详解" class="headerlink" title="Apache Kafka分区副本与消费者组详解"></a>Apache Kafka分区副本与消费者组详解</h2><h2 id="Apache-Kafka流式处理详解"><a href="#Apache-Kafka流式处理详解" class="headerlink" title="Apache Kafka流式处理详解"></a>Apache Kafka流式处理详解</h2><h2 id="Apache-Kafka生产者与消费者实例演示与解析"><a href="#Apache-Kafka生产者与消费者实例演示与解析" class="headerlink" title="Apache Kafka生产者与消费者实例演示与解析"></a>Apache Kafka生产者与消费者实例演示与解析</h2><h2 id="Apache-Kafka重点内容剖析与回顾"><a href="#Apache-Kafka重点内容剖析与回顾" class="headerlink" title="Apache Kafka重点内容剖析与回顾"></a>Apache Kafka重点内容剖析与回顾</h2><h2 id="Apache-Kafka分区构成与原则详解"><a href="#Apache-Kafka分区构成与原则详解" class="headerlink" title="Apache Kafka分区构成与原则详解"></a>Apache Kafka分区构成与原则详解</h2><h2 id="Apache-Kafka分区理论与作用详解"><a href="#Apache-Kafka分区理论与作用详解" class="headerlink" title="Apache Kafka分区理论与作用详解"></a>Apache Kafka分区理论与作用详解</h2><h2 id="Apache-Kafka分区与段之间的关系深入详解"><a href="#Apache-Kafka分区与段之间的关系深入详解" class="headerlink" title="Apache Kafka分区与段之间的关系深入详解"></a>Apache Kafka分区与段之间的关系深入详解</h2><h2 id="Apache-Kafka日志文件格式详解"><a href="#Apache-Kafka日志文件格式详解" class="headerlink" title="Apache Kafka日志文件格式详解"></a>Apache Kafka日志文件格式详解</h2><h2 id="Apache-Kafka脚本命令实战详解"><a href="#Apache-Kafka脚本命令实战详解" class="headerlink" title="Apache Kafka脚本命令实战详解"></a>Apache Kafka脚本命令实战详解</h2><h2 id="Apache-Kafka消费者组操作与主题删除原理详解"><a href="#Apache-Kafka消费者组操作与主题删除原理详解" class="headerlink" title="Apache Kafka消费者组操作与主题删除原理详解"></a>Apache Kafka消费者组操作与主题删除原理详解</h2><h2 id="Apache-Kafka重要操作详解与系统总结回顾"><a href="#Apache-Kafka重要操作详解与系统总结回顾" class="headerlink" title="Apache Kafka重要操作详解与系统总结回顾"></a>Apache Kafka重要操作详解与系统总结回顾</h2><h2 id="SpringBoot整合Apache-Kafka详解"><a href="#SpringBoot整合Apache-Kafka详解" class="headerlink" title="SpringBoot整合Apache Kafka详解"></a>SpringBoot整合Apache Kafka详解</h2><h2 id="SpringBoot操纵Apache-Kafka实例分析"><a href="#SpringBoot操纵Apache-Kafka实例分析" class="headerlink" title="SpringBoot操纵Apache Kafka实例分析"></a>SpringBoot操纵Apache Kafka实例分析</h2><h2 id="主流消息队列产品总结与分析"><a href="#主流消息队列产品总结与分析" class="headerlink" title="主流消息队列产品总结与分析"></a>主流消息队列产品总结与分析</h2><h2 id="SpringBoot对于SpringMVC的整合原理深度解析"><a href="#SpringBoot对于SpringMVC的整合原理深度解析" class="headerlink" title="SpringBoot对于SpringMVC的整合原理深度解析"></a>SpringBoot对于SpringMVC的整合原理深度解析</h2><h2 id="SpringServletContainerInitializer初始化流程详解"><a href="#SpringServletContainerInitializer初始化流程详解" class="headerlink" title="SpringServletContainerInitializer初始化流程详解"></a>SpringServletContainerInitializer初始化流程详解</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看笔记：&lt;code&gt;https://www.bilibili.com/video/BV1Eg4y187XT&lt;/code&gt;  &lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="jdk8" scheme="https://fengshana.github.io/categories/jdk8/"/>
    
    
      <category term="java" scheme="https://fengshana.github.io/tags/java/"/>
    
      <category term="SprigBoot" scheme="https://fengshana.github.io/tags/SprigBoot/"/>
    
  </entry>
  
  <entry>
    <title>MicroservicesGuide-走近微服务词汇</title>
    <link href="https://fengshana.github.io/2020/05/27/%E3%80%90MICROSERVICES%E3%80%91/%E3%80%90MICROSERVICES%E3%80%91MicroservicesGuide-%E8%B5%B0%E8%BF%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AF%8D%E6%B1%87/"/>
    <id>https://fengshana.github.io/2020/05/27/%E3%80%90MICROSERVICES%E3%80%91/%E3%80%90MICROSERVICES%E3%80%91MicroservicesGuide-%E8%B5%B0%E8%BF%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AF%8D%E6%B1%87/</id>
    <published>2020-05-27T10:36:35.464Z</published>
    <updated>2020-05-27T10:36:35.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Microservices-Guide-微服务指南词汇导读"><a href="#Microservices-Guide-微服务指南词汇导读" class="headerlink" title="Microservices Guide 微服务指南词汇导读"></a>Microservices Guide 微服务指南词汇导读</h2><p>我觉得我对有道词典的翻译有点迷…..<br>感觉怪怪的；  </p><p><strong>software</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">so : f : t : wa : re ( 英 /ˈsɒftweə(r)/  )</span><br><span class="line">n. 软件</span><br><span class="line">网络释义 软件；软件；软件；软设备</span><br><span class="line">Software 软件；软件；软件；软设备</span><br><span class="line">free software 自由软件；自由软体；免费软件；自在软件</span><br><span class="line">software framework 软件框架；软体框架；软件架构</span><br><span class="line">software development 软件开发</span><br><span class="line">software design 软件设计；软件开发</span><br><span class="line">software<span class="built_in"> system </span>软件系统</span><br></pre></td></tr></table></figure><p><strong>development</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">de</span> : <span class="string">ve : lo : p : men : t ( 英 /dɪˈveləpmənt/  )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">发展；开发；发育；住宅小区（专指由同一开发商开发的）；[摄]显影</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">developments</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">开发；发展；发育；进化；</span></span><br><span class="line"><span class="attr">Development</span> <span class="string">开发；发展；发育；进化</span></span><br><span class="line"><span class="attr">Software</span> <span class="string">Development 软件开发；软体开发；软件发展；软件研发</span></span><br><span class="line"><span class="attr">Career</span> <span class="string">Development 生涯规划；职业规划；生涯发展；事业发展</span></span><br><span class="line"><span class="attr">sustainable</span> <span class="string">development 可持续发展</span></span><br><span class="line"><span class="attr">economic</span> <span class="string">development 经济发展；经济开发</span></span><br><span class="line"><span class="attr">with</span> <span class="string">the development of 随着 ... 发展</span></span><br></pre></td></tr></table></figure><p><strong>young</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">young</span> <span class="string">( 英 /jʌŋ/ )</span></span><br><span class="line"><span class="meta">adj.</span> <span class="string">年轻的；初期的；没有经验的</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">年轻人；（动物的）崽，仔</span></span><br><span class="line"><span class="meta">比较级</span> <span class="string">younger</span></span><br><span class="line"><span class="meta">最高级</span> <span class="string">youngest</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">youngs</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">年轻人；青年版；杨格</span></span><br><span class="line"><span class="attr">Young</span> <span class="string">年轻人；青年版；杨格</span></span><br><span class="line"><span class="attr">Neil</span> <span class="string">Young 尼尔 杨；尼尔杨</span></span><br><span class="line"><span class="attr">Brigham</span> <span class="string">Young 杨百翰；杨百翰大学；</span></span><br></pre></td></tr></table></figure><p><strong>profession</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">p</span> : <span class="string">ro : fe : ssion ( 英 /prəˈfeʃn/ )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">职业；专业；声明；宣布；表白</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">professions</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">职业；专业；专业；行业</span></span><br><span class="line"><span class="attr">profession</span> <span class="string">职业；专业；专业；行业</span></span><br><span class="line"><span class="attr">caring</span> <span class="string">profession 护理行业；照顾他人的职业</span></span><br><span class="line"><span class="attr">Profession</span> <span class="string">informationization 行业信息化</span></span><br><span class="line"><span class="attr">profession</span> <span class="string">of 宣称（感情、信念等）；表白</span></span><br><span class="line"><span class="attr">legal</span> <span class="string">profession 法律界；法律专业</span></span><br><span class="line"><span class="attr">medical</span> <span class="string">profession 医疗职业</span></span><br></pre></td></tr></table></figure><p><strong>still</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span> : <span class="string">t : ill ( 英 /stɪl/  )</span></span><br><span class="line"><span class="meta">adv.</span> <span class="string">仍然；更；静止地</span></span><br><span class="line"><span class="meta">adj.</span> <span class="string">静止的；不动的；寂静的；平静的；不起泡的</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">寂静；剧照；蒸馏室</span></span><br><span class="line"><span class="meta">conj.</span> <span class="string">仍然；但是；尽管如此</span></span><br><span class="line"><span class="meta">vt.</span> <span class="string">蒸馏；使...静止；使....平静下来</span></span><br><span class="line"><span class="meta">vi.</span> <span class="string">静止；平静；蒸馏</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">静止；仍然；蒸馏釜；依然</span></span><br><span class="line"><span class="attr">still</span> <span class="string">静止；仍然；蒸馏釜；依然</span></span><br><span class="line"><span class="attr">still</span> <span class="string">camera 静物照相机；静物摄影集；拍照机</span></span><br><span class="line"><span class="attr">Still</span> <span class="string">wine 静止葡萄酒；静态葡萄酒；无气葡萄酒；平静葡萄酒</span></span><br><span class="line"><span class="attr">still</span> <span class="string">on 仍在进行</span></span><br><span class="line"><span class="attr">still</span> <span class="string">remains 仍然是</span></span><br><span class="line"><span class="attr">sit</span> <span class="string">still 安静地坐着</span></span><br></pre></td></tr></table></figure><p><strong>learning</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lear</span> : <span class="string">ning ( 英 /ˈlɜːnɪŋ/  )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">学习；学问</span></span><br><span class="line"><span class="meta">v.</span> <span class="string">学习（learn的现在分词）</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">学习；学习；学问；知识</span></span><br><span class="line"><span class="attr">learning</span> <span class="string">学习；学习；学问；知识</span></span><br><span class="line"><span class="attr">ensemble</span> <span class="string">learning 集成学习；围绕中心点的划分；组合算法</span></span><br><span class="line"><span class="attr">Blended</span> <span class="string">Learning 混合式学习；混合学习；混合式教学</span></span><br><span class="line"><span class="attr">learning</span> <span class="string">English 学习英语</span></span><br><span class="line"><span class="attr">higher</span> <span class="string">learning n. 高等教育；高深学问；（电影名称）校园大冲突</span></span><br><span class="line"><span class="attr">language</span> <span class="string">learning 语言学习</span></span><br></pre></td></tr></table></figure><p><strong>techniques</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">te</span> : <span class="string">chi : ni : qu : es ( chi 读 k 的音；qu 读 k 的音； 英 /tekˈni:ks/ )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">技术（technique的复数）；方法；技巧</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">技法；技术；技巧；网站架构</span></span><br><span class="line"><span class="attr">Techniques</span> <span class="string">技法；技术；技巧；网站架构</span></span><br><span class="line"><span class="attr">Sampling</span> <span class="string">techniques 采样技术；抽样技术；取样技术；采样妙技</span></span><br><span class="line"><span class="attr">Metallographic</span> <span class="string">Techniques 金相技术</span></span><br><span class="line"><span class="attr">application</span> <span class="string">Techniques 涂装技术</span></span><br><span class="line"><span class="attr">selling</span> <span class="string">techniques 推销技术</span></span><br><span class="line"><span class="attr">motivational</span> <span class="string">techniques 激励技能；激励方法（motivational technique 的复数）</span></span><br></pre></td></tr></table></figure><p><strong>building</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bu </span>: il : ding ( 英 /ˈ<span class="keyword">bɪldɪŋ/ </span> )</span><br><span class="line"><span class="symbol">n.</span> 建筑；建筑物</span><br><span class="line"><span class="symbol">v.</span> 建筑；建立；增加（<span class="keyword">build的ing形式）</span></span><br><span class="line"><span class="keyword">复数 </span><span class="keyword">buildings</span></span><br><span class="line"><span class="keyword">网络释义 </span>建筑物；大楼；号楼；房屋</span><br><span class="line"><span class="keyword">building </span>建筑物；大楼；号楼；房屋</span><br><span class="line"><span class="symbol">green</span> <span class="keyword">building </span>绿色建筑；绿色生态建筑；绿色修建</span><br><span class="line"><span class="symbol">Chrysler</span> <span class="keyword">Building </span>克莱斯勒大厦；克莱斯勒大楼；美国克莱斯勒大厦；克莱斯勒</span><br><span class="line"><span class="keyword">building </span>up 建造；装配；堆焊；建立增长</span><br><span class="line"><span class="symbol">office</span> <span class="keyword">building </span>办公大楼（等于office <span class="keyword">block）</span></span><br><span class="line"><span class="keyword">building </span>material 建筑材料</span><br></pre></td></tr></table></figure><p><strong>tools</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">too : l : s ( 英 /tuːlz/  )</span><br><span class="line">n. [计]工具，工具菜单；工具箱（tool的复数形式）</span><br><span class="line">v. 用工具加工<span class="built_in">..</span>. (tool的第三人称单数形式)</span><br><span class="line">网络释义 工具；刀具；面板；工具栏</span><br><span class="line">Tools 工具；刀具；面板；工具栏</span><br><span class="line">Game Tools 游戏常用工具；游戏常用支持工具集合；游戏开发工具；游戏工具</span><br><span class="line">Debugging Tools 调试工具；翟工具；排错工具；除错工具；</span><br><span class="line">hardware tools 五金工具；日用五金</span><br><span class="line">new tools 新工具</span><br><span class="line">machines <span class="keyword">and</span> tools 机具</span><br></pre></td></tr></table></figure><p><strong>effectively</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e : <span class="type">ffe</span> : <span class="type">c</span> : <span class="type">ti</span> : <span class="type">ve</span> : <span class="type">ly</span> ( 英 /ɪˈfektɪvli/ )</span><br><span class="line">adv. 有效地；生效地；有力地；实际上</span><br><span class="line">网络释义 有效地；起作用地；实际上；有用地</span><br><span class="line">effectively 有效地；起作用地；实际上；有用地</span><br><span class="line">effectively grounded 直接接地；有效被接地；有效接地；有效接地的</span><br><span class="line"><span class="keyword">use</span> effectively 有效利用；有效地利用</span><br></pre></td></tr></table></figure><p><strong>involved</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">in</span> : <span class="string">vol : ve : d (ve 读 v 的音 英 /ɪnˈvɒlvd/  )</span></span><br><span class="line"><span class="meta">adj.</span> <span class="string">有关的；卷入的；复杂的</span></span><br><span class="line"><span class="meta">v.</span> <span class="string">涉及；使参与；包含（involve的过去时和过去分词）</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">卷入；涉案；涉足；所涉及</span></span><br><span class="line"><span class="attr">Involved</span> <span class="string">卷入；涉案；涉足；所涉及</span></span><br><span class="line"><span class="attr">parties</span> <span class="string">involved 交换中的各方；当事人；当事者；互换中的各方</span></span><br><span class="line"><span class="attr">get</span> <span class="string">involved 介入；加入我们；项目介绍；参与</span></span><br><span class="line"><span class="attr">involved</span> <span class="string">in 涉及；包含；牵涉进...</span></span><br><span class="line"><span class="attr">involved</span> <span class="string">with 涉及；与...有关联</span></span><br><span class="line"><span class="attr">get</span> <span class="string">involved in 涉及；卷入</span></span><br></pre></td></tr></table></figure><p><strong>activity</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span> : <span class="string">c : ti : vi : ty ( 英 /ækˈtɪvəti/ )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">活动；行动；活跃</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">activities</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">活动；活性；活度；活动</span></span><br><span class="line"><span class="attr">Activity</span> <span class="string">活动；活性；活度；活动</span></span><br><span class="line"><span class="attr">logistics</span> <span class="string">activity 物流活动；物流</span></span><br><span class="line"><span class="attr">physical</span> <span class="string">activity 体力活动；体育活动；体能活动</span></span><br><span class="line"><span class="attr">economic</span> <span class="string">activity 经济活动</span></span><br><span class="line"><span class="attr">catalytic</span> <span class="string">activity 催化活性</span></span><br><span class="line"><span class="attr">physical</span> <span class="string">activity 身体活动；体育活动；体力活动</span></span><br></pre></td></tr></table></figure><p><strong>over</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">o : v : er ( 英 /ˈəʊvə(r)/  )</span><br><span class="line">adv. 倒下；翻转；穿过；完全覆盖；以上；大于；再；结束；改变；完毕；仔细地</span><br><span class="line">prep. 在<span class="params">...</span>上面；从<span class="params">...</span>上方；穿越；在<span class="params">...</span>的另一边；在<span class="params">...</span>的远端；从<span class="params">...</span>落下；遍及；多于；在<span class="params">...</span>期间；渡过；由于；关于；利用；通过；声音大于；高于；级别在<span class="params">...</span>之上；优先于；超过</span><br><span class="line">n. （板球）一轮投球</span><br><span class="line">adj. 倒下的；折起来的；结束的；剩下的</span><br><span class="line">v. 越过</span><br><span class="line">网络释义 结束；越过；超过</span><br><span class="line">over 结束；越过；超过</span><br><span class="line">hand over 移交；交出；让与</span><br><span class="line">Over There 那时那地；在那边；在那里；那边</span><br><span class="line"><span class="literal">all</span> over 到处；遍及；浑身；全部结束</span><br><span class="line">over there adv. 在那里</span><br><span class="line">over <span class="literal">and</span> over 反复；再三</span><br></pre></td></tr></table></figure><p><strong>decades</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">n.</span> <span class="string">数十年（decade的复数）</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">十年；几十年；几十年来；台阶</span></span><br><span class="line"><span class="attr">decades</span> <span class="string">十年；几十年；几十年来；台阶</span></span><br><span class="line"><span class="attr">Mixed</span> <span class="string">Decades 某某年代风</span></span><br><span class="line"><span class="attr">Frogger</span> <span class="string">Decades 青蛙过河纪念版</span></span><br><span class="line"><span class="attr">over</span> <span class="string">the past decade 在过去的十年里</span></span><br></pre></td></tr></table></figure><p><strong>writing</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wri</span> : <span class="string">ting ( 英 /ˈraɪtɪŋ/  )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">书写；写作技能；著书立说；写作的职业；作品；著作；文字；笔迹</span></span><br><span class="line"><span class="meta">v.</span> <span class="string">书写；写作（write的现在分词）</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">writings</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">写作；书写；文字</span></span><br><span class="line"><span class="attr">Writing</span> <span class="string">写作；书写；文字</span></span><br><span class="line"><span class="attr">Nature</span> <span class="string">Writing 自然写作；自然书写；自然文学</span></span><br><span class="line"><span class="attr">English</span> <span class="string">Writing 英语写作；英文写作；英文书面表达；写作</span></span><br><span class="line"><span class="attr">in</span> <span class="string">writing 书面；书面的；用书面写</span></span><br><span class="line"><span class="attr">writing</span> <span class="string">ability 写作能力；书写能力</span></span><br><span class="line"><span class="attr">writing</span> <span class="string">skill 写作技巧；书写技能；笔头</span></span><br></pre></td></tr></table></figure><p><strong>in the last two</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在最后两个</span><br><span class="line"><span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">last</span> <span class="literal">two</span> months 在过去的两个月；在最后两个月</span><br><span class="line">In <span class="keyword">the</span> <span class="keyword">last</span> <span class="literal">two</span> years 在最后两年中</span><br><span class="line">In <span class="keyword">the</span> <span class="keyword">last</span> <span class="literal">two</span> decades 在最近二十年</span><br></pre></td></tr></table></figure><p><strong>website</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">we</span> : <span class="string">b : si : te ( 英 /ˈwebsaɪt/ )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">网站（全球资讯网的主机站）</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">websites</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">网站；网址；网站建设；站点</span></span><br><span class="line"><span class="attr">Website</span> <span class="string">网站；网址；网站建设；站点</span></span><br><span class="line"><span class="attr">Website</span> <span class="string">Design 网站设计；网页设计；网站建设；品牌网站形象设计</span></span><br><span class="line"><span class="attr">Website</span> <span class="string">Promotion 网站推广；网站推广常识；网站推广知识；企业网站网络推广；</span></span><br><span class="line"><span class="attr">website</span> <span class="string">design 网站设计</span></span><br><span class="line"><span class="attr">website</span> <span class="string">promotion 网站推广</span></span><br><span class="line"><span class="attr">website</span> <span class="string">development 网站开发；网页设计</span></span><br></pre></td></tr></table></figure><p><strong>patterns</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pa</span> : <span class="string">tter : n : s</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">模式（pattern的复数形式）</span></span><br><span class="line"><span class="meta">v.</span> <span class="string">摹制；用图案装饰；复写（pattern的第三人称单数形式）</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">花样；模型；木模；形态</span></span><br><span class="line"><span class="attr">patterns</span> <span class="string">花样；模型；木模；形态</span></span><br><span class="line"><span class="attr">fashionable</span> <span class="string">patterns 花色入时；花样进时；时尚模式；花样入时</span></span><br><span class="line"><span class="attr">Corrective</span> <span class="string">Patterns 调整浪形态；调剂浪形态</span></span><br><span class="line"><span class="attr">development</span> <span class="string">patterns 发展模式</span></span><br></pre></td></tr></table></figure><p><strong>practices</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">p :</span> <span class="string">ra :</span> <span class="string">c :</span> <span class="string">ti :</span> <span class="string">ce :</span> s ( 英 <span class="regexp">/ˈpræktɪsɪs/</span>  )</span><br><span class="line">n. 实践（practice 的复数）；练习</span><br><span class="line">v. 练习（practice的第三人称单数形式）</span><br><span class="line">网络释义 客户专区；业务中心</span><br><span class="line">Practices 客户专区；业务中心</span><br><span class="line">Disciplinazy Practices 惩戒性措施；性措施</span><br><span class="line">Agricultural practices 农业方式；耕作方法；农业方法</span><br><span class="line">cultural practices 文化实践；栽培技术</span><br><span class="line">foreign corrupt practices act 反国外行贿法规</span><br></pre></td></tr></table></figure><p><strong>easier</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ea</span> : <span class="string">si : er ( 英 /'iːzɪə/  )</span></span><br><span class="line"><span class="meta">adj.</span> <span class="string">更简单；容易些（easy 的比较级形式）；较早的</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">知易行难；更简单；更容易的；更便捷</span></span><br><span class="line"><span class="attr">Easier</span> <span class="string">知易行难；更简单；更容易的；更便捷</span></span><br><span class="line"><span class="attr">EASIER</span> <span class="string">RIDER 更逍遥的骑士</span></span><br><span class="line"><span class="attr">Work</span> <span class="string">easier 工作比较轻松</span></span><br><span class="line"><span class="attr">easier</span> <span class="string">said than done 说来容易做起来难</span></span><br><span class="line"><span class="attr">make</span> <span class="string">life easier 日子会过得更潇洒；生活变得更加舒适</span></span><br></pre></td></tr></table></figure><p><strong>useful</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">u</span> : <span class="string">se : ful ( 英 /ˈjuːsfl/  )</span></span><br><span class="line"><span class="meta">adj.</span> <span class="string">有用的；有益的；有帮助的</span></span><br><span class="line"><span class="meta">比较级</span> <span class="string">more useful；</span></span><br><span class="line"><span class="meta">最高级</span> <span class="string">most useful</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">有用的；有益；软碟通软件；有效的</span></span><br><span class="line"><span class="attr">useful</span> <span class="string">有用的；有益；软碟通软件；有效的</span></span><br><span class="line"><span class="attr">Useful</span> <span class="string">numbers 常用电话号码；常用电话；常用德律风号码；经常使用电话号头</span></span><br><span class="line"><span class="attr">useful</span> <span class="string">resistance 有益阻力</span></span><br><span class="line"><span class="attr">be</span> <span class="string">useful to 对...有用；具有...用途</span></span><br><span class="line"><span class="attr">useful</span> <span class="string">life 使用寿命；有效期</span></span><br><span class="line"><span class="attr">useful</span> <span class="string">data 有用数据和资料</span></span><br></pre></td></tr></table></figure><p><strong>began</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">be </span>: gan ( 英 /<span class="keyword">bɪˈɡæn/ </span>)</span><br><span class="line"><span class="symbol">v.</span> 开始；创建；着手于（<span class="keyword">begin的过去式）</span></span><br><span class="line"><span class="keyword">网络释义 </span>开始；贝加；开始了；才开始；</span><br><span class="line"><span class="keyword">began </span>开始；贝加；开始了；才开始</span><br><span class="line"><span class="keyword">Began </span>menopause 开始更年期</span><br><span class="line"><span class="symbol">Passion</span> <span class="keyword">began </span>翻译公司开始</span><br><span class="line"><span class="keyword">begin </span>with 以...开始；开始于...</span><br><span class="line"><span class="keyword">begin </span>at 几点开始；从..开始</span><br><span class="line"><span class="keyword">begin </span>again 重新开始；重做</span><br></pre></td></tr></table></figure><p><strong>place</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">p</span> : <span class="string">la : ce ( 英 /pleɪs/  )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">地方；住所；座位</span></span><br><span class="line"><span class="meta">vt.</span> <span class="string">放置；任命；寄予</span></span><br><span class="line"><span class="meta">vi.</span> <span class="string">名列前茅；取得名次</span></span><br><span class="line"><span class="meta">过去式</span> <span class="string">placed</span></span><br><span class="line"><span class="meta">过去分词</span> <span class="string">placed</span></span><br><span class="line"><span class="meta">现在分词</span> <span class="string">placing</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">places</span></span><br><span class="line"><span class="meta">第三人称单数</span> <span class="string">places</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">渠道；地方；放置；地点</span></span><br><span class="line"><span class="attr">Place</span> <span class="string">渠道；地方；放置；地点</span></span><br><span class="line"><span class="attr">Lanham</span> <span class="string">Place 朗豪坊；朗豪酒店；朗豪坊商场；朗豪酒店</span></span><br><span class="line"><span class="attr">Martin</span> <span class="string">Place 马丁广场；牛；火车站</span></span><br><span class="line"><span class="attr">in</span> <span class="string">place 适当；适当的；在适当的地方；在适当的位置</span></span><br><span class="line"><span class="attr">place</span> <span class="string">in 安排；放置</span></span><br><span class="line"><span class="attr">take</span> <span class="string">place 发生；举行</span></span><br></pre></td></tr></table></figure><p><strong>publish</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pub</span> : <span class="string">li : sh ( 英 /ˈpʌblɪʃ/  )</span></span><br><span class="line"><span class="meta">vt.</span> <span class="string">出版；发表；公布</span></span><br><span class="line"><span class="meta">vi.</span> <span class="string">出版；发行；刊印</span></span><br><span class="line"><span class="meta">过去式</span> <span class="string">published</span></span><br><span class="line"><span class="meta">过去分词</span> <span class="string">published</span></span><br><span class="line"><span class="meta">现在分词</span> <span class="string">publishing</span></span><br><span class="line"><span class="meta">第三人称单数</span> <span class="string">publishes</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">出版；公布；发布</span></span><br><span class="line"><span class="attr">publish</span> <span class="string">出版；公布；发布</span></span><br><span class="line"><span class="attr">publish</span> <span class="string">connections 发布连接</span></span><br><span class="line"><span class="attr">Publish</span> <span class="string">Entry 发布项；宣布项</span></span><br></pre></td></tr></table></figure><p><strong>articles</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ar</span> : <span class="string">ti : cle : s</span></span><br><span class="line"><span class="attr">n.[语]文章；物品；[法]条款（article的复数）；[语]冠词</span></span><br><span class="line"><span class="meta">v.</span> <span class="string">使受协议条款的约束；指控（article的三单形式）</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">冠词；文章；各条；本刊</span></span><br><span class="line"><span class="attr">Articles</span> <span class="string">冠词；文章；各条；本刊</span></span><br><span class="line"><span class="attr">Instant</span> <span class="string">Articles 即时文章；新闻快读；即时文汇；文章快手</span></span><br><span class="line"><span class="attr">Plastic</span> <span class="string">Articles 塑料制品；塑料件；整形篇；主要进口商品英文</span></span><br><span class="line"><span class="attr">articles</span> <span class="string">of association 公司章程；组织章程</span></span><br><span class="line"><span class="attr">articles</span> <span class="string">for daily use 生活用品</span></span><br><span class="line"><span class="attr">original</span> <span class="string">articles 原作；研究文章</span></span><br></pre></td></tr></table></figure><p><strong>colleagues</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">co</span> : <span class="string">lle : gu : es</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">同事；同行（colleague的复数）</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">同仁；同人；同事；同事之间</span></span><br><span class="line"><span class="attr">Colleagues</span> <span class="string">同仁；同人；同事；同事之间</span></span><br><span class="line"><span class="attr">Visiting</span> <span class="string">Colleagues 拜访同事；造访同事</span></span><br><span class="line"><span class="attr">Complimenting</span> <span class="string">Colleagues 赞美同事；赞誉同事</span></span><br></pre></td></tr></table></figure><p><strong>joined</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jo</span> : <span class="string">in : ed ( 英 /dʒɔind/  )</span></span><br><span class="line"><span class="meta">v.</span> <span class="string">加入；参加（join的过去式；过去分词）；[计]连接</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">加入；客户留言；连接；招生简章</span></span><br><span class="line"><span class="attr">joined</span> <span class="string">加入；客户留言；连接；招生简章</span></span><br><span class="line"><span class="attr">JOINED</span> <span class="string">Strategy 连接策略</span></span><br><span class="line"><span class="attr">joined</span> <span class="string">field 将两个表中连接字段</span></span><br><span class="line"><span class="attr">join</span> <span class="string">hands 携手；联手；齐心协力</span></span><br><span class="line"><span class="attr">join</span> <span class="string">in 加入；参加</span></span><br><span class="line"><span class="attr">join</span> <span class="string">hands with 握手；同...联合</span></span><br></pre></td></tr></table></figure><p><strong>ThoughtWorks</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>role</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ro : le ( 英 /rəʊl/  )</span><br><span class="line">n. 角色；任务</span><br><span class="line">网络释义 角色；作用；社会角色；任务</span><br><span class="line"><span class="keyword">Role</span> <span class="title">角色；作用；社会角色；任务</span></span><br><span class="line"><span class="title">role</span> playing 角色扮演；角色扮演法；职能演习；角色表演</span><br><span class="line"><span class="keyword">role</span> <span class="title">model</span> 行为榜样；角色模型；榜样；模范</span><br><span class="line"><span class="keyword">role</span> <span class="title">of</span> ....的角色</span><br><span class="line">play an important <span class="keyword">role</span> <span class="title">起到重要作用</span></span><br><span class="line"><span class="title">leading</span> <span class="keyword">role</span> <span class="title">主导作用；主导地位</span></span><br></pre></td></tr></table></figure><p><strong>learn</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lear</span> : <span class="string">n ( 英 /lɜːn/  )</span></span><br><span class="line"><span class="meta">vt.</span> <span class="string">学习；得知；认识到</span></span><br><span class="line"><span class="meta">vi.</span> <span class="string">学习；获悉</span></span><br><span class="line"><span class="meta">过去式</span> <span class="string">learned 或 learnt</span></span><br><span class="line"><span class="meta">过去分词</span> <span class="string">learned 或 learnt</span></span><br><span class="line"><span class="meta">现在分词</span> <span class="string">learning</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">学会；得知</span></span><br><span class="line"><span class="attr">Learn</span> <span class="string">学会；得知</span></span><br><span class="line"><span class="attr">learn</span> <span class="string">about 了解；得知；获悉；听到</span></span><br><span class="line"><span class="attr">learn</span> <span class="string">of 听到；获悉；获悉的事；听说</span></span><br><span class="line"><span class="attr">learn</span> <span class="string">from 向...学习</span></span><br><span class="line"><span class="attr">learn</span> <span class="string">English 学习英语</span></span><br><span class="line"><span class="attr">learn</span> <span class="string">about 了解；学习</span></span><br></pre></td></tr></table></figure><p><strong>deliver</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">de</span> : <span class="string">li : ver ( 英 /dɪˈlɪvə(r)/  )</span></span><br><span class="line"><span class="meta">vt.</span> <span class="string">交付；发表；递送；释放；给予（打击）；给...接生</span></span><br><span class="line"><span class="meta">vi.</span> <span class="string">实现；传送；履行；投递</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">投球</span></span><br><span class="line"><span class="meta">过去式</span> <span class="string">delivered</span></span><br><span class="line"><span class="meta">过去分词</span> <span class="string">delivered</span></span><br><span class="line"><span class="meta">现在分词</span> <span class="string">delivering</span></span><br><span class="line"><span class="meta">第三人称单数</span> <span class="string">delivers</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">投递；交付；发出；发表</span></span><br><span class="line"><span class="attr">deliver</span> <span class="string">投递；交付；发出；发表</span></span><br><span class="line"><span class="attr">deliver</span> <span class="string">value 价值传递；传递价值</span></span><br><span class="line"><span class="attr">Deliver</span> <span class="string">Hope 传递希望；递送希望</span></span><br><span class="line"><span class="attr">deliver</span> <span class="string">the goods 交货；履行诺言</span></span><br><span class="line"><span class="attr">deliver</span> <span class="string">a speech 发表演讲；发表讲话</span></span><br></pre></td></tr></table></figure><p><strong>clients</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c : lien : ts</span><br><span class="line">n. 顾客；客户端；委托方（client的复数）；救济对象；应受账款</span><br><span class="line">网络释义 客户；客户端；案例；合作客户</span><br><span class="line">Clients 客户；客户端；案例；合作客户</span><br><span class="line">major clients 大客户；主要客户；客户</span><br><span class="line">Entertaining Clients 招待客户；款待客户；宴请客户；接待客户</span><br><span class="line">client<span class="built_in"> service </span>客户服务；向委托部门提供服务</span><br><span class="line">client base 客户群；基本顾客</span><br><span class="line">client side 客户端；使用端</span><br></pre></td></tr></table></figure><p><strong>pass</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pa</span> : <span class="string">ss ( 英 /pɑːs/  )</span></span><br><span class="line"><span class="meta">v.</span> <span class="string">通过；经过；沿某方向前进；使达到（某位置）；传递；传球；遗留给；超过；变化；推移；度过；终止；几个；经表决通过（法律等）；允许；宣布；过；排泄；流通；放弃</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">及格；经过；通行证；道路，山口；传球；飞跃；阶段；鱼道；（桥牌）不叫；（击剑中的）戳刺；变戏法；（计算机）一次浏览</span></span><br><span class="line"><span class="meta">过去式</span> <span class="string">passed</span></span><br><span class="line"><span class="meta">过去分词</span> <span class="string">passed</span></span><br><span class="line"><span class="meta">现在分词</span> <span class="string">passing</span></span><br><span class="line"><span class="meta">第三人称单数</span> <span class="string">passes</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">传球；通过；经过；传递</span></span><br><span class="line"><span class="attr">Pass</span> <span class="string">传球；通过；经过；传递</span></span><br><span class="line"><span class="attr">scissor</span> <span class="string">pass 交叉传球；交织传球；穿插传球；传球</span></span><br><span class="line"><span class="attr">Khyber</span> <span class="string">Pass 开伯尔山口；开伯尔通道；咖喱王</span></span><br><span class="line"><span class="attr">pass</span> <span class="string">through 穿过....；通过...</span></span><br><span class="line"><span class="attr">come</span> <span class="string">to pass 实现；发生</span></span><br><span class="line"><span class="attr">pass</span> <span class="string">on 传递；继续；去世</span></span><br></pre></td></tr></table></figure><p><strong>wider</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wi</span> : <span class="string">d : er ( 英 /waɪdə(r)/  )</span></span><br><span class="line"><span class="meta">adj.</span> <span class="string">宽的；广阔的（wide的比较级形式）</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">快尔达；世界发展经济研究所；宽的</span></span><br><span class="line"><span class="attr">WIDER</span> <span class="string">快尔达；世界发展经济研究所；宽的</span></span><br><span class="line"><span class="attr">wider</span> <span class="string">margin 较大差幅；俏利</span></span><br><span class="line"><span class="attr">wider</span> <span class="string">spreading 更大的穿电</span></span><br></pre></td></tr></table></figure><p><strong>industry</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">in</span> : <span class="string">du : s : try ( 英 /ˈɪndəstri/  )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">产业；工业；勤勉</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">industries</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">产业；工业；职业；行业</span></span><br><span class="line"><span class="attr">industry</span> <span class="string">产业；工业；职业；行业</span></span><br><span class="line"><span class="attr">water</span> <span class="string">industry 水利产业；水产业；水工业</span></span><br><span class="line"><span class="attr">automobile</span> <span class="string">industry 汽车工业；汽车产业；汽车业；汽车制造业</span></span><br><span class="line"><span class="attr">industry</span> <span class="string">and commerce 工商业</span></span><br><span class="line"><span class="attr">chemical</span> <span class="string">industry 化学工业</span></span><br><span class="line"><span class="attr">manufacturing</span> <span class="string">industry 制造业；制造工业</span></span><br></pre></td></tr></table></figure><p><strong>site</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">si</span> : <span class="string">te ( 英 /saɪt/ )</span></span><br><span class="line"><span class="meta">n.</span> <span class="string">地点；位置；场所</span></span><br><span class="line"><span class="meta">vt.</span> <span class="string">设置；为...选址</span></span><br><span class="line"><span class="meta">过去式</span> <span class="string">sited</span></span><br><span class="line"><span class="meta">过去分词</span> <span class="string">sited</span></span><br><span class="line"><span class="meta">现在分词</span> <span class="string">siting</span></span><br><span class="line"><span class="meta">复数</span> <span class="string">sites</span></span><br><span class="line"><span class="meta">第三人称单数</span> <span class="string">sites</span></span><br><span class="line"><span class="meta">网络释义</span> <span class="string">站点；场地；现场；场所</span></span><br><span class="line"><span class="attr">Site</span> <span class="string">站点；场地；现场；场所</span></span><br><span class="line"><span class="attr">Site</span> <span class="string">planning 敷地计划；总平面设计；场地规划</span></span><br><span class="line"><span class="attr">Site</span> <span class="string">Selection 选址；基地选择；场地选择</span></span><br><span class="line"><span class="attr">web</span> <span class="string">site 网页；网址</span></span><br><span class="line"><span class="attr">on</span> <span class="string">site 现场；原地；原位</span></span><br><span class="line"><span class="attr">construction</span> <span class="string">site 建筑工地；施工场地</span></span><br></pre></td></tr></table></figure><p><strong>developed</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">de : ve : lo : p : ed ( 英 /dɪˈveləpt/ )</span><br><span class="line">adj. 发达的（国家或地区）；成熟的</span><br><span class="line">网络释义 发达；自主开发；研制出；成熟的</span><br><span class="line">Developed 发达；自主开发；研制出；成熟的</span><br><span class="line">developed countries 发达国家；已开发国家；已发展国家；发达国家或工业化国家</span><br><span class="line">developed dimension 展开尺寸</span><br><span class="line">developed country n.发达国家</span><br><span class="line">developed<span class="built_in"> area </span>[计]展开面积</span><br><span class="line">less developed 欠发达地区；不发达的</span><br></pre></td></tr></table></figure><p><strong>respected</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">re :</span> <span class="string">s :</span> <span class="string">pe :</span> <span class="string">c :</span> <span class="string">te :</span> d ( 英 <span class="regexp">/ri'spektid/</span>  )</span><br><span class="line">adj. 受尊敬的</span><br><span class="line">v. 尊敬；重视（respect的过去式和过去分词）</span><br><span class="line">网络释义 推崇；受尊敬的；德高望重；受人尊敬</span><br><span class="line">Respected 推崇；受尊敬的；德高望重；受人尊敬</span><br><span class="line">Are respected 很受尊敬</span><br><span class="line">Respected person 德高望重的人</span><br><span class="line">respected ideas 公认理论；权威理论</span><br><span class="line">be respected <span class="keyword">as</span> 被尊为...</span><br></pre></td></tr></table></figure><p><strong>platform</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p : la : t : <span class="keyword">for</span> : m ( 英 /ˈplætfɔːm/  )</span><br><span class="line">n. 平台；月台；站台；坛；讲台；厚底松糕鞋</span><br><span class="line">网络释义 平台；站台；台；平台</span><br><span class="line">platform 平台；站台；台；平台</span><br><span class="line">side platform 侧式站台；侧式月台；侧向式站台；侧向收割台</span><br><span class="line">fixed platform 固定平台；固定式平台；固定式钻井平台</span><br><span class="line">service platform 工作台；操作平台</span><br><span class="line">offshore platform 海上平台；近海平台</span><br><span class="line">open platform 开放平台</span><br></pre></td></tr></table></figure><p><strong>edited</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">e</span> : <span class="keyword">di</span> :<span class="keyword">te</span> : <span class="keyword">d</span> ( 英 /'<span class="keyword">ed</span>ɪtɪ<span class="keyword">d</span>/  )</span><br><span class="line">adj. 编辑过的</span><br><span class="line">v. 编辑；校订；剪接；主编（<span class="keyword">edit</span>的过去式和过去分词）</span><br><span class="line">网络释义 编辑过的；编辑；分钟；已编辑</span><br><span class="line">Edited 编辑过的；编辑；分钟；已编辑</span><br><span class="line">Edited Books 编辑书籍</span><br><span class="line">SpinnBox Edited 旋转方块</span><br><span class="line"><span class="keyword">edit</span> box [计]编辑框</span><br><span class="line"><span class="keyword">edit</span> mode [计]编辑方式</span><br><span class="line"><span class="keyword">edit</span> <span class="keyword">window</span> 编辑窗口</span><br></pre></td></tr></table></figure><p><strong>published</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adj. 已发布的</span><br><span class="line">v. 出版；发行（publish的过去式）</span><br><span class="line">网络释义 刊登；刊出；刊发；刊载</span><br><span class="line">Published 刊登；刊出；刊发；刊载</span><br><span class="line">published<span class="built_in"> interface </span>已发布接口；发布接口</span><br><span class="line">published angle 预定</span><br><span class="line">published price 图书零售价；定价；公布价格</span><br></pre></td></tr></table></figure><p><strong>ThoughtWorkers</strong></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">**others**</span><br></pre></td></tr></table></figure><p>  o : ther : s ( 英 /ˈʌðə(r)z/   )<br>  pron. 其他人<br>  网络释义 其它；其他；全部信息；其他组件保养<br>  Others 其他；其它；全部信息；其他组件保养<br>  the others 小岛惊魂；神鬼第六感；其它<br>  Introduce Others 先容别人<br>  each other 彼此；互相<br>  on the other 另一方面<br>  on the other hand 另一方面</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*reach*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  rea : ch (  英 /riːtʃ/ )<br>  vi. 达到；延伸；伸出手；传开<br>  vt. 达到；影响；抵达；伸出<br>  n. 范围；延伸；河段；横风行驶<br>  第三人称单数 reaches<br>  过去式 reached<br>  过去分词 reached<br>  现在分词 reaching<br>  网络释义 到达；达到；到达率；化学品注册<br>  Reach 到达；达到；到达率；化学品注册<br>  Reach Me 书缘寻踪；抓住我；请与我联系；联系我<br>  reach out 伸出；提供援助；接纳我<br>  reach out vt. 伸出<br>  reach for 伸手去拿<br>  reach an agreement 达成协议；取得一致意见；达成共识</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*audience*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  au : di : en : ce ( 英 /ˈɔːdiəns/  )<br>  n. 观众；听众；读者；接见；正式会见；拜会<br>  网络释义 观众；听众；受众；阅听人<br>  Audience 观众；听众；受众；阅听人<br>  target audience 目标观众；目标消费者；目标大众；目标受众<br>  Audience area 听众区；看台区；观众区<br>  target audience 目标受众；目标观众；目标客户<br>  audience rating n. 收视率；试听率<br>  mass audience 大众受众</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*material*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  ma : te : ri : al ( 英 /məˈtɪəriəl/  )<br>  n. 材料；用具；（有指明特征的）人才；素材；曲目；布料<br>  adj. 物质的；身体需要的；和推理内容相关的；重要的；（证据或事实）决定性的；客观存在的；物欲的<br>  n. (Material)(意、美)妈特力娅丽（人名）<br>  复数 materials<br>  网络释义 材质；材料；物料；资料<br>  Material 材质；材料；物料；资料<br>  Material Girl 物质女孩；拜金女孩；物质女郎；拜金女郎<br>  insulating material 隔热材料；绝热材料；绝缘物<br>  raw material 原料<br>  teaching material 教学内容；教学资料<br>  new material 新材料</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*MicroServices*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  Mi: cro : Ser : vi : ce : s<br>  微服务；<br>  微服务架构<br>  网络释义 微服务；微服务架构<br>  Microservices 微服务；微服务架构<br>  cognitive microservices 认知微服务；认证微服务<br>  Microservices Architecture 微服务架构</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*Guide*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  gui : de  ( 英 /ɡaɪd/ )<br>  n. 指南；向导；入门书；<br>  vt. 引导；带领；操纵；<br>  vi. 担任向导；<br>  n.(Guide)人名；（法、葡）吉德<br>  过去式 guided；<br>  过去分词 guided；<br>  现在分词 guiding；<br>  复数 guides；<br>  第三人称单数 guides；<br>  网络释义 导游、指导、指南、领队<br>  Guide 导游；指导；指南；领队；<br>  guide post 路标；引导柱；导柱；导杆<br>  User Guide 说明书；用户指南；用户操作手册</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*In short*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  总之；<br>  简言之；<br>  网络释义 简言之；总之；简而言之；简单地说<br>  in short 简言之；总之；简而言之；简单地说<br>  in the short term 从短期来看<br>  in a short time 不久；在短时间内</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*architectural*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  ar : chi : te : c : tur : al（chi读ki的音，英 /ˌɑːkɪˈtektʃərəl/  ）<br>  adj. 建筑学的；建筑上的；符合建筑法的<br>  网络释义 建筑；建筑设计；建筑材质；建筑学的<br>  architectural 建筑；建筑设计；建筑材质；建筑学的<br>  architectural style 建筑风格；建筑形式；架构风格<br>  Architectural acoustics 建筑声学；建筑音响；构筑声学；建筑音响学</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*style*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  s : ty : le  （ 英 /staɪl/ ）<br>  n. 风格；时尚；类型；字体<br>  vt. 设计；称呼；使合潮流<br>  vi. 设计式样；用刻刀作装饰画<br>  n. (Style)人名；（英）斯泰尔<br>  过去式 styled；<br>  过去分词 styled；<br>  现在分词 styling；<br>  复数 styles；<br>  第三人称单数 styles；<br>  网络释义 风格；样式；款式；作风<br>  style 风格；样式；款式；作风<br>  Style 作风<br>  Text Style 字体样式；字布局；文字样式；文字布局</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="number">*a</span>pproach <span class="keyword">to</span>**</span><br></pre></td></tr></table></figure><p>  a : pp : roa : ch  （ 英 /əˈprəʊtʃ/  ）<br>  接近；约等于；通往…的方法<br>  网络释义 约等于；接近；类似；办法；<br>  approach to 约等于；接近；类似；办法<br>  approach h to criticality 接近临界<br>  approach h to 做某事的方法；约等于；接近；对…的态度</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*developing*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  de : ve : lo : ping  （ 英 /dɪˈveləpɪŋ/  ）<br>  adj. 发展中的；生长的；变化的<br>  n. 发展<br>  v. 发展；成长；产生；感受；使（摄影胶片）显影（develop的现在分词）<br>  网络释义 发展；发展中的；显影；开发<br>  Developing 发展；发展中的；显影；开发<br>  developing trend 发展趋势；发展走向；趋势<br>  developing machine 洗片机；显影机；头影机（这个头？我抄的有道词典上的）；显色机</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*single*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  sin : gle （ 英 /ˈsɪŋɡl/ ）<br>  adj. 单一的；单身的；单程的<br>  n. 一个；单打；单程票<br>  vt. 选出<br>  vi. 击出一垒安打<br>  过去式 singled<br>  过去分词 singled<br>  现在分词 singling<br>  复数 singles<br>  第三人称单数 singles<br>  网络释义 未婚；一垒安打；单曲；单一的；<br>  single 未婚；一垒安打；单曲；单一的<br>  single market 统一市场；北京市场；单一市场；同一市场<br>  single parent 单亲家庭；单亲；单父协同；单亲母亲</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="built_in">application</span>**</span><br></pre></td></tr></table></figure><p>  a : pp : li : ca : tion （ 英 /ˌæplɪˈkeɪʃn/  ）<br>  n. 应用；申请；应用程序；敷用；（对事物、学习等）投入<br>  网络释义 用途；应用软件；应用<br>  APPLICATION 用途；应用软件；应用<br>  application fee 申请费；报名费；申请费用；登记费<br>  patent application 专利申请；专利申请书；专利声请；专利申请说明书</p><p>  patent<br>  pa : ten : t  （英 /‘pæt(ə)nt; ‘peɪt(ə)nt/）<br>  n. 专利权；专利证；专利品；<br>  adj. 专利的；特许生产或销售的；显著的；公开的；（脉管等）开放的<br>  v. 取得…的专利权；授予专利<br>  复数 patents<br>  过去式 patented<br>  过去分词 patented<br>  现在分词 patenting<br>  第三人称单数 patents<br>  网络释义 专利权；专利；专利品；科技玩具<br>  patent 专利权；专利；专利品；科技玩具<br>  patent family 专利族；同族专利<br>  patent attorney 专利律师；专利代理人；称为专利法务人员</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">**a suite of**</span></span><br></pre></td></tr></table></figure><p>  s : ui : te（ui读wi的音， 英 /swiːt/ ）<br>  一系列<br>  网络释义 一套；一整组；详细翻译（详细翻译&gt;&gt;a suite of 一系列；一套…）<br>  a suite of 一套；一整组；详细翻译<br>  a suite of racks 一套机架<br>  a suite of paintings 一组从不同角度和层次反映同一中心思想和题材的绘画</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*small*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  s : ma : ll  （ 英 /smɔːl/  ）<br>  adj. 少的，小的；微弱的；几乎没有的；不重要的；幼小的<br>  adv. 小小地；卑鄙地<br>  n. 小件物品；矮小的人<br>  n. （Small）人名；（英）斯莫尔<br>  网络释义 小的；小型的；小码；卡片纸英国标准<br>  small 小的；小型的；小码；卡片纸英国标准<br>  small intestine 小肠<br>  small incision 小切口；隧道切口；微创；微小切口</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*services*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  s : er : vi : ce : s  （ 英 /‘sə:visis/ ）<br>  n. 服务；服务项目（service复数形式）<br>  v. 服务（service的第三人称单数）<br>  网络释义 服务；服务项目；服务范围；服务业<br>  Services 服务；服务项目；服务范围；服务业<br>  Services 服务<br>  Web Services 网络服务；Web服务；应用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="keyword">each</span>**</span><br></pre></td></tr></table></figure><p>  ea : ch  （ 英 /iːtʃ/  ）<br>  det. （两个或两个以上的人或物中）各自<br>  pron. （两个或两个以上的人或物中）每个<br>  adv. 每个地<br>  adj. 各自的<br>  网络释义 每个；各自；每次；每一<br>  Each 每个；各自；每次；每一<br>  each other 互相；彼此；相互；取长补短<br>  Each line 每行</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="built_in">running</span>**</span><br></pre></td></tr></table></figure><p>  run : ning  （ 英 /ˈrʌnɪŋ/  ）<br>  n. 运转；赛跑；流出<br>  adj. 连续的；流动的；跑者的，运转着的<br>  v. 跑；运转（run的ing形式）；行驶<br>  n. (Running)人名；（英）朗宁<br>  网络释义 跑步；跑；磨合；运行<br>  running 跑步；跑；磨合；运行<br>  Running Man 过关斩将；奔跑吧兄弟；落跑老爸；奔跑的男人<br>  running shoes 跑步鞋；慢跑鞋；竞走鞋</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*own*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  o : wn （ 英 /əʊn/  ）<br>  vt. 拥有；承认<br>  vi. 承认<br>  adj. 自己的；特有的<br>  n. 自己的<br>  n.（Own）人名；（阿拉伯）奥恩（我就服这些人名，不会读是吧，读这个中文式译音人名就会读了）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="built_in">process</span>**</span><br></pre></td></tr></table></figure><p>  p : ro : ce : ss  (  英 /prəˈses; (for n.) ˈprəʊses/ )<br>  n. （为达到某一目标的）过程；（自然变化的）工程；工艺流程；诉讼程序；传票；突起；进展；（发型）直发式<br>  v. 加工；审核；处理（数据）；队列行进；冲印（照片）；把（头发）弄成直发<br>  adj. 经过特殊加工的；照相板的；染印法的<br>  第三人称单数 processes<br>  过去式 processed<br>  过去分词 processed<br>  现在分词 processing<br>  复数 processes<br>  网络释义 进程；流程；过程<br>  process 进程；流程；过程<br>  Process Management 进程管理；过程管理；流程管理；进程管理<br>  Background Process 后台进程；背景程序；背景处理程序</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*communicating*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  com : mu : ni : ca : ting ( 英 /kə’mjʊnə,keɪtɪŋ/ )<br>  adj. （房间）相同的，相连的<br>  v. 交流；传递；传播（communicate的现在分词）<br>  网络释义 沟通；交流；通信的互通的；交流与通讯<br>  Communicating 沟通；交流；通信的互通的；交流与通讯<br>  communicating vessels 连通器；连通管<br>  Communicating junctions 通讯连接</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*lightweight*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  li : ght : wei : ght ( 英 /ˈlaɪtweɪt/ )<br>  n. 轻量级（拳击手）；比通常重量轻的人或东西；无足轻重的人（或事）<br>  adj. 轻量的；给人印象不深的；无足轻重的；比通常重量轻的；浅薄的；<br>  网络释义 轻量级；轻身的；轻量；轻量化；<br>  lightweight 轻量级；轻身的；轻量；轻量化<br>  lightweight 轻填料；轻质搀和料<br>  lightweight cover 轻型上盖；避雷保护</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*mechanisms*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  me : cha : ni : sm : s（cha 读 ke 的音，英 /‘mekənɪzəmz/ ）<br>  n. 机制；[计]机构（mechanism的复数）；机械；[机]机构学<br>  网络释义 发病机制；发生机制；机制；机构<br>  Mechanisms 发病机制；发生机制；机制；机构<br>  interaction mechanisms 互动机制；作用机制<br>  resistant mechanisms 耐药机制；抗病机制</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*often*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  o : f : ten ( 英 /ˈɒfn; ˈɒftən/  )<br>  adv. 常常；时常；往往，大多<br>  比较级 more often 或 oftener；<br>  最高级 most often 或 oftenest<br>  网络释义 经常；常常；时常；常有<br>  Often 进场；常常；时常；常有<br>  more often 更经常；经常；更多的时候；更多<br>  OFT OFTen 常常；再三</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*HTTP*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  H : T : T : P ( 英 /ˌeɪtʃ tiː tiː ˈpiː/  )<br>  abbr. 超文本传输协议（Hyper Text Transfer Protocol）<br>  网络释义 超文本传输协议（Hyper Text Transfer Protocol）；网站；平台；超文本传送协议</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*resource*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  re : sou : r : ce ( 英 /rɪˈsɔːs; rɪˈzɔːs/  )<br>  n. 资源，财力；办法；智谋<br>  vi. 向…提供资金<br>  网络释义 资源；资源类型；财力；办法<br>  Resource 资源；资源类型；财力；办法<br>  human resource 人力资源；激励；人事部<br>  computational resource 计算资源</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*API*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  A : P : I ( /ˌeɪ piː ˈaɪ/  )<br>  abbr. 空气污染指数（Air Pollution Index）；应用程序界面（Application Program Interface）；精确位置指示器（Accurate Position Indicator）；美国石油学会（American Petroleum Institute）；自动发音教学机（Automated Pronunciation Instructor）<br>  网络释义 美国石油协会；应用程序接口；美国石油学会；应用编程接口<br>  API 美国石油协会；应用程序接口；美国石油学会；应用编程接口<br>  Windows API 使用；调用；关于进程操作的；关于线程操作的<br>  Google API 谷歌应用界面；应用程序编程接口；网址二维码生成函数；应用程序接口</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*these*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  th : e : se ( 英 /ðiːz/  )<br>  det. 这些（this的复数）<br>  pron. 这些（this的复数）<br>  adj. 这些的（this的复数）<br>  网络释义 这些，此等；复数；这些个<br>  These 这些；此等；复数；这些个<br>  Know these 知其然；到知其然<br>  These payments 营养费</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*built*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  bu : il : t ( 英 /bɪlt/ )<br>  v. 建造，建立；逐步增强；把…嵌入（墙壁、物体等）（build的过去式和过去分词）<br>  adj. 有…体格的；身段优美的；….建成的<br>  网络释义 建起；比优丽；建有；建好<br>  Built 建起；比优丽；建有；建好<br>  Built NY 比优丽<br>  BLT Built 建造；制作<br>  built in 安装在里面的；装入的；机内的<br>  built up 组合<br>  built on 以…作基础</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="keyword">around</span>**</span><br></pre></td></tr></table></figure><p>  a : roun : d ( 英 /əˈraʊnd/  )<br>  adv. 在四周；朝对立面；到处；漫无目的的；在附近；大约；围绕；以圆周计算；现有；转弯<br>  prep. 围绕；在那边；绕着；同…一致；到处；以（已提及物）为中心；迂回<br>  网络释义 围绕；四处；在周围；大约<br>  Around 围绕；四处；在周围；大约；<br>  come around 苏醒；顺便来访；来访；复原<br>  stick around 在附近逗留或等待；在附近等着；在邻近勾留或等候；逗留<br>  all round 周围；到处，四处<br>  around here 附近；在这周围<br>  go around 四处走动；供应；（消息）流传</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*business*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  bu : si : ne : ss ( 英 /ˈbɪznəs/ )<br>  n. 商业，交易；生意；事务，业务；职业，行业；<br>  网络释义 商业；生意；企业；业务<br>  Business 商业；生意；企业；业务<br>  Business 业务<br>  business cycle 商业周期；经济周期；商业周期；景气循环<br>  business card 名片；商务名片<br>  in business 经商；在经营；在商界<br>  business philosophy 经营理念，经营哲学</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*capabilities*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  ca : pa : bi : li : ti : es ( 英 /ˌkeɪpəˈbɪlətɪs/  )<br>  n. 能力（capability的复数）；功能；性能<br>  网络释义 能力；功能；权限；责任<br>  capabilities 能力；功能；权限；责任<br>  economic capabilities 经济实力；经济能力<br>  defense capabilities 防卫作战能力；防务能力；防卫功能；<br>  process capability 加工能力；工序能力<br>  design capability 设计能力</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*independently*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  in : de : pen : den : t : ly ( 英 /ˌɪndɪˈpendəntli/  )<br>  adv. 独立地；自立地<br>  网络释义 各自地；独立地；独自地；自立地<br>  independently 各自地；独立地；独自地；自立地<br>  think independently 独立思考；独立的思考<br>  living independently 独立生活<br>  independently of 独立于…之外；与…无关</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*deployable*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  de : p : lo : y : a : ble<br>  adj. 可开展的<br>  网络释义 可开展的；散播性<br>  deployable 可开展性的；散播性<br>  Deployable Structures 折叠结构；可展结构<br>  deployable joint 运动关节</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*fully*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  fu : lly ( 英 /ˈfʊli/  )<br>  adv. 充分地；完全地；彻底地<br>  n. (Fully)人名；（法）菲利<br>  网络释义 完全地；彻底地；充分地；十分地<br>  fully 完全地；彻底地；充分地；十分地<br>  FULLY OPENING 全开口；全启齿；齐闭口<br>  fully  secured 足额担保；全额担保<br>  fully automatic 全自动的<br>  fully integrated 完全整合<br>  fully loaded 满载</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="built_in">auto</span>mated**</span><br></pre></td></tr></table></figure><p>  au : to : ma : te : d ( 英 /ˈɔːtəˌmeɪtɪd/  )<br>  adj. 自动化的；机械化的<br>  v. 自动化（automate的过去分词）；自动操作<br>  网络释义 自动化的；自动的；机械化的；自动化<br>  automated 自动化的；自动的；机械化的；自动化<br>  automated design 自动设计；自动化设计；自动想象<br>  Automated inspection 自动化检验；自动检验<br>  automated machine 自动化机械；自动化的机器<br>  automated teller machine 自动柜员机<br>  automated welding 自动焊接</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*deployment*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  de : p : lo : y : men : t ( 英 /dɪˈplɔɪmənt/ )<br>  n. 调度，部署<br>  复数 deployments<br>  网络释义 部署；展开；发布；布防<br>  Deployment 部署，展开；发布；布防<br>  Deployment Editors 部署编辑器；安排编纂器<br>  Resources deployment 资源配置<br>  disposition n.调度，部署</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*machinery*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  ma  chi : ne : ry ( 英 /məˈʃiːnəri/  )<br>  n. 机械；机器；机构；机械装置<br>  网络释义 机械；机器；机具<br>  machinery 机械；机器；机具<br>  packaging machinery 包装机械；包装设备；包装机器；放大器<br>  Electrical Machinery 电机学；电力机械；电机；电机驱动<br>  machinery and equipment 机器及设备<br>  construction machinery 建筑机械；施工机械<br>  agricultural machinery 农业机械</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*there*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  the : re ( 英 /ðeə(r)/  )<br>  adv. 在那里；在那边；在那点上；<br>  int. 你瞧<br>  n. 那个地方<br>  网络释义 那里；在那里；那儿；那<br>  There 那里；在那里；那儿；那<br>  Always There 永驻；守候一生；到约定的那时；总在我身旁<br>  There be 句型；的句子结构；存在句；结构<br>  out there 到战场；在那里<br>  over there adv. 在那里<br>  go there 去那里</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*bare*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  b : are ( 英 /beə(r)/ )<br>  adj. 空的；赤裸的；无遮蔽的<br>  vt. 露出；使赤裸<br>  n. (Bare)人名；（英）贝尔<br>  比较级 barer<br>  最高级 barest<br>  过去式 bared<br>  过去分词 bared<br>  现在分词 baring<br>  网络释义 赤裸的；光光；赤裸；仅仅的<br>  bare 赤裸的；光光；裸露；仅仅的<br>  bare mass 裸质量<br>  bare machine 裸机；硬件计算机；裸机<br>  bare of vt. 几乎没有，缺乏<br>  lay bare 揭发，暴露；公开<br>  bare feet 赤脚；光脚；光着脚</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*minimum*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  mi : ni : mum ( 英 /ˈmɪnɪməm/ )<br>  n. 最小值；最低限度；最小化；最小量<br>  adj.最小的；最低的<br>  复数 minimums 或 minima<br>  网络释义 最小的；最低；起码；最小量<br>  minimum 最小的；最低；起码；最小量<br>  minimum charge 最低费用；最低运费；最低收费<br>  minimum balance 最小库存余量；最低余额；存款限制；把费用减到最低限度</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="keyword">bare </span>minimum of**</span><br></pre></td></tr></table></figure><p>  最低限度的<br>  网络释义 Bare Minimum Of Expense 最低支出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*centralized*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  cen : tra : li : ze : d ( 英 /‘sentrəlaɪzd/  )<br>  adj. 集中的；中央集权的<br>  v. 集中（centralize的过去分词）<br>  网络释义 集中的，中央集权的；一致<br>  Centralized 集中的；中央集权的；一致<br>  centralized control 集中控制；中央控制；集中控制方式；中心控制<br>  Centralized Monitoring 集中监控；中化监查<br>  centralized management 集中式管理；集权管理<br>  centralized control 集中控制<br>  centralized processing 集中式处理</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*management*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  ma : na : ge : men : t ( 英 /ˈmænɪdʒmənt/  )<br>  n. 管理；管理人员；管理部门；操纵；经营手段<br>  复数 managements<br>  网络释义 管理；经营；管理学；管理层；<br>  Management 管理；经营；管理学；管理层<br>  Management Accounting 管理会计；管理会计学；治理会计；会计管理<br>  performance management 绩效管理；业绩管理；性能管理<br>  management system 管理系统；经营责任制<br>  quality management 质量管理<br>  project management 项目管理；专案管理</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*written*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  wri : tten ( 英 /ˈrɪtn/  )<br>  adj. 书面的，成文的，文字的<br>  v. 写（writen的过去分词）<br>  网络释义 写成；写给；书面；成文<br>  Written 写成；写给；书面；成文<br>  written English 书面英语；书面语；书面表达；英语书面语<br>  written notice 书面通知；面通知；书面通知<br>  written by 由…所写<br>  written english 书面英语<br>  written consent 书面同意；同意书</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*different*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  di : ffe : ren : t ( 英 /ˈdɪfrənt/  )<br>  adj. 不同的；个别的；与众不同的<br>  网络释义 不同；差异；两样<br>  Different 不同；差异；两样<br>  different from 不同于；两回事；不同；区别于<br>  Different Seasons 四季奇谭；不同的季节；肖申克的救赎；不同季节<br>  different from 与…不同，不同于<br>  different kinds 不同的种类<br>  in different ways 以不同方式；用不同方法；通过不同的方式</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*programming*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  pro : g : ram : ming ( 英 /ˈprəʊɡræmɪŋ/  )<br>  n. 设计；规划；编制程序；[计]程序编制<br>  网络释义 编程；程序设计；编程；程序编制<br>  programming 编程；程序设计；编程；程序编制<br>  Linear Programming 线性规划；第二十九章；线性程序编制；线性规划法<br>  generic programming 泛型；泛型编程；程序设计；类属编程<br>  linear programming n. 线性规划<br>  programming language 编程语言；程序设计语言<br>  dynamic programming 动态规划；动态程序设计</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*languages*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  lan : g : ua : ge : s ( 美 /‘læŋgwɪdʒ/ )<br>  n. 语系，语种；语言文字（language复数）<br>  网络释义 语文；语言；语言能力；语言学<br>  Languages 语文；语言；语言能力；语言学<br>  altaic languages 阿尔泰语系；阿尔泰语言<br>  Uralic languages 乌拉尔语系<br>  modern languages 现代语言（modern language的复数）<br>  foreign languages school 外语学校<br>  romance languages 罗曼斯语（由拉丁语演变而成的语言）</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="keyword">use</span>**</span><br></pre></td></tr></table></figure><p>  u : se ( 英 /juːz/  )<br>  n. 使用；用途；发挥<br>  vt. 利用；耗费<br>  vi. 使用，运用<br>  n.(Use)人名；（德）乌泽<br>  过去式 used<br>  过去分词 used<br>  现在分词 using<br>  复数 uses<br>  第三人称单数 using<br>  网络释义 使用；用途；利用；应用<br>  use 使用；用途；利用；应用<br>  use up 用完；用光；耗尽<br>  Use Case 用例；用例图<br>  make use of 使用；利用<br>  in use 在使用中<br>  of use 有用</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="class"><span class="keyword">data</span>**</span></span><br></pre></td></tr></table></figure><p>  da : ta ( 英 /ˈdeɪtə; ˈdɑːtə/  )<br>  n. 数据（datum的复数）；资料<br>  n. (Data)人名；(日)驮太 (姓)；(印、葡)达塔<br>  网络释义 数据；资料；数据区；参考数据<br>  data 数据；资料；数据区；参考数据<br>  Data Center 数据中心；资料中心；数据交互中心<br>  data collection 数据收集；数据采集；数据搜集；搜集资料<br>  data processing 数据处理<br>  experimental data 实验数据；试验数据<br>  data mining 数据挖掘技术（即指从资料中发掘咨询或知识）</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*storage*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  s : to : ra : ge ( 英 /ˈstɔːrɪdʒ/  )<br>  n. 存储；仓库；贮藏所<br>  复数 storages<br>  网络释义 存储；储存；保管；贮藏；<br>  Storage 存储；储存；保管；贮藏<br>  storage room 行李仓；储物室；储藏室；贮藏室<br>  cold storage 冷藏；冷藏库；冷库；冷藏公司<br>  data storage 数据存储<br>  storage system 存储系统；存储器存储系统<br>  energy storage 蓄能；能量储存；储能器</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*technologies*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure><p>  te : ch : no : lo : gi : es (  美 /tɛk’nɑlədʒi/  )<br>  n. 技术；科技（technology的复数）<br>  网络释义 姓；科技<br>  Technologies 姓；科技<br>  Agilent Technologies 安捷伦科技公司；安捷伦科技有限公司；安捷伦<br>  United Technologies 联合技术；联合技术公司；联合科技；联合科技公司<br>  united technologies 联合科技（财富500强公司之一，总部所在地美国，主要经营航空航天）<br>  cleaner technologies 净化技术；清洁技术<br>  lucent technologies 美国朗讯科技公司（财富500强公司之一）<br>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Microservices-Guide-微服务指南词汇导读&quot;&gt;&lt;a href=&quot;#Microservices-Guide-微服务指南词汇导读&quot; class=&quot;headerlink&quot; title=&quot;Microservices Guide 微服务指南词汇导读&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="MICROSERVICES" scheme="https://fengshana.github.io/categories/MICROSERVICES/"/>
    
    
      <category term="MICROSERVICES" scheme="https://fengshana.github.io/tags/MICROSERVICES/"/>
    
      <category term="词汇" scheme="https://fengshana.github.io/tags/%E8%AF%8D%E6%B1%87/"/>
    
  </entry>
  
  <entry>
    <title>MicroservicesGuide-走近微服务</title>
    <link href="https://fengshana.github.io/2020/05/27/%E3%80%90MICROSERVICES%E3%80%91/%E3%80%90MICROSERVICES%E3%80%91MicroservicesGuide-%E8%B5%B0%E8%BF%91%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://fengshana.github.io/2020/05/27/%E3%80%90MICROSERVICES%E3%80%91/%E3%80%90MICROSERVICES%E3%80%91MicroservicesGuide-%E8%B5%B0%E8%BF%91%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-05-27T10:36:35.464Z</published>
    <updated>2020-06-05T17:56:56.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Nothing better than a buzy Saturday morning.</p></blockquote><p>为什么想要翻译这篇博客呢，因为也是看了b站上的一个学习springboot的一个视频，而且我今天面试的时候人家问了微服务是什么，然后由此可得我万分后悔没有当时通篇翻译这篇博客。<br>好了现在后悔也挽救不了我的愚不可及了。<br>观看笔记：<code>https://www.bilibili.com/video/BV1Eg4y187XT</code><br>就是这个视频告诉了我：推荐看哦~<br>为了不后悔，以后每件事情，能做笔记就一定要压着自己做，不然会后悔的；  </p><h2 id="Microservices-Guide-微服务指南（翻译）"><a href="#Microservices-Guide-微服务指南（翻译）" class="headerlink" title="Microservices Guide 微服务指南（翻译）"></a>Microservices Guide 微服务指南（翻译）</h2><p>链接：<code>https://www.martinfowler.com/microservices/</code>  </p><blockquote><p>A guide to material on martinfowler.com about microservices.<br><strong>Matin Fowler</strong><br>21 Aug 2019  </p></blockquote><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">martinfowler.com网站关于微服务的一个材料指南</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">--------------------------------------------------------</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">有道词典翻译：</span></span><br><span class="line"><span class="keyword">martinfowler.com </span>上关于微服务的材料指南。</span><br></pre></td></tr></table></figure><h3 id="Microservices-Guide"><a href="#Microservices-Guide" class="headerlink" title="Microservices Guide"></a>Microservices Guide</h3><h4 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h4><blockquote><p>In short , the microservice architectural style is an approach to developing a single application as a <strong>suite of small services</strong> , each <strong>running in its own process</strong>  and communicating with lightweight mechanisms , often an HTTP resource API .<br>These services are <strong>built around business capabilities</strong> and <strong>independently deployable</strong> by fully automated deployment machinery .<br>There is a bare minimum of centralized management of these services , which may be written in different programming languages and use different data storage technologies .<br>– <strong>James Lewis</strong> and <strong>Martin Fowler</strong>（2014）  </p></blockquote><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">简而言之，</span><br><span class="line">微服务架构风格 是一种近似于 将一个单体应用程序作为一个小型服务套件来进行开发的风格，</span><br><span class="line">每一个小型服务都运行在它自身的进程当中，</span><br><span class="line">并且通过轻量级机制进行相互间的交流，</span><br><span class="line">通常是以一种超文本传输协议资源应用编程接口的方式进行交互。</span><br><span class="line">这些服务都是围绕业务逻辑来进行构建的并且通过全自动化部署机制来进行独立部署。</span><br><span class="line">最低限度的集中式管理着这些服务（这些服务的集中管理非常少），</span><br><span class="line">通过这种方式，</span><br><span class="line">或许可以使用不同的程序语言进行编写以及使用不同的数据存储技术。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------</span><br><span class="line"></span><br><span class="line">有道词典翻译：</span><br><span class="line"></span><br><span class="line">简而言之，</span><br><span class="line">微服务体系结构风格是一种将单个应用程序作为一组小服务进行开发的方法，</span><br><span class="line">每个小服务都在自己的进程中运行，并与轻量级机制<span class="params">(通常是HTTP资源API)</span>进行通信。</span><br><span class="line">这些服务是围绕业务功能构建的，</span><br><span class="line">并且可以通过完全自动化的部署机制独立部署。</span><br><span class="line">这些服务的集中管理非常少，</span><br><span class="line">它们可以用不同的编程语言编写，</span><br><span class="line">并使用不同的数据存储技术。</span><br><span class="line">——詹姆斯·刘易斯和马丁·福勒<span class="params">(<span class="number">2014</span>)</span></span><br></pre></td></tr></table></figure><h3 id="Introduce-Martin-Fowler"><a href="#Introduce-Martin-Fowler" class="headerlink" title="Introduce - Martin Fowler"></a>Introduce - Martin Fowler</h3><p>了解微服务之前首先来看看<strong>Martin Fowler</strong>老爷子的自我介绍；<br>Fowler刚被我打成了Flower；  </p><p>简介链接：<code>https://www.martinfowler.com</code>  </p><h4 id="Contents-1"><a href="#Contents-1" class="headerlink" title="Contents"></a>Contents</h4><blockquote><p>Software development is a young profession , and we are still learning the techniques and building the tools to do it effectively .<br>I’ve been involved in this activity for over three decades and in the last two I’ve been writing on this website about patterns and practives that make it easier to build userful software .<br>The site began as a place to put my own writing , but I also use it to publish articles by my colleagues .  </p></blockquote><blockquote><p>In 2000 , I joined ThoughtWorkds , where my role is to learn about the techniques that we’ve learned to deliver software for our clients , and pass these techniques on to the wider software industry .<br>As this site has developed into a respected platform on software development , I’ve edited and published articles by me colleagues , both ThoughtWorkers and others , to help useful writing reach a wider audience .  </p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">软件发展是一个年轻的专业技术，</span><br><span class="line">并且我们是仍然在学习这门技术 和 构建一些工具去有效的完成它。</span><br><span class="line">我已经参与到这一项活动（工作）当中已经超过三十年了，</span><br><span class="line">并且在最近两年内，</span><br><span class="line">我在这个网站站点上已经编写了关于如何更容易的去构建有用的软件的一些思想模式以及练习方法；</span><br><span class="line">这个站点开始时作为来存放我自己的一个写作的一个地方，</span><br><span class="line">但是我也使用这个地方来进行发布一些通过我同事们写的文章；</span><br><span class="line"></span><br><span class="line">在<span class="number">2000</span>年，我加入到了ThoughtWorks，</span><br><span class="line">在这个地方我扮演的角色是去学习这一项技术，</span><br><span class="line">我们已经学习到去为我们的客户实现软件，</span><br><span class="line">以及通过这些技术在更广阔的软件产业当中；</span><br><span class="line">这个站点已经逐渐发展成为一个受人尊敬的平台在软件发展史当中，</span><br><span class="line">我已经写了很多以及发布了很多我同事写的文章，同时还有ThoughtWorkers的员工以及其他人；</span><br><span class="line">来帮助有用的写作，即逐渐成为一个有深度的受众；</span><br><span class="line"></span><br><span class="line">------------------------------------------------</span><br><span class="line"></span><br><span class="line">有道词典翻译：</span><br><span class="line">软件开发是一个年轻的职业，</span><br><span class="line">我们仍然在学习技术和构建工具来有效地完成它。</span><br><span class="line">我已经参与这项活动超过<span class="number">30</span>年了，</span><br><span class="line">在过去的两年中，</span><br><span class="line">我一直在这个网站上撰写关于使构建有用软件变得更容易的模式和实践的文章。</span><br><span class="line">这个网站一开始是一个放置我自己的文章的地方，</span><br><span class="line">但我也用它来发表我同事的文章。</span><br><span class="line"><span class="number">2000</span>年，我加入了ThoughtWorks，</span><br><span class="line">在这里，我的职责是学习我们为客户交付软件的技术，</span><br><span class="line">并将这些技术传递给更广泛的软件行业。</span><br><span class="line">随着这个网站发展成为一个受人尊敬的软件开发平台，</span><br><span class="line">我已经编辑并发表了我的同事们的文章，</span><br><span class="line">包括ThoughtWorkers和其他人，</span><br><span class="line">以帮助更广泛的读者阅读有用的文章。</span><br></pre></td></tr></table></figure><h3 id="A-website-on-building-software-effectively"><a href="#A-website-on-building-software-effectively" class="headerlink" title="A website on building software effectively"></a>A website on building software effectively</h3><p>A website on building software effectively</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在一个网站上有效地构建软件</span><br><span class="line"></span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line"></span><br><span class="line">一个有效开发软件的网站</span><br></pre></td></tr></table></figure><h4 id="Contents-2"><a href="#Contents-2" class="headerlink" title="Contents"></a>Contents</h4><blockquote><p>If there’s a theme that runs through my work and writing on this site , it’s the interplay between the shift towards agile thinking and the technical patterns and practices that make agile software development practical .<br>While specifics of technology change rapidly in our profession , fundamental practices and patterns are more stable .<br>So writing about these allows me to have articles on this site that are several years old but still as relevant as when they were written .  </p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如果 这是一个主题（定语：贯穿着我的工作经历以及在这个站点上的文字）</span><br><span class="line">那么在 转变成敏捷式思维 与 技术的模式和使得敏捷式软件开发 变成事实 这两者之间其实是相互影响的。</span><br><span class="line">当 技术的特性 在我们的职业该行当中 发展改变十分迅速 时，</span><br><span class="line">基本的实践练习 与 模式 就变得需要十分的牢固。</span><br><span class="line">所以编写这些关于 容许我在这个站点（定语：虽然才只有几岁即虽然才开始几年，但是只要当遇到与之相关的他们就都会被一致持续写入进来）上拥有了的文章。</span><br><span class="line"></span><br><span class="line"><span class="comment">---------------------------------------------</span></span><br><span class="line"></span><br><span class="line">有道词典翻译：</span><br><span class="line">如果说我在这个站点上的工作和写作中贯穿着一个主题，那就是敏捷思维的转变与使敏捷软件开发切实可行的技术模式和实践之间的相互作用。</span><br><span class="line">虽然技术细节在我们的职业中变化很快，但基本的实践和模式更加稳定。</span><br><span class="line">所以写这些东西让我可以在这个网站上写一些文章，这些文章已经有好几年的历史了，但是仍然和当初写的时候一样重要。</span><br></pre></td></tr></table></figure><blockquote><p>As software becomes more critical to modern business , software needs be able to react quickly to changes ,  allowing new features to be be conceived , developed and put into production rapidly .<br>The techniques of <font style="color:red;font-weight:bolder">agile software development</font> began in the 1990s and became steadily more popular in the last decade .<br>The focus on a flexible approach to planning , which allows software products to change direction as the user’s needs change and as product managers learn more about how to make their users effective .<br>While widely accepted now , agile approaches are not easy , requiring significant skills for a team , but more importantly a culture of open collaboration both within the team and with a team’s partners .  </p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">当软件为了现在的业务逻辑就越需要批评，</span><br><span class="line">软件需要能够快速地对改变做出反应，允许一些新特性被构思实现，发展以及迅速地落实成为一个产品。</span><br><span class="line">敏捷式开发软件的这项技术开始在<span class="number">1990</span>年的时候，直到在近十年内开始稳定地变得越发流行起来了。</span><br><span class="line">集中于在一个灵活性上，类似于规划预期中，它允许软件产品来进行定向的改变当客户需要进行改变以及当产品管理者学到更多关于如何让他们的客户变得印象深刻。</span><br><span class="line">当现在被更广泛的接受，敏捷式的处理是并不容易的，它要求重大的的技能对于一个团队来说，但是更重要的是一个开源合作的文化，这两者都需要团队以及团队成员之间的协作。</span><br><span class="line"></span><br><span class="line">----------------------------------------------------</span><br><span class="line"></span><br><span class="line">有道词典翻译：</span><br><span class="line">随着软件在现代商业中变得越来越重要，</span><br><span class="line">软件需要能够对变化做出快速反应，</span><br><span class="line">允许快速构思、开发新特性并将其投入生产。</span><br><span class="line">敏捷软件开发技术开始于<span class="number">20</span>世纪<span class="number">90</span>年代，并在过去十年中逐渐流行起来。</span><br><span class="line">他们专注于一种灵活的计划方法，</span><br><span class="line">这种方法允许软件产品随着用户需求的变化而改变方向，</span><br><span class="line">并且随着产品经理更多地了解如何让他们的用户更有效。</span><br><span class="line">虽然敏捷方法现在已被广泛接受，</span><br><span class="line">但它并不简单，</span><br><span class="line">需要团队的重要技能，</span><br><span class="line">但更重要的是团队内部和团队合作伙伴之间的开放协作文化。</span><br></pre></td></tr></table></figure><blockquote><p>This need to respond fluently to changes has an important impact upon the <font style="color:red;font-weight:bolder">architecture</font> of a software system.<br>The software needs to be built in such a way that it is able to adapt to unexpected changes in features .<br>One of the most important ways to do this is to write clear code , making it easy to understant what the program is supposed to do .<br>This code should be devided into modules which allow developers to understand only the parts of the system they need to make a change .<br>This production code should be supported with automated tests that can detect any errors made when making a change while providing examples of how internal structures are used .<br>Large and complex software efforts may find the <font style="color:red;font-weight:bolder">microservices</font> architectural style helps teams deploy software with less entangling dependencies .  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Creating software that has a good architecture isn’t something that can be done first time .<br>Like good prose , it needs regular revisions and programmers learn more about what the product needs to do and how best to design the product to achieve its goals .<br><font style="color:red;font-weight:bolder">Refactoring</font> is an essential technique to allow a program to be changed safety .<br>It consists of making small changes that don’t alter the observable behavior of the software .<br>Bt combining lots of small changes , developers can revise the software’s structure supporting significant modifications that weren’t planned when the system was first conceived .  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Software that runs only on a developer’s machine isn’t providing value to the customers of the software .<br>Traditionally releasing software has been a long and complicated process , one that hinders the need to evolve software quickly .<br><font style="color:red;font-weight:bolder">Continuous Delivery</font> uses automation and collaborative workflows to remove this bottleneck , allowing teams to release software as often as the customers demand .<br>For Continuous Delivery to be possible , we need to build in a solid foundation of <font style="color:red;font-weight:bolder">Testing</font> , with a range of automated tests that can give us confidence taht our changes haven’t introduced any bugs .<br>This leads us to integrate testing into programming , which can act to improve our architectural .  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Photostream"><a href="#Photostream" class="headerlink" title="Photostream"></a>Photostream</h3><h3 id="Data-Management"><a href="#Data-Management" class="headerlink" title="Data Management"></a>Data Management</h3><h4 id="Contents-3"><a href="#Contents-3" class="headerlink" title="Contents"></a>Contents</h4><blockquote><p>There are many kinds of softeare out there , the kind I’m primarily engaged is Enterprise Applications .<br>One of the enduring problems we need to tackle in this world is <font style="color:red;font-weight:bolder">data management</font> .<br>The aspectes of data management I’ve focused on here are how to migrate data stores as their applications respond to changing needs , coping with different contexts across a large enterprice , the role of NoSQL databases , and the broader issues of coping with data that is both Big and Messy .  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Domain-Specific-Languages"><a href="#Domain-Specific-Languages" class="headerlink" title="Domain-Specific Languages"></a>Domain-Specific Languages</h3><h3 id="Contents-4"><a href="#Contents-4" class="headerlink" title="Contents"></a>Contents</h3><blockquote><p>A common problem in complex software systems is how to capture complicated domain logic in a way that programmers can both easily manipulate and also easily communicate to domain experts .<br><font style="color:red;font-weight:bolder">Domain-Specific Languages</font>(DSLs) create a custom language for a particular problem , either with custom parsers or by conventions within a host language .  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Books"><a href="#Books" class="headerlink" title="Books"></a>Books</h3><h4 id="Contents-5"><a href="#Contents-5" class="headerlink" title="Contents"></a>Contents</h4><blockquote><p>I’ve written seven books on software development , including Refactoring , Patterns of Enterprise Application Architectural , and UML Distilled .<br>I’m also the editor of a signature series for Addison-Wesley that includes five jolt award winners .<br><font style="color:red;font-weight:bolder">My Books Page…</font>  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Conference-Talks"><a href="#Conference-Talks" class="headerlink" title="Conference Talks"></a>Conference Talks</h3><h4 id="Contents-6"><a href="#Contents-6" class="headerlink" title="Contents"></a>Contents</h4><blockquote><p>I’m often asked to give talks at conferences , from which I’ve inferred that I’m a pretty good speaker - which is ironic since I really hate giving talks .<br>You can form your own opinion of my talks by watching videos of some my conference talks .<br><font style="color:red;font-weight:bolder"> My Videos Page…</font>  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Board-Games"><a href="#Board-Games" class="headerlink" title="Board Games"></a>Board Games</h3><h4 id="Contents-7"><a href="#Contents-7" class="headerlink" title="Contents"></a>Contents</h4><blockquote><p>I’ve long been a fan of board games , I enjoy a game that fully occupies my mind , clearing out all the serious thoughts for a bit , while enjoying the company of good friends .<br>Modern board games saw dramatic improvement in the 1990’s with the rise of Eurogames , and I expect many people would be surprised if they haven’t tried any of this new generation .<br>I also appear regularly on <font style="color:red;font-weight:bolder">Heavy Cardboard</font> .<br><font style="color:red;font-weight:bolder">My Board Games page…</font>  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Nothing better than a buzy Saturday morning.&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
    
      <category term="MICROSERVICES" scheme="https://fengshana.github.io/categories/MICROSERVICES/"/>
    
    
      <category term="面试" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="MICROSERVICES" scheme="https://fengshana.github.io/tags/MICROSERVICES/"/>
    
  </entry>
  
  <entry>
    <title>全面深入讲解MySQL数据库优化01</title>
    <link href="https://fengshana.github.io/2020/05/27/%E3%80%90MYSQL%E3%80%91/%E3%80%90MYSQL%E3%80%91%E5%85%A8%E9%9D%A2%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%9601/"/>
    <id>https://fengshana.github.io/2020/05/27/%E3%80%90MYSQL%E3%80%91/%E3%80%90MYSQL%E3%80%91%E5%85%A8%E9%9D%A2%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%9601/</id>
    <published>2020-05-27T10:35:55.031Z</published>
    <updated>2020-06-05T17:55:42.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：<code>https://www.bilibili.com/video/BV1fJ41127Rj?from=search&amp;seid=13531213796559959972</code>  </p><p>本课程作为MySQL高级课程，主要讲解了：  </p><ul><li><strong>MySQL</strong>中的<strong>视图</strong>/<strong>存储过程</strong>/<strong>触发器</strong>/<strong>索引</strong>等对象的使用</li><li>常见的<strong>SQL</strong>语句<strong>优化</strong>的技巧</li><li><strong>应用优化</strong></li><li><strong>数据库优化</strong></li><li><strong>数据库日志</strong></li></ul><p>等方面的知识，并通过综合案例，对课程中的知识进行一个整合应用。  </p><p>本课程旨在通过MySQl高级部分内容，可以在满足现有业务需求基础上，对<strong>MySQL底层的体系结构</strong>，及<strong>底层的优化</strong>有一个深入的理解，对<strong>系统的整体性能</strong>进行提升。  </p><h2 id="课程内容介绍"><a href="#课程内容介绍" class="headerlink" title="课程内容介绍"></a>课程内容介绍</h2><blockquote><p>Mysql高级-day01</p></blockquote><p>MySQL高级课程简介</p><ol><li>Linux系统安装MySQL</li><li><strong>索引</strong></li><li><strong>视图</strong></li><li><strong>存储过程</strong>和<strong>函数</strong></li><li><strong>触发器</strong></li></ol><h3 id="MySQL高级课程简介"><a href="#MySQL高级课程简介" class="headerlink" title="MySQL高级课程简介"></a>MySQL高级课程简介</h3><table>    <tr>      <th>序号</th>      <th>Day01</th>      <th>Day02</th>      <th>Day03</th>      <th>Day04</th>    </tr>    <tr>      <td>1</td>      <td>Linux系统安装MySQL</td>      <td>体系结构</td>      <td>应用优化</td>      <td>MySQL常用工具</td>    </tr>    <tr>      <td>2</td>      <td>索引</td>      <td>存储引擎</td>      <td>查询缓存优化</td>      <td>MySQL日志</td>    </tr>    <tr>      <td>3</td>      <td>视图</td>      <td>优化SQL步骤</td>      <td>内存管理及优化</td>      <td>MySQl主从复制</td>    </tr>    <tr>      <td>4</td>      <td>存储过程和函数</td>      <td>索引使用</td>      <td>MySQL锁问题</td>      <td>综合案例</td>    </tr>    <tr>      <td>5</td>      <td>触发器</td>      <td>SQL优化</td>      <td>常用SQL技巧</td>      <td></td>    </tr></table><h2 id="Linux上安装MySQL"><a href="#Linux上安装MySQL" class="headerlink" title="Linux上安装MySQL"></a>Linux上安装MySQL</h2><h3 id="下载Linux安装包"><a href="#下载Linux安装包" class="headerlink" title="下载Linux安装包"></a>下载Linux安装包</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/dev.mysql.com/downloads</span><span class="regexp">/mysql/</span><span class="number">5.7</span>.html<span class="comment">#downloads</span></span><br></pre></td></tr></table></figure><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><ol><li><strong>卸载</strong>centos中预安装的mysql</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep -i mysql # 查询服务器当中mysql的安装包是否存在，存在则显示出存在安装包的名称</span><br><span class="line"></span><br><span class="line">rpm -e mysql-libs<span class="number">-5.1</span><span class="number">.71</span><span class="number">-1.e16</span>.x86_64 --nodeps # 对已存在的安装包(mysql-libs<span class="number">-5.1</span><span class="number">.71</span><span class="number">-1.e16</span>.x86_64)进行卸载</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>上传</strong>mysql的安装包</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alt + p -------&gt;put E:/tset/MySQL<span class="number">-5.6</span><span class="number">.22</span><span class="number">-1.e16</span>.i686.rpm-bundle.tar（MySQL安装包的目录）</span><br><span class="line"></span><br><span class="line"># 使用SecureCRT远程连接服务器工具，alt+p命令进入sftp模式；再执行put （MySQL安装包的目录）[ 上传 ]</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>解压</strong>mysql的安装包</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir mysql</span><br><span class="line"></span><br><span class="line">tar -xvf MySQL-<span class="number">5.6</span>.<span class="number">22</span>-<span class="number">1</span><span class="selector-class">.e16</span><span class="selector-class">.i686</span><span class="selector-class">.rpm-bundle</span><span class="selector-class">.tar</span> -c /root/mysql</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>安装</strong>依赖包</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装第三方的依赖库；yum -y 在线安装需连接网络</span><br><span class="line">yum -y install libaio.so<span class="number">.1</span> libgc_s.so<span class="number">.1</span> libstdc++.so<span class="number">.6</span> libncurses.so<span class="number">.5</span> --setopt=protected_multilib=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">yum update listdc++<span class="number">-4.4</span><span class="number">.7</span><span class="number">-4.e16</span>.x86_64 # 更新第三方类包</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>安装</strong>mysql-client</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rpm</span> <span class="selector-tag">-ivh</span> <span class="selector-tag">MySQL-client-5</span><span class="selector-class">.6</span><span class="selector-class">.22-1</span><span class="selector-class">.e16</span><span class="selector-class">.i686</span><span class="selector-class">.rpm</span></span><br></pre></td></tr></table></figure><ol start="6"><li><strong>安装</strong>mysql-server</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rpm</span> <span class="selector-tag">-ivh</span> <span class="selector-tag">MySQL-server-5</span><span class="selector-class">.6</span><span class="selector-class">.22-1</span><span class="selector-class">.e16</span><span class="selector-class">.i686</span><span class="selector-class">.rpm</span></span><br></pre></td></tr></table></figure><blockquote><p>Linux</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ipconfig</span> <span class="comment"># 查看本机ip地址，内网地址</span></span><br></pre></td></tr></table></figure><h2 id="启动及登录MySQL"><a href="#启动及登录MySQL" class="headerlink" title="启动及登录MySQL"></a>启动及登录MySQL</h2><blockquote><p><strong>启动mysql</strong>命令</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service mysql status  # 查看mysql服务状态</span><br><span class="line">service mysql start   # 启动mysql服务</span><br><span class="line">service mysql stop    # 停止mysql服务</span><br></pre></td></tr></table></figure><blockquote><p><strong>登录mysql</strong></p></blockquote><p>mysql 安装完成之后，会自动生成一个<strong>随机密码</strong>，并且保存在一个密码文件中：/root/<strong>.mysql_secret</strong>；  </p><blockquote><p><strong>查看</strong>随机密码</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/root/</span>.mysql_secret</span><br></pre></td></tr></table></figure><blockquote><p><strong>登录</strong>命令</p></blockquote><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line"><span class="meta"># -u 指的是用户</span></span><br><span class="line"><span class="meta"># -p 指的是该用户所对应的密码</span></span><br></pre></td></tr></table></figure><blockquote><p>登录之后，修改密码命令</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">password</span> = <span class="keyword">password</span>(<span class="string">'itcast'</span>);</span><br><span class="line"><span class="comment"># itcast即明文密码</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>授权远程访问</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'itcast'</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>防火墙</strong></p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service iptables status # 查看防火墙状态</span><br><span class="line">service iptables stop # 关闭防火墙</span><br></pre></td></tr></table></figure><h2 id="索引-概述"><a href="#索引-概述" class="headerlink" title="索引 - 概述"></a>索引 - 概述</h2><p><strong>MySQL官方</strong>对<strong>索引</strong>的定义为：  </p><p><strong>索引</strong>（<strong>index</strong>）是 <strong>帮助</strong> MySQL <strong>高效 获取数据</strong> 的 <strong>数据结构</strong>（<strong>有序</strong>）。  </p><p>在数据之外，<strong>数据库系统</strong> 还 <strong>维护</strong>着 满足 <strong>特定查找</strong> <strong>算法</strong> 的 <strong>数据结构</strong>，<br>这些 <strong>数据结构</strong> 以 某种方式 <strong>引用</strong>（<strong>指向</strong>）<strong>数据</strong>，<br>这样就可以在这些 <strong>数据结构</strong> 上实现 <strong>高级查找算法</strong>，<br>这种 <strong>数据结构</strong> 就是 <strong>索引</strong>。<br>如下面的示意图所示：  </p><p>左边是数据库，一共有两列七条记录，最左边的是数据记录的物理地址<br>（注意 <strong>逻辑上 相邻的记录</strong> 在<strong>磁盘上</strong> 也 <strong>不是一定物理相邻</strong> 的）。  </p><p>为了<strong>加快Col2的查找</strong>，可以<strong>维护</strong>右边所示的<strong>二叉查找树</strong>，<br>每个<strong>结点</strong>分别包含 <strong>索引键值</strong> 和一个 <strong>指向</strong> <strong>对应数据记录</strong> <strong>物理地址</strong> 的 <strong>指针</strong>，<br>这样就可以运用 <strong>二叉查找</strong> 快速后去到相应数据。  </p><p>一般来说 <strong>索引本身也很大</strong>，<br><strong>不可能全部存储在内存</strong> 中，<br>因此索引往往以 <strong>索引文件</strong> 的形式 <strong>存储在磁盘</strong> 上，<br><strong>索引</strong>是数据库中用来 <strong>提供性能</strong> 的最常用的工具。  </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mspaint</span> <span class="comment"># windows打开画板</span></span><br></pre></td></tr></table></figure><table>  <tr>    <td>物理地址</td>    <td>Col1</td>    <td>Col2</td>  </tr>  <tr>    <td>0x07</td>    <td>1</td>    <td>34</td>  </tr>  <tr>    <td>0x56</td>    <td>2</td>    <td>77</td>  </tr>  <tr>    <td>0x6A</td>    <td>3</td>    <td>5</td>  </tr>  <tr>    <td>0xF3</td>    <td>4</td>    <td>91</td>  </tr>  <tr>    <td>0x90</td>    <td>5</td>    <td>22</td>  </tr>  <tr>    <td>0x77</td>    <td>6</td>    <td>59</td>  </tr>  <tr>    <td>0xD1</td>    <td>7</td>    <td>3</td>  </tr></table><p>当前该为一张数据库表；<br>在数据库表的左侧展示的是每一条记录的一个<strong>物理地址</strong>；<br>右侧则是两列；<br>一列字段Col1是序号；<br>Col2字段数据可以认为就是主键数据；<br>数据库表结构有了，接下来查询数据；  </p><p><strong>（1）第一种情况</strong>：<br><strong>查询主键Col2为34的数据</strong>；<br>因为这个时候只存在表，<strong>没有设置索引</strong>这些方便查询的<strong>数据结构</strong>；<br>所以这个时候就会在表当中 <strong>自上而下</strong> 的进行 <strong>遍历</strong>；<br>这个时候就会去遍历到第一个，发现第一个的主键id，Col2的值就是34；此时即拿到数据；<br>这样的话 <strong>只</strong> 需要 <strong>查询一条记录</strong>；<br>而且<strong>查询第一条记录就是</strong>，那么这样的话<strong>查询速度</strong>是<strong>很快</strong>的；<br>这只是第一种情况；  </p><p><strong>（2）第二种情况</strong>：<br><strong>查询主键Col2 id为91的记录行数据</strong>；<br>那么还是需要<strong>自上而下</strong>从id为34的记录行数据开始<strong>遍历</strong>；<br>那么第一条记录不是；<br>第二条记录不是；<br>第三条记录也不是；<br>直到第四条记录的时候发现数据行id是91；<br>那么这个时候也就是需要去遍历列表4次，查询4次才能够得到结果；  </p><p><strong>（3）第三种情况</strong>：<br><strong>查询主键Col2 id为3的记录行数据</strong>；<br>这个时候再来看，如果说遍历查询的元素id是3；<br>那么这个时候依然是 <strong>从上往下</strong> 进行<strong>遍历</strong>，一直<strong>遍历到</strong>列表的<strong>最底部</strong>；<br>才能将3查找出来；那么这个时候就相当于需要进行一个<strong>全表扫描</strong>的这样一个操作；<br>对于当前该表当中只有6、7条数据；<br>但是如果在<strong>实际开发</strong>当中<strong>数据量</strong>比较<strong>大</strong>；<br>一张表当中存储了几百万上千万的记录；<br>那么这个时候如果只有表中的记录，而没有索引的话；<br>这个时候就会造成一种现象，在查找的时候<strong>从上往下</strong>进行<strong>整表扫描</strong>，所以这种<strong>查询效率</strong>是<strong>非常慢</strong>的；  </p><p>以上就是第一种情况，即<strong>没有建立索引</strong>的情况；<br><strong>查询效率很慢</strong>；  </p><p>下面分析<strong>有了索引</strong>之后，又是<strong>如何</strong>进行<strong>查找</strong>的；<br>此时有了表结构还需要对表结构当中的<strong>字段进行建立索引</strong>；<br><strong>索引就是一种数据结构</strong>；<br>那么此时就可以使用<strong>数据结构</strong>来表示这种表当中的索引；<br>这里使用一种 <strong>数据结构 二叉树</strong>；  </p><p>既然是 <strong>二叉树</strong>；<br>那么二叉树当中的第一个结点，也就是34；<br>即<strong>根节点</strong>；<br>34即作为当前该树状结构的<strong>根结点</strong>；  </p><p>接下来第二行记录是77；  </p><p>对于<strong>二叉树</strong>来说，<strong>二叉树</strong>有一个特点；<br>即当<strong>根结点已经存在</strong>的时候，<strong>再插入下一个结点</strong>；<br>则需要将 <strong>下一个结点的数值</strong>与<strong>根结点的数值</strong> 进行 <strong>比较大小</strong>；<br>如果<strong>比根结点小</strong>则放在<strong>左边</strong>，称之为生成一个<strong>左子树</strong>；<br>如果<strong>比根结点大</strong>则放在<strong>右边</strong>，称之为生成一个<strong>右子树</strong>，作为<strong>右子树</strong>存在；</p><p>这个时候77是比34要大的，所以放在34的右边，即77为34<strong>根结点</strong>的一个<strong>子节点</strong>；  </p><p>接下来第三行是5，需要对5也要进行插入到二叉树该数据结构当中，那么此时也是需要进行与34根结点进行比较的；<br>此时5比34要小；那么则放在根结点34的左边，所以此时34根结点又有一个子节点5；  </p><p>当5插入到二叉树结构当中之后，接着下一行记录91；<br>则首先将91与34根结点进行比较大小；<br>显然91比34要大，则处于根结点34的右边；  </p><p>当前使用的是<strong>二叉树</strong>的这种<strong>数据结构</strong>，也就意味着 <strong>每一个结点</strong> <strong>最多</strong> 都<strong>只能有</strong> <strong>2个分支</strong>；所以称之为<strong>二叉树</strong>；  </p><p>所以当此时34 <strong>根结点</strong> 已经有了两个分支之后，那么此时91比34大，但是34的右边已经有元素77了，所以这个时候91就需要去和77去进行比较；<br>77与91进行比较，91显然要大，所以放在77的右侧，作为77的一个<strong>右子节点</strong>存在；  </p><p>接下来是第5行记录数据集22；22比34小，显然要放在根结点的左侧；<br>但是<strong>根结点</strong>的<strong>左侧</strong>已经有<strong>左子节点</strong>也就是5；<br>那么此时22就去与5进行比较，显然22比5大；也就放在5的右边；称为5的<strong>右子结点</strong>；  </p><p>最后还剩下最后两条记录，一个是59一个是3；<br>快速过一下；59首先和34这个元素进行比较；<br>显然59比34大需要放在34的右侧；<br>然34已经有右子结点77了，那么这个时候59和77进行比较；<br>显然77大于59，那么这个时候就将59放置在77的左侧，叶子结点91的左边，成为77的左子节点；  </p><p>同理最后一个元素，3也是同样的方式；<br>3与34进行比较；显然3比34要小；<br>然此时34是存在有<strong>左子节点</strong>5的；<br>那么这个时候就将3与5进行比较；显然3比5要小；<br>那么这个时候；就把3放在5的左侧；<br>成为5的左子节点，叶子结点22的左侧；  </p><p>此时到此为止二叉树已经构建完毕；二叉树构建完毕之后再来进行分析；<br>构建了一棵二叉树之后就能够提高查询效率吗？  </p><p>（<br>我认为；<br>在二叉树一定的深度下，二叉树依然会存在查询效率慢的情况；<br>）  </p><p>二叉树构建好了之后，再来进行搜索；<br>如果按照刚才的查询情况；<br>先进行搜索34这一数值；  </p><p>搜索二叉树；那么就需要到索引的结构二叉树的数据结构当中来进行搜索；<br>在进行<strong>二叉树搜索</strong>的时候，是<strong>从根结点处开始进行查询匹配数值</strong>；<br>即树状结构当中最顶层的这一节点即为根结点；<br>最底层的结点，即3、22、59、91这四个结点称之为<strong>叶子结点</strong>；<br>那么<strong>二叉树的搜索</strong>是<strong>从根节点开始进行搜索的</strong>；  </p><p>走根结点34；这个时候就已经将34查询到了，那么这个时候就可以直接进行返回即可；<br>但是如果这一块当中查询的并不是34而是3；<br>那么此时仍然先会去搜索根结点34，将要查询搜索的值3去与根节点34进行比较；<br>发现3比根结点要小；<br>所以此时就会去根结点的左侧，即左子树当中去进行查找3；  </p><p><strong>二叉树</strong>当中<strong>根结点的左边</strong>的称之为<strong>左子树</strong>；<strong>右边</strong>则称之为<strong>右子树</strong>；  </p><p>那么在左子树当中通过3去跟根结点的左子节点5进行比较，那么此时5比3要大；<br>所以紧接着，让3去跟结点5的左子节点3去进行比较；<br>所以在这个时候就找到了3这个元素；<br>而找到了3之后，二叉树的这种数据结构是如何关联到表当中具体行数当中的具体数据的呢？<br>这个时候就需要看笔记当中提到的一句话：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</span><br></pre></td></tr></table></figure><p>那也就意味着，二叉树这种数据结构当中的每一个结点都是需要 <strong>指向</strong>具体表当中具体行数的具体数据；<br>那么从刚才的查询规律当中<strong>从上而下</strong>进行查找3，则从根结点34到左子节点5，再从5到5的左子节点3查找到了3这一元素的指向/引用即可找到在具体某表当中的具体某一行的数据；<br>那么这样的话就查找到了数据；  </p><table>  <tr>    <td>物理地址</td>    <td>Col1</td>    <td>Col2</td>  </tr>  <tr>    <td>0x07</td>    <td>1</td>    <td>34</td>  </tr>  <tr>    <td>0x56</td>    <td>2</td>    <td>77</td>  </tr>  <tr>    <td>0x6A</td>    <td>3</td>    <td>5</td>  </tr>  <tr>    <td>0xF3</td>    <td>4</td>    <td>91</td>  </tr>  <tr>    <td>0x90</td>    <td>5</td>    <td>22</td>  </tr>  <tr>    <td>0x77</td>    <td>6</td>    <td>59</td>  </tr>  <tr>    <td>0xD1</td>    <td>7</td>    <td>3</td>  </tr></table><blockquote><p><strong>分析</strong>：<strong>没有建立索引</strong> 的表与 <strong>建立了索引</strong> 的表当中，建立了索引之后 <strong>性能</strong> 的一个 <strong>提升</strong> ；</p></blockquote><ul><li><p><strong>没有建立索引</strong> 的表：<br>在没有建立索引的情况下，如果是要进行查询数据元素3；<br>那么则需要把整张表当中所有的数据都需要进行 <strong>遍历</strong> 一遍即 <strong>全表扫描</strong> ，直到找到3这个id数据；  </p></li><li><p><strong>建立了索引</strong> 的表：<br>如果是在建立了索引的这种情况之下；<br>那么同样还是查找元素3；<br>只需要查找第一次34；第二次5；第三次3即可；三次即可；<br>那么这样的话这个时候通过 <strong>索引</strong> 由 <strong>二叉树</strong> 这种 <strong>数据结构</strong> 实现的话就 <strong>不再需要去遍历整张表的数据</strong> 了；<br>通过 <strong>二叉树</strong> 这种 <strong>数据结构</strong> 就可以 <strong>快速</strong> 的 <strong>定位</strong> 到3这个查询的数据元素；<br>那么这就是<strong>索引</strong>；<strong>索引的目的</strong> 即在于 <strong>快速</strong> 的来 <strong>查找数据</strong>；  </p></li></ul><h2 id="索引-优势和劣势"><a href="#索引-优势和劣势" class="headerlink" title="索引 - 优势和劣势"></a>索引 - 优势和劣势</h2><blockquote><p><strong>优势</strong><br>1） 类似于书籍的 <strong>目录索引</strong> ， <strong>提高数据检索的效率</strong> ， <strong>降低数据库的IO成本</strong> ；<br>2） 通过 <strong>索引列</strong> 对 <strong>数据</strong> 进行 <strong>排序</strong> ， <strong>降低数据排序的成本</strong> ，<strong>降低CPU的消耗</strong> ；  </p></blockquote><blockquote><p><strong>劣势</strong><br>1）实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录， <strong>索引列</strong> 也是要 <strong>占用空间</strong> 的；（并不放在内存当中而是 <strong>放在磁盘当中</strong> ， <strong>索引占用磁盘空间</strong> ）<br>2）虽然 <strong>索引</strong> <strong>大大提高了查询效率</strong> ，同时却也 <strong>降低</strong> 了 <strong>更新表的速度</strong> ，如对表进行 <strong>INSERT、UPDATE、DELETE</strong> （都需要 <strong>对索引进行维护</strong>，也就是相关实现该索引的数据结构当中存储的数据也要进行变动）。因为 <strong>更新表</strong> 时，MySQL不仅要 <strong>保存数据</strong> ，还要 <strong>保存</strong> 一下 <strong>索引文件</strong> 每次 <strong>更新添加</strong> 了 <strong>索引列的字段</strong> ，都会因为更新所带来的的 <strong>键值变化</strong> 后的索引信息。（所以 <strong>索引的字段并不是越多越好也会影响到性能</strong> ）  </p></blockquote><h2 id="索引-索引结构"><a href="#索引-索引结构" class="headerlink" title="索引 - 索引结构"></a>索引 - 索引结构</h2><p><strong>索引</strong> 是在<strong>MySQL</strong>的 <strong>存储引擎</strong> 层中实现的，而不是在服务器层实现的。  </p><p>所以每种存储引擎的索引都不一定完全相同；也不是所有的存储引擎都支持所有的索引类型。  </p><p>MySQL目前提供了以下4中索引：  </p><ul><li><strong>BTREE索引</strong>：最常见的索引类型，大部分索引都支持 <strong>B树索引</strong> ；</li><li><strong>HASH索引</strong>：只有 <strong>Memory引擎</strong> 支持，<br>使用场景简单（刚刚看了下我当前MySQL数据库现在InnoDB也支持HASH哦）；</li><li><strong>R-tree索引（空间索引）</strong>：<strong>空间索引</strong> 是 <strong>MyISAM引擎</strong> 的一个 <strong>特殊索引类型</strong> ，<br>主要用于 <strong>地理空间数据类型</strong> ，<br>通常使用较少，不做特别介绍；</li><li><strong>Full-text（全文索引）</strong>：<strong>全文索引</strong> 也是 <strong>MyISAM</strong> 的一个 <strong>特殊索引类型</strong>，<br>主要用于 <strong>全文索引</strong> ，</li><li><em>InnoDB*</em> 从 <strong>MySQL5.6</strong> 版本开始支持 <strong>全文索引</strong> ；  </li></ul><p>这个统计应该也有些时候了；不是一定正确的哦；<br>需要结合当前不同版本的MySQL来说明；<br>我还是贴一下吧；  </p><h3 id="MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持"><a href="#MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持" class="headerlink" title="MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持"></a>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</h3><table>  <tr>    <th>索引</th>    <th>InnoDB引擎</th>    <th>MyISAM引擎</th>    <th>Memory引擎</th>  </tr>  <tr>    <td>BTREE索引</td>    <td>支持</td>    <td>支持</td>    <td>支持</td>  </tr>  <tr>    <td>HASH索引</td>    <td>不支持</td>    <td>不支持</td>    <td>支持</td>  </tr>  <tr>    <td>R-tree索引</td>    <td>不支持</td>    <td>支持</td>    <td>不支持</td>  </tr>  <tr>    <td>Full-text索引</td>    <td>5.6版本之后支持</td>    <td>支持</td>    <td>不支持</td>  </tr></table><p>平常所说的索引，如果没有特别指明，都是指 <strong>B+树</strong> （ <strong>多路搜索树</strong> ，并不一定是二叉的）结构组织的索引。<br>其中 <strong>聚集索引</strong>、 <strong>复合索引</strong> 、 <strong>前缀索引</strong> 、 <strong>唯一索引</strong> 默认都是使用 <strong>B+tree树索引</strong> ，统称为 <strong>索引</strong> 。  </p><h2 id="索引-索引结构-BTREE"><a href="#索引-索引结构-BTREE" class="headerlink" title="索引 - 索引结构 - BTREE"></a>索引 - 索引结构 - BTREE</h2><p><strong>BTree</strong> 又叫做 <strong>多路平衡搜索树</strong> ，一棵 <strong>m</strong> 叉的 <strong>BTree</strong> 特性如下：  </p><ul><li><strong>树</strong> 中每个 <strong>结点</strong> <strong>最多</strong> 包含 <strong>m</strong> 个孩子；</li><li><strong>除根结点与叶子结点</strong>外，<br>每个 <strong>结点</strong> <strong>至少</strong> 有[ <strong>cell ( m / 2 )</strong> ]（cell<strong>向上取整</strong>）个 <strong>孩子</strong> ；</li><li>若<strong>根结点不是叶子结点，则至少有两个孩子</strong>；</li><li><strong>所有的叶子结点都在同一层</strong>；</li><li>每个<strong>非叶子结点</strong>由 <strong>n</strong> 个 <strong>key</strong> 与 <strong>n + 1</strong> 个<strong>指针</strong>组成，<br>其中 <strong>[cell ( m / 2 ) -1 ] &lt; = n &lt; =  m - 1</strong></li></ul><p>（对于<strong>二叉树</strong>来说，<strong>树</strong>中的每个<strong>结点</strong> <strong>最多有2个分支</strong> ）  </p><p>以5叉BTree为例（当前根结点下最多有5个分支，即每个结点下最多包含5个孩子），key的数量：公式推导[ cell ( m / 2 ) - 1 ] &lt; = n &lt; = m-1 ；所以 2 &lt; = n &lt; = 4。<br>当n&gt;4时，中间节点分裂到父节点，两边结点分裂。<br>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例；<br>1）插入前4个字母C N G A；  </p><table border="1">  <tr>    <td>A</td>    <td>C</td>    <td>G</td>    <td>N</td>  </tr></table><p>（按照26个字母排队顺序，字母A在C前，C排在G前，G排在N前的顺序进行排列）  </p><p>2）插入H ，n &gt; 4，中间元素G字母向上分裂到新的结点；  </p><table border="1">  <tr>    <td>A</td>    <td>C</td>    <td>G</td>    <td>H</td>    <td>N</td>  </tr></table><p>所以演变成中间元素G字母向上分裂到新的结点，即G分裂到父节点；</p><table border="1"><tr>     <td colspan="5" style="text-align:center">G</td>  </tr>  <tr>    <td>A</td>    <td>C</td>    <td></td>    <td>H</td>    <td>N</td>  </tr></table><br><table border="1">  <tr>     <td></td>    <td></td>      <td></td>     <td colspan="2" style="text-align:center;background-color:lightblue;color:black;">G</td>     <td></td>     <td></td>    <td></td>  </tr>  <tr>     <td></td>    <td></td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>     <td></td>    <td></td>  </tr>  <tr>    <td colspan="8"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C</td>    <td></td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span> N</td>  </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>新插入的H结点会在元素G之后，那么排序也就是 A C G H N 这个样子的一个排序；那么此时的中间的结点就是G元素了；那么按照规则，当n&gt;4时，中间节点分裂到父节点；此时的G元素结点就将会进行一次分裂；分裂至父节点（H插入至BTree则G分裂至父节点）；而此时两边结点进行一次分裂；也就是原本的中间元素中间节点G左边的A、C以及右边的（新插入的）H、N就将会被分裂成父节点G的两边结点；左边的A、C分裂至父节点G的左子节点；右边的H、N分裂至父节点G的右子结点；  </p><p>接下来继续进行插入操作；插入元素E；<br>插入的E首先进行跟根结点G进行比较前后顺序；比较完成之后，E应该是在根结点G的排位在前的；所以应该被放在根结点G的左侧；也就是结点A、C该侧，A、C、E这三个元素也是需要进行排出一个顺序来的，那么也就是A、C、E这样的一个顺序排列放置；插入的是左边；由于左边元素未构成5个，所以不做任何的（分裂）变化等；  </p><p>接下来再继续插入元素K；<br>在K插入元素的时候就需要拿G与K元素的前后排位顺序进行比较，K的排位顺序比G大，所以插入到根结点G的右侧，也就是H、N所在该侧；插入的是右边，即插入时也需要与H、N这两个元素相进行比较排位顺序，也就是K元素插入到H、N这两个元素的中间；那么此时右侧的元素未构成5个所以不作任何变化；  </p><p>接下来继续插入Q；<br>插入Q也是需要与根节点G相进行比较排位顺序的；得出Q是在G之后，那么就将Q放在G根节点的右侧，然后将Q进行与节点元素H、K、N相进行比较；得到排列顺序H、K、N、Q这样一个排列顺序，当然此时仍然不需要做出（分裂）变化；因为此时n并没有超过4；只有当n超过4的时候才会发生分裂的变化；分叉小于等于4的情况下并不做任何的分裂改变只进行结点元素间的大小排位；  </p><p>在此之前一直在说分裂；当前已经分裂过一次；也就是A、C、G、H、N的时候进行将G分裂至父节点；A、C结点与H、N结点进行两边结点的分裂；并且插入了三个新的元素E、K、Q；  </p><p>此时需要说明的是：  </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个非叶子结点由 n 个 <span class="type">key</span> 与 n + <span class="number">1</span> 个指针组成，其中[ cell( m / <span class="number">2</span>) <span class="number">-1</span> ] &lt; = n &lt; = m<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>n+1个指针值的就是每个结点下都有两个方块，这两个方块都是指针存储区域；<br>指针的含义：当进行插入一个元素的时候，比如说插入元素E；当插入E元素的时候会进行与根节点G进行一个前后顺序排位的一个对比；如果E比G要小；那么E元素就需要放在G的左侧，指向左侧；成为根结点当中的左子节点当中的一个；那么这个时候就由G结点的左指针指向左子节点的方向；通过左边的这个指针指向左边的这个数据块；小于G那么这个指针就指向的是小于G的这个数据块（也就是左侧的左子结点）；大于G那么指向的就是大于G的这个数据块（也就是右侧的右子结点）；  </p><p>即</p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="2" style="text-align:center;background-color:lightblue;color:black;">G</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>  </tr>  <tr>    <td colspan="11"></td>  </tr>  <tr>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C<span style="margin-left:5px;margin-right:5px;"></span> E</td>    <td></td>    <td></td>    <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> N <span style="margin-left:5px;margin-right:5px;"></span> Q</td>  </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>接下来继续插入M元素；M与G根结点相进行比较，应该是属于在G的后面的；所以应该排放在G的右侧；通过G的右指针指向右边的数据块；M插入进来之后，应该要介于K和N之间；也就是说此时G的右子结点当中的排列顺序为H、K、M、N、Q这样一个排列顺序；这个时候就需要将M插入到K和N之间；但是当M插入到K和N之间之后，此时右子结点当中的元素已经超过了4个，即5个了；超过4个元素那么此时就要发生分裂变化，M结点刚好是中间节点；即会要发生中间节点（新插入的元素）M结点元素最终需要向上分裂到G父节点当中去，以及同时左右两边的元素H、K以及H、Q需要分裂变化成两块；  </p><p>问题：明白没有？小朋友？<br>答：明白了！(ಥ_ಥ)  </p><p>经过分裂之后再来看其指针；那么根结点当中的三个指针分别指的是；第一个指针指的是小于根节点当中的G元素则指针指向左侧第一个数据元素块A、C、E；第二个指针，则因为根节点当中存在两个元素；所以中间这个第二个指针用于大于根节点当中的G元素而小于根节点当中的M元素则指向中间的H、K的这个数据块；最后根节点当中的第三个指针用于大于根节点当中M元素的指向第三个数据元素块即N、Q；  </p><p>问题：明白？小朋友？<br>答：明白了！o(ﾟДﾟ)っ！  </p><p>当前为插入M的数据结构；  </p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">G<span style="margin-left:5px;margin-right:5px;"></span> M</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="14"></td>  </tr>  <tr>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C<span style="margin-left:5px;margin-right:5px;"></span> E</td>    <td></td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    N <span style="margin-left:5px;margin-right:5px;"></span> Q</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>当前M插入完成之后，继续插入F、W、L、T这四个数据元素；<br>那么此时插入F、W、L、T这四个数据元素时是不需要进行分裂变化的；因为当这四个元素插入进来之后，各个数据块当中的key 结点都没有超过4；所以是不需要进行分裂变化处理的；  </p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">G<span style="margin-left:5px;margin-right:5px;"></span> M</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="18"></td>  </tr>  <tr>    <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C<span style="margin-left:5px;margin-right:5px;"></span> E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    N <span style="margin-left:5px;margin-right:5px;"></span> Q<span style="margin-left:5px;margin-right:5px;"></span> T<span style="margin-left:5px;margin-right:5px;"></span> W</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>上述F、W、L、T这四个元素插入完成之后，接着插入元素Z；<br>插入Z的时候，首先会进行与根节点的G和M相进行比较；Z元素比G、M都要大；所以就由根结点的第三个指针指向第三个数据块，也就是N、Q、T、W；走向第三个数据块时又会与第三个数据块当中的元素相进行比较得到其元素排列顺序N、Q、T、W、Z这样一个排列摆放位置；所以此时将Z插入第三个数据块当中的最后一个位置，当Z元素出现在W元素之后的时候，此时观察第三个数据库块当中的元素个数已经超过了4，即已经成为5个了，那么此时这5个元素当中中间元素需要进行向上分裂，分裂至父节点，然后其左右两边需要分裂成两个数据块；该第三个数据块当中的中间元素为T；T元素此时应当符合条件需要分裂至上一节点父节点当中去；以及T元素在分裂至父节点之前原来两边的结点需要进行分裂成两块也就是N、Q结点以及W、Z结点这两大块进行分裂开来称为单独的结点；</p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">G<span style="margin-left:5px;margin-right:5px;"></span> M<span style="margin-left:5px;margin-right:5px;"></span> T</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="20"></td>  </tr>  <tr>    <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C<span style="margin-left:5px;margin-right:5px;"></span> E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    N <span style="margin-left:5px;margin-right:5px;"></span> Q<span style="margin-left:5px;margin-right:5px;"></span>     </td>    <td></td><td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>当元素Z插入完成之后，接下来进行插入元素D；<br>元素D和根结点当中的G、M、T相比，显然是都小于这三者的；所以由根结点当中的第一个指针进行指向第一个数据块，也就是A、C、E、F这个数据块当中来；并且D元素需要进行与数据块元素当中的A、C、E、F这四个元素需要进行比较排序顺序大小；即通过排序顺序可得A、C、D、E、F；插入进来之后，此时该数据块当中的key元素大于4个了，即出现了5个；那么此时就需要将该数据块元素当中的那个中间元素（D作为该数据块当中的中间元素存在），也就是刚刚新插入的元素D进行向上分裂至父节点G、M、T当中去，且分裂至父节点的元素D也需要与G、M、T进行一个排序，排序得到D、G、M、T这样一个排列顺序；那么此时分裂至父节点的元素D的两边的元素同样也需要进行分裂成两个结点；即A、C与E、F进行分裂开来；<br>最终出现的数据结构：  </p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">D<span style="margin-left:5px;margin-right:5px;"></span> G<span style="margin-left:5px;margin-right:5px;"></span> M<span style="margin-left:5px;margin-right:5px;"></span> T</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="22"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C    </td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    N <span style="margin-left:5px;margin-right:5px;"></span> Q<span style="margin-left:5px;margin-right:5px;"></span>     </td>    <td></td><td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>当元素D插入完成之后，接着进行插入元素P、R、X、Y；<br>插入P、R、X、Y时并不需要进行相应的变化分裂；因为插入到数据块当中元素key并没有满足 &gt; 4 的这样一个条件；所以并不需要做出分裂；  </p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">D<span style="margin-left:5px;margin-right:5px;"></span> G<span style="margin-left:5px;margin-right:5px;"></span> M<span style="margin-left:5px;margin-right:5px;"></span> T</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="26"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C    </td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    N<span style="margin-left:5px;margin-right:5px;"></span> P<span style="margin-left:5px;margin-right:5px;"></span> Q<span style="margin-left:5px;margin-right:5px;"></span> R</td>    <td></td><td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> X<span style="margin-left:5px;margin-right:5px;"></span> Y<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>当插入元素P、R、X、Y这四个元素之后，接下来进行插入最后一个元素S；<br>S首先和根结点当中的是个元素D、G、M、T进行比较；显然介于M与T之间；即大于M而小于T这样一个范围；从而使得根结点的第四个指针指向第四个数据块，即N、P、Q、R这一个数据块当中；而当S插入到第四个数据块当中首先也是需要进行比较排序顺序大小的；有顺序可得；得到顺序为N、P、Q、R、S这样一个顺序排列；将S插入到该数据块当中来；此时第四个数据块当中的元素个数已经达到了5个，也就是超过了4个就需要进行分裂了；那么此时；该数据块当中的中间元素为Q；也就是Q元素需要进行向上分裂至父节点D、G、M、T该数据块当中去；以及Q元素两边的元素需要进行分裂，也就是N、P与R、S这两块分裂开来；<br>但是Q如果此时向上进行分裂，而此时父节点当中的元素对向上分裂来的Q元素进行排序得到D、G、M、Q、T；父节点插入元素Q；父节点当中的元素也达到了了5个；也需要进行分裂；其父节点当中的中间元素为M元素，则此时M元素继续向上进行分裂，则M更新称为该BTree的根节点；而M两边的元素，即D、G两元素与Q、T两元素则这两块进行分裂开来，D、G块称为根结点M的左子节点，Q、T块称为M根结点的右子结点；这就是所提到的五叉BTree结构的一个演变过程；</p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="2" style="text-align:center;background-color:lightblue;color:black;">M</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">D<span style="margin-left:5px;margin-right:5px;"></span>  G    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    Q <span style="margin-left:5px;margin-right:5px;"></span> T</td>         <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C    </td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    N<span style="margin-left:5px;margin-right:5px;"></span> P</td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">R<span style="margin-left:5px;margin-right:5px;"></span> S</td>    <td></td><td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> X<span style="margin-left:5px;margin-right:5px;"></span> Y<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>了解了五叉BTree数据结构的一个演变过程之后回过头来再看；一棵m叉的BTree特性；<br>如果是一个五叉的BTree；<br>则：  </p><ul><li>树中每个结点最多包含m个孩子；即树中每个结点最多包含5个孩子；不能多于5个，即不能多于m个；  </li></ul><blockquote><p>举例</p></blockquote><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">D<span style="margin-left:5px;margin-right:5px;"></span> G<span style="margin-left:5px;margin-right:5px;"></span> M<span style="margin-left:5px;margin-right:5px;"></span> T</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="26"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C    </td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    N<span style="margin-left:5px;margin-right:5px;"></span> P<span style="margin-left:5px;margin-right:5px;"></span> Q<span style="margin-left:5px;margin-right:5px;"></span> R</td>    <td></td><td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> X<span style="margin-left:5px;margin-right:5px;"></span> Y<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><ul><li>除根结点与叶子结点外，每个结点至少有 [ cell( m / 2 )]个孩子；即每个结点至少有5/2=3（向上取整）个孩子；M为根节点；AC块、EF块、HKL块、NP块、RS块、WXYZ块为叶子结点；所以仅剩DG块与QT块非叶子结点也非根节点；这两块分别有三个字节点，DG块的孩子即AC块、EF块、HKL块；QT块的孩子即NP块、RS块、WXYZ块；  </li></ul><blockquote><p>举例</p></blockquote><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="2" style="text-align:center;background-color:lightblue;color:black;">M</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">D<span style="margin-left:5px;margin-right:5px;"></span>  G    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    Q <span style="margin-left:5px;margin-right:5px;"></span> T</td>         <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C    </td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    N<span style="margin-left:5px;margin-right:5px;"></span> P</td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">R<span style="margin-left:5px;margin-right:5px;"></span> S</td>    <td></td><td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> X<span style="margin-left:5px;margin-right:5px;"></span> Y<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><ul><li>若根结点不是叶子结点，则至少有两个孩子；</li></ul><blockquote><p>举例</p></blockquote><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="2" style="text-align:center;background-color:lightblue;color:black;">M</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">D<span style="margin-left:5px;margin-right:5px;"></span>  G    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    Q <span style="margin-left:5px;margin-right:5px;"></span> T</td>         <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C    </td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    N<span style="margin-left:5px;margin-right:5px;"></span> P</td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">R<span style="margin-left:5px;margin-right:5px;"></span> S</td>    <td></td><td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> X<span style="margin-left:5px;margin-right:5px;"></span> Y<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><ul><li>所有的叶子结点都在同一层；</li></ul><blockquote><p>举例</p></blockquote><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="2" style="text-align:center;background-color:lightblue;color:black;">M</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">D<span style="margin-left:5px;margin-right:5px;"></span>  G    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    Q <span style="margin-left:5px;margin-right:5px;"></span> T</td>         <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>    <td></td>    <td></td>    <td></td>    <td></td><td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td colspan="28"></td>  </tr>  <tr>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C    </td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">    N<span style="margin-left:5px;margin-right:5px;"></span> P</td>    <td></td>    <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">R<span style="margin-left:5px;margin-right:5px;"></span> S</td>    <td></td><td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    W<span style="margin-left:5px;margin-right:5px;"></span> X<span style="margin-left:5px;margin-right:5px;"></span> Y<span style="margin-left:5px;margin-right:5px;"></span> Z</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>      <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><ul><li>每个非叶子结点由n个key与n+1个指针组成；其中[ cell( m / 2)-1] &lt; = n &lt; = m - 1；即</li></ul><p>key即指的每一个结点当中的元素；指针即用来指向数据块</p><table border="1">  <tr>    <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>     <td></td>    <td></td>     <td colspan="3" style="text-align:center;background-color:lightblue;color:black;">G<span style="margin-left:5px;margin-right:5px;"></span> M</td>     <td></td>    <td></td>     <td></td>    <td></td>    <td></td>    <td></td>    <td></td>  </tr>  <tr>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td></td>    <td></td>     <td></td>     <td></td>     <td></td>  </tr>  <tr>    <td colspan="18"></td>  </tr>  <tr>    <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">A<span style="margin-left:5px;margin-right:5px;"></span> C<span style="margin-left:5px;margin-right:5px;"></span> E<span style="margin-left:5px;margin-right:5px;"></span> F</td>    <td></td>    <td></td>    <td colspan="4" style="text-align:center;background-color:lightblue;color:black;">H<span style="margin-left:5px;margin-right:5px;"></span>  K<span style="margin-left:5px;margin-right:5px;"></span> L    </td>    <td></td>    <td></td>      <td colspan="5" style="text-align:center;background-color:lightblue;color:black;">    N <span style="margin-left:5px;margin-right:5px;"></span> Q<span style="margin-left:5px;margin-right:5px;"></span> T<span style="margin-left:5px;margin-right:5px;"></span> W</td>      </tr>  <tr>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td></td>    <td></td>    <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>    <td></td>    <td></td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>     <td style="background-color:lightgreen;color:black;">指针</td>  </tr></table><p>到此已经提到了两种数据结构，一种是二叉树；一种是BTree；这两个数据结构可以拿过来相互比较一下优劣；  </p><p>BTree数据结构相对于二叉树相比；存在有多个分支；而二叉树一个结点仅仅只存在有两个结点；那么对于相同数据量来说，二叉树的数据层次，也就是二叉树的深度要更高一些；一旦层次更深也就意味着查找数据的时候；磁盘的IO的次数也就更多；从而导致查询的效率也就比较低；<br>到此，该BTree树就已经构建完成了，BTREE树和二叉树相比，查询数据的效率更高，因为对于相同的数据量来说，BTREE的层次结构相比二叉树小，因此搜索速度更快；  </p><h2 id="索引-索引结构-B-TREE"><a href="#索引-索引结构-B-TREE" class="headerlink" title="索引 - 索引结构 - B+TREE"></a>索引 - 索引结构 - B+TREE</h2><p>B+Tree为BTree的变种，B+Tree与BTree的区别为：<br>1） n叉B+Tree最多含有n个key，而BTree最多含有n-1个key；<br>2） B+Tree的叶子结点保存所有的key信息，依照key大小顺序排列；<br>3） 所有的非叶子结点都可以看做是key的索引部分；  </p><p>没有子节点的结点称之为叶子结点；叶子结点当中包含了所有key的信息；叶子结点当中的key才是完整的包含了所有的key的信息；包含了所有的数据信息；根结点当中以及非叶子结点当中的key起到的是一个索引的作用；索引就是为了查找到叶子结点当中的key；而且对于B+树来说所有的数据都是存储在叶子结点上面了；非叶子结点是不存在数据信息的；B树当中的所有数据是跟结点挂钩的；B+树当中所有的key存储在叶子结点所有的数据也都存储在叶子结点上了；<br>这也是B+树与B树的一个区别；  </p><p>B+Tree相对于BTree的一个优势：<br>由于B+Tree只有叶子结点保存key信息，查询任何key都要从root走到叶子（非叶子结点上的key都是起到一个索引的作用并没有数据，叶子结点上的key才关联着相关的数据信息），所以B+Tree的查询效率更加稳定；  </p><h2 id="索引-索引结构-MySQL中的B-Tree"><a href="#索引-索引结构-MySQL中的B-Tree" class="headerlink" title="索引 - 索引结构 - MySQL中的B+Tree"></a>索引 - 索引结构 - MySQL中的B+Tree</h2><p>MySQL索引数据结构对经典的B+Tree进行了优化。<br>在原B+Tree的基础上，增加一个指向相邻叶子结点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能；<br>问题：为什么要增加这样一个指针？<br>答：方便进行查询；  </p><blockquote><p>增加该指针的原因在于：方便进行范围搜索；  </p></blockquote><p>举例：如果想要进行搜索id为9~15的数据；由于有该指针相连所以从9一直查询链表下一结点到15即可；<br>所以该链表指针的作用主要是用来提高区间访问的性能；  </p><h2 id="索引-索引分类"><a href="#索引-索引分类" class="headerlink" title="索引 - 索引分类"></a>索引 - 索引分类</h2><p>1） 单值索引：即一个索引值包含单个列，一个表可以有多个单列索引(一个索引当中只包含一个列；比如现在需要对某一张表当中建立索引；该表当中有多个字段name、gender、age、help_category_id等字段，但是只针对name该字段该列进行建立索引；help_category_id也可以建立个索引；则当前存在两个索引，但是每个索引只对应了相对应的一列；这个叫做单列索引或者是单值索引；一个表当中可以包含有多个单列索引)<br>2） 唯一索引：索引列的值必须唯一，但允许有空值；（当前表当中某一个字段或者是某一列当中其值都是唯一的；也就是说如果存在有列当中的值都是唯一的；那么必要情况下就可以针对该列建立一个唯一索引，在唯一索引的该列当中允许包括有多个NULL值；）<br>3） 复合索引：即一个索引包含多个列（比如：经常在查询当中需要对name字段以及parent_category_id或者是说age字段进行联合查询，那么此时可以将name字段以及age字段组合起来建立一个复合索引，即一个索引当中包含了两个列或者说多个列；那么这种索引称之为复合索引）；  </p><h2 id="索引-索引语法"><a href="#索引-索引语法" class="headerlink" title="索引 - 索引语法"></a>索引 - 索引语法</h2><p>索引在创建表的时候，可以同时创建，也可以随时增加新的索引；<br>准备环境：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> demo_01 <span class="keyword">default</span> charset=utf8mb4;</span><br><span class="line"></span><br><span class="line">use demo_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">'city'</span>(</span><br><span class="line">    <span class="string">'city_id'</span> <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT;</span><br><span class="line">    <span class="string">'city_name'</span> <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="string">'country_id'</span> <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (<span class="string">'city_id'</span>)</span><br><span class="line">)ENGINE=InnoDB <span class="keyword">DEFAULT</span> CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">'country'</span>(</span><br><span class="line">    <span class="string">'country_id'</span> <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT;</span><br><span class="line">    <span class="string">'country_name'</span> <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (<span class="string">'country_id'</span>)</span><br><span class="line">)ENGINE=InnoDB <span class="keyword">DEFAULT</span> CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'city'</span>(<span class="string">'city_id'</span>,<span class="string">'city_name'</span>,<span class="string">'country_id'</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'西安'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'city'</span>(<span class="string">'city_id'</span>,<span class="string">'city_name'</span>,<span class="string">'country_id'</span>) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'NewYork'</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'city'</span>(<span class="string">'city_id'</span>,<span class="string">'city_name'</span>,<span class="string">'country_id'</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'北京'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'city'</span>(<span class="string">'city_id'</span>,<span class="string">'city_name'</span>,<span class="string">'country_id'</span>) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'上海'</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'country'</span>(<span class="string">'country_id'</span>,<span class="string">'country_name'</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'China'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'country'</span>(<span class="string">'country_id'</span>,<span class="string">'country_name'</span>) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'America'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'country'</span>(<span class="string">'country_id'</span>,<span class="string">'country_name'</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Japan'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'country'</span>(<span class="string">'country_id'</span>,<span class="string">'country_name'</span>) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'UK'</span>);</span><br></pre></td></tr></table></figure><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>语法：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">UNIQUE</span> | <span class="keyword">FULL</span> <span class="built_in">TEXT</span> |SPATIAL] <span class="keyword">INDEX</span> index_name</span><br><span class="line">[ <span class="keyword">using</span> index_type ]</span><br><span class="line"><span class="keyword">ON</span> tb1_name(index_col_name, .... )</span><br><span class="line"></span><br><span class="line">index_col_name : column_name[ ( <span class="keyword">length</span> ) ] [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ]</span><br></pre></td></tr></table></figure><p>索引的类型：UNIQUE唯一索引、FULLTEXT全文索引、SPATIAL；索引类型可选；可以不进行指定；<br>index_name：索引的名称；<br>using index_type：索引所使用的哪一个类型；如果不指定；则使用，默认的索引类型即B+树索引类型；<br>ON tb1_name(index_col_name, ….)：进行指定对哪一张表的哪几个字段创建索引；  </p><p>在MySQL当中，如果当前该字段是主键的话；则默认该字段默认有一个索引叫做主键索引；  </p><p>所以此时在city表当中对city_id字段的索引不必再进行创建；可以在city_name字段上创建索引；  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_city_name <span class="keyword">on</span> city(city_name);<span class="comment">#此时在city_name字段上创建的该索引为普通索引；</span></span><br></pre></td></tr></table></figure><p>示例：为city表中的city_name 字段创建索引：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_city_name <span class="keyword">on</span> city(city_name);</span><br></pre></td></tr></table></figure><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><p>语法：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> <span class="built_in">table_name</span>; #<span class="built_in">table_name</span>，索引所建立在该字段，该字段所处的表的名称</span><br></pre></td></tr></table></figure><p>示例：查看city表中的索引信息：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> city\G; <span class="comment">#\G格式化</span></span><br></pre></td></tr></table></figure><p>在MySQL当中会默认对主键city_id字段创建一个索引就称作是主键索引key_name：primary；<br>而刚刚对city_name创建的索引则为key_name：idx_city_name；<br>主键索引primary以及刚刚没有指定索引类型的idx_city_name的索引类型都是BTREE类型；即B+Tree索引，BTree索引；</p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>语法：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> tb1_name;</span><br><span class="line"><span class="comment"># index_name索引的名称</span></span><br><span class="line"><span class="comment"># 该index_name索引所具体在的表的名称</span></span><br></pre></td></tr></table></figure><p>示例：想要删除city表上的索引[ idx_city_name ]，可以操作如下：  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> idx_city_name <span class="keyword">on</span> city;</span><br></pre></td></tr></table></figure><p>删除之后可以通过以下命令来进行查看删除的索引是否仍然存在；</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> <span class="built_in">table_name</span>\G;</span><br></pre></td></tr></table></figure><h3 id="ALTER指令"><a href="#ALTER指令" class="headerlink" title="ALTER指令"></a>ALTER指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alter 修改</span></span><br><span class="line"><span class="comment"># 该语句添加一个主键，这意味着索引值必须唯一，且不能为NULL；</span></span><br><span class="line">1. <span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> primary <span class="keyword">key</span>(column_list);</span><br><span class="line"></span><br><span class="line"><span class="comment"># unique 唯一的</span></span><br><span class="line"><span class="comment"># 这条语句创建索引的值必须是唯一的（除了NULL意外，NULL可能会出现多次）</span></span><br><span class="line"><span class="comment"># Non_unique:0 #Non不，unique唯一；0：否定；双重否定等于肯定；即唯一</span></span><br><span class="line"><span class="comment"># 当创建普通索引时其Non_unique:1；即不唯一；  </span></span><br><span class="line">2. <span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> <span class="keyword">unique</span> index_name(column_list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加普通索引，索引值可以出现多次</span></span><br><span class="line">3. <span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> <span class="keyword">index</span> index_name(column_list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 该语句指定了索引为FULLTEXT，用于全文索引</span></span><br><span class="line">4. <span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> fulltext index_name(column_list);</span><br></pre></td></tr></table></figure><p>示例：添加唯一索引  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> city <span class="keyword">add</span>  <span class="keyword">unique</span>  idx_city_name(city_name);</span><br></pre></td></tr></table></figure><h2 id="索引-索引设计原则"><a href="#索引-索引设计原则" class="headerlink" title="索引 - 索引设计原则"></a>索引 - 索引设计原则</h2><p>索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引；  </p><ul><li>对查询频次较高，且数据量比较大的表建立索引；</li><li>索引字段的选择，最佳候选列应当从where子句的条件中提取（即查询条件当中的字段），如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。</li><li>使用唯一索引，区分度越高，使用索引的效率越高；</li><li>索引可以有效的提升查询数据的效率，但是索引数量不是多多益善；索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价（维护索引的数据结构），降低DML操作的效率，增加响应操作的时间消耗；另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但是无疑提高了选择的代价；</li><li>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，乡音的可以有效地提升MySQL访问索引的I/O效率。</li><li>利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升性能；  </li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建复合索引：</span><br><span class="line"></span><br><span class="line">CREATE <span class="built_in">INDEX</span> idx_name_email_status ON tb_seller(<span class="keyword">NAME</span>,email,<span class="keyword">STATUS</span>);</span><br><span class="line"></span><br><span class="line">就相当于</span><br><span class="line">      对<span class="keyword">name</span> 创建了索引；</span><br><span class="line">      对<span class="keyword">name</span> , email 创建了索引；</span><br><span class="line">      对<span class="keyword">name</span> , email , <span class="keyword">status</span> 创建了索引；</span><br><span class="line">只需要创建这么一个索引，在查询<span class="keyword">name</span>单个字段的时候就将会走索引；在查询<span class="keyword">name</span>，email这两个字段的时候也会走索引；在查询<span class="keyword">name</span>,email,<span class="keyword">status</span>这三个字段的时候也会走索引；  </span><br><span class="line">最左索引：最左指的是复合索引当中的第一个字段，只要查询的时候包含第一个字段，那么这个时候就会走索引；</span><br></pre></td></tr></table></figure><h2 id="视图-创建及修改视图"><a href="#视图-创建及修改视图" class="headerlink" title="视图 - 创建及修改视图"></a>视图 - 创建及修改视图</h2><p>视图（View）是一种虚拟存在的表。<br>视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。<br>通俗的讲，视图就是一条SELECT语句执行后返回的结果集。<br>所以在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。  </p><p>视图相对于普通表的又是主要包括以下几项：  </p><ul><li>简单：使用视图的用户完全不需要关心后面对应表的结构、关联条件和筛选条件，对用户来说已经是过滤好的符合条件的结果集。  </li><li>安全：使用视图的用户只能访问他们被允许查询的结果喜，对表的权限管理并不能先知道某个行某个列，但是通过视图就可以简单的实现；</li><li>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响；</li></ul><h3 id="创建或者修改视图"><a href="#创建或者修改视图" class="headerlink" title="创建或者修改视图"></a>创建或者修改视图</h3><blockquote><p>创建视图的语法为</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">OR</span> <span class="keyword">REPLACE</span>] [ ALGORITHM = &#123; UNDEFINED | <span class="keyword">MERGE</span> | TEMPTABLE &#125; ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">VIEW</span> view_name [ (column_list) ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line"></span><br><span class="line">[ <span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> | <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> <span class="keyword">OPTION</span> ]</span><br></pre></td></tr></table></figure><blockquote><p>修改视图的语法</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> [ ALGORITHM = &#123; UNDEFINED | <span class="keyword">MERGE</span> | TEMPTABLE &#125; ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">VIEW</span> view_name [ (column_list) ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line"></span><br><span class="line">[ WITE [ <span class="keyword">CASCADED</span> | <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> <span class="keyword">OPTION</span> ]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选项：</span><br><span class="line">    <span class="keyword">WITH</span> [ <span class="keyword">CASCADED</span> | <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> <span class="keyword">OPTION</span> 决定了是否允许更新数据使记录不在满足视图的条件；</span><br><span class="line">    <span class="keyword">LOCAL</span> 只要满足本视图的条件就可以更新</span><br><span class="line">    <span class="keyword">CASCADED</span> 必须满足所有针对该视图的所有视图的条件才可以更新（默认值）</span><br><span class="line"></span><br><span class="line">    <span class="keyword">CREATE</span> [ <span class="keyword">OR</span> <span class="keyword">REPLACE</span>] 创建或者是替换</span><br><span class="line">    <span class="keyword">AS</span> select_statement select_statement即<span class="keyword">select</span>语句</span><br></pre></td></tr></table></figure><p>示例：在视图当中展示国家以及其相关城市的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>; <span class="comment"># 显示在该数据库下所有的表</span></span><br><span class="line">desc table_name; <span class="comment"># 显示该table_name当中的表结构</span></span><br><span class="line">desc city;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> city c,country t <span class="keyword">where</span> c.country_id=t.country_id;</span><br><span class="line"><span class="keyword">select</span> c.*,t.country_name <span class="keyword">from</span> city c,country t <span class="keyword">where</span> c.country_id=t.country_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_city_country <span class="keyword">as</span> <span class="keyword">select</span> c.*,t.country_name <span class="keyword">from</span> city c,country t <span class="keyword">where</span> c.country_id=t.country_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> view_city_country;<span class="comment"># 查询视图与表操作一致</span></span><br><span class="line"><span class="keyword">update</span> view_city_country <span class="keyword">set</span> city_name=<span class="string">'西安市'</span> <span class="keyword">where</span> city_id=<span class="number">1</span>;<span class="comment">#修改视图与表操作一致</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> city; <span class="comment"># 这个时候基础表当中的数据也会被更新掉；也就是说此时的视图修改操作是会影响到基础表当中的数据；  </span></span><br><span class="line">虽然视图能够做到更新，但是并不建议去更新数据；因为视图就是用来简化查询操作的，不建议更新视图；</span><br></pre></td></tr></table></figure><h2 id="视图-查看及删除视图"><a href="#视图-查看及删除视图" class="headerlink" title="视图 - 查看及删除视图"></a>视图 - 查看及删除视图</h2><h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><p>从MySQL5.1版本开始，使用SHOW TABLES命令的时候不仅会显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的SHOW VIEWS命令。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;<span class="comment"># 显示表以及视图的名称</span></span><br></pre></td></tr></table></figure><p>同样，在使用SHOW TABLE STATUS命令的时候，不但可以显示表的信息，同时也可以显示视图的信息；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span>; <span class="comment"># 显示表以及视图的信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'city_country_view'</span>\G; <span class="comment"># 示例查看视图city_country_view</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> view_city_country; <span class="comment"># 查看创建视图时所使用的的SQL语句是什么</span></span><br></pre></td></tr></table></figure><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>语法：  </p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">DROP</span> <span class="meta">VIEW</span> [ <span class="meta">IF</span> EXISTS ] view_name [, view_name ] ... [ <span class="meta">RESTRICT</span> | <span class="meta">CASCADE</span> ]</span><br></pre></td></tr></table></figure><p>示例，删除视图city_country_view:  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> city_country_view;# or <span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="keyword">if</span> <span class="keyword">exists</span> city_country_view;</span><br></pre></td></tr></table></figure><h2 id="存储过程-概述"><a href="#存储过程-概述" class="headerlink" title="存储过程 - 概述"></a>存储过程 - 概述</h2><p>存储过程和函数是实现经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率时有好处的。<br>存储过程和函数的区别在于函数必须有返回值，而存储过程没有；<br>函数：是一个有返回值的过程；<br>存储过程：是一个没有返回值的函数；</p><h2 id="存储过程-创建调用查询删除语法"><a href="#存储过程-创建调用查询删除语法" class="headerlink" title="存储过程 - 创建调用查询删除语法"></a>存储过程 - 创建调用查询删除语法</h2><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="function"><span class="keyword">PROCEDURE</span> <span class="title">procedure_name</span> <span class="params">( [proc_parameter[,.....]])</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    -- <span class="title">SQL</span>语句</span></span><br><span class="line"><span class="function"><span class="title">end</span>;</span></span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">select</span> '<span class="title">Hello</span> <span class="title">MySQL</span>';</span></span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h4 id="知识小贴士"><a href="#知识小贴士" class="headerlink" title="知识小贴士"></a>知识小贴士</h4><p>DELEMITER<br>    该关键字用来声明SQL语句的分隔符，告诉MySQL解释器，改短命令是否已经结束了，mysql是否可以执行了，默认情况下，delimiter是分号;<br>    在命令行客户端中，如果一行命令以分号结束，那么回车后，mysql将会执行该命令；</p><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> procedure_name();</span><br></pre></td></tr></table></figure><h3 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 查询db_name 数据库中的所有的存储过程</span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> mysql.proc <span class="keyword">where</span> db=<span class="string">'db_name'</span>;</span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> mysql.proc <span class="keyword">where</span> db=<span class="string">'demo_01'</span>$ #示例</span><br><span class="line"></span><br><span class="line">-- 查询存储过程的状态信息</span><br><span class="line">show <span class="function"><span class="keyword">procedure</span> <span class="title">status</span>;</span></span><br><span class="line">show <span class="function"><span class="keyword">procedure</span> <span class="title">status</span>$ # 示例</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-- 查询某个存储过程的定义</span></span><br><span class="line"><span class="function"><span class="title">show</span> <span class="title">create</span> <span class="title">procedure</span> <span class="title">test</span>.<span class="title">pro_test1</span> \<span class="title">G</span>;</span></span><br><span class="line">show <span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test</span>\<span class="title">G</span>$ #示例</span></span><br></pre></td></tr></table></figure><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DROP <span class="function"><span class="keyword">PROCEDURE</span> [ <span class="title">IF</span> <span class="title">EXISTS</span> ] <span class="title">sp_name</span>;</span></span><br><span class="line"></span><br><span class="line">drop <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test1</span>$ # 示例</span></span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-变量"><a href="#存储过程-语法-变量" class="headerlink" title="存储过程 - 语法 - 变量"></a>存储过程 - 语法 - 变量</h2><p>存储过程是可以编程的，意味着可以使用变量，表达式，控制结构，来完成比较复杂的功能。(使得SQL具有过程化语言的处理能力)  </p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>DECLARE</li></ul><p>通过DECLARE可以定义一个局部变量，该变量的作用返回只能在BEGIN…END块中。  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE var_name[ <span class="built_in">..</span>. ]<span class="built_in"> type </span>[DEFAULT value]</span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">declare</span> <span class="title">num</span> <span class="title">int</span> <span class="title">default</span> 5;</span></span><br><span class="line">    <span class="keyword">select</span> num+ <span class="number">10</span>;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">declare</span> <span class="title">num</span> <span class="title">int</span> <span class="title">default</span> 10;</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'num的值为'</span>,num);</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">call pro_test1()$</span><br><span class="line">call pro_test2()$</span><br><span class="line"></span><br><span class="line">delimiter $</span><br></pre></td></tr></table></figure><ul><li>SET</li></ul><p>直接赋值使用SET，可以赋常量或者赋表达式，具体语法如下：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">SET</span> var_name = expr [ , <span class="attribute">var_name</span>=expr ] <span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="function"><span class="keyword">PROCEDURE</span> <span class="title">pro_test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">BEGIN</span></span></span><br><span class="line"><span class="function">    <span class="title">DECLARE</span> <span class="title">NAME</span> <span class="title">VARCHAR</span><span class="params">(20)</span>;</span></span><br><span class="line">    <span class="keyword">SET</span> NAME = <span class="string">'MYSQL'</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> NAME ;</span><br><span class="line"><span class="keyword">END</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="function"><span class="keyword">PROCEDURE</span> <span class="title">pro_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">declare</span> <span class="title">num</span> <span class="title">int</span> <span class="title">default</span> 0;</span></span><br><span class="line">    <span class="keyword">set</span> num = num +<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">select</span> num;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">call pro_test3()$</span><br><span class="line">call pro_demo()$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>也可以通过 select….into 方式进行赋值操作；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> pro_test5()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> countnum <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> countnum <span class="keyword">from</span> city;</span><br><span class="line">    <span class="keyword">select</span> countnum;</span><br><span class="line"><span class="keyword">END</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> PPROCEDURE pro_demo()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">num</span> <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> <span class="keyword">num</span> <span class="keyword">from</span> city;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'city表中的记录数为'</span>,<span class="keyword">num</span>);</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> pro_test5()$</span><br><span class="line"><span class="keyword">call</span> pro_demo()$</span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-if判断"><a href="#存储过程-语法-if判断" class="headerlink" title="存储过程 - 语法 - if判断"></a>存储过程 - 语法 - if判断</h2><h3 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h3><p>语法结构：  </p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> search_condition then statement_list</span><br><span class="line">      [ <span class="keyword">elseif</span> search_condition then statement_list ] ...</span><br><span class="line">      [ <span class="keyword">else</span> statementlist ]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br></pre></td></tr></table></figure><p>需求：  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">根据定义的身高变量，判定当前身高的所属的身材类型</span><br><span class="line"></span><br><span class="line"><span class="number">180</span>及以上----------》身材高挑</span><br><span class="line"><span class="number">170</span> ~ <span class="number">180</span>----------》标准身材</span><br><span class="line"><span class="number">170</span>一下------------》一般身材</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">delimiter &amp;</span><br><span class="line">create procedure pro_test4()</span><br><span class="line">begin</span><br><span class="line">    declare height int<span class="built_in"> default </span>175;</span><br><span class="line">    declare description varchar(50)<span class="built_in"> default </span><span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> hegith &gt;= 180 then</span><br><span class="line">      <span class="builtin-name">set</span> <span class="attribute">description</span>=<span class="string">'身材高挑'</span>;</span><br><span class="line">    elseif height &gt;=170 <span class="keyword">and</span> height &lt; 180 then</span><br><span class="line">      <span class="builtin-name">set</span> <span class="attribute">description</span>=<span class="string">'标准身材'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="builtin-name">set</span> <span class="attribute">description</span>=<span class="string">'一般身材'</span>;</span><br><span class="line">    end <span class="keyword">if</span>;</span><br><span class="line">    select concat(<span class="string">'身高'</span>,height,<span class="string">'对应的身材类型为'</span>,description);</span><br><span class="line">end$</span><br><span class="line"></span><br><span class="line">call pro_test()$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-输入参数"><a href="#存储过程-语法-输入参数" class="headerlink" title="存储过程 - 语法 - 输入参数"></a>存储过程 - 语法 - 输入参数</h2><p><strong>传递参数</strong></p><p>语法格式：  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">procedure_name</span><span class="params">([ <span class="keyword">in</span> / <span class="keyword">out</span> / inout ]参数名称 参数类型)</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># <span class="title">IN</span> 该参数可以作为输入，也就是需要调用方传入值，默认</span></span><br><span class="line"><span class="function"># <span class="title">OUT</span> 该参数作为输出，也就是该参数可以作为返回值</span></span><br><span class="line"><span class="function"># <span class="title">INOUT</span> 既可以作为输入参数，也可以作为输出参数</span></span><br></pre></td></tr></table></figure><p><strong>IN - 输入</strong></p><p>需求：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据定义的身高变量，判定当前身高的所属的身材类型</span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">create procedure pro_test5(<span class="keyword">in</span> height int)</span><br><span class="line">begin</span><br><span class="line">    declare description varchar(50)<span class="built_in"> default </span><span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> hegith &gt;= 180 then</span><br><span class="line">      <span class="builtin-name">set</span> <span class="attribute">description</span>=<span class="string">'身材高挑'</span>;</span><br><span class="line">    elseif height &gt;=170 <span class="keyword">and</span> height &lt; 180 then</span><br><span class="line">      <span class="builtin-name">set</span> <span class="attribute">description</span>=<span class="string">'标准身材'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="builtin-name">set</span> <span class="attribute">description</span>=<span class="string">'一般身材'</span>;</span><br><span class="line">    end <span class="keyword">if</span>;</span><br><span class="line">    select concat(<span class="string">'身高'</span>,height,<span class="string">'对应的身材类型为'</span>,description);</span><br><span class="line">end$</span><br><span class="line"></span><br><span class="line">call pro_test5(198)$</span><br><span class="line">call pro_test5(178)$</span><br><span class="line">call pro_test5(158)$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-输出参数"><a href="#存储过程-语法-输出参数" class="headerlink" title="存储过程 - 语法 - 输出参数"></a>存储过程 - 语法 - 输出参数</h2><p>需求：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据传入的身高变量，获取当前身高的所属的身材类型</span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test5</span><span class="params">(<span class="keyword">in</span> height int ,<span class="keyword">out</span> description varchar(10)</span>)</span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">height</span> &gt;=180 <span class="title">then</span></span></span><br><span class="line"><span class="function">        <span class="title">set</span> <span class="title">description</span>='身材高挑';</span></span><br><span class="line">    elseif height &gt;= <span class="number">170</span> <span class="keyword">and</span> height &lt; <span class="number">180</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> description=<span class="string">'身材标准'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">set</span> description=<span class="string">'一般身材'</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">call pro_test5(<span class="number">188</span>,@description)$</span><br><span class="line"># @description 代表用户的变量；用户的会话变量</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @description$ # 查询用户会话变量取值</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p><strong>小知识</strong><br>@description：这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程它都是有作用的，这个类似于全局变量一样。<br>@@global.sort_buffer_size:这种在变量前加上“@@”，叫做系统变量；  </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">set</span> <span class="variable">@name</span>=<span class="string">'itcast'</span>$</span><br><span class="line"></span><br><span class="line"><span class="literal">select</span> <span class="variable">@name</span>$</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-case结构"><a href="#存储过程-语法-case结构" class="headerlink" title="存储过程 - 语法 - case结构"></a>存储过程 - 语法 - case结构</h2><p>语法结构：  </p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">方式一：  </span><br><span class="line"><span class="keyword">CASE</span> case_value <span class="meta"># case_value 条件</span></span><br><span class="line">    <span class="keyword">WHEN</span> when_value <span class="keyword">THEN</span> statement_list <span class="meta"># statement_list SQL语句</span></span><br><span class="line">    [ <span class="keyword">WHEN</span> when_value <span class="keyword">THEN</span> statement_list ] ...</span><br><span class="line">    [ <span class="keyword">ELSE</span> statement_list ]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方拾二：  </span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> search_condition <span class="keyword">THEN</span> statement_list <span class="meta"># search_condition 条件表达式；如果该表达式为真只执行THEN后的statement_list SQL语句</span></span><br><span class="line">    [ <span class="keyword">WHEN</span> search_condition <span class="keyword">THEN</span> statement_list ] ...</span><br><span class="line">    [ <span class="keyword">ELSE</span> statement_list ]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure><p>需求：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个月份，然后计算出所在的季度</span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test7</span><span class="params">( mon int)</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">declare</span> <span class="title">result</span> <span class="title">varchar</span><span class="params">(10)</span>;</span></span><br><span class="line">    <span class="keyword">case</span></span><br><span class="line">      when mou&gt;=<span class="number">1</span> <span class="keyword">and</span> mon &lt;=<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span>=<span class="string">'第一季度'</span>;</span><br><span class="line">      when mou&gt;=<span class="number">4</span> <span class="keyword">and</span> mon &lt;=<span class="number">6</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span>=<span class="string">'第二季度'</span>;</span><br><span class="line">      when mou&gt;=<span class="number">7</span> <span class="keyword">and</span> mon &lt;=<span class="number">9</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span>=<span class="string">'第三季度'</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span>=<span class="string">'第四季度'</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'传递的月份为'</span>,mon,<span class="string">'， 计算出的结果为：'</span>,<span class="keyword">result</span>) <span class="keyword">as</span> content;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">call pro_test7(<span class="number">7</span>)$</span><br><span class="line">call pro_test7(<span class="number">2</span>)$</span><br><span class="line">call pro_test7(<span class="number">11</span>)$</span><br><span class="line">call pro_test7(<span class="number">9</span>)$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-while循环"><a href="#存储过程-语法-while循环" class="headerlink" title="存储过程 - 语法 - while循环"></a>存储过程 - 语法 - while循环</h2><p>语法结构：  </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> search_condition <span class="keyword">do</span> <span class="comment"># search_condition 条件成立执行循环；条件不成立则跳出循环</span></span><br><span class="line">    statement_list</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br></pre></td></tr></table></figure><p>需求：  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算从<span class="number">1</span>加到n的值</span><br></pre></td></tr></table></figure><p>示例:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test8(n <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">start</span> <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    while <span class="keyword">start</span> &lt;= n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">set</span> total=total+<span class="keyword">start</span>;</span><br><span class="line">        <span class="keyword">start</span>=<span class="keyword">start</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> pro_test8(<span class="number">3</span>)$</span><br><span class="line"><span class="keyword">call</span> pro_test8(<span class="number">6</span>)$</span><br><span class="line"><span class="keyword">call</span> pro_test8(<span class="number">100</span>)$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-repeat循环"><a href="#存储过程-语法-repeat循环" class="headerlink" title="存储过程 - 语法 - repeat循环"></a>存储过程 - 语法 - repeat循环</h2><p>有条件的循环控制语句，当满足条件的时候退出循环。<br>while是满足条件才执行，repeat是满足条件就退出循环。  </p><p>语法结构：  </p><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REPEAT</span></span><br><span class="line">    statement_list</span><br><span class="line"></span><br><span class="line">    <span class="keyword">UNTIL</span> search_condition</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br></pre></td></tr></table></figure><p>需求：  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算从<span class="number">1</span>加到n的值</span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test9</span><span class="params">(n int)</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">declare</span> <span class="title">total</span> <span class="title">int</span> <span class="title">default</span> 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">set</span> total=total+n;</span><br><span class="line">        <span class="keyword">set</span> n=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">until</span> n=<span class="number">0</span> # 此处不加分号；加分号报错；满足当前条件则跳出循环</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">call pro_test10(<span class="number">50</span>)$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-loop循环"><a href="#存储过程-语法-loop循环" class="headerlink" title="存储过程 - 语法 - loop循环"></a>存储过程 - 语法 - loop循环</h2><h3 id="loop语句"><a href="#loop语句" class="headerlink" title="loop语句"></a>loop语句</h3><p>LOOP实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用LEAVE语句实现，具体语法如下：  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ begin_label: ] <span class="keyword">LOOP</span></span><br><span class="line">    statement_list</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span> [ end_label ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果不在 statement_list 中增加退出循环的语句，那么LOOP语句可以用来实现简单的死循环</p><h3 id="leave语句"><a href="#leave语句" class="headerlink" title="leave语句"></a>leave语句</h3><p>用来从标注的流程构造中退出，通常和BEGIN….END或者循环一起使用。<br>下面是一个使用LOOP和LEAVE的简单例子，退出循环；</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="function"><span class="keyword">PROCEDURE</span> <span class="title">pro_test10</span><span class="params">(n int)</span></span></span><br><span class="line"><span class="function"><span class="title">BEGIN</span></span></span><br><span class="line"><span class="function">    <span class="title">declare</span> <span class="title">total</span> <span class="title">int</span> <span class="title">default</span> 0;</span></span><br><span class="line"></span><br><span class="line">    ins:<span class="keyword">LOOP</span></span><br><span class="line">        <span class="keyword">IF</span> n &lt;= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">          leave ins;</span><br><span class="line">        <span class="keyword">ELSE</span></span><br><span class="line">          <span class="keyword">SET</span> total=total+n;</span><br><span class="line">          <span class="keyword">SET</span> n=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">LOOP</span> ins;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">END</span>$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">pro_test10</span><span class="params">(n int)</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">declare</span> <span class="title">total</span> <span class="title">int</span> <span class="title">default</span> 0;</span></span><br><span class="line"></span><br><span class="line">    c:<span class="keyword">loop</span></span><br><span class="line">        <span class="keyword">set</span> total=total+n;</span><br><span class="line">        <span class="keyword">set</span> n=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            leave c; # 满足条件跳出循环</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span> c;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">call pro_test10(<span class="number">100</span>)$</span><br><span class="line">call pro_test10(<span class="number">99</span>)$</span><br><span class="line">call pro_test10(<span class="number">3</span>)$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-游标介绍"><a href="#存储过程-语法-游标介绍" class="headerlink" title="存储过程 - 语法 - 游标介绍"></a>存储过程 - 语法 - 游标介绍</h2><p>游标是用来存储查询结果集的数据类型，唉存储过程和函数中可以使用光标对结果集进行循环的处理。<br>光标的使用包括光标的声明、OPEN、FETCH和CLOSE。  </p><h2 id="存储过程-语法-游标基本操作"><a href="#存储过程-语法-游标基本操作" class="headerlink" title="存储过程 - 语法 - 游标基本操作"></a>存储过程 - 语法 - 游标基本操作</h2><p>其语法分别如下：  </p><p>声明光标：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">for</span> select_statement;</span><br></pre></td></tr></table></figure><p>OPEN光标：  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN cursor_name<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>FETCH光标：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH cursor_name INTO var_name [ , var_name ] <span class="string">...</span> <span class="comment"># 每抓取一次，即获取结果集当中每一行数据；调用一次指针往下指向一次；调用一次指针往下指向一次；当指针指到最后没有数据的那一行时，即此时就应该退出游标了；</span></span><br></pre></td></tr></table></figure><p>CLOSE光标：  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE cursor_name<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>示例：<br>初始化脚本:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'姓名'</span>,</span><br><span class="line">  age <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">comment</span> <span class="string">'年龄'</span>,</span><br><span class="line">  salary <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">comment</span> <span class="string">'薪水'</span>,</span><br><span class="line">  primary <span class="keyword">key</span>(<span class="string">'id'</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(<span class="keyword">id</span>,<span class="keyword">name</span>,age,salary) <span class="keyword">values</span> (<span class="literal">null</span>,<span class="string">'金毛狮王'</span>,<span class="number">55</span>,<span class="number">3800</span>),(<span class="literal">null</span>,<span class="string">'白眉鹰王'</span>,<span class="number">60</span>,<span class="number">4400</span>),(<span class="literal">null</span>,<span class="string">'青翼蝠王'</span>,<span class="number">38</span>,<span class="number">2800</span>),(<span class="literal">null</span>,<span class="string">'素衫龙王'</span>,<span class="number">42</span>,<span class="number">1800</span>);</span><br></pre></td></tr></table></figure><p>需求：  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询emp表中数据，并逐行获取进行显示</span></span><br></pre></td></tr></table></figure><p>示例：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delimiter</span> $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test11()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> e_id <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">declare</span> e_name <span class="type">varchar</span>(<span class="number">50</span>);</span><br><span class="line">    decalre e_age <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">declare</span> e_salary <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">declare</span> emp_result <span class="keyword">cursor</span> fro <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> emp_result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fetch</span> emp_result <span class="keyword">into</span> e_id,e_naem,e_age,e_salary;</span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">'id为：'</span> , e_id,<span class="string">', 名字为: '</span> , e_name , <span class="string">', 年龄为：'</span> , e_age , <span class="string">', 薪资为：'</span> , e_salary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fetch</span> emp_result <span class="keyword">into</span> e_id,e_naem,e_age,e_salary;</span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">'id为：'</span> , e_id,<span class="string">', 名字为: '</span> , e_name , <span class="string">', 年龄为：'</span> , e_age , <span class="string">', 薪资为：'</span> , e_salary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fetch</span> emp_result <span class="keyword">into</span> e_id,e_naem,e_age,e_salary;</span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">'id为：'</span> , e_id,<span class="string">', 名字为: '</span> , e_name , <span class="string">', 年龄为：'</span> , e_age , <span class="string">', 薪资为：'</span> , e_salary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fetch</span> emp_result <span class="keyword">into</span> e_id,e_naem,e_age,e_salary;</span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">'id为：'</span> , e_id,<span class="string">', 名字为: '</span> , e_name , <span class="string">', 年龄为：'</span> , e_age , <span class="string">', 薪资为：'</span> , e_salary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fetch</span> emp_result <span class="keyword">into</span> e_id,e_naem,e_age,e_salary;</span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">'id为：'</span> , e_id,<span class="string">', 名字为: '</span> , e_name , <span class="string">', 年龄为：'</span> , e_age , <span class="string">', 薪资为：'</span> , e_salary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">close</span> emp_result;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"># emp表当中只有四条数据，如果<span class="keyword">fetch</span>的次数大于表当中的数据，那么<span class="keyword">fetch</span>表中总行数依然可以打印出来，一旦<span class="keyword">fetch</span>大于表中的总行数则进行报错；</span><br><span class="line"></span><br><span class="line"># 通过<span class="keyword">fetch</span>一行一行进行抓取记录编写的效率十分低；</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> pro_test11();</span><br><span class="line"><span class="keyword">delimiter</span> ;</span><br></pre></td></tr></table></figure><h2 id="存储过程-语法-循环获取游标"><a href="#存储过程-语法-循环获取游标" class="headerlink" title="存储过程 - 语法 - 循环获取游标"></a>存储过程 - 语法 - 循环获取游标</h2><blockquote><p>循环当中，游标的fetch退出判断</p></blockquote><p>1） count(*) into num;  num –<br>2） mysql存在机制，变量，通过改变该变量取值状态及退出fetch  </p><p>示例：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delimiter</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test12()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> e_id <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line">    decalre e_name <span class="type">varchar</span>(<span class="number">50</span>);</span><br><span class="line">    decalre e_age <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line">    decalre e_salary <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">declare</span> has_data <span class="type">int</span> <span class="keyword">default</span> <span class="number">1</span>;#当has_data为<span class="number">1</span>时表示还有数据；当has_data为<span class="number">0</span>时表示没有数据</span><br><span class="line"></span><br><span class="line">    <span class="keyword">declare</span> emp_result <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="keyword">EXIT</span> <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">NOT</span> <span class="built_in">FOUND</span> <span class="keyword">set</span> has_data=<span class="number">0</span>;#退出当前游标指向程序并设置has_data为<span class="number">0</span>；此为mysql提供的一种机制；同时该句话需要声明在声明游标的下方；当游标进行<span class="keyword">fetch</span>获取不到数据的时候，此时会进行触发；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> emp_reuslt;</span><br><span class="line"></span><br><span class="line">    repeat</span><br><span class="line">        <span class="keyword">fetch</span> emp_result <span class="keyword">into</span> e_id,e_name,e_age,e_salary;</span><br><span class="line">        <span class="keyword">select</span> concat(<span class="string">'id为：'</span> , e_id,<span class="string">', 名字为: '</span> , e_name , <span class="string">', 年龄为：'</span> , e_age , <span class="string">', 薪资为：'</span> , e_salary);</span><br><span class="line">        <span class="keyword">until</span> has_data=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span> repeat;</span><br><span class="line">    <span class="keyword">close</span> emp_result;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> pro_test12()$</span><br><span class="line"></span><br><span class="line"><span class="keyword">delimiter</span> ;</span><br></pre></td></tr></table></figure><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><p>语法结构：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION function_name([ param<span class="built_in"> type </span><span class="built_in">..</span>. ])</span><br><span class="line">RETURNS type</span><br><span class="line">BEGIN</span><br><span class="line">    <span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>案例：<br>定义一个存储过程，请求满足条件的总记录数：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delimiter</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> count_city(countryId <span class="type">int</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="type">int</span> # 此处不需要分号</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> cnum <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> count(*) <span class="keyword">into</span> cnum <span class="keyword">from</span> city <span class="keyword">where</span> country_id = countryId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnum;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">delimiter</span> ;</span><br><span class="line"></span><br><span class="line"># 存储过程虽然没有返回值；但是依然可以返回结果；因为其参数列表当中有<span class="keyword">in</span>、<span class="keyword">out</span>（返回值）、<span class="keyword">inout</span>；存储函数能做的事情；存储过程也可以做；</span><br></pre></td></tr></table></figure><blockquote><p>调用存储函数命令</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> count_city(<span class="number">1</span>)$</span><br><span class="line"><span class="keyword">select</span> count_city(<span class="number">2</span>)$</span><br></pre></td></tr></table></figure><blockquote><p>删除存储函数命令</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop <span class="keyword">function</span> <span class="title">count_city$</span></span><br></pre></td></tr></table></figure><h2 id="触发器-介绍"><a href="#触发器-介绍" class="headerlink" title="触发器 - 介绍"></a>触发器 - 介绍</h2><p>触发器是与表有关的数据库对象，指的是在insert、update、delete之前或者之后，触发并执行触发器中定义的SQL语句集合，触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作；  </p><p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。<br>现在触发器还只支持行级触发，不支持语句级触发。  </p><table>  <tr>    <th>触发器类型</th>    <th>NEW和OLD的使用</th>  </tr>  <tr>    <td>INSERT型触发器</td>    <td>NEW表示将要或者已经新增的数据</td>  </tr>  <tr>    <td>UPDATE型触发器</td>    <td>OLD表示修改之前的数据，NEW表示将要或者已经修改后的数据</td>  </tr>  <tr>    <td>DELETE型触发器</td>    <td>OLD表示将要或者已经删除的数据</td>  </tr></table><h2 id="触发器-创建及应用"><a href="#触发器-创建及应用" class="headerlink" title="触发器 - 创建及应用"></a>触发器 - 创建及应用</h2><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>语法结构：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">before</span>/<span class="keyword">after</span> <span class="keyword">insert</span>/<span class="keyword">update</span>/<span class="keyword">delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># before 在...之前/after 在...之后</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">on</span> tb1_name</span><br><span class="line"></span><br><span class="line">[ <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> ] <span class="comment">-- 当前操作的是一个行级触发器;oracle数据库当中既有行级触发器也有语句级的触发器；而mysql数据库当中只支持行级触发器现还不支持语句级触发器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  trigger_stmt;<span class="comment">--触发的内容</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>需求：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过触发器记录 emp表的数据变更日志，包含新增、修改、删除；</span><br></pre></td></tr></table></figure><p>示例：  </p><p>首先创建一张日志表:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp_logs(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    operation <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'操作类型，insert/update/delete'</span>,</span><br><span class="line">    operate_time datatime <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'操作时间'</span>,</span><br><span class="line">    operate_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'操作表的id'</span>,</span><br><span class="line">    operate_params <span class="built_in">varchar</span>(<span class="number">500</span>) <span class="keyword">comment</span> <span class="string">'操作参数'</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="string">'id'</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>$</span><br></pre></td></tr></table></figure><p>创建insert性触发器，完成插入数据时的日志记录；  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELIMITER</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">trigger</span> emp_logs_insert_trigger</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> emp</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(</span><br><span class="line">      <span class="keyword">null</span>,<span class="string">'insert'</span>,now(),<span class="built_in">new</span>.id,concat( <span class="string">'插入后 ( id：'</span>, <span class="built_in">new</span>.id , <span class="string">', name: '</span> , <span class="built_in">new</span>.name , <span class="string">' ,  age: '</span> ,  <span class="built_in">new</span>.age , <span class="string">' , salary: '</span> , <span class="built_in">new</span>.salary , <span class="string">')'</span>)</span><br><span class="line">    );</span><br><span class="line">    # 此处的<span class="built_in">new</span>.id即新插入emp表中数据的记录的id，即emp当中的id字段；</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,<span class="type">name</span>,age,salary) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">'光明左使'</span>,<span class="number">30</span>,<span class="number">3500</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp$</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_logs$</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,<span class="type">name</span>,age,salary) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">'光明右使'</span>,<span class="number">35</span>,<span class="number">3800</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">trigger</span> emp_logs_update_trigger</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">on</span> emp</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(</span><br><span class="line">      <span class="keyword">null</span>,<span class="string">'update'</span>,now(),<span class="built_in">new</span>.id,</span><br><span class="line">      concat( </span><br><span class="line">        <span class="string">'修改前 ( id：'</span>, <span class="built_in">old</span>.id ,</span><br><span class="line">        <span class="string">',name: '</span> , <span class="built_in">old</span>.name ,</span><br><span class="line">        <span class="string">',age: '</span> ,  <span class="built_in">old</span>.age ,</span><br><span class="line">        <span class="string">',salary: '</span> , <span class="built_in">old</span>.salary ,</span><br><span class="line">        <span class="string">') 修改后( id：'</span>, <span class="built_in">new</span>.id ,</span><br><span class="line">        <span class="string">',name: '</span> , <span class="built_in">new</span>.name ,</span><br><span class="line">        <span class="string">',age: '</span> ,  <span class="built_in">new</span>.age ,</span><br><span class="line">        <span class="string">',salary: '</span> , <span class="built_in">new</span>.salary ,</span><br><span class="line">        <span class="string">')'</span>  </span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    # 此处的<span class="built_in">new</span>.id即新插入emp表中数据的记录的id，即emp当中的id字段；</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> age=<span class="number">39</span> <span class="keyword">where</span> id=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp$</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_logs$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">trigger</span> emp_logs_delete_trigger</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> emp</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(</span><br><span class="line">      <span class="keyword">null</span>,<span class="string">'delete'</span>,now(),<span class="built_in">old</span>.id,</span><br><span class="line">      concat(</span><br><span class="line">        <span class="string">'删除前( id：'</span>, <span class="built_in">old</span>.id ,</span><br><span class="line">        <span class="string">',name: '</span> , <span class="built_in">old</span>.name ,</span><br><span class="line">        <span class="string">',age: '</span> ,  <span class="built_in">old</span>.age ,</span><br><span class="line">        <span class="string">',salary: '</span> , <span class="built_in">old</span>.salary ,</span><br><span class="line">        <span class="string">')'</span>  </span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp$</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_logs$</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp$</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_logs$</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELIMITER</span> ;</span><br></pre></td></tr></table></figure><h2 id="触发器-查看及删除"><a href="#触发器-查看及删除" class="headerlink" title="触发器 - 查看及删除"></a>触发器 - 查看及删除</h2><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><p>语法结构：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> [ <span class="built_in">schema_name</span>.] trigger_name</span><br></pre></td></tr></table></figure><p>如果没有指定schema_name，默认为当前数据库。</p><h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h3><p>可以通过执行SHOW TRIGGERS 命令查看触发器的状态、语法等信息。<br>语法结构：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br><span class="line"></span><br><span class="line"># Event 触发器监听的事件 <span class="keyword">INSERT</span>/<span class="keyword">UPDATE</span>/<span class="keyword">DELETE</span></span><br><span class="line"># <span class="keyword">Table</span> 对于哪一张表监听的触发器</span><br><span class="line"># <span class="keyword">Timing</span> 触发器是前置触发<span class="keyword">BEFORE</span>还是后置触发<span class="keyword">AFTER</span></span><br><span class="line"># <span class="keyword">Statement</span> 触发器定义</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看笔记：&lt;code&gt;https://www.bilibili.com/video/BV1fJ41127Rj?from=search&amp;amp
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="MySQL" scheme="https://fengshana.github.io/tags/MySQL/"/>
    
      <category term="数据库优化" scheme="https://fengshana.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySql索引底层数据结构</title>
    <link href="https://fengshana.github.io/2020/05/27/%E3%80%90MYSQL%E3%80%91/%E3%80%90MYSQL%E3%80%91MySql%E7%B4%A2%E5%BC%95/"/>
    <id>https://fengshana.github.io/2020/05/27/%E3%80%90MYSQL%E3%80%91/%E3%80%90MYSQL%E3%80%91MySql%E7%B4%A2%E5%BC%95/</id>
    <published>2020-05-27T10:35:55.031Z</published>
    <updated>2020-06-05T17:56:34.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 索引的本质</span><br><span class="line"></span><br><span class="line">**索引的本质**</span><br><span class="line"></span><br><span class="line">![索引](http:&#x2F;&#x2F;r.photo.store.qq.com&#x2F;psc?&#x2F;V13IdniL0W0T32&#x2F;TCfiP1YaPeRT4Jil9RANXwvSlPCJJI2vYZaT3H0rZCG38flqH5eE7TMAOK*DSM1BhWXXI4cugphYQTkM94HMJ9GHGpkBn3QA6a5u74EOK8M!&#x2F;r)</span><br><span class="line"></span><br><span class="line">* **索引** 是 **帮助MySQL** **高效 获取数据** 的 **排好序** 的 **数据结构**</span><br><span class="line">* **索引存储在文件里**</span><br><span class="line">* **索引结构**</span><br><span class="line">  * **二叉树**</span><br><span class="line">  * **红黑树**</span><br><span class="line">  * **HASH**</span><br><span class="line">  * **BTREE**</span><br><span class="line"></span><br><span class="line">&gt;**问题**：有没有在生产环境SQL查询的非常慢，需要优化的。  </span><br><span class="line">**答**：真的有过，就是上一家公司做的那个项目关系到全国，省，市，区，县这种的，每次一统计吧就是全国的那种统计，就是该省下有多少人注册了，该市下有多少人注册了.....这种，每次加载大半天都搞不赢，那个页面都出不来。  </span><br><span class="line">这个属于慢查询吗？  </span><br><span class="line">我也不是很清楚诶。反正就是数据量贼大，然后用的Oracle数据库，因为还有就是交易量很大。  </span><br><span class="line"></span><br><span class="line">&gt;**问题**： 遇到这种问题第一时间想到的优化是什么？  </span><br><span class="line">**答**：额，我好像也没有做什么优化，通过主键来进行查询，就是交易量特别大的时候，然后去查询的时候，就是使用的交易表TRANS 当中的主键去进行查询大部分是。</span><br><span class="line">然后就是因为是二次开发这个系统，所以在Oracle数据库当中是存在之前的开发者所写的索引的。</span><br><span class="line">然后就是不去使用外键，就是外键关联的外键这种不去进行使用，而是有些表当中额怎么说呢，就是有些表当中记录的字段存在，而另外一张表当中因为不去进行关联查询trans表这种数据量大的表就自己这张表也会记录一些数据这种。</span><br><span class="line">尽量通过主键去查询，因为通过其他的去查询，比如字符串这种的碰到有些时候会很慢。</span><br><span class="line">或者是还有就是写那个查询，navicat当中写个查询然后保存。  </span><br><span class="line">我想不到其他的了，因为没有怎么用过索引。  </span><br><span class="line"></span><br><span class="line">**首先检查索引**；  </span><br><span class="line"></span><br><span class="line">1. 查看**SQL**当中的**where**当中的**查询字段** **是否有加索引**；  </span><br><span class="line">2. 或者说加了索引 **是否正确索引** 呢；  </span><br><span class="line">只要SQL不太烂，正常的走索引，数据量几百万上千万行的数据表，查询的速度依然会很快。  </span><br><span class="line"></span><br><span class="line">&gt; **思考**： 一个几百万上千万数据量的表，只要加上了索引，然后查询的条件又是走的索引，关键的字段，为什么查找的速度就能够提高很多，性能会高？  </span><br><span class="line">**答**：因为索引就相当于是书的页码，比如我要查询新华字典当中的某一个字，找到它的索引，也就是它的页码，一下子就能找到了。</span><br><span class="line">不过至于它的底层方面的原理我不是很清楚。没有过这方面的研究，我也只是听说过是通过b+ 树实现的？  </span><br><span class="line"></span><br><span class="line">**索引的定义**：**索引** 是 **帮助MySQL** **高效 获取数据** 的 **排好序** 的 **数据结构**。  </span><br><span class="line">**索引结构**：  </span><br><span class="line"></span><br><span class="line">* **二叉树**</span><br><span class="line">* **红黑树**</span><br><span class="line">* **HASH(哈希表)**</span><br><span class="line">* **BTREE（B树）**</span><br><span class="line"></span><br><span class="line">**数据表** 是 **存储在磁盘文件** 当中；  </span><br><span class="line">所装MySQL当中的data目录，目录下为数据库；  </span><br><span class="line">**表数据**实际上就 **存放在磁盘上** 了；  </span><br><span class="line">那**从数据表当中去读取数据的时候查询某一行数据**的时候，意味着就需要从**磁盘**上去**查询**这个数据表当中的数据。  </span><br><span class="line">如果该数据**没有加索引 则 从第一行开始进行查找**；  </span><br><span class="line">select * from t where t.col2&#x3D;89;  </span><br><span class="line">如果该表t没有加任何索引则需要从该表**第一行**开始**遍历**。  </span><br><span class="line">**逐行查找逐行比对**。  </span><br><span class="line">直到查找到**n次**磁盘查找到数据匹配位置。  </span><br><span class="line">如果要查找的**数据在末尾**，**数据量非常大**的情况下，每次从**表头进行查找**，**性能非常差**。  </span><br><span class="line">这也就是 **全表扫描**。  </span><br><span class="line"></span><br><span class="line">&gt; **问题**：有什么办法**优化SQL查询**？  </span><br><span class="line">&gt; * 给**字段加索引**。</span><br><span class="line">给col2字段加上索引后，即便是该表当中存在数据量十分大，查询起来的效率也会很高。  </span><br><span class="line">这个原因是什么？  </span><br><span class="line">给该字段加上索引之后，该字段作为索引字段之后，它在该表中的存储结构，该字段的存储结构就有一点区别。  </span><br><span class="line">**索引本质上是一种数据结构**。  </span><br><span class="line">所以当给col2字段加上索引之后，那么就会将该col2字段列的数据通过**以一种数据结构进行存储起来**。  </span><br><span class="line"></span><br><span class="line">#### 二叉树</span><br><span class="line"></span><br><span class="line">**二叉树（Binary Search Trees，简写BST）**：&#96;&#96;&#96;https:&#x2F;&#x2F;www.cs.usfca.edu&#x2F;~galles&#x2F;visualization&#x2F;BST.html&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">比方说，常见的**数据结构**-**二叉树**，  </span><br><span class="line">将col2字段该列的数据放到二叉树当中来，  </span><br><span class="line">该字段col2的列的数据，每一个数据都放到二叉树当中去；  </span><br><span class="line"></span><br><span class="line">而 **二叉树的每一个结点** 是一个 **key-value** 的一个取值；  </span><br><span class="line">也就是说 **key** 其实即为 **索引字段** ，而 **value** 则为 **箭头的指针** ；  </span><br><span class="line">**索引字段**所对应的这**一行的数据**，在**磁盘**上的一个**文件指针**；  </span><br><span class="line">如果通过一个合理的方式，或者说是一个好一点的数据结构，来放索引的这个字段，以及每一个索引对应的这一行数据，**磁盘文件指针**；  </span><br><span class="line">那么再去看查找这行数据。  </span><br><span class="line"></span><br><span class="line">**数据结构-二叉树**常识：  </span><br><span class="line"></span><br><span class="line">* **根节点（父节点）的右孩子取值大于根节点（父节点）取值**；</span><br><span class="line">* **根节点（父节点）的左孩子取值小于根节点（父节点）取值**；</span><br><span class="line">* **从左到右依次递增**；</span><br><span class="line"></span><br><span class="line">如果要查找 select * from t where t.col2&#x3D;89这一行数据；  </span><br><span class="line">用**索引字段**去查找的话，那么**先走索引**；  </span><br><span class="line">而**索引**是当前被放在**二叉树**这样一种数据结构当中去了；  </span><br><span class="line">那么再去进行查找；  </span><br><span class="line">那么肯定是从**根结点**开始进行查找；  </span><br><span class="line">那么第一次查询，从磁盘上进行查询结点后发现34和89对不上，错了；  </span><br><span class="line">89是大于34的；  </span><br><span class="line">按照**二叉树数据结构**的这样一个特点、特性；  </span><br><span class="line">找到该**根结点的右边的子结点**，一找即发现当前右边的子结点即为当前查询的结点；  </span><br><span class="line">然后通过**找到的该结点**找到**该结点所对应的value**；  </span><br><span class="line">该**value**放的就是这个 **索引字段** **所对的那一行**的**数据磁盘文件指针**；  </span><br><span class="line">那么就可以很快查找得到；  </span><br><span class="line"></span><br><span class="line">通过一种**合理的数据结构**来放刚加的这个索引字段；那么这个**查找的速度**就会变得**快**很多。  </span><br><span class="line"></span><br><span class="line">**MySQL的底层原理并不是二叉树**。  </span><br><span class="line">**MySQL的底层是B+树**；  </span><br><span class="line">MySQL的最终底层为什么选择B+树而不选择其他的数据结构？  </span><br><span class="line"></span><br><span class="line">通过一种**合理的数据结构**来放**索引的字段**，那么**查找的效率**就将会**快**很多；  </span><br><span class="line">就**不用一行一行**的去**遍历**表，即**不用全表扫描式** **查询某一行数据** ；</span><br><span class="line">而是可以先快速的**从索引的数据结构当中** **快速的定位到某一个索引**，</span><br><span class="line">再把**这个索引** **对应的那一行数据** 的 **磁盘文件指针** 给查询出来，</span><br><span class="line">就能够**快速的** 从**磁盘上** 找到 **该行** 要 **查询的数据**；  </span><br><span class="line"></span><br><span class="line">**索引具体是什么样的数据结构？**  </span><br><span class="line"></span><br><span class="line">MySQL官方没有选择二叉树，说明**二叉树**在**某些场景**下是**存在问题**的；  </span><br><span class="line"></span><br><span class="line">for example:  </span><br><span class="line"></span><br><span class="line">假设表t，将**col1作为索引字段**，那么SQL语句就需要变成：  </span><br><span class="line">select * from t **where t.col1**&#x3D;6;来进行查找；  </span><br><span class="line">现在将col1作为一个**二叉树**；  </span><br><span class="line">当**t表在插入数据**的时候，**二叉树插入数据**的一个变化过程；  </span><br><span class="line">**二叉树**这样一个**索引结构的变化**；  </span><br><span class="line">插入第一行数据首先会去**维护这个索引**，第一列col1的数据呈现的**规律为顺序递增，递增**；  </span><br><span class="line">每插入一行数据会先要去**维护索引的这个数据结构**；  </span><br><span class="line">**索引**在**二叉树**当中存在一个**递增**的规律，**顺序递增**；  </span><br><span class="line">每插入一个数据，首先要**维护二叉树（Binary Search Trees）递增顺序的一个字段**；  </span><br><span class="line">**二叉树**如果是**维护这样一个递增顺序的字段**作为索引会是一个什么样的一个情况；  </span><br><span class="line"></span><br><span class="line">* 索引-BinarySearchTrees插入递增数据</span><br><span class="line">![索引-BinarySearchTrees插入递增数据](.&#x2F;【MYSQL】MySql索引&#x2F;索引-BinarySearchTrees插入递增数据.gif)</span><br><span class="line"></span><br><span class="line">&gt; 国外二叉树（各种数据结构）的一个教学网站（解析动画演示）：</span><br><span class="line">&#96;&#96;&#96;https:&#x2F;&#x2F;www.cs.usfca.edu&#x2F;~galles&#x2F;visualization&#x2F;Algorithms.html</span><br></pre></td></tr></table></figure><p>插入第一行数据，再插入第二行数据，先进行<strong>维护</strong>这个<strong>索引</strong>；<br>如果<strong>二叉树维护的是这种单边增长的这种字段</strong>，而<strong>二叉树正好作为索引的底层数据结构</strong>，此时就会出现问题；<br><strong>二叉树</strong>也会变成<strong>单边增长</strong>；<br><strong>二叉树</strong>对于这种col1字段是<strong>单边增长</strong>的这种情况是不符合的；<br>这种用二叉树存储索引字段，就跟在数据表中去<strong>全表扫描</strong>没有任何区别，效果一样,没有什么区别；<br><strong>二叉树</strong>这种数据结构对于索引的存储，<strong>索引字段的存储</strong>在某些方面是<strong>存在局限</strong>的；  </p><ul><li>索引-BinarySearchTrees查询递增数据<br><img src="/2020/05/27/%E3%80%90MYSQL%E3%80%91/%E3%80%90MYSQL%E3%80%91MySql%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95-BinarySearchTrees%E6%9F%A5%E8%AF%A2%E9%80%92%E5%A2%9E%E6%95%B0%E6%8D%AE.gif" alt="索引-BinarySearchTrees查询递增数据"></li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><strong>红黑树</strong>：<code>https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</code>  </p><p>问题：是否听说过<strong>红黑树</strong>？<br>答：听说过，且jdk1.8当中HashMap当中链表长度达到8之后就会将数据结构链表转化成红黑树这种数据结构；  </p><p>二叉树不行，则看看其他的更好的数据结构是否能够更好的存储索引字段;<br>红黑树也是一种常见的数据结构；<br>jdk在1.8之后，HashMap底层的链表实际上就是用红黑树来做了一个优化；  </p><p><strong>插入递增数据 会 自动平衡</strong>；  </p><ul><li>索引-RedBlack插入递增数据<br><img src="/2020/05/27/%E3%80%90MYSQL%E3%80%91/%E3%80%90MYSQL%E3%80%91MySql%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95-RedBlack%E6%8F%92%E5%85%A5%E9%80%92%E5%A2%9E%E6%95%B0%E6%8D%AE.gif" alt="索引-RedBlack插入递增数据"></li></ul><p>查询时相对于二叉树来说要少一点；<br>用<strong>红黑树</strong>来存储索引字段，相对于用普通的二叉树来存储来说，性能稍微高一点；<br><strong>红黑树</strong>针对于这种单边增长的这种情况，只要<strong>单边出现3个连续递增的结点</strong>会做一个<strong>自动平衡</strong>的处理；<br>那么存储同样的数据的话，整体的<strong>高度</strong>相对来说<strong>红黑树</strong>肯定要<strong>比二叉树要短</strong>；  </p><ul><li>索引-RedBlack查询递增数据<br><img src="/2020/05/27/%E3%80%90MYSQL%E3%80%91/%E3%80%90MYSQL%E3%80%91MySql%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95-RedBlack%E6%9F%A5%E8%AF%A2%E9%80%92%E5%A2%9E%E6%95%B0%E6%8D%AE.gif" alt="索引-RedBlack查询递增数据"></li></ul><p><strong>问题</strong>：<strong>二叉树 是可以 自动平衡</strong>的，那么想一想如果用二叉树来做索引字段存储的数据结构有没有什么<strong>弊端</strong>？在哪些业务场景当中可能又有一些<strong>小问题</strong>？<br>答：我想不太出来诶。  </p><ul><li><strong>红黑树范围查询</strong></li><li>当数据量小的时候查询起来,效率还在线上；<br>如果<strong>当数据量大</strong>的话，<strong>红黑树</strong>将<strong>不断的往下增长</strong>；</li><li><em>树的高度*</em>有可能变成<strong>2的n次方</strong>；<br>这个<strong>n即为树的高度</strong>；<br>每个结点即2，这个树能够存多少索引字段，即2的n次方；</li><li>如果说要查找的n，要查找的那一行的索引字段刚好是在树的叶子结点上面。<br>一般是从<strong>根节点上进行遍历</strong>，那么<strong>查找遍历的次数</strong>至少是<strong>树的n</strong>，<strong>高度次</strong>这么多；<br>那么从磁盘上要经过几十次，一个结点查找一次，查找一次有一个专业的术语，跟磁盘打一次交道，叫做<strong>磁盘IO</strong>，这样的话针对<strong>磁盘IO</strong>来说性能是不高的；<br>效率不是特别高；<br>可以说效率比较低了；<br>如果还经历几十次这样的<strong>磁盘IO</strong>，性能是肯定没有办法接受的；</li></ul><p><strong>红黑树</strong>这种数据结构，<strong>一旦表的数据量特别大</strong>的时候，<strong>查找数据的效率</strong>依然会<strong>很慢</strong>；<br>因为查找数据可能就在叶子结点上；<br><strong>红黑树</strong>在<strong>数据量大的时候</strong>也是存在<strong>弊端</strong>的；  </p><p>红黑树不行，可以对其做一点点改造；  </p><p>即便是<strong>大数量情况</strong>下，几百万甚至是上千万的数据量下；<br>通过一种数据结构能够<strong>快速的定位</strong>到所需要的那个数据的索引的字段；<br>从而根据那个索引的字段能够得到结点当中的那个value值，也就是<strong>索引所在那一行数据的磁盘文件指针</strong>来<strong>定位到磁盘上的某一个位置</strong>查找到这一行数据；  </p><p>可以对红黑树进行改造进行优化；  </p><p><strong>红黑树</strong>也是<strong>二叉树</strong>；叫做<strong>二叉平衡树</strong>；<br>因为<strong>红黑树会自动平衡</strong>；在红黑树的基础上做一下改造，从而解决在大数据量这种情况下出现的弊端<br>（因为<strong>树的高度太高</strong>，也就是树<strong>存储大数据量的情况</strong>下，<strong>树的高度太高</strong>，<strong>磁盘IO</strong>就将<strong>随着树的高度height增长而增长</strong>）；  </p><p>问题： 对红黑树进行改造，让红黑树效率更高一点？  </p><ul><li><strong>n叉树</strong></li><li>原来<strong>结点存储到磁盘</strong>上面，之前<strong>结点就只存储一个索引字段</strong>；<br>那么可以将这个<strong>结点弄大一点</strong>，也就是将它的<strong>磁盘存储空间分配大一点</strong>（也就是让这个<strong>结点上多存储几个索引字段</strong>）；<br>且<strong>每一个索引</strong>之间<strong>都可以进行分叉</strong>，<strong>分叉下的索引结点的磁盘存储空间</strong>也分配大一点，也存储多个索引字段，每一个结点都可以有多个结点（多个索引元素）；  </li></ul><p><strong>问题</strong>： 这样的存储结构，同样的大数据量的情况下，这样改造红黑树后的结构存储大数据量记录比改造前的红黑树，树的高度要小得多得多；  </p><p><strong>减小</strong>了<strong>红黑树</strong>的<strong>纵向</strong>，<strong>红黑树的高度</strong>，而<strong>增长</strong>了<strong>红黑树</strong>的<strong>横向</strong>；<br><strong>横向越长</strong>，<strong>存储同样大的数据量</strong>，<strong>树的高度就越矮</strong>；<br><strong>树的高度越矮</strong>，查找一行数据，也就是某一结点上的数据，那么其<strong>效率也就越高</strong>；  </p><p>已经慢慢接触到MySQL底层的数据结构：<br>这种改造其实就是<strong>B树</strong>  </p><ul><li>磁盘存取原理<ul><li>寻道时间（速度慢、费时）</li><li>旋转时间（速度较快）<br><img src="/2020/05/27/%E3%80%90MYSQL%E3%80%91/%E3%80%90MYSQL%E3%80%91MySql%E7%B4%A2%E5%BC%95/%E7%A3%81%E7%9B%98%E5%AD%98%E5%8F%96%E5%8E%9F%E7%90%86.png" alt="磁盘存取原理"></li></ul></li></ul><p>横向查找不就慢了吗？</p><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p><strong>B-Tree</strong></p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL0W0T32/TCfiP1YaPeRT4Jil9RANXx5xRm2O7Hw.CPoJY21PbGHy3.R9D2C3BHGRAwPaR*QEhgcUF1UMc2yymaSzxbgBOKNjFYrOEqnDAvX4*fMGPmY!/r" alt="索引"></p><ul><li><strong>度（Degree）</strong>-<strong>结点的 数据存储个数</strong></li><li><strong>叶子结点 具有 相同的深度</strong></li><li><strong>叶子结点的 指针 为 空</strong></li><li><strong>结点中的 数据key 从左到右 递增排列</strong></li></ul><p>刚刚说到红黑树不行，可以在<strong>红黑树的横向上</strong>做文章；<br><strong>存储同样大的数据量</strong>，<strong>树的高度</strong>将会大大的<strong>减小</strong>；<br>那就变成了引入<strong>B树</strong>；  </p><ul><li>索引-<strong>BTree</strong>插入递增数据<br><img src="/2020/05/27/%E3%80%90MYSQL%E3%80%91/%E3%80%90MYSQL%E3%80%91MySql%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95-BTree%E6%8F%92%E5%85%A5%E9%80%92%E5%A2%9E%E6%95%B0%E6%8D%AE.gif" alt="索引-BTree插入递增数据"></li></ul><p><strong>结点内 数据 有限</strong>，<strong>不能 无限放大</strong>；<br><strong>B树</strong>比<strong>红黑树</strong>来说有<strong>更大的优点</strong>；  </p><p><strong>问题</strong>：在<strong>横向上</strong>做文章，那<strong>横向查找不就慢了</strong>吗？  </p><p><strong>注意</strong>：一个<strong>结点的大小</strong> 是 <strong>有限制的</strong>；<br><strong>结点当中的 数据量 是 有限制的</strong>；<br><strong>不可能 无限延长、大</strong>；<br>比如说给这个结点设置几k大小，或者1Mb这么大；<br>如果这个结点太大；<br>一个结点对应磁盘上的一个磁盘文件地址，对应一个大的磁盘文件地址；<br>MySQL设计的是，<strong>尽量</strong>的<strong>一次 磁盘IO 查找</strong>，在进行查找的时候是希望一次性把这个<strong>结点</strong>放到<strong>内存</strong>；<br>MySQL<strong>查找一次</strong>，跟<strong>磁盘做一次磁盘IO交互</strong>的时候，它会把这一个<strong>横向结点</strong> 全部<strong>放到内存</strong>当中；<br>只要这一个<strong>结点的数据 都 放到 内存</strong>之后；<br>那之后再到这个横向结点当中再进行查找数据；<br>比方说要查找77，那么刚刚说经过了一次磁盘IO之后，会将这一个<strong>横向结点 当中的 所有索引元素 都 放到 内存 当中去</strong>，那么再去查找77，实际上就是从内存当中去进行查找这个77了；<br><strong>内存</strong>当中查找<strong>性能</strong>就非常<strong>快</strong>了；<br><strong>内存</strong>当中<strong>查找</strong>跟一次<strong>磁盘IO</strong>进行<strong>查找</strong>完全是<strong>不同级别</strong>的；<br>所以<strong>不用担心 横向查找 是否 会慢</strong>；  </p><p><strong>问题</strong>：那<strong>是否 能 将表中的 所有行数据 都 放在一个 横向结点 当中</strong>，将这个<strong>横向结点</strong>设置为<strong>无限大</strong>；几百MB或者是几个G的大小用以这个横向结点做存储索引元素？<br>那么<strong>一次查找</strong>即<strong>一次磁盘IO</strong>将这些<strong>数据一次性</strong>放到<strong>内存</strong>当中；<br>之后就是<strong>从 内存 当中 查询 索引数据</strong>；那就很快了？  </p><p>这个<strong>横向结点 不能 设置太大</strong>；<br>如果<strong>设置太大</strong>那么<strong>弊端将存在更多</strong>；<br>首先；<br>比如说几百万行上千万行的数据的索引怎么说也要几百MB，甚至1、2G来存储；<br>也跟<strong>索引的字段类型</strong>有关，比如说<strong>String类型</strong>或者<strong>UUID类型</strong>等就肯定要几百MB；<br>那么<strong>一次查找 就 全部放到 内存</strong>的话；<br><strong>一次磁盘IO</strong> 就 <strong>需要 花费 很长时间</strong>，而且<strong>一次磁盘IO 还不一定 能够 全部 放到 内存 当中去</strong>；<br><strong>一次磁盘IO 也是有 存在 大小限制 的</strong>；<br>就算<strong>一次磁盘IO 能够将 该横向结点 当中的 所有的索引元素 放到 内存 当中去</strong>，那也<strong>需要时间来放</strong>这几百MB的索引元素；<br>而且可以思考一下，事先就将这几百MB设置几个G的<strong>索引元素直接放到内存</strong>当中去，而<strong>真正去查找数据</strong>的时候<strong>可能 也就是 查找 最常用的 10% 都不到的 行数据</strong>；<br>如果老是将整张表的<strong>数据 全部都 一次性 放到 内存</strong>当中去；<br>那就将对这个<strong>内存 的 消耗 太过于 浪费</strong>；<br><strong>内存 的 资源</strong>是很<strong>宝贵</strong>的；<br>所以说这对该<strong>弊端</strong>；<br>MySQL对于这一个<strong>横向结点</strong>是<strong>不会将其设置过大</strong>；<br>尽量设置<strong>一个合适的大小</strong>；<br>让这个结点，通过<strong>一次磁盘IO</strong>能够<strong>快速 全部 存入 到 内存</strong>当中；  </p><p><strong>B-Tree</strong>应该叫做<strong>多叉平衡树</strong>；<br><strong>B-Tree</strong>有一个特点：在中间来看一样也<strong>满足二叉树的原则</strong>；  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL0W0T32/TCfiP1YaPeRT4Jil9RANX5q0FjtHgrmg9JO6KfRhTseVNI0ZlC7sOBVRXN8io620BWK0osf4XOQsJRaBrrA60171VhwueoMM9fAlldBY.Fs!/r" alt="索引"></p><p>56<strong>左边的所有元素</strong> 都 <strong>小于</strong>56相对来说 <strong>右边的元素</strong>；<br>而56<strong>右边的索引元素</strong>都是 <strong>大于</strong>56 <strong>左边的父元素</strong>；<br>20和49都小于56；<br>而20和49都大于15；  </p><p>然后<strong>B树</strong>还有一个特点就是在这一个结点当中，这一个<strong>横向结点</strong>当中<strong>从左到右</strong>它也<strong>是递增排序</strong>的；<br>15小于56；<br>56小于77；<br>这是<strong>B树</strong>的一个特性；<br>同时也是<strong>该数据结构的一个特性</strong>；  </p><p>也就是说要用<strong>B树</strong>来维护这个数据结构时，它会按照这个特性进行初始化好；<br>需要进行<strong>查询</strong>某一<strong>索引元素</strong>时也同样<strong>按照其特性</strong>去查找；<br>比方说要进行查找49这一索引元素；</p><p>那么MySQL的查找方式即为：先将<strong>第一个结点 横向结点 根结点</strong>通过<strong>磁盘IO</strong>之后<strong>放到 内存</strong>当中；<br>然后到<strong>内存</strong>当中进行去<strong>比对</strong>；<br>先<strong>比对</strong>15与49之间的<strong>大小</strong>；<br>49大于15，接着进行比对49与56；<br>则49小于56；<br>然后再去查找比对15和56中间的索引元素；<br>15和56中间存放的是指针，<strong>指针 存放的是 下一个索引元素</strong>，也就是<strong>下一个结点 所对应的 磁盘指针</strong>整个查询出来；<br>即<strong>该指针 所对应的 结点数据 全部放入到 内存</strong> 当中；<br>然后放到<strong>内存</strong>当中去进行<strong>比对大小</strong>；<br>然后接下来49与20进行比对，49大于20；<br>那么接着49与49进行比对；<br>就刚好相等；<br>刚好找到该索引元素了；<br>找到该索引元素之后，则<strong>每一个索引</strong>当中存放的为<strong>key-value</strong>；<br><strong>value</strong>当中即<strong>存储着 该索引 这一行数据 所在的磁盘文件 当中的 指针</strong>；<br>那么拿到这个data之后；<br><strong>磁盘文件指针</strong>就能够快速的找到<strong>磁盘文件数据</strong>；<br>即<strong>聚众索引</strong>；  </p><p><strong>MySQL真正的底层索引</strong>并<strong>不是用B树</strong>来进行实现；<br>而是使用的一种<strong>变种的B树</strong>，称之为<strong>B+树</strong>；  </p><h4 id="B-Tree-B-Tree变种"><a href="#B-Tree-B-Tree变种" class="headerlink" title="B+Tree(B-Tree变种)"></a>B+Tree(B-Tree变种)</h4><p><strong>B+Tree(B-Tree变种)</strong></p><ul><li><strong>非叶子结点 不存储 data，只存储 key，可以 增大 度</strong>；</li><li><strong>叶子结点 不存储 指针</strong>；</li><li><strong>顺序访问 指针，提高 区间 访问性能</strong>；</li></ul><p>什么叫做<strong>B+树</strong>，<strong>B+树</strong>是<strong>B树</strong>的一个<strong>变种</strong>；  </p><p><strong>B+树</strong> 与 <strong>B树</strong> 的 <strong>区别</strong>：<br><strong>B+树</strong>：所有的<strong>data</strong>都<strong>放到</strong>了<strong>叶子结点</strong>上；<br>而<strong>非叶子结点 没有</strong>了<strong>data</strong>；<br><strong>B+树</strong>的<strong>叶子结点</strong>上都有一个<strong>右指针</strong>；  </p><p><strong>问题</strong>：为什么<strong>B树</strong>当中<strong>非叶子结点</strong>上的<strong>data元素</strong>都<strong>移到</strong>了<strong>叶子结点</strong>上去了；<br><strong>B树</strong>当中每一个<strong>叶子结点</strong>并<strong>不重复</strong>；<br>而<strong>B+树</strong>当中一些<strong>关键的索引</strong>做了<strong>冗余</strong>；<br>不光是在<strong>叶子结点</strong>上，<strong>非叶子结点</strong>上也做了<strong>冗余</strong>；  </p><p><strong>非叶子结点</strong>上为什么<strong>没有data元素</strong>了？<br>这么一存的话（叶子结点上存data元素，非叶子结点不存data元素）；<br>那么就意味着整个<strong>B+树</strong>的<strong>叶子结点</strong>当中；<br>就有了数据表的<strong>完整的 所有行的 索引</strong>；<br>因为把<strong>每一行的 data 都往 叶子结点 上移动</strong>；<br>那么<strong>每一行数据</strong>都存在有一个<strong>data 的 磁盘文件指针</strong>；<br>那也就意味着；<strong>所有的行数据</strong>应该在<strong>叶子结点</strong>都有一份<strong>完整</strong>；<br>只不过某一些关键的索引的元素；<br>在<strong>非叶子结点上做</strong>了一个<strong>冗余</strong>；<br>15、20、49做了冗余；<br><strong>方便遍历数据</strong>；<br><strong>一次磁盘IO 取 更多的 k</strong>；  </p><p>其中<strong>常见的数据结构</strong>在<strong>不同场景下</strong>的<strong>区别</strong>  </p><p>MySQL实际上希望的是这一个<strong>结点的大小</strong>是有一个<strong>适当的大小</strong>，<strong>不能设置太大</strong>；<br>也就是说这一个<strong>结点的大小</strong>是<strong>存在有限制</strong>的；<br>每一个<strong>结点</strong>当中能够<strong>存储更小的元素</strong>，是不是也就意味着；<br>一个<strong>大结点</strong>当中里面能够<strong>存储 更多的 索引的 key</strong>；<br>也就是说能够存储更多的索引字段；<br>也就意味着这一个结点在大小相同的情况下；<br>比方说，<strong>默认 MySQL 把这个 结点的大小 设置为 16k</strong>；<br>在这一个<strong>大结点</strong>，一个<strong>大小固定的情况</strong>下面；<br>这一个<strong>大结点</strong>当中的每一个<strong>小结点</strong>如果把<strong>data元素</strong>移动到<strong>叶子结点</strong>上去；<br>是不是也就意味着整个这一个<strong>大结点</strong>可以<strong>横向</strong>可以<strong>存储 更多的 索引元素</strong>；  </p><p>那么如果<strong>横向</strong>可以<strong>存储 更多的 索引元素</strong>，那也就意味着这个<strong>横向结点 向下的分叉 也就 越多</strong>；<strong>分叉 分得更多</strong>，也就说明，<strong>存储 同样大的 数据量，树的高度 也就 更小</strong>了；那么 <strong>叶子结点 也就 更大</strong>了；  </p><p>为什么要将<strong>data移动到叶子结点</strong>上去的原因就在于：<strong>非叶子结点</strong>当中也就可以<strong>横向存放更多的索引元素</strong>；从而<strong>树的高度</strong>也就效率，<strong>查找的效率也就提高</strong>了上来；  </p><p><strong>MySQL</strong> <strong>默认</strong>把<strong>结点的大小</strong> <strong>设置</strong>为 <strong>16k</strong>；  </p><p><strong>SHOW GLOBAL STATUS like ‘Innodb_page_size’;</strong>  </p><table><tr><th>Variable_name</th><th>Value</th></tr><tr><td>Innodb_page_size</td><td>16384</td></tr></table><p>该sql语句查出来的值实际是上就是<strong>MySQL底层 存储 索引字段</strong>，<strong>B+树</strong>的这个<strong>大结点的大小</strong>；<br>当然也可以去进行修改该值；<br>但是一般并不推荐去修改该值；<br><strong>16384个字节</strong>；<br>实际上也就相当于是<strong>16k数据</strong>；<br>也就是<strong>16k的大小</strong>；<br>这个大小在<strong>磁盘上</strong>也就是<strong>分配的 16k 的一个 磁盘大小</strong>；  </p><p><strong>思考</strong>：刚刚将<strong>data元素 放到 叶子结点</strong>上面去了；<br>现在画的树的高度为3；<br>思考现在<strong>高度为3</strong>的该树<strong>一共可以存储多少索引字段</strong>？  </p><p>假设该索引字段的字段类型为<strong>bigint</strong>；<br><strong>表的主键/索引的类型</strong>一般为<strong>bigint</strong>；<br><strong>bigint</strong>在<strong>MySQL</strong>的<strong>底层的存储大小</strong>大概为<strong>8个字节byte</strong>；  </p><p><strong>大结点</strong>当中除了<strong>索引字段</strong> <strong>占据 n*8 个字节</strong>外，还存在有<strong>指针</strong>；<br><strong>指针</strong>在<strong>MySQL底层源码</strong>使用的是<strong>6个字节byte</strong>来进行<strong>存储</strong>这个<strong>指针</strong>；<br>这个<strong>指针</strong>说白了就是 <strong>下个结点 在 磁盘文件 上的 一个地址</strong>；  </p><p>也就是说这个<strong>大结点</strong>当中存储了这样一个<strong>小的索引</strong>，以及<strong>索引旁边的指针</strong>；<br>差不多也就是 <strong>8Byte+6Byte=14Byte（一个索引+一个指针）</strong>；<br>这一个<strong>大结点16k</strong>大概能够<strong>存储多少个索引</strong>；<br><strong>公式 = 16384Byte / ( 8Byte + 6Byte = 14Byte ) = 1,170.285714285714</strong><br>一个<strong>大的结点</strong>可存储的索引数约为<strong>1170个</strong>；也就是大概<strong>1k</strong>的样子；  </p><p>那么第二个结点，也可以进行<strong>存储 1170 个索引数</strong>；  </p><p>再说到<strong>叶子结点</strong>；<br>所有的<strong>data元素 都放到 叶子结点</strong>；<br>那么<strong>叶子结点 就会 变大</strong>；<br><strong>每一个小结点</strong>就<strong>都会变大</strong>了相比之前没有放data元素之前变大了；  </p><p>假设一下；<br>假设这个<strong>叶子结点</strong>当中的<strong>一个小叶子结点</strong>，也就是对应的这一行索引以及该索引所在的行的那个<strong>磁盘文件文件指针</strong>或者说<strong>这一行的其他数据</strong>就<strong>存储</strong>到这个<strong>小结点</strong>当中；<br>假设这个<strong>小结点</strong>就大一点，就<strong>存储1k的数据</strong>；<br>那么这一个存储该小结点的大结点同样是<strong>存储16k的数据</strong>；<br>那么也就是该<strong>结点</strong>所能够<strong>存储的索引元素 为 16个</strong>；<br>整个<strong>叶子结点</strong>当中可以容纳多少的<strong>索引元素</strong>（存储的所有的索引的数值）？<br><strong>公式：（ 根结点上 的 1170 这一层 ）1170 * 1170 * 16 = 21,902,400‬</strong><br>算出来的该值实际上就是该<strong>叶子结点</strong>上所有<strong>可以存储的 索引元素的 总和</strong>；  </p><p><strong>非叶子结点 的 所有的 索引元素 * 每一个叶子结点 可以存储的 多少个 索引行数据</strong>  </p><p>这个结果算出来差不多等于两千多万；<br>两千多万所算出来的东西；<br>也就意味着该<strong>叶子结点 能够放的 总索引元素 个数（小索引元素+data元素）</strong>大概是两千多万；（也就相当于是两千多万条/行数据）；  </p><p>使用<strong>B+树</strong>这么一改造之后；<br>发现<strong>同样树的高度</strong>；<br>高度为3；<br>该<strong>树</strong>就能够存储两千多万条个索引，也就说明可以支撑两千万行的表；<br>将这两千多万行数据的表当中的一字段作为索引存储到该数据结构当中，那么同样高度为3，height为3，查找一个元素比方说查找50；<br>那么从<strong>根结点 去进行 匹配 对比</strong>；<br>经过<strong>顺序查找</strong>；<br>50与父节点/根结点当中的15-56对比，查找中间的数值即该根结点的左节点；<br>也就是再跟15-28-49进行比较，得到50再去与该结点的下一结点比较即49-50；<br>最多经过三次<strong>磁盘IO</strong>；<br>就能够找到索要查找得到的元素50；<br><strong>性能十分高</strong>；  </p><p>这也就是为什么上千万行数据；只要<strong>索引字段</strong>建的比较的<strong>合理、合适</strong>；<br>那么其<strong>磁盘查找次数</strong>是非常<strong>少</strong>的；  </p><p>用<strong>B+树</strong>来说；常见的数据表，<strong>树的高度</strong>一般就控制在<strong>2~4</strong>之间；<br>不管如何查询；即使是<strong>查询到 叶子结点 的 速度</strong>也是十分<strong>快</strong>的；<br>只需要经过几次<strong>磁盘IO</strong>查找；  </p><h4 id="HASH表"><a href="#HASH表" class="headerlink" title="HASH表"></a>HASH表</h4><p><strong>MySQL</strong>的<strong>索引字段</strong>当中存在有<strong>索引方法</strong>；<br>点击下拉框进行选择索引方法（存在有两种实现：一种是<strong>BTREE</strong>；一种是<strong>HASH</strong>）<br><strong>HASH</strong> 也是官方的一种实现；但是使用的不多；<br>90%以上的场景都是使用的<strong>B树</strong>；<br>为什么<strong>不用 HASH表 的原因</strong>：<br><strong>HASH表 存储 索引 的原理</strong>：<br>比方说将col1作为索引字段；select * from t where t.col1=4;<br>通过一个<strong>hash算法</strong>，hash（4）；<br>对该4取了一个<strong>HASH</strong>；<br>得到的该结果，那么该结果就跟所查询的where t.col1(4)这一行<strong>数据所在磁盘文件</strong>是有一个<strong>映射关系</strong>的；<br>这就是<strong>HASH表</strong>的一个<strong>存储结构</strong>；<br><strong>HASH</strong>实际上就是一种<strong>算法</strong>；<br>比说MD5；MD5就是一种HASH算法；<br><strong>HASH</strong>就是将<strong>索引列</strong> 通过一种<strong>HASH算法</strong> 将 <strong>索引列的值 存放到 HASH 这一 数据结构 当中去</strong>；<br>那么select * from t where t.col1=6;进行查找该t.col1=6的数据行；<br>的HASH查找即为：对该col1=6；<br>该6的该<strong>取值</strong>做一次<strong>HASH算法 运算 得到 它的结果 hash(6)</strong>；<br>根据这个结果；只需要做<strong>一次映射</strong>就能够<strong>快速的定位</strong>到<strong>这一行 数据 所在的 文件磁盘指针</strong>；<br>那么即便是千万级别的数据也只需要通过<strong>hash() 一次HASH结果</strong> 进行 <strong>计算 定位 得到 索引 所在行 数据的 文件磁盘指针</strong> 也是能够快速的查找得到的；<br>感觉<strong>HASH</strong>表性能更高，比<strong>B+树</strong>效率更高；<br><strong>B+树</strong>还要经过两三次的树的一个<strong>遍历</strong>；<br>而<strong>HASH</strong>表的查找感觉更快；<br>只需要有这个索引字段，走索引，经过MYSQL底层定义好索引方法为<strong>HASH算法</strong>，<strong>只需要 一次HASH 计算结果 就能够拿到 该查找行 数据的 所在 文件磁盘指针</strong>；感觉性能很快；<br>甚至在数据量更大的表当中进行查找表尾的数据，也只需要经过一次<strong>HASH计算</strong>就能找到<strong>该行 数据 所在的 磁盘文件指针</strong>；  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL0W0T32/TCfiP1YaPeRT4Jil9RANXzV2Z6K9IOXoYW6kFdX*NnL.fv6XCleV5BjrQCN4Bw3HvJfkZCF6LFsSX26xC5WuUZwgbGD9vBaj2.Lec10r*m8!/r" alt="索引"></p><blockquote><p>那么<strong>为什么 MySQL 一般用 B树 而不用 HASH表</strong> 呢？  </p></blockquote><p><strong>（1）</strong> <strong>范围查找太慢</strong>；<br>      比如说select * from t where t.col1&gt;6;<br>      那么当这种情况下；<br>      如果col1<strong>大于</strong>的数值，极端来想的话，也就相当于是<strong>全表扫描</strong>了；  </p><p><strong>（2）</strong> <strong>HASH</strong>只用于<strong>范围查找很少的情况</strong>下才进行使用；<br>      那么这个时候索引使用HASH是没有问题的；<br>      而正常情况下一般都会要使用得到<strong>范围查找</strong> ,<br>      所以这个时候使用<strong>B Tree更佳</strong>；  </p><p><strong>（3）</strong> 回到问题：为什么<strong>InnoDB 的 主键索引 的 叶子结点 上 存在有 指针（右指针）</strong>？<br>      在<strong>维护B+树</strong>的时候，比方说<strong>叶子结点</strong>的<strong>最后一个结点</strong> <strong>满了</strong>，那么就需要<strong>开辟 一个 新的 结点（下一个结点）</strong> 来进行<strong>存储 新的 索引元素</strong>；<br>      那么就将<strong>前面那个结点</strong><br>      （也就是之前叶子结点的最后一个结点满了的那个结点）<br>      中间<strong>开辟 一个 小小的 元素空间</strong>；<br>      把<strong>下一个 新开辟的 这一个结点的 磁盘文件地址的 指针 存放到 该新开辟的结点的 上一个结点的 那个 小元素空间 当中去</strong>；<br>      也就说白了；<br>      该<strong>新开辟的结点 的 上一结点 有一个 指针</strong>，<strong>指向 了 下一结点</strong>，也就是<strong>该新开辟的 结点 的 磁盘文件指针</strong>；<br>      通过有了这个<strong>指针</strong>；<br>      再联想<strong>HASH</strong>表的<strong>范围查找</strong>进行思考，那么是不是说明该指针就能够帮忙解决很大的问题；<br>      比方说：查找索引字段取值col1<strong>大于</strong>20取值的记录；<br>      从<strong>B+ 树的索引</strong>找到该20的这一个元素；<br>      因为<strong>整个 叶子结点的 索引元素</strong>都是<strong>从左到右 依次 递增形式</strong> 的；<br>      通过这个（右）指针顺藤摸瓜的形式<br>      （其实这里形成了一个<strong>双向指针</strong>，查询即小于20的元素也是一样的；<strong>双向链表</strong>），<br>      通过<strong>指针</strong>就能够找到大于20，也就是20这个索引元素后面的<strong>所有索引元素结点</strong>；<br>      最后放到一个<strong>大的集合</strong>当中去；也就是这条sql语句所要返回的<strong>结果集合</strong>；  </p><blockquote><p><strong>B+树</strong>的<strong>两个特性</strong>：  </p></blockquote><p><strong>（1）</strong> 为了让<strong>非叶子结点</strong>能够<strong>存储更多的索引</strong>；<br>          从而<strong>叶子结点上</strong>除了<strong>索引元素</strong>还存在有<strong>data元素</strong>；  </p><p><strong>（2）</strong> 在<strong>叶子结点 索引元素</strong>之间还存在有一个<strong>指针</strong> <strong>指向 下一 索引元素 结点 的 地址</strong>；<br>存在有一个<strong>双向 的 指针</strong>；<br>也就是为了<strong>解决</strong>如何<strong>高效的 进行 范围查找</strong>的这样一个问题；<br>所以<strong>高效的 范围查找</strong>也是<strong>可以</strong>进行<strong>走索引</strong>的；<br>在某种情况下，<strong>范围查找</strong>也是<strong>可以走索引</strong>的；<br>（因为<strong>存在指针</strong>，<strong>存在 顺序递增 顺序递减</strong> 的这样一个结构，那么则肯定是<strong>可以走 相关的索引</strong> 的）  </p><h5 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B+Tree索引的性能分析"></a>B+Tree索引的性能分析</h5><ul><li>一般使用 <strong>磁盘I/O次数</strong> 评价<strong>索引结构的优劣</strong></li><li><strong>预读</strong>：<strong>磁盘</strong>一般会<strong>顺序向后</strong> <strong>读取</strong> <strong>一定长度 的 数据（页的 整数倍） 放入 内存</strong></li><li><strong>局部性原理</strong>：当一个<strong>数据被用到</strong>时，其<strong>附近的数据</strong>也<strong>通常</strong>会马上<strong>被使用</strong>；</li><li><strong>B+Tree结点 的 大小</strong>设为等于<strong>一个页</strong>，每次<strong>新建结点</strong>直接<strong>申请 一个页 的 空间</strong>，这样就保证<strong>一个结点 物理上 也存储在 一个页 里</strong>，就实现了<strong>一个结点 的 载入 只需 一次 I/O</strong>。</li><li><strong>B+Tree</strong>的<strong>度d</strong>一般会超过100；因此<strong>h非常小</strong>（<strong>一般为1~3之间</strong>）  </li><li>一般<strong>操作系统</strong>的<strong>最小 存储单元 为 页</strong>，<strong>1页 大小为 4k</strong>；  </li><li>查看<strong>Mysql 文件页 大小（16k）</strong>: <strong>SHOW GLOBAL STATUS like ‘Innodb_page_size’;</strong>  </li></ul><h5 id="为什么MySQL页文件默认为16k"><a href="#为什么MySQL页文件默认为16k" class="headerlink" title="为什么MySQL页文件默认为16k"></a>为什么MySQL页文件默认为16k</h5><p>假设一行数据大小为1k；<br>那么一页就能够存16条数据；<br>也就是一个叶子结点能够存16条数据；<br>再看非叶子结点，假设主键ID为bigint类型，那么长度为8B，指针大小在InnoDB源码中为6B，一共就是14B，那么一页里就可以存储16k/14=1170个（主键+指针）<br>那么一棵高度为2的B+树能存储的数据为1170<em>16=18720条，一棵高度为3的B+树能存储的数据为1170</em>1170*16=21902400（千万级条）  </p><h3 id="索引底层数据结构与算法"><a href="#索引底层数据结构与算法" class="headerlink" title="索引底层数据结构与算法"></a>索引底层数据结构与算法</h3><h3 id="InnoDB与MyISAM索引区别"><a href="#InnoDB与MyISAM索引区别" class="headerlink" title="InnoDB与MyISAM索引区别"></a>InnoDB与MyISAM索引区别</h3><p><strong>InnoDB形容表</strong>还是形容数据库？<br><strong>InnoDB以及MyISAM存储引擎</strong>是用来<strong>形容数据表</strong>的；  </p><p>当在设计表时，在选项当中有引擎选项存在有：ARCHIVE、BLACKHOLE、CSV、InnoDB、MEMORY、MRG MYISAM、MyISAM、PERFORMANCE SCHEMA…等等；  </p><p><strong>存储引擎是形容表</strong>的，最<strong>常见的存储引擎</strong>即<strong>InnoDB</strong>以及<strong>MyISAM</strong>这两种<strong>存储引擎</strong>；<br><strong>用的比较多的 为 InnoDB 该 存储引擎</strong>；  </p><p><strong>不同表 不同存储引擎 底层的数据结构 区别</strong>：  </p><p>test数据库对应都是存储在本地磁盘上的；<br>以数据库名命名的磁盘文件夹下；  </p><p><strong>表 = 表结构 + 数据 + 索引</strong>  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL0W0T32/TCfiP1YaPeRT4Jil9RANX8IZB7poXY4Ed7**8BhOfVx.BLlNb39BqBwC.ebBPiVr7.bXbWAXqMbGapRUkOP8BwmJQWBxopXJj*htdZrocUE!/r" alt="索引"></p><p><strong>InnoDB</strong>:<br>test.innodb.lock <strong>.frm</strong> - <strong>表结构等相关信息存储文件</strong><br>test.innodb.lock <strong>.ibd</strong> - <strong>表数据 + 表索引结构</strong>  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL0W0T32/TCfiP1YaPeRT4Jil9RANX*r9r8zOgb4r0dv8mg9Q5qMyppmh2cPcvbiy6hMFV9ap4rR0IrTk.u5U5HvIcDcxnTh0*XJn4IhWeLwxBiXTkPg!/r" alt="索引"></p><p><strong>InnoDB</strong>的表有一个<strong>主键</strong>，该<strong>主键自带索引</strong>；<br><strong>主键索引</strong>在<strong>InnoDB存储引擎</strong>下如何存储；<br>InnoDB的这种文件存储方式，MySQL官方在开发的时候，<br><strong>InnoDB当中的主键索引</strong>以及<strong>表当中的所有数据</strong>全部存储同一个文件，<br>叫做<strong>后缀为ibd的文件</strong>当中；  </p><p><strong>InnoDB存储方式</strong>当中的<strong>叶子结点当中的的data元素 所表示的内容</strong><br>与<br><strong>MyISAM存储方式</strong>当中<strong>叶子结点当中的data元素</strong> 所 <strong>表示的内容不一致</strong>；</p><p><strong>索引结构有点区别</strong>；</p><p><strong>MyISAM 叶子结点的 data元素</strong>当中所存为<strong>索引 所在行的 行数据的 磁盘文件指针</strong>；<br>但是发现<strong>InnoDB的主键索引</strong>，它的<strong>叶子结点 当中的 data元素</strong>当中所 存储的 为 <strong>索引所在行 的 其他所有列的 数据</strong>；<br><strong>这一行的 所有列数据 全部存储到 该data元素 当中去</strong>；<br>也就是说在<strong>InnoDB</strong>当中，通过一条sql语句，带有where查询通过索引进行查询的sql语句；<br><strong>只需要查找一个文件</strong>，从这个<strong>ibd文件</strong>当中<strong>一次性 定位到 索引元素</strong>，快速的就能根据data元素，这个索引所在行的其他的所有字段，将该行的所有字段进行查询出来<strong>放入内存</strong>当中去；<br>就查找到了所需要查找的元素；相对来说<strong>性能</strong>应该要<strong>比 MyISAM存储引擎的 性能</strong>会<strong>高一点</strong>；  </p><p><strong>InnoDB与MyISAM的底层存储</strong>是稍微有些<strong>区别</strong>的；  </p><p><strong>MyISAM</strong>：<br>test.myisam <strong>.frm</strong> - 该文件存储对<strong>表的表结构一些定义</strong>的一些数据；<br>test.myisam <strong>.MYD</strong> - 实际上存储的为<strong>表的数据</strong>，<strong>D英文单词data的简写</strong>（该表当中所有的数据行）；<br>test.myisam <strong>.MYI</strong> - 该表<strong>所对应的索引字段存储的位置</strong>；  </p><p><strong>主键自带主键索引</strong>；<br><strong>索引</strong>，它是一个<strong>数据结构</strong>，<strong>数据结构</strong>实际上存储在<strong>MYI文件</strong>当中；<br><strong>I即为Index首字母的简写</strong>；  </p><p><strong>MyISAM底层</strong>也为<strong>B+树数据结构</strong>进行<strong>存储</strong>；<br><strong>MyISAM索引底层存储</strong>，如何进行存储：  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL0W0T32/TCfiP1YaPeRT4Jil9RANX8sBSc*PWI*GgGhWe3pcWW625GV21FTGHFPkQrnPSFTCe3vCEKM3QCpTupcvYLjHH7f2N4y0qI7TTFDwZaL9fXc!/r" alt="索引"></p><p>col1是作为表的<strong>主键索引</strong>；<br>因为支持<strong>二叉查找</strong>，所以像15、20、49这种处于在中间的这些个数据将被作为<strong>冗余字段</strong>；<br>就更可以<strong>区分查找数据</strong>；<br>像二叉折半查找等；<br>一般取中间的元素作为<strong>冗余的索引</strong>；<br><strong>快速的过滤</strong>一些<strong>数据</strong>；<br><strong>减少查找次数</strong>；<br>将col1该字段列当中的所有数据放入到数据结构当中去；然后看；<br>原来在叶子结点当中存储的data元素，data元素存储的即<strong>该索引 所在行的 行数据的 磁盘文件指针</strong>；（地址指针，16进制的值）  </p><p>select * from t where t.col1=49;<br>col1<strong>主键索引</strong>；<br><strong>MySQL底层</strong>实际上先会去到<strong>MYI文件</strong>当中；<br>因为<strong>索引（数据结构）</strong>存储在<strong>MYI索引文件</strong>当中；<br>先拿col1=49在MYI文件当中快速地定位到结点为49的结点；<br>根据<strong>B+树的特性</strong>；<br>先<strong>从根结点 去进行 定位</strong>；<br>根结点当中的数据通过<strong>一次磁盘IO</strong>，根结点当中的索引元素将会被<strong>放到内存</strong>当中，49将会在<strong>内存</strong>当中与15-56-77相进行<strong>比较</strong>；<br>得到49在15-56之间；<br>49就将走15与56中间的向下的指针，左节点也就是存放有15-20-49这三个索引元素的该结点中，那么此时左节点当中的索引元素将会进行第二次磁盘IO的操作，将<strong>左节点当中的索引元素放到内存当中</strong>去，与查询的数据49相进行<strong>比较</strong>；<br>得到49在区间20-49之间；<br>最后到了<strong>叶子结点</strong>，该叶子结点当中包括两个小结点49-50以及2个data元素（指针），那么<strong>第三次磁盘IO</strong>时，将49-50该叶子结点<strong>放到内存当中去</strong>，49就将与49-50相进行比较得到49，该49即为要查找的元素；<br>49该小结点当中所对应的data元素拿出来，该data元素对于<strong>MyISAM存储引擎</strong>来说<strong>data元素 存储的是 为 该索引 所在行的 行数据的 磁盘文件指针</strong>；<br>当拿到获取得到该<strong>指针</strong>之后就将到<strong>MYD文件</strong>当中进行查询获取得到相应数据值；  </p><p><strong>面试题</strong>：<strong>聚集索引 or 聚众索引</strong>  </p><blockquote><p><strong>什么叫做聚集索引</strong>?  </p></blockquote><p><strong>聚集索引</strong> <strong>定义</strong>：<strong>叶结点 包含了 完整的 数据记录</strong>；  </p><p><strong>InnoDB的主键索引</strong>，<strong>ibd</strong>这个主键索引的这个文件；<strong>主键索引 其就叫做 聚集索引</strong>；<br>因为<strong>InnoDB的主键索引</strong>，它是跟它的<strong>文件数据行</strong>整个是存储在<strong>一个文件当中ibd文件</strong>；<br><strong>索引 和 数据 是 聚集存储 在一起 的</strong>；  </p><p><strong>有 聚集索引 即 存在 非 聚集索引</strong>；  </p><p><strong>MyISAM的主键索引</strong> 就称作是 <strong>非聚集索引</strong>；<br>因为<strong>MyISAM的主键索引</strong>存储在<strong>MYI文件</strong>当中；而<strong>数据</strong>存储在<strong>MYD文件</strong>当中；<br>那如果需要查找数据，每次都需要<strong>两个文件的一同查找</strong>才能查找得到；<br><strong>数据文件和索引文件分开存储</strong>了；<br>所以称<strong>MyISAM的 主键索引 为 非聚集索引</strong>；<strong>InnoDB的主键索引 称为 聚集索引</strong>；  </p><p>常见数据结构理论；  </p><p>结合具体的MySQL表来看一下；<br>不同的表底层如何进行存储；<br>MySQL的表无非就是MyISAM存储引擎/InnoDB存储引擎；<br>不同的表可能有不同的存储引擎；  </p><p><strong>MyISAM索引</strong>实现（<strong>非聚集</strong>）<br><img src="http://r.photo.store.qq.com/psc?/V13IdniL0W0T32/TCfiP1YaPeRT4Jil9RANX2tYjinQbFQFT5hJICKOua.p8u*tNGRGnBmzDnCDDuui9JbsxaFmbrmLTSu0V4thfYO9zIg6UNnWwUY*NxnoWlU!/r" alt="索引"></p><ul><li><strong>MyISAM索引文件 和 数据文件</strong>是<strong>分离</strong>的；</li></ul><p><strong>InnoDB索引</strong>实现（<strong>聚集</strong>）</p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL0W0T32/TCfiP1YaPeRT4Jil9RANX*GhKIY3zUQdhemNpwYPZHMTx6WJ6HggRWyAqiDQHIGmxm2m2V7hUQmLQaYwj8CF*g.zfe8sCKjjxpzzRlDfl3I!/r" alt="索引"></p><ul><li><strong>表数据</strong>本身就是按照<strong>B+Tree</strong>组织的一个<strong>索引结构文件</strong></li><li><strong>聚集索引</strong>-<strong>叶结点 包含了 完整的 数据记录</strong></li><li>为什么<strong>InnoDB表必须要有主键</strong>？并且<strong>推荐使用 整型的 自增主键</strong>?  <ul><li>为什么必须要建主键，MySQL官方对于<strong>InnoDB的表</strong>，其数据就需要用一个<strong>索引B+树</strong>来组织；所以肯定是<strong>需要主键</strong>的；<br>（之间建了InnoDB的表但是没有建索引也建成功了）针对这种情况，MySQL会<strong>自动</strong>在<strong>底层建一个索引</strong>；<br>如果表中<strong>没有建索引</strong>，<strong>MySQL</strong>会在<strong>底层</strong>找一个<strong>唯一能标识</strong>这一行数据的字段作为索引；<br>如果找不到，它会<strong>默认</strong>给表<strong>生成</strong>一个类似像row_id，一个<strong>隐藏列</strong>作为<strong>主键索引，主键</strong>；<br>根据该表<strong>主键索引</strong>来<strong>维护</strong>整张表的<strong>数据</strong>；</li><li><em>MySQl官方*</em>设计的就是要用一个<strong>B+树的存储结构</strong>来组织；</li><li><em>B+树*</em>其实就是该<strong>索引，索引结构</strong>；<br>所以必须要有一个<strong>主键索引</strong>；<br>即便表中<strong>没有建立</strong>，<strong>MySQL</strong>也会<strong>默认生成一个隐藏的列/主键索引</strong>；  </li><li><strong>主键</strong>尽量为<strong>整型自增</strong>；为什么<strong>主键尽量为整型自增</strong>？<br>假设主键<strong>不设置为整型</strong>，设置为<strong>UUID类型</strong>，</li><li><em>UUID不为整型，而是字符串类型*</em>；<br>为什么<strong>不推荐使用 UUID</strong>，而<strong>推荐使用 整型 并且 自增 的类型</strong>；<br>首先用UUID，它是<strong>字符串类型</strong>的，而且是很长一串，字母+数字+其他符号；<br>这样<strong>存在的弊端</strong>有：  </li><li><em>（1）*</em> 相对于<strong>整型</strong>来说，首先，这一长串字符串的<strong>存储空间</strong>比整型大得多（<strong>字符串长度 越长 占用 空间 越大</strong>；</li><li><em>索引 存放在 磁盘上面，那么也将会 占用 磁盘存储空间*</em>；<br>那么UUID<strong>存储磁盘空间</strong>是肯定会要比整型类型字段要<strong>大得多</strong>）；  </li><li><em>（2）*</em> 而且，<strong>底层B+树索引</strong>去进行<strong>查找</strong>的时候；是需要进行结点之间<strong>比较大小的</strong>；<br>一个一个根据<strong>B+树</strong>，二叉一个个进行比较大小找对应的元素；<br>而结点当中存储的都为UUID，<strong>一个个去比较大小</strong>的话；<br>字符串比较大小，字符串跟数字进行比较，<strong>一位一位</strong>进行比较<strong>性能将会非常的低</strong>；<br>字符串去进行比较先要<strong>转成ASCII码值（国标码）</strong> ，<strong>按照码表当中的顺序</strong>进行<strong>比较大小</strong>；<br>这个<strong>性能就非常低</strong>了；<br>相对于整型来比较：<strong>数值</strong>之间的<strong>比较性能</strong>肯定是<strong>高的多</strong>的；  </li><li><em>（3）*</em> 为什么<strong>要使用自增的</strong>？</li><li><em>UUID肯定不是自增类型的*</em>；<br>正常情况下如果是使用<strong>顺序自增</strong>：<strong>插入的元素</strong>基本上是<strong>往后面进行插入的</strong>；</li><li><em>后面的结点空间满了*</em>，然后继续<strong>往后面去开辟一个空间继续放</strong>；<br>如果现在新加一个元素；<strong>叶子结点 从左到右 都是 依次递增的</strong>；<br>在<strong>每一个结点</strong>当中<strong>每一个元素</strong>都是<strong>依次递增</strong>，<strong>左边小于右边</strong>；</li><li><em>B+树*</em>当中的所有<strong>叶子结点 从左到右 都是 依次递增</strong>的；<br>现在将一个不是自增的新元素UUID进行插入；<br>而<strong>插入的位置</strong>正好是<strong>叶子结点中间的一个位置</strong>，而并不是结尾的位置；<br>比如插入到20与30的叶子结点中间；<br>那么这个时候将20和30想象成UUID类型的字符串内容；<br>当新元素UUID进行插入的时候就将会形成<strong>分裂</strong>的这种情况；<br>有可能就是将20与新元素新<strong>分裂出一个叶子结点</strong>，30<strong>单独分裂出去一个叶子结点</strong>；  </li><li><em>插入的元素需要进行分裂一次*</em>；然后还需要<strong>平衡一次</strong>；<br>相对于这种插入新元素，插入一个元素按<strong>顺序递增</strong>往<strong>后面进行一个一个递增的加元素</strong>的这种情况<strong>效率就要高</strong>多了；<br>这也就是为什么 <strong>B+ 树</strong>推荐的<strong>主键索引为整型并且自增类型</strong>；<br>因为<strong>自增</strong>它会<strong>尽可能的避免</strong>：<strong>新增的 该结点 插入到 叶子结点</strong>上去了之后，会<strong>导致叶子结点 原有的 已经满了的 大的 叶子结点 做分裂 以及 自动平衡</strong>；  </li><li><em>（4）*</em> <strong>指针（B+树的 叶子结点上的 右指针）的作用</strong>：叶子结点当中某一大结点如已经存满了16k的索引元素；按照<strong>B+树</strong> <strong>从左到右 的 依次递增 的 顺序</strong>；<br>假设当前该字段<strong>不是自增</strong>的；<br>现在来了一个新的元素需要进行插入数据，看到索引的值比方说为25；<br>那么按顺序这个索引值就应该插入到叶子结点20-30的中间；<br>但是当前该叶子结点的存储空间大小16k已经满了，已经存不下了；<br>那么此时在这种情况下：  </li><li><em>1&gt;*</em> <strong>当前叶子结点 的 存储空间 已经满</strong>了  </li><li><em>2&gt;*</em> 当前需要<strong>新插入 一个新的 索引元素</strong>，而该<strong>索引元素的大小取值</strong>应该放在该<strong>当前叶子结点的中间</strong>；<br>那么这个时候就需要进行<strong>叶子结点的分裂</strong>；</li><li><em>分裂成两个结点*</em>；<br>20与25这两个索引元素<strong>成为一个新的叶子结点</strong>；<br>而30将被<strong>分裂到另外一个叶子结点</strong>上面去；<br>而如果插入的元素都是递增类型的元素的话则比如说插入新元素100；<br>那么就肯定<strong>不再需要 往中间 去 进行 插入</strong>；<br>都是<strong>直接在后面 新开辟一块空间 来进行 存储 该新元素</strong>100；  </li></ul></li></ul><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL0W0T32/TCfiP1YaPeRT4Jil9RANX8fDAvL3g7DJ9HhnBQeGRqDvrpkZXABEIRyvGCl2wXfLlwUZMMrCWHUUoUCg2YMQdB8MP3ElixOLflsVbBIu18U!/r" alt="索引"></p><ul><li>为什么<strong>非主键索引结构 叶子结点 存储的是 主键值</strong>？（<strong>一致性 和 节省存储空间</strong>）  </li></ul><h3 id="索引最左前缀原理"><a href="#索引最左前缀原理" class="headerlink" title="索引最左前缀原理"></a>索引最左前缀原理</h3><ul><li>联合索引的底层存储结构长什么样?  </li></ul><p>(字段1，字段2，字段3)<br>比方说字段1、字段2、字段3是联合索引；  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL0W0T32/TCfiP1YaPeRT4Jil9RANX50m84lF6rjqlgyWXpKCriCR9zfdJdu7YbMYTBq.e8Oj47TQyP3KTeZ1anErrKoy5mNBgGaDtLH9DbfHrrCBYYg!/r" alt="索引"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观看笔记：  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面试" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="红黑树" scheme="https://fengshana.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="MySql索引" scheme="https://fengshana.github.io/tags/MySql%E7%B4%A2%E5%BC%95/"/>
    
      <category term="B+树" scheme="https://fengshana.github.io/tags/B-%E6%A0%91/"/>
    
      <category term="B树" scheme="https://fengshana.github.io/tags/B%E6%A0%91/"/>
    
      <category term="HASH表" scheme="https://fengshana.github.io/tags/HASH%E8%A1%A8/"/>
    
      <category term="二叉树" scheme="https://fengshana.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Git工作流学习笔记</title>
    <link href="https://fengshana.github.io/2020/05/27/%E3%80%90GIT%E3%80%91/%E3%80%90GIT%E3%80%91Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://fengshana.github.io/2020/05/27/%E3%80%90GIT%E3%80%91/%E3%80%90GIT%E3%80%91Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-05-27T10:34:59.148Z</published>
    <updated>2020-06-05T17:45:56.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git工作流指南-分布式版本控制系统"><a href="#Git工作流指南-分布式版本控制系统" class="headerlink" title="Git工作流指南 分布式版本控制系统"></a>Git工作流指南 分布式版本控制系统</h2><p>观看笔记：<code>https://www.bilibili.com/video/BV1dW411U7ER?p=1</code><br>老师笔记： <code>http://www.funtl.com/zh/git/</code>  </p><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><ul><li>什么是<strong>版本控制系统</strong></li><li>什么是<strong>Git</strong></li><li>如何<strong>安装Git</strong></li></ul><h3 id="什么是版本控制系统"><a href="#什么是版本控制系统" class="headerlink" title="什么是版本控制系统"></a>什么是版本控制系统</h3><h4 id="为什么需要版本控制"><a href="#为什么需要版本控制" class="headerlink" title="为什么需要版本控制"></a>为什么需要版本控制</h4><p>在软件开发过程中，每天都会产生新的代码，<strong>代码合并</strong>的过程中可能会出现如下<strong>问题</strong>：  </p><ul><li><strong>代码覆盖或丢失</strong>；</li><li>代码写的不理想，希望<strong>还原</strong>之前的<strong>版本</strong>；</li><li>希望知道与之前<strong>版本的差别</strong>；</li><li>是<strong>谁</strong>修改了代码以及<strong>为什么</strong>修改；</li><li><strong>发版</strong>时希望分成<strong>不同的版本</strong>（测试版本、发行版本等）；</li></ul><p>因此，希望有一种<strong>机制</strong>，能够帮助我们：  </p><ul><li>可以<strong>随时回滚</strong>到之前的<strong>版本</strong>；</li><li>协同开发时，<strong>不会覆盖</strong>别人的代码；</li><li>留下<strong>修改记录</strong>，以便随时查看；</li><li><strong>发版</strong>时可以方便的管理<strong>不同的版本</strong>；</li></ul><h4 id="什么是版本控制系统-1"><a href="#什么是版本控制系统-1" class="headerlink" title="什么是版本控制系统"></a>什么是版本控制系统</h4><p>一个标准的<strong>版本控制系统</strong> <strong>Version Control System（VCS）</strong>，通常需要有以下功能：  </p><ul><li>能够<strong>创建Repository</strong>（<strong>仓库</strong>），用来<strong>保存代码</strong>；</li><li>协同开发时，方便将<strong>代码分发</strong>给团队成员；</li><li><strong>记录</strong>每次<strong>修改</strong>代码的内容、时间、原因等<strong>信息</strong>；</li><li>能够<strong>创建Branch（分支）</strong>，可以根据<strong>不同的场景</strong>进行<strong>开发</strong>；</li><li>能够<strong>创建Tag（标签）</strong>，<strong>建立</strong>项目<strong>里程碑</strong>；</li></ul><h4 id="版本控制系统的发展史"><a href="#版本控制系统的发展史" class="headerlink" title="版本控制系统的发展史"></a>版本控制系统的发展史</h4><p><strong>版本控制系统</strong>发展至今有几种<strong>不同的模式</strong>：  </p><h5 id="Local-VCS"><a href="#Local-VCS" class="headerlink" title="Local VCS"></a>Local VCS</h5><p><strong>本地</strong>使用 <strong>复制/粘贴</strong> 的方式进行管理，<strong>缺点</strong>是<strong>无法协同开发</strong></p><h5 id="Gentralized-VCS（Lock，悲观锁）"><a href="#Gentralized-VCS（Lock，悲观锁）" class="headerlink" title="Gentralized VCS（Lock，悲观锁）"></a>Gentralized VCS（Lock，悲观锁）</h5><p><strong>中央集中式版本控制系统</strong>团队共用仓库，当某人需要编辑文件时，<strong>进行锁定，以免其他人同时编辑时造成冲突</strong>，但不是很方便，<strong>其他人需要排队才能编辑文件，如果有人编辑了很久或是忘记解锁会造成其他人长时间等待</strong>的情况；  </p><p>如何理解悲观锁：总有刁民想害朕。<br>我要是面试这么答，会怎么样？  </p><h5 id="Gentralized-VCS（Merge，乐观锁）"><a href="#Gentralized-VCS（Merge，乐观锁）" class="headerlink" title="Gentralized VCS（Merge，乐观锁）"></a>Gentralized VCS（Merge，乐观锁）</h5><p><strong>中央集中式版本控制系统</strong>团队共用仓库，<strong>不采用悲观锁方式来避免冲突</strong>，而是时候发现如果别人也修改相同文件（冲突），再<strong>进行手动修改解决</strong>。  </p><p>有很多VCS属于这种类型，如：CVS、<strong>Subversion</strong>、Perforce等；  </p><p><strong>中央集中式版本控制系统</strong>的共同问题是，做<strong>任何操作都需要和服务器同步</strong>，如果<strong>服务器宕机则会造成无法继续工作的窘迫</strong>；  </p><p>如何理解乐观锁：天网恢恢疏而不漏。<br>我想给自己两锤子；  </p><h5 id="Distributed-VCS"><a href="#Distributed-VCS" class="headerlink" title="Distributed VCS"></a>Distributed VCS</h5><p><strong>分布式版本控制系统</strong>，<strong>本地</strong>也<strong>拥有完整的代码仓库</strong>，就不会出现上述集中式管理的问题，即使<strong>没有网络，依然可以commit和看log</strong>，也<strong>无需担心服务器同步</strong>问题；  </p><p>如：<strong>Git</strong>、Mercurial、Bazaar等就属于<strong>分布式版本控制系统</strong>。<strong>缺点</strong>是<strong>功能比较复杂</strong>，上手需要一定的学习时间；  </p><p>（<strong>分布式版本控制系统</strong>都有一个<strong>本地化</strong>的这样一个概念；<strong>区块链系统</strong>也能称之为一个<strong>分布式系统</strong>）  </p><h2 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h2><p><strong>Git工作流</strong>：<strong>代码管理</strong>的<strong>工作流程、方式</strong>  </p><ul><li><strong>Git工作流</strong>简介</li><li><strong>集中式工作流</strong></li><li><strong>功能分支工作流</strong></li><li><strong>GitFlow工作流</strong></li><li><strong>Forking工作流</strong></li><li><strong>Pull Requests</strong></li></ul><h3 id="Git工作流简介"><a href="#Git工作流简介" class="headerlink" title="Git工作流简介"></a>Git工作流简介</h3><p>工作流有各式各样的用法，但也正因此使得在实际工作中如何上手使用增加了难度。  </p><p>这篇指南通过总览公司团队中最常用的集中Git工作流让大家可以上手使用；  </p><p>在阅读的过程中请记住，本文中的集中工作流是作为方案指导而不是条例规定，在展示了各种工作流可能的用法后，可以从不同的工作流中挑选或揉合出一个满足自己需求的工作流；  </p><h4 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXyIW2ezMoDhUXO*s5pTGue2N753CPNKcE42sPIP6l3d0rpu2DZjcGmC.Kga3cDUruqQwuWnPoetw.KevCfGSm5U!/r" alt="集中式工作流"></p><p>如果开发团队成员已经很熟<strong>Subversion</strong>，<strong>集中式工作流</strong>让你无需去适应一个全新流程就可以体验Git带来的收益。  </p><p>这个工作流也可以作为向更Git风格工作流迁移的友好过渡。  </p><p>（个人、三五个人的小团队）  </p><h4 id="功能分支工作流"><a href="#功能分支工作流" class="headerlink" title="功能分支工作流"></a>功能分支工作流</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX.QLkS1nyIjv6HHWnbV4dX7srariw7MEQpLi1gOAxL3ou18PqhQZr1mrBrEaIbVs5JuQWzjNbAd8lfxuJK8OGPM!/r" alt="功能分支工作流"></p><p><strong>功能分支工作流</strong>以<strong>集中式工作流</strong>为<strong>基础</strong>，不同的是为<strong>各个新功能</strong>分配<strong>一个专门的分支</strong>来开发。  </p><p>这样可以在把新功能继承到正式项目前，用<strong>Pull  Requests</strong>的方式<strong>讨论变更</strong>；  </p><p>（达到约12个人的团队）  </p><h4 id="Git-Flow工作流"><a href="#Git-Flow工作流" class="headerlink" title="Git Flow工作流"></a>Git Flow工作流</h4><p><strong>Git Flow工作流</strong>通过为<strong>功能开发</strong>、<strong>发布准备</strong>和<strong>维护分配独立的分支</strong>，让<strong>发布迭代</strong>过程<strong>更顺畅</strong>。  </p><p>严格的分支模型也为大型项目提供了一些非常必要的结构。  </p><p>（整个公司，这么一个团队的规模）  </p><h4 id="Forking工作流"><a href="#Forking工作流" class="headerlink" title="Forking工作流"></a>Forking工作流</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7NQkdqkFQWuuELLHKCcql5ABKaPDZFUejww*HH9qtsi8qr7IlATkqBkQ9PV1LJ9rT6faqWzcfgS3pJZnzLSzVg!/r" alt="Forking工作流"></p><p>Forking工作流是分布式工作流，充分利用了Git在分支和克隆上的优势。  </p><p>可以安全可靠地管理大团队的开发者（developer），并能接受不信任贡献者（contributor）的提交。  </p><p>（跨国合作。跨国团队的使用，一般用于Forking工作流）  </p><h4 id="Pull-Requests"><a href="#Pull-Requests" class="headerlink" title="Pull Requests"></a>Pull Requests</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXzYbgZ.02.6Smac50apszMyWGwg89uQEVJSVU01e69u2Dts1al5lueZ4HgBrr.WyV.0GtO*ZTdT3LpQtilbX2Vk!/r" alt="Pull Requests"></p><p><strong>功能分支工作流</strong>、<strong>GitFlow工作流</strong>、<strong>Forking工作流</strong>都会穿插一个<strong>Pull Requests</strong>的一个东西。  </p><p><strong>Pull Requests</strong>通常称为<strong>请求合并</strong>（<strong>Merge Pull Requests</strong>）；  </p><p><strong>Pull Requests</strong>让开发者更<strong>方便地进行协作</strong>的功能，提供了友好的Web界面可以在提议的修改合并到正式项目之前对修改进行讨论。  </p><p>（相当于一个评论系统）；</p><h3 id="集中式工作流-1"><a href="#集中式工作流-1" class="headerlink" title="集中式工作流"></a>集中式工作流</h3><p>转到<strong>分布式版本控制系统</strong>看起来像个令人生畏的任务，但不改变已用的工作流你也可以用上Git带来的收益。  </p><p>团队可以用和Subversion完全不变的方式来开发项目。  </p><p>但使用Git加强开发的工作流，<strong>Git比SVN有几个优势</strong>。  </p><p><strong>（1）</strong> 首先，每个开发者可以有属于自己的整个<strong>工程的本地拷贝</strong>。隔离的环境让各个开发者的工作和项目的其他部分（修改）独立开来——-即自由地提交到自己的本地仓库，先完全忽略上游的开发，直到方便的时候再把修改反馈上去。  </p><p><strong>（2）</strong> 其次，<strong>Git</strong>提供了<strong>强壮的分支和合并模型</strong>。不像SVN，Git的分支设计成可以作为一种用来在仓库之间集成代码和分享修改的 <strong>【失败安全】</strong> 的<strong>机制</strong>。  </p><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX58rubGqwbukXS4rvP.hcw8vVDFpcMEKyanOzFC60vYY7EfnKsFaNa8DYFcGkpbCkTOCu8b0QXObUxn8ABvZn4U!/r" alt="工作方式"></p><p>像<strong>Subversion</strong>一样，<strong>集中式工作流</strong>以<strong>中央仓库</strong>作为项目<strong>所有修改的单点实体</strong>。  </p><p>相比SVN缺省的开发分支trunk，Git叫做master，所有修改提交到这个分支上。  </p><p>该工作流只用到master这一个分支。  </p><p>开发者开始先克隆中央仓库。  </p><p>在自己的项目拷贝中，像SVN一样的编辑文件和提交修改；  </p><p>但修改是存在本地的，和中央仓库完全隔离的；  </p><p>开发者可以把和上游的同步延后到一个方便时间点；  </p><p>要发布修改到正式项目中，开发者要把本地master分支的修改【推（push）】到中央仓库中。  </p><p>这相当于svn  commit操作，但push操作会把所有还不在中央仓库的本地提交都推上去。  </p><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7NAq94egRJ5nBPO8Co87th*P0cTdtAGYXp43mklxBxvhd73.i5d8Lm58WdsFYNrarV7XZaiqfrmkd3gUFAFW0o!/r" alt="解决冲突"></p><p>中央仓库代表了正式项目，所以提交历史应该被尊重且是稳定不变的。  </p><p>如果开发者本地的提交历史和中央仓库有分歧，Git会拒绝push提交否则会覆盖已经在中央库的正式提交。  </p><p>在开发者提交自己功能修改到中央库前，需要先fetch在中央库的新增提交，rebase自己提交到中央库提交历史之上。  </p><p>这样做的意思是在说，【我要把自己的修改加到别人已经完成的修改上。】最终的结果是一个完美的线性历史，就像以前的SVN的工作流中一样；  </p><p>如果本地修改和上游提交有冲突，Git会暂停rebase过程，给你手动解决冲突的机会。  </p><p>Git解决合并冲突，用和生成提交一样的git  status和git add命令，很一致方便。  </p><p>还有一点，如果解决冲突时遇到麻烦，Git可以很简单中止整个rebase操作，重来一次（或者让别人来帮助解决）。  </p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>一起逐步分解来看看一个常见的小团队如何用这个工作流来协作的。  </p><p>有两个开发者小明和小红，看他们是如何开发自己的功能并提交到中央仓库上的。  </p><h5 id="有人先初始化好中央仓库"><a href="#有人先初始化好中央仓库" class="headerlink" title="有人先初始化好中央仓库"></a>有人先初始化好中央仓库</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX9UbT3uXKi44e*o.QOIDNJOk403REJAlPsZkIyST70GEweXbAbks3cFR7TqiVMFHAtTg9MXSvYT6HSyIH1eLii4!/r" alt="有人先初始化好中央仓库"></p><p>第一步，有人在服务器上创建好中央仓库。  </p><p>如果是新项目，可以初始化一个空仓库；否则要导入已有的Git或SVN仓库。  </p><p>中央仓库应该是个裸仓库（bare repository），即没有工作目录（working directory）的仓库。  </p><h5 id="所有人克隆中央仓库"><a href="#所有人克隆中央仓库" class="headerlink" title="所有人克隆中央仓库"></a>所有人克隆中央仓库</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX8lXRlkamDF*h*SxpL42PuUsH4aIULseTwL66K.p5pWkVzGz*Bh8Nih.I7qaVf43t7zoP8GGUp44vHNS*NRccIY!/r" alt="所有人克隆中央仓库"></p><p>下一步，各个开发者创建整个项目的本地拷贝。  </p><p>通过git clone命令完成。  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span>  <span class="title">https</span>://github.com/path/to/repo.git</span><br></pre></td></tr></table></figure><p>基于后续会持续和克隆的仓库做交互的假设，克隆仓库时Git会自动添加远程别名origin指回【父】仓库。  </p><p>github即git的中央仓库；版本控制系统有一个版本仓库。  </p><p>github上public即开源，公开的意思，代码开源。  </p><p>如果是私有private则需要进行CreditCard 信用卡支付相应的金额；收费；  </p><h5 id="小明开发功能"><a href="#小明开发功能" class="headerlink" title="小明开发功能"></a>小明开发功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX3cSXX6681Ge8WeUymk3FFjspNtDVB3t7XeHuVufMD05ZhJzX9OyWJDCYAlloD65QJLNRkDaLpYfFLKjESAA0SM!/r" alt="小明开发功能"></p><p>在小明的本地仓库中，他使用标准的Git过程开发功能：编辑、暂存（Stage）和提交。  </p><p>如果你不熟悉暂存区（Stageing Area），这里说明一下：暂存区的用来准备一个提交，但可以不用把工作目录中所有的修改内容都包含进来。  </p><p>这样可以创建一个高度聚焦的提交，尽管本地修改很多内容。  </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status <span class="comment"># 查看本地仓库的修改状态</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> <span class="comment"># 暂存文件</span></span></span><br><span class="line">git commit <span class="comment"># 提交文件</span></span><br></pre></td></tr></table></figure><p>请记住，因为这些命令生成的是本地提交，小明可以按自己需求反复操作多次，而不用担心中央仓库有了什么操作。  </p><p>对需要多个更简单更原子分块的大功能，这个做法是很有用的；  </p><h5 id="小红开发功能"><a href="#小红开发功能" class="headerlink" title="小红开发功能"></a>小红开发功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX3AhXN0w*Kh7FwIloQiq3PMOUwp*anqXsBqPo.yaxL1hWnR.kZm*XseG5RhBNtuoS8.PVSKuKSdHEw1x7MixOxA!/r" alt="小红开发功能"></p><p>与此同时，小红在自己的本地仓库中用相同的编辑、暂存和提交过程开发功能。  </p><p>和小明一样，她也不关心中央仓库有没有新提交；当然更不关心小明在他的本地仓库中的操作，因为所有本地仓库都是私有的。  </p><h5 id="小明发布功能"><a href="#小明发布功能" class="headerlink" title="小明发布功能"></a>小明发布功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX2DDMKOOXZiA6a0j82260kNXKGqba7MbMMt5OmvuzTfK3A*Lxszb8CTdFEjjZXvIDOZez3cKxhQHt2dZMB.G9S4!/r" alt="小明发布功能"></p><p>一旦小明完成了他的功能开发，会发布他的本地提交到中央仓库中，这样其他团队成员可以看到他的修改。  </p><p>他可以用下面的git push  命令：  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><p>注意，origin是小明克隆仓库时Git创建的远程中央仓库别名。  </p><p>master参数告诉Git推送的分支。  </p><p>由于中央仓库自从小明克隆以来还没有被更新过，所以push操作不会有冲突，成功完成。  </p><h5 id="小红试着发布功能"><a href="#小红试着发布功能" class="headerlink" title="小红试着发布功能"></a>小红试着发布功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX49Hssuuk2yHbmsbkSdUuOtLRbTxRlP3xEORKm5txDWaExKbZyYnyzyBD0oDqcjETeUWkabVFxZpo*3gs9yQWHs!/r" alt="小红试着发布功能"></p><p>一起来看看在小明发布修改后，小红push修改会怎么样？  </p><p>她使用完全一样的push命令：  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><p>但她的本地历史已经和中央仓库有分歧了，Git拒绝操作并给出下面很长的出错消息：  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error: failed <span class="keyword">to</span> push some refs <span class="keyword">to</span> <span class="string">'/path/to/repo.git'</span></span><br><span class="line">hin<span class="variable">t:</span> Updates were rejected because the tip of your current branch <span class="keyword">is</span> behind</span><br><span class="line">hin<span class="variable">t:</span> its remote counterpart. Merge the remote <span class="keyword">changes</span>(<span class="keyword">e</span>.g. <span class="string">'git pull'</span>)</span><br><span class="line">hin<span class="variable">t:</span> before pushing again.</span><br><span class="line">hin<span class="variable">t:</span> See the <span class="string">'Note about fast-forwards'</span> in <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>这避免了小红覆写正式的提交。  </p><p>她要先pull小明的更新到她本地仓库合并上她的本地修改后，再重试。  </p><h5 id="小红在小明的提交之上rebase"><a href="#小红在小明的提交之上rebase" class="headerlink" title="小红在小明的提交之上rebase"></a>小红在小明的提交之上rebase</h5><p>小红用git pull 合并上游的修改到自己的仓库中。  </p><p>这条命令类似svn update ——-拉取所有上游提交命令到小红的本地仓库，并尝试和她本地修改合并。  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">--rebase origin master</span></span><br></pre></td></tr></table></figure><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXyi6Y8l5sb1aRwQRlb0CiRDNdgM9NZtfk5D41PvfJEccriZP3FT6WnQ4PWKvEqz*e7LpBOfcXui.l9nUXAPUgd4!/r" alt="images"></p><p>–rebase 选项告诉Git把小红的提交移到同步了中央仓库修改后的master分支的顶部；  </p><p>如果忘了加这个选项，pull操作仍然可以完成，但每次pull操作要同步中央仓库别人修改时，提交历史会以一个多余的【合并提交】结尾。  </p><p>对于集中式工作流，最好是使用rebase而不是生成一个合并提交。  </p><h5 id="小红解决合并冲突"><a href="#小红解决合并冲突" class="headerlink" title="小红解决合并冲突"></a>小红解决合并冲突</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7FxPBYYYsKKPOWXqC*0rCPhZKJRqU86pJwCJIVi3g31ZcpHEH2b76upvPK6lrEAQ9UWa9VqeFjlEC4dX2PAHTw!/r" alt="小红解决合并冲突"></p><p>rebase操作过程是把本地提交一次一个地迁移到更新了的中央仓库master分支之上，这意味着可能要解决在迁移某个提交时出现的合并冲突，而不是解决包含了所有提交的大型合并时所出现的冲突。  </p><p>这样的方式让你尽可能保持每个提交的聚焦和项目历史的整洁。  </p><p>反过来，简化了哪里引入Bug的分析，如果有必要，回滚修改也可以做到对项目影响最小。  </p><p>如果小红和小明的功能是相关的，不大可能在rebase过程中有冲突。  </p><p>如果有，Git在合并有冲突的提交出暂停rebase过程，输出下面的信息并带上相关的指令：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONFLICT</span> (content): Merge <span class="keyword">conflict</span> <span class="keyword">in</span></span><br></pre></td></tr></table></figure><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX5fiCqpawh2bvFoyuusAOSGHKu5sc59EGgvKP1aVmHVmey3BEhEwMSvuvtOXh1oSZU1zNvf5QV2G*SN2a1sgwiA!/r" alt="images"></p><p>Git 很赞的一点是，任何人可以解决他自己的冲突。  </p><p>在这个例子中，小红可以简单的运行 git status 命令来查看哪里有问题。  </p><p>冲突文件列在 Unmerged paths（未合并路径）一节中：  </p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Unmerged paths：</span><br><span class="line"><span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">use</span> <span class="string">"git reset HEAD &lt;some-file&gt;..."</span> <span class="variable">to</span> <span class="variable">unstage</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">use</span> <span class="string">"git add/rm &lt;some-file&gt;..."</span> <span class="variable">as</span> <span class="variable">appropriate</span> <span class="variable">to</span> <span class="variable">mark</span> <span class="variable">resolution</span>)</span></span></span><br><span class="line">#</span><br><span class="line"># both modified:&lt;some-file&gt;</span><br></pre></td></tr></table></figure><p>接着小红编辑这些文件。  </p><p>修改完成后，用老套路暂存这些文件，并让git rebase 完成剩下的事情：  </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span></span><br><span class="line"><span class="bash">git rebase --<span class="built_in">continue</span></span></span><br></pre></td></tr></table></figure><p>要做的就这些了。  </p><p>Git会继续一个一个的合并后面的提交，如其他的提交有冲突就重复这个过程。  </p><p>如果你碰到了冲突，但是发现搞不定，不要惊慌。  </p><p>只要执行下面这条命令，就可以回到你执行git pull –rebase命令前的样子：  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase <span class="comment">--abort</span></span><br></pre></td></tr></table></figure><h5 id="小红成功发布功能"><a href="#小红成功发布功能" class="headerlink" title="小红成功发布功能"></a>小红成功发布功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX0kBnWeNL8ejRYU6ro4.2u6jfdf4WmDKrAtmoAnmJ9TQ4sDBTQl0i3xlqRsJMoYZns72c0lo3zm5ObKWH4CoUG0!/r" alt="小红成功发布功能"></p><p>小红完成和中央仓库的同步之后，就能成功发布她的修改了。  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>如你所见，仅仅使用几个Git命令，就可以模拟出传统Subversion开发环境。  </p><p>对于要从SVN迁移过来的团队来说这太好了，但是没有发挥出Git分布式本质的优势。  </p><p>如果你的团队适应了集中式工作流，但想要更流畅的协作效果，绝对值得探索一下功能分支工作流的收益。  </p><p>通过为一个功能分配一个专门的分支，能够做到一个新增功能集成到正式项目之前对新功能进行深入讨论。  </p><h3 id="功能分支工作流-1"><a href="#功能分支工作流-1" class="headerlink" title="功能分支工作流"></a>功能分支工作流</h3><p>一旦玩转了集中式工作流，在开发过程中可以很简单地加上功能分支，用来鼓励开发者之间协作和简化交流。  </p><p>功能分支工作流背后的核心思路是所有的功能开发应该在一个专门的分支，而不是在master分支上。  </p><p>这个隔离可以方便多个开发者在各自的功能上开发而不会弄乱主干代码。  </p><p>另外，也保证了master分支的代码一定不会是有问题的，极大有利于集成环境。  </p><p>功能开发隔离也让pull  requests工作流成为可能， pull requests工作流能为每一个分支发起一个讨论，在分支合入正式项目之前，给其它开发者有表示赞同的机会。  </p><p>另外，如果你在功能开发中有问题卡出了，可以开一个pull Requests来向同学们征求建议。  </p><p>这些做法的重点就是，pull Requests让团队成员之间互相评论工作变成非常方便！  </p><h4 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h4><p>功能分支工作流仍然用中央仓库，并且master分支还是代表了正式项目的历史。  </p><p>但不是直接提交本地历史到各自的本地master分支，开发者每次在开始新功能前先创建一个新分支。  </p><p>功能分支应该有个描述性的名字，比如 animated-menu-items 或者  issue-#1061，这样可以让分支有个清楚且高聚焦的用途。  </p><p>在master分支和功能分支之间，Git是没有技术上的区别，所以开发者可以用和集中式工作流完全一样的方式编辑、暂存和提交修改到功能分支上。  </p><p>另外，功能分支也可以（且应该）push到中央仓库中。  </p><p>这样不修改正是代码就可以和其他开发者分享提交的功能。  </p><p>由于master仅有的一个【特殊】分支，在中央仓库上存在多个功能分支不会有任何问题。  </p><p>当然这样做也可以很方便地备份各自的本地提交。  </p><h4 id="Pull-Requests-1"><a href="#Pull-Requests-1" class="headerlink" title="Pull Requests"></a>Pull Requests</h4><p>功能分支除了可以隔离功能的开发，也使得通过 Pull Requests讨论变更称为可能。  </p><p>一旦某个开发完成一个功能，不是立即合并到master，而是push到中央仓库的功能分支上并发起一个Pull Requests的请求去合并并修改到master。  </p><p>在修改成为主干代码之前，这让其他的开发者有机会先去Review变更。  </p><p>Code Review是Pull Requests的一个重要的收益。  </p><p>但是pull Requests目的是讨论代码一个通用方式。  </p><p>你可以把Pull  Requests作为专门给某个分支的讨论。  </p><p>这意味着可以在更早的开发过程中就可以进行Code Review。  </p><p>比如，一个开发者开发功能需要帮助时，要做的就是发起一个Pull Requests，相关的人就会自动收到通知，在相关的提交旁边能看到需要帮助解决的问题。  </p><p>一旦Pull  Requests被接受了，发布功能要做的就和集中式工作流就很像了。  </p><p>（1）首先，确定本地的master分支和上游的master分支是同步的。  </p><p>（2）然后合并功能分支到本地master分支，并push已经更新的本地master分支到中央仓库。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>下面的示例演示了如何把Pull Requests作为Code Review的方式，但注意Pull Requests可以用于很多其他的目的。  </p><h5 id="小红开始开发一个新功能"><a href="#小红开始开发一个新功能" class="headerlink" title="小红开始开发一个新功能"></a>小红开始开发一个新功能</h5><p>在开始开发功能之前，小红需要一个独立的分支。  </p><p>使用下面的命令新建一个分支。  </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> checkout -<span class="keyword">b </span><span class="keyword">marys-feature </span>master</span><br></pre></td></tr></table></figure><p>这个命令检出一个基于master名为marys-feature的分支，Git的-b选项表示如果分支还不存在则新建分支。  </p><p>这个新分支上，小红按照老套路编辑、暂存和提交修改，按需要提交以实现功能：  </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span>  <span class="string">status</span></span><br><span class="line"><span class="attr">git</span> <span class="string">add</span></span><br><span class="line"><span class="attr">git</span> <span class="string">commit</span></span><br></pre></td></tr></table></figure><h5 id="小红要去吃个午饭"><a href="#小红要去吃个午饭" class="headerlink" title="小红要去吃个午饭"></a>小红要去吃个午饭</h5><p>（两个人、多个人同时开发，称之为协同开发）  </p><p>仓库：github、码云、码市、gitlab  </p><p>review 代码审核；  </p><p>早上小红为新功能添加了一些提交。  </p><p>去吃午饭前，push功能分支到中央仓库是很好的做法，这样可以方便地备份，如果和其他开发协作，也让他们可以看到小红的提交。  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> -u <span class="built_in">origin</span> marys-<span class="built_in">feature</span></span><br></pre></td></tr></table></figure><p>这条命令  push marys-feature 分支到中央仓库（origin），-u选项设置本地分支去跟踪远程对应的分支。  </p><p>设置好跟踪的分支后，小红就可以使用git push 命令省去指定推送分支的参数。  </p><h5 id="小红完成功能开发"><a href="#小红完成功能开发" class="headerlink" title="小红完成功能开发"></a>小红完成功能开发</h5><p>小红吃完午饭回来，完成整个功能的开发。  </p><p>在合并到master之前，她发起一个Pull Requests让团队的其他人知道功能已经完成。  </p><p>但是首先，她要确认中央仓库中已经有她最近的提交。  </p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure><p>然后，在她的Git GUI客户端中发起Pull Request，请求合并marys-feature到master，团队成员会自动收到通知。  </p><p>Pull Request很酷的是可以在相关的提交旁边显示评注，所以你可以很对某个变更集提问。  </p><h5 id="小黑收到Pull-Request"><a href="#小黑收到Pull-Request" class="headerlink" title="小黑收到Pull  Request"></a>小黑收到Pull  Request</h5><p>小黑收到Pull Request后会查看marys-feature的修改。  </p><p>决定在合并到正式项目前是否要做些修改，且通过Pull Request和小红来回的讨论。  </p><h5 id="小红再做修改"><a href="#小红再做修改" class="headerlink" title="小红再做修改"></a>小红再做修改</h5><p>要在做修改，小红用和功能第一个迭代完全一样的过程。  </p><p>编辑、暂存、提交并push更新到中央仓库。  </p><p>小红这些活动都会显示在Pull Request上，小黑可以断续做评注。  </p><p>如果小黑有需要，也可以把marys-feature分支拉到本地，自己来修改，他加的提交也会一样显示在Pull Request上。  </p><h5 id="小红发布她的功能"><a href="#小红发布她的功能" class="headerlink" title="小红发布她的功能"></a>小红发布她的功能</h5><p>一旦小黑可以接受Pull Request，就可以合并功能到稳定项目代码中（可以由小黑或者是小红来做这个操作）：  </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">checkout master</span></span><br><span class="line"><span class="attr">git</span> <span class="string">pull</span></span><br><span class="line"><span class="attr">git</span> <span class="string">pull origin marys-feature</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push</span></span><br></pre></td></tr></table></figure><p>无论谁来做合并，首先要检出master分支并确认它是最新的。  </p><p>然后执行 git pull origin marys-feature 合并 marys-feature 分支到已经和远程一直的本地 master分支。  </p><p>你可以使用简单 git merge marys-feature命令，但是前面的命令可以保证总是最新的新功能分支。  </p><p>最后更新的master分支要重新push回到origin。  </p><p>这个过程常常会生成一个和并提交。  </p><p>有些开发者喜欢有合并提交。  </p><p>因为它像一个新功能和原来代码基线的连通符。  </p><p>但如果你偏爱线性的提交历史，可以在执行合并rebase新功能到master分支的顶部，这样生成一个快进（fast-forward）的合并。  </p><p>一些GUI客户端只要点一下【接受】按钮执行好上面的命令来自动化Pull Request接受过程。  </p><p>如果你的不能这样，至少在功能合并到master分子后自动关闭Pull Request。  </p><h5 id="与此同时，小明在做和小红一样的事情"><a href="#与此同时，小明在做和小红一样的事情" class="headerlink" title="与此同时，小明在做和小红一样的事情"></a>与此同时，小明在做和小红一样的事情</h5><p>当小红和小黑在marys-feature上工作并讨论她的Pull  Request的时候，小明在自己的功能分支上做完全一样的事情。  </p><p>通过隔离功能能到独立的分支上，每个人都可以自主的工作，当然必要的时候在开发者之间分享变更还是比较繁琐的。  </p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>到了这里，但愿你发现了功能分支可以很直接地在集中式工作流的仅有的master分支上完成多功能的开发。  </p><p>另外，功能分支还使用了Pull Request，使得可以在你的版本控制GUI客户端中讨论某个提交。  </p><p>功能分支工作流是开发项目异常灵活的方式。  </p><p>问题是，有时候太灵活了。  </p><p>对于大型团队，常常需要给不同分支分配一个更具体的角色。  </p><p>GitFlow工作流是管理功能开发、发布准备和维护的常用模式。  </p><h3 id="GitFlow工作流"><a href="#GitFlow工作流" class="headerlink" title="GitFlow工作流"></a>GitFlow工作流</h3><p>在实际开发当中，可能通常使用GitFlow工作流。  </p><p>GitFlow工作流定义了一个围绕项目发布的严格分支模型。  </p><p>虽然比功能分支工作流复杂几分，但是提供了一个用于健壮的用于管理大型项目的框架。  </p><p>GitFlow工作流没有用超出功能分支工作流的概念和命令。  </p><p>而是为不同的分支分配了一个很明确的角色，并定义分支之间如何交互和什么时候进行交互。  </p><p>除了使用功能分支，在做准备、维护和记录发布也是用各自的分支。  </p><p>当然你可以用上功能分支工作流所有的好处：Pull Request、隔离实验性开发和更高效的工作。  </p><h4 id="工作方式-2"><a href="#工作方式-2" class="headerlink" title="工作方式"></a>工作方式</h4><p>GitFlow工作流仍然用中央仓库作为所有开发者的交互中心。  </p><p>和其他工作流一样，开发者在本地工作并push分子到中央分支去。  </p><h5 id="历史分支"><a href="#历史分支" class="headerlink" title="历史分支"></a>历史分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX0DucqArpSZN8V1mN.Djx7WchltIFUxePFkxo0wF6tL9hJ92GPpyK1meBHYC6jQnh92Uk6*6zENCWbjq21uqLsI!/r" alt="历史分支"></p><p>相对使用仅有的一个master分支，GitFlow工作流使用两个分支来记录项目的历史。  </p><p>master分支存储了正式发布的历史，而develop分支作为功能的集成分支，这样也方便master分支上的所有提交分配一个版本号。  </p><p>剩下要说明的问题就是围绕这两个分支的区别展开。  </p><h5 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX4suzD8O2OoWbYPwQ150IFWgQS3qSKoLWdglLxIjfri4eWAHC*W6m9OYJM0vFH4CxIhXiOdTBQYoWLsUJ3d8M.k!/r" alt="功能分支"></p><p>每个新功能位于一个自己的分支，这样可以push到中央仓库以备份和协作。  </p><p>但是功能分支不是从master分支上拉出新分支，而是使用develop分支作为父分支。  </p><p>当新功能完成时，合并会develop分支。  </p><p>新功能提交应该从不直接与master分支交互。  </p><p>开源软件基本上是使用GitFlow来做代码版本管理的控制。  </p><p>注意，从各种含义和目的上来看，功能分支加上develop分支就是功能分支工作流的用法。  </p><p>但是GitFlow工作流没有在这里止步。  </p><h5 id="发布分支"><a href="#发布分支" class="headerlink" title="发布分支"></a>发布分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX1K5y5ivKrS*rhk3l.NtQVVaNHmKMdlqKelqYaRENh70*1X*IrEmFCJIhfs5U7wXELfZbYI1tihPDOGBwBPqt6E!/r" alt="发布分支"></p><p>一旦develop分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从develop分支上fork一个发布分支。  </p><p>新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上——-这个分支只应该叫Bug修复、文档生成或其他面向发布任务。  </p><p>一旦对外发布的工作都完成了，发布分支合并到master分支并飞配一个版本号打好Tag。  </p><p>另外，这些新建发部分之以来做的修改要合并回develop分支。  </p><p>使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。  </p><p>这也打造定义良好的开发阶段（比如，可以很轻松的说，【这周我们要做准备发布版本4.0】，并且在仓库的目录结构中可以实际看到）  </p><p>常用的分支约定：  </p><ul><li>用于新建发布分支的分支：develop</li><li>用于合并的分支：master</li><li>分支命名：release- 或 release/</li></ul><h5 id="维护分支"><a href="#维护分支" class="headerlink" title="维护分支"></a>维护分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX8qfvx9q8UhYcwpU4tSoxZoCzp2TGnchoEgJnBAd**ejGrSWx7H1n1RbZFVAdVlD7v3kEO6EHjpPFNMCD9pabTQ!/r" alt="维护分支"></p><p>维护分支或者说是热修复（hotfix）分支用于生成快速给产品发布版本（production release）打补丁，这是唯一可以从master分支fork出来的分支。  </p><p>修复完成，修改应该马上合并回master分支和develop分支（当前的发部分支），master分支应该用新的版本号打好Tag。  </p><p>为了Bug修复使用专门分支，让团队可以处理问题而不用打断其他工作或者是等待下一个发布循环。  </p><p>你可以把维护分支想成是一个直接在master分支上处理的临时发布。  </p><p>即hotfix，维护的是v1.0.0—&gt;v1.0.1这种；<br>第三位数修改的是Bug（hotfix维护版本第三位数）；第二位数修改的是功能（功能分支维护的是版本的第二位数）；第一位为大架构改变的时候进行修改（维护版本的第一位数）；  </p><p>GitFlow从这点上就可以与语义化规范牵扯上联系；  </p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>下面的示例演示本工作流如何用于管理单个发布循环。  </p><p>假设你已经创建了一个中央仓库。  </p><h5 id="创建开发分支"><a href="#创建开发分支" class="headerlink" title="创建开发分支"></a>创建开发分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX4Xsg92Awirp0bThQ4n*YW8UWB.U5*XFBFsn5hkNOcst0hBz.q1uwuu*KDADM.W9naZBQq8eKQyo4iLkzk28e1g!/r" alt="创建开发分支"></p><p>第一步为master分支配套一个develop分支。  </p><p>简单来做可以本地创建一个空的develop分支，push到服务器上：  </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>develop</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>-u origin master</span><br></pre></td></tr></table></figure><p>以后这个分支将会包含了项目的全部历史。  </p><p>而master分支将只包含部分历史。  </p><p>其他开发者这时应该克隆中央仓库，建好develop分支的跟踪分支：  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">ssh</span>://user@host/path/to/repo.git</span><br><span class="line">git checkout -b develop origin/develop</span><br></pre></td></tr></table></figure><p>现在每个开发都有了这些历史分支的本地拷贝。  </p><h5 id="小红和小明开始开发新功能"><a href="#小红和小明开始开发新功能" class="headerlink" title="小红和小明开始开发新功能"></a>小红和小明开始开发新功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX2X16EiSaoizI9a2HRgo6HRlddb*dD0yGRzorFtrKInoqDMveDkX4.ujU1ZgrgxXoZf1vY83YLzd6Dl2YO5SDUc!/r" alt="小红和小明开始开发新功能"></p><p>这个示例中，小红和小明开始各自的功能开发。  </p><p>他们需要为各自的功能创建相应的分支。  </p><p>新分支不是基于master分支，而是应该基于develop分支：  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="built_in">some</span>-<span class="built_in">feature</span> develop</span><br></pre></td></tr></table></figure><p>他们用老套路添加提交到各自功能分支上：编辑、暂存、提交；  </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">status</span></span><br><span class="line"><span class="attr">git</span> <span class="string">add</span></span><br><span class="line"><span class="attr">git</span> <span class="string">commit</span></span><br></pre></td></tr></table></figure><h5 id="小红完成功能开发-1"><a href="#小红完成功能开发-1" class="headerlink" title="小红完成功能开发"></a>小红完成功能开发</h5><p>添加了提交后，小红觉得她的功能OK了。  </p><p>如果团队使用Pull Requests，这时候可以发起一个用于合并到develop分支。  </p><p>否则她可以直接合并到她本地的develop分之后push到中央仓库：  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="built_in">origin</span> develop</span><br><span class="line">git checkout develop</span><br><span class="line">git merge <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line">git <span class="built_in">push</span></span><br><span class="line">git branch -d <span class="built_in">some</span>-<span class="built_in">feature</span></span><br></pre></td></tr></table></figure><p>第一条命令在合并功能前确保develop分支是最新的。  </p><p>注意，功能绝不应该直接合并到master分支。  </p><p>冲突解决方法和集中式工作流一样。  </p><h5 id="小红开始准备发布"><a href="#小红开始准备发布" class="headerlink" title="小红开始准备发布"></a>小红开始准备发布</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXxm6aYd1gMGOxylETc6cDcj7kTwBnGuyoyzYDL7pNxxvtXeo*D5bCxnVfWE*k.cQe8O4lhgkHo2zR.IIDII1kmA!/r" alt="小红开始准备发布"></p><p>这个时候小明正在实现他的功能。  </p><p>小红开始准备她的第一个项目正式发布（发布分支也叫预发布分支，预发布分支基于develop，只有预发布版本分支才能够去合并到master分支，而预发布版本是经过测试人员测试之后的没有问题的一个版本；master分支代码必须可以执行，没有被污染）。  </p><p>像功能开发一样，她用一个新的分支来做发布准备。  </p><p>这一步也确定了发布的版本号：  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b release<span class="number">-0.1</span> develop</span><br></pre></td></tr></table></figure><p>这个分支是清理分支、执行所有测试、更新文档和其他为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。  </p><p>只要小红创建的这个分支push到中央仓库，这个发布就是功能冻结的。  </p><p>任何不在develop分支中的新功能都推到下一个发布循环中。  </p><h5 id="小红完成发布"><a href="#小红完成发布" class="headerlink" title="小红完成发布"></a>小红完成发布</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXx2fdZ*.CxsTwPMg235DDXkchbPbk7hNVec6.FIcmcf72k0vjzhdQvVlYt8u8ao*65n3gyQAyN5GOxndJKhwiNk!/r" alt="小红完成发布"></p><p>一旦准备好了对外发布，小红合并修改到master分支和develop分支上，删除发布分支。  </p><p>合并回develop分支很重要，因为在发布分支中已经提交的更新需要在后面的新功能中也要是可用的。  </p><p>另外，如果小红的团队要求Code  Review，这是一个发起Pull Request的理想时机。  </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">checkout master</span></span><br><span class="line"><span class="attr">git</span> <span class="string">merge release-0.1</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push</span></span><br><span class="line"><span class="attr">git</span> <span class="string">checkout develop</span></span><br><span class="line"><span class="attr">git</span> <span class="string">merge release-0.1</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push</span></span><br><span class="line"><span class="attr">git</span> <span class="string">branch -d release-0.1</span></span><br></pre></td></tr></table></figure><p>发布分支是作为功能开发（develop分支）和对外发布（master分支）间的缓冲。  </p><p>只要有合并到master分支，就应该打好Tag以方便跟踪。  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-a</span> <span class="number">0.1</span> -m <span class="string">"Initial public release"</span> <span class="literal">master</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p>Git有提供各种钩子（hook），即仓库有时间发生时触发执行的脚本。  </p><p>可以配置一个钩子，在你push中央仓库的master分支时，自动构建好对外发布。  </p><h5 id="最终用户发现Bug"><a href="#最终用户发现Bug" class="headerlink" title="最终用户发现Bug"></a>最终用户发现Bug</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXzsQH1hJotlrx1khR6EZ0dUlyxkaf9L1Yi66Fs6sohYE0UTifJNygNHa*okiIgZc5dg2qSXBW*VyQGtiyMr0yo8!/r" alt="最终用户发现Bug"></p><p>对外发布后，小红回去和小明一起做下个发布的新功能开发，直到有最终用户开了一个Ticket抱怨当前版本的一个Bug。  </p><p>为了处理Bug，小红（或者小明）从master分支上来去了一个维护分支（hotfix），提交修改以解决问题，然后直接合并回master分支：  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b issue-<span class="comment">#001 master</span></span><br><span class="line"><span class="comment"># Fix the bug</span></span><br><span class="line">git checkout <span class="literal">master</span></span><br><span class="line">git merge issue-<span class="comment">#001</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>就像发布分支，维护分支中新加这些重要修改需要包含到develop分支中，所以小红要执行一个合并操作，然后就可以安全地删除这个分支了：  </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">checkout develop</span></span><br><span class="line"><span class="attr">git</span> <span class="string">merge issue-#001</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push</span></span><br><span class="line"><span class="attr">git</span> <span class="string">branch -d issue-#001</span></span><br></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>到了这里，但愿你对集中式工作流、功能分支工作流和GitFlow工作流已经感觉很舒适了。  </p><p>你应该也牢固的掌握了本地仓库的潜能，push/pull模式和Git健壮的分支和合并模型。  </p><p>记住，这里演示的工作流只是可能用法的例子，而不是在实际工作中使用Git不可违逆的条例。  </p><p>所以不要畏惧按自己需要对工作流的用法做取舍，不变的目标就是让Git为你所用。  </p><p>（在整个GitFlow工作流当中，只会去进行省略功能分支Feature，Master、HotFix、Release、Develop是必不可少的分支，以便控制每一次版本的迭代）  </p><h3 id="Forking工作流-1"><a href="#Forking工作流-1" class="headerlink" title="Forking工作流"></a>Forking工作流</h3><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX2qjPC0eDN.Xf29HcBYoAsTtpBFvJhu8qPVkh5cv575QWLsHx3q8JbFYK3X5cts.Zn43gkCjc7OzyBcDFaNdl.g!/r" alt="Forking工作流"></p><p>Forking工作流和前面讨论的几种工作流有根本的不同。  </p><p>这种工作流不是适用单个服务器端仓库作为【中央】代码基线，而让各个开发者都有一个服务端仓库。  </p><p>这意味着各个代码贡献者有2个Git仓库而不是1个：一个本地私有的，另一个服务端公开的。  </p><p>Forking工作流的一个主要优势是，贡献的代码可以被集成，而不需要所有人都能push代码到仅有的中央仓库中。  </p><p>开发者push到自己的服务端仓库，而只有项目维护者才能push到正式仓库。  </p><p>这样项目维护者可以接受任何开发者的提交，但无需给他正式代码库的写权限。  </p><p>效果就是一个分布式的工作流，能为大型、自发性的团队（包括了不受信的第三方）提供灵活的方式来安全的写作。  </p><p>也让这个工作流称为开源项目的理想工作流。  </p><h4 id="工作方式-3"><a href="#工作方式-3" class="headerlink" title="工作方式"></a>工作方式</h4><p>和其他的Git工作流一样，Forking工作流要先有一个公开的正式仓库存储在服务器上，但一个新的开发者想要在项目上工作时，不是直接从正式仓库克隆，而是fork正式项目在服务器上创建一个拷贝。  </p><p>这个仓库拷贝作为他人公开仓库—–其他开发者不允许push到这个仓库，但可以pull到修改（后面很快就会看到这点很重要）。  </p><p>在创建了自己服务端拷贝之后，和之前的工作流一样，开发者执行git clone命令克隆仓库到本地机器上，作为私有的开发环境。  </p><p>要提交本地修改时，push提交到自己公开仓库中——-而不是正式仓库中。  </p><p>然后，给正式仓库发起一个pull request，让项目维护者知道有更新已经准备好可以集成了。  </p><p>对于贡献的代码，pull request也可以很方便地作为一个讨论的地方。  </p><p>为了集成功能到正式代码库，维护者pull贡献者的变更到自己的本地仓库中，检查变更以确保不会让项目出错，合并变更到自己本地的master分支，然后push master分支到服务器的正式仓库中。  </p><p>到此，贡献的提交成为了项目的一部分，其他的开发者应该执行pull操作与正式仓库同步自己本地仓库。  </p><h5 id="正式仓库"><a href="#正式仓库" class="headerlink" title="正式仓库"></a>正式仓库</h5><p>在Forking工作流中，【官方】仓库的叫法只是一个约定，理解这点很重要。  </p><p>从技术上来看，各个开发者仓库和正式仓库在Git卡那里没有任何区别。  </p><p>事实上，让正式仓库之所以正式的唯一原因是他是项目维护者的公开仓库。  </p><h5 id="Forking工作流的分支使用方式"><a href="#Forking工作流的分支使用方式" class="headerlink" title="Forking工作流的分支使用方式"></a>Forking工作流的分支使用方式</h5><p>所有的个人公开仓库实际商只是为了方便和其他的开发者共享分支。  </p><p>各个开发者应该用分支隔离各个功能，就像功能分支工作流和GitFlow工作流一样。  </p><p>唯一的区别是这些分支被共享了。  </p><p>在Forking工作流中这些分支会被pull到另一个开发者的本地仓库中，而在功能分支工作流和GitFlow工作流中是直接被push到正式仓库当中。  </p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><h5 id="项目维护者初始化正式仓库"><a href="#项目维护者初始化正式仓库" class="headerlink" title="项目维护者初始化正式仓库"></a>项目维护者初始化正式仓库</h5><p>和任何使用Git项目一样，第一步还是创建在服务器上一个正式仓库，让所有团队成员都可以访问到。  </p><p>通常这个仓库也会作为项目维护者的公开仓库。  </p><p>公开仓库应该是裸仓库，不管是不是正式代码库。  </p><p>所以项目维护者会运行像下面的命令来搭建正式仓库：  </p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh user<span class="symbol">@host</span></span><br><span class="line">git init --bare /path/<span class="keyword">to</span>/repo.git</span><br></pre></td></tr></table></figure><p>Bitbucket和Stash提供了一个方便的GUI客户端已完成上面命令行做的事。  </p><p>这个搭建中央仓库的过程和前面提到的工作流完全一样。  </p><p>如果有现存的代码库，维护者也要push到这个仓库中。  </p><h5 id="开发者fork正式仓库"><a href="#开发者fork正式仓库" class="headerlink" title="开发者fork正式仓库"></a>开发者fork正式仓库</h5><p>其他所有的开发需要fork正式仓库。  </p><p>可以用git clone命令用SSH协议连通到服务器，拷贝仓库到服务器另一个位置—–是的，fork操作基本上就只是一个服务端的克隆。  </p><p>Bitbucket和Stash上可以点一下按钮就让开发者完成仓库的fork操作。  </p><p>这一步完成后，每个开发都在服务端有一个自己的仓库。  </p><p>和正式仓库一样，这些仓库应该是裸仓库。  </p><h5 id="开发者克隆自己fork出来的仓库"><a href="#开发者克隆自己fork出来的仓库" class="headerlink" title="开发者克隆自己fork出来的仓库"></a>开发者克隆自己fork出来的仓库</h5><p>下一步，各个开发者要克隆自己的公开仓库，用熟悉的git clone命令。  </p><p>在这个示例中，假定用Bitbucket托管了仓库。  </p><p>记住，如果这样的话各个开发者需要有各自的Bitbucket账号，使用下面命令克隆服务端自己的仓库。  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://user@bitbucket.org/user/repo.git</span><br></pre></td></tr></table></figure><p>相比前面介绍的工作流只用了一个origin远程别名指向中央仓库，Forking工作流需要2个远程别名——-一个指向正式仓库，另一个指向开发者自己的服务端仓库。  </p><p>别名的名字可以任意命名，常见的约定是使用origin作为远程克隆的仓库的别名（这个别名会在运行git clone自动创建），upstream（上游）作为正式仓库的别名。  </p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span> upstream https://bitbucket<span class="meta">.org</span>/maintainer/repo</span><br></pre></td></tr></table></figure><p>需要自己用上面的命令创建upstream别名。  </p><p>这样可以简单地保持本地仓库和正式仓库的同步更新。  </p><p>注意，如果上游仓库需要认证（比如不是开源的），你需要提供用户：  </p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span> upstream https://user@bitbucket<span class="meta">.org</span>/maintainer/repo</span><br></pre></td></tr></table></figure><p>这时在克隆和pull正式仓库时，需要提供用户的密码。  </p><h5 id="开发者开发自己的功能"><a href="#开发者开发自己的功能" class="headerlink" title="开发者开发自己的功能"></a>开发者开发自己的功能</h5><p>在刚克隆的本地仓库中，开发者可以向其他工作流一样的编辑代码、提交修改和新建分支：  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line">// Edit <span class="built_in">some</span> code</span><br><span class="line">git commit -a -m <span class="string">"Add first draft of some feature"</span></span><br></pre></td></tr></table></figure><p>所有的修改都是私有的直到push到自己公开仓库中。  </p><p>如果正式项目已经向前走了，可以用git pull命令获得新的提交：  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull upstream <span class="literal">master</span></span><br></pre></td></tr></table></figure><p>由于开发者应该都在专门的功能分支上工作，pull操作结果会都是快进合并。  </p><h5 id="开发者发布自己的功能"><a href="#开发者发布自己的功能" class="headerlink" title="开发者发布自己的功能"></a>开发者发布自己的功能</h5><p>一旦开发者准备好了分享新功能，需要做两件事。  </p><p>（1）首先，通过push他的贡献代码到自己的公开仓库中，让其他的开发者都可以访问到。他的origin远程别名应该已经有了，所有要做的就是：  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span>  <span class="built_in">feature</span>-branch</span><br></pre></td></tr></table></figure><p>这里和之前的工作流的差异是，origin远程别名指向开发者自己的服务端仓库，而不是正式仓库。  </p><p>（2）第二件事，开发者要通知项目维护者，想要合并他的新功能到正式库中。Bitbucket和Stash提供了Pull Request按钮，弹出个表单让你指定哪个分支要合并到正式仓库。一般你会想集成你的功能分支到上游远程仓库的master分支中。  </p><h5 id="项目维护者集成开发者的功能"><a href="#项目维护者集成开发者的功能" class="headerlink" title="项目维护者集成开发者的功能"></a>项目维护者集成开发者的功能</h5><p>当项目维护者收到pull request时，他要做的是决定是否集成它到正式代码库中。  </p><p>有两种方式来做：  </p><ul><li>直接在pull request中查看代码</li><li>pull代码到他自己的本地仓库，再手动合并</li></ul><p>第一种做法更简单，维护者可以在GUI中查看变更的差异，做评注和执行合并。  </p><p>但如果出现了合并冲突，需要第二种做法来解决。  </p><p>这种情况下，维护者需要从开发者的服务端仓库中fetch功能分支，合并到他本地的master分支，解决冲突：  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch https:<span class="regexp">//</span>bitbucket.org<span class="regexp">/user/</span>repo feature-branch</span><br><span class="line"><span class="regexp">//</span>查看变更</span><br><span class="line">git checkout master</span><br><span class="line">git merge FETCH_HEAD</span><br></pre></td></tr></table></figure><p>变更集成到本地的master分支后，维护者要push变更到服务器上的正式仓库，这样其他的开发者都能访问到：  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><p>注意，维护者的origin是指向他自己公开仓库的，即是项目的正式代码库。  </p><p>到此，开发者的贡献完全集成到了项目中。  </p><h5 id="开发者和正式仓库做同步"><a href="#开发者和正式仓库做同步" class="headerlink" title="开发者和正式仓库做同步"></a>开发者和正式仓库做同步</h5><p>由于正式代码库往前走了，其他的开发需要和正式仓库做同步：  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull upstream <span class="literal">master</span></span><br></pre></td></tr></table></figure><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>如果你之前是使用SVN，Forking工作流可能看起来像是一个激进的范式切换（paradigm shift）。  </p><p>但是不要害怕，这个工作流实际上就是在功能分支工作流之上引入了另一个抽象层。  </p><p>不是直接通过单个中央仓库来分享分支，而是把贡献代码发布到开发者自己的服务端仓库中。  </p><p>示例中解释了，一个贡献如何从一个开发者流到正式的master分支中，但是同样的方法可以把贡献集中到任意一个仓库中。  </p><p>比如，如果团队的几个人协作实现一个功能，可以在开发之间用相同的方法分享变更，完全不涉及正式仓库。  </p><p>这使得Forking工作流对于松散组织的团队来说是个非常强大的工具。  </p><p>任一开发者可以方便地和另一开发者分享变更，任何分支都能有效地合并到正式代码库中。  </p><h3 id="Pull-Requests-2"><a href="#Pull-Requests-2" class="headerlink" title="Pull Requests"></a>Pull Requests</h3><p>Pull Requests 是Bitbucket上方便开发者之间协作的功能。  </p><p>提供了一个用户友好的Web界面，在集成提交的变更到正式向目前可以对变更进行讨论。  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX1zLLMp65VmnavK5XDJUKS6zYUJDvvIJN*Lt1FNUoIJG0DkTCKRNuOGToGtjWmjIrVLu*fSpHVogAtzO4DgCm80!/r" alt="images"></p><p>开发者向团队成员通知功能开发已经完成，pull Requests是最简单的用法。  </p><p>开发者完成功能开发后，通过Bitbucket账号发起一个pull Request。这样让涉及这个功能的所有人知道，要去做Code Review和合并到master分支。  </p><p>但是，Pull  Request远不止一个简单的通知，而是为讨论提交的功能的一个专门论坛。  </p><p>如果变更有任何问题，团队成员反馈在Pull Request中，甚至pull新的提交微调功能。  </p><p>所有的这些活动都直接跟踪在Pull Request中。  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7SLIJSUYxrmcZpwuXYsQB1Ya2zpcBawWJ7atpdZcoSsGWSrxt3XnkjpSfeaAffmHrs3SyEpgZCaBKHAdN3ReSA!/r" alt="images"></p><p>相比其他的协作模型，这种分享提交的形式有助于打造一个更流畅的工作流。  </p><p>SVN和Git都能通过一个简单的脚本收到通知邮件；  </p><p>但是，讨论变更时，开发者通常只能去回复邮件。  </p><p>这样做会变得杂乱，尤其还要涉及后面的几个提交时。  </p><p>Pull Requests吧所有相关功能整合到一个和Bitbucket仓库界面集成的用户友好Web界面中。  </p><h4 id="解析Pull-Request"><a href="#解析Pull-Request" class="headerlink" title="解析Pull Request"></a>解析Pull Request</h4><p>当腰发起一个pull Request，你所要做的就是请求（Request）另一个开发者（比如项目的维护者），来pull你仓库中一个分支到他的仓库中。  </p><p>这意味着你要提供4个信息（源仓库、源分支、目的仓库、目的分支），以发起Pull Request。  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7SLIJSUYxrmcZpwuXYsQB1Ya2zpcBawWJ7atpdZcoSsGWSrxt3XnkjpSfeaAffmHrs3SyEpgZCaBKHAdN3ReSA!/r" alt="images"></p><h4 id="工作方式-4"><a href="#工作方式-4" class="headerlink" title="工作方式"></a>工作方式</h4><p>Pull Request可以和功能分支工作流、GitFlow工作流或Forking工作流一起使用。  </p><p>但Pull Request要求要么分支不同，要么仓库不同，所以不能用于集中式工作流。  </p><p>在不同的工作流中使用pull  Request会有一些不同，但基本的过程是这样的：  </p><ul><li>开发者在本地仓库新建一个专门的分支开发功能；</li><li>开发者push分支修改到公开的Bitbucket仓库中；</li><li>开发者通过Bitbucket发起一个Pull Request；</li><li>团队的其他成员review code，讨论并修改；</li><li>项目维护者合并功能到官方仓库中并关闭Pull Request；</li></ul><h4 id="在功能分支工作流中使用Pull-Request"><a href="#在功能分支工作流中使用Pull-Request" class="headerlink" title="在功能分支工作流中使用Pull Request"></a>在功能分支工作流中使用Pull Request</h4><p>功能分支工作流用一个共享的Bitbucket仓库来管理协作，开发者在专门的分支上开发功能。  </p><p>但不是立即合并到master分支上，而是在合并到主代码之前开发这应该开一个Pull Request发起功能的讨论。  </p><p>功能分支工作流只有一个公开的仓库，所以Pull Request的目的仓库和源仓库总是同一个。  </p><p>通常开发者会指定他的功能分支作为源分支，master分支作为目的分支。  </p><p>收到Pull Request后，项目维护者要决定如何做。  </p><p>如果功能没问题，就简单地合并到master分支，关闭Pull Request。  </p><p>但如果提交的变更有问题，他可以在Pull Request中反馈，之后的新加的评论也会评论之后接着显示出来。  </p><p>在功能还没有完全开发完的时候，也可能发起一个pull Request。  </p><p>比如开发者在实现某个需求时遇到了麻烦。  </p><p>他可以发一个包含正在进行工作的Pull Request。  </p><p>其他的开发者可以在Pull Request提供建议，或者甚至直接添加提交来解决问题。  </p><h4 id="在GitFlow工作流中使用Pull-Request"><a href="#在GitFlow工作流中使用Pull-Request" class="headerlink" title="在GitFlow工作流中使用Pull Request"></a>在GitFlow工作流中使用Pull Request</h4><p>GitFlow工作流和功能分支工作流类似，单围绕项目发布定义一个严格的分支模型。  </p><p>在GitFlow工作流中使用Pull Request让开发者在发布分支或者是维护分支上工作时，可以有个方便的地方对关于发布分支或者是维护分支的问题进行交流。  </p><p>GitFlow工作流中Pull Request的使用过程和上一节中完全一致：当一个功能、发布或者是热修复分支需要Review时，开发者简单发起一个Pull Request，团队的其他成员会通过Bitbucket收到通知。  </p><p>新功能一般合并到develop分支，而发布和热修复则要同时合并到develop分支和master分支上。  </p><p>Pull Request可能用作所有合并的正式管理。  </p><h4 id="在Forking工作流中使用Pull-Request"><a href="#在Forking工作流中使用Pull-Request" class="headerlink" title="在Forking工作流中使用Pull Request"></a>在Forking工作流中使用Pull Request</h4><p>在Forking工作流中，开发者push完成的功能到他自己的仓库中，而不是共享仓库。  </p><p>然后，他发一个Pull  Request，让项目维护者知道他的功能已经可以Review了。  </p><p>在这个工作流，Pull Request的通知功能非常有用，因为项目维护者不可能知道其他开发者在他们自己的仓库添加了提交。  </p><p>由于各个开发者有自己的公开仓库，Pull Request的源仓库和目标仓库不是同一个。  </p><p>源仓库是开发者的公开仓库，源分支是包含了修改的分支。  </p><p>如果开发者要合并修改到正式代码库中，那么目标仓库是正式仓库，目标分支是master分支。  </p><p>Pull Request也可以用于正式项目之外的其他开发者之间的协作。  </p><p>比如，如果一个开发者和一个团队成员一起开发一个功能，他们可以发起一个Pull Request，用团队成员的Bitbucket仓库作为目标，而不是正式项目的仓库。  </p><p>然后使用相同的功能分支作为源和目标分支。  </p><p>2个开发者之间可以在Pull Request中讨论和开发功能。  </p><p>完成开发后，他们可以发起另一个Pull  Request，请求合并功能到正式的master分支。  </p><p>在Forking工作流中，这样的灵活性称为一个强有力的协作工具。  </p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>下面的示例演示了Pull Request如何在Forking工作流中使用。  </p><p>也同样适用于小团队的开发协作和第三方开发者向开源项目的贡献。  </p><p>在示例中，小红是个开发，小明是项目维护者。  </p><p>他们各自有一个公开的Bitbucket仓库，而小明的仓库包含了正式工程。  </p><h5 id="小红fork正式项目"><a href="#小红fork正式项目" class="headerlink" title="小红fork正式项目"></a>小红fork正式项目</h5><p>小红先要fork小明的Bitbucket仓库，开始项目的开发。  </p><p>她登录Bitbucket，浏览到小明的仓库页面，点fork按钮。  </p><p>然后为fork出来的仓库填写名字和描述，这样小红就有了服务端的项目拷贝了。  </p><h5 id="小红克隆她的Bitbucket仓库"><a href="#小红克隆她的Bitbucket仓库" class="headerlink" title="小红克隆她的Bitbucket仓库"></a>小红克隆她的Bitbucket仓库</h5><p>下一步，小红克隆自己刚才fork出来的Bitbucket仓库，以在本机上准备出工作拷贝。  </p><p>命令如下：  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://user@bitbucket.org/user/repo.git</span><br></pre></td></tr></table></figure><p>请记住，git clone 会自动创建origin远程别名，是指向小红fork出来的仓库。  </p><h5 id="小红开发新功能"><a href="#小红开发新功能" class="headerlink" title="小红开发新功能"></a>小红开发新功能</h5><p>在开始改代码前，小红要为新功能新建一个新分支。  </p><p>她会用这个分支作为Pull Request的源分支。  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="built_in">some</span>-<span class="built_in">feature</span></span><br></pre></td></tr></table></figure><h5 id="编辑代码"><a href="#编辑代码" class="headerlink" title="编辑代码"></a>编辑代码</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -<span class="keyword">a</span> -m <span class="string">"Add first draft of some feature"</span></span><br></pre></td></tr></table></figure><p>在新功能分支上，小红按照需要添加提交。  </p><p>甚至如果小红觉得功能分支上的提交历史太乱了，她可以用交互式rebase来删除或者压制提交。  </p><p>对于大型项目，整理功能分支的历史可以让项目维护者更容易看出在pull Request中做了什么内容。  </p><h5 id="小红push功能到她的Bitbucket仓库中"><a href="#小红push功能到她的Bitbucket仓库中" class="headerlink" title="小红push功能到她的Bitbucket仓库中"></a>小红push功能到她的Bitbucket仓库中</h5><p>小红完成功能后，push功能到她自己的Bitbucket仓库中（不是正是仓库），用下面简单的命令。  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> <span class="built_in">some</span>-branch</span><br></pre></td></tr></table></figure><p>这时她的变更可以让项目维护者看到了（后者任何想要看的协作者）  </p><h5 id="小红发起Pull-Request"><a href="#小红发起Pull-Request" class="headerlink" title="小红发起Pull Request"></a>小红发起Pull Request</h5><p>Bitbucket上有了她的功能分支后，小红可以用她的Bitbucket账号浏览到她fork出来的仓库页面，点右上角的[ Pull Request ]按钮，发起一个Pull Request。  </p><p>弹出的表单自动设置小红的仓库为源仓库，询问小红以指定源分支、目标仓库和目标分支。  </p><p>小红想要合并功能到正式仓库，所以源分支是她的功能分支，目标仓库是小明的公开仓库，而目标分支是master分支。  </p><p>另外，小红需要提供Pull Request的标题和描述信息。  </p><p>如果需要小明以外的人审核批准diamante，她可以把这些人填在[ Reviewers ]文本框中。  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX4eBUNEH.PnD8cXLFX3FNQ1TY28uOV3j2Ic*FLo6qk1HERoVGDzy.ccPi6KWHQ1Ha7aF4qrprhr6a71aswRPe1s!/r" alt="images"></p><p>创建好了Pull Request，通知会通过Bitbucket系统消息或者邮件（可选）发给小明。  </p><h5 id="小明-review-Pull-Request"><a href="#小明-review-Pull-Request" class="headerlink" title="小明 review Pull Request"></a>小明 review Pull Request</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXz.TEdJt9fHfFvRXR*aihUCZBZl8OSFD1T7r*7GIRRSRDePO5EI5YO0pxG7Qo02eHht0.LfxlnFiUPPKgPzRY4U!/r" alt="images"></p><p>在小明的Bitbucket仓库页面的[ Pull Request ]Tab可以看到所有人发起的Pull Request。  </p><p>点击小红的Pull Request会显示Pull Request的描述、功能的提交历史和每个变更的差异（diff）。  </p><p>如果小明想要合并到项目中，只要点一下[ Merge ]按钮，就可以同意Pull Request并合并到master分支。  </p><p>但如果像这个示例中一样，小明发现了在小红的代码中的一个小Bug，要在小红合并前修复。  </p><p>小明可以在整个Pull Request上加上评注，或者是选择历史中的某个提交加上评注。  </p><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXywJcEdXUnF5drr2Tn8vpOshxucsOMz.iW9qg*vXiM80CBz6VcPZTn4e7NC2txFi9Xf.oe9HyW39vilYdBhizv0!/r" alt="images"></p><h5 id="小红补加提交"><a href="#小红补加提交" class="headerlink" title="小红补加提交"></a>小红补加提交</h5><p>如果小红对反馈有任何疑问，可以在Pull Request中响应，把Pull Request当做是她功能讨论的论坛。  </p><p>小红在她的功能分支新加提交以解决代码问题，并push到她的Bitbucket仓库中，就像前一轮中的做饭一样。  </p><p>这些提交会进入到Pull Request，小明在原来的评注旁边可以再次Review 变更。  </p><h5 id="小明接受Pull-Request"><a href="#小明接受Pull-Request" class="headerlink" title="小明接受Pull Request"></a>小明接受Pull Request</h5><p>最终，小明接受变更，合并功能分支到master分支，并关闭Pull Request。  </p><p>至此，功能集成到项目中，其他的项目开发者可以用标准的git pull命令pull这些变更到自己的本地仓库中。  </p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>到了这里，你应该有了所有需要的工具来集成Pull Request到你自己的工作流。  </p><p>请记住，Pull Request并不是为了替代任何基于Git的协作工作流，而是它们的一个便利的补充，让团队成员间的协作更加轻松方便。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git工作流指南-分布式版本控制系统&quot;&gt;&lt;a href=&quot;#Git工作流指南-分布式版本控制系统&quot; class=&quot;headerlink&quot; title=&quot;Git工作流指南 分布式版本控制系统&quot;&gt;&lt;/a&gt;Git工作流指南 分布式版本控制系统&lt;/h2&gt;&lt;p&gt;观看笔记：&lt;
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://fengshana.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Git工作流" scheme="https://fengshana.github.io/tags/Git%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>前端页面双色球3</title>
    <link href="https://fengshana.github.io/2020/05/27/%E3%80%90%E5%91%A8%E5%BD%A4%E5%BD%A4%E3%80%91/%E3%80%90%E5%91%A8%E5%BD%A4%E5%BD%A4%E3%80%91%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%94%B9%E8%BF%9B3/"/>
    <id>https://fengshana.github.io/2020/05/27/%E3%80%90%E5%91%A8%E5%BD%A4%E5%BD%A4%E3%80%91/%E3%80%90%E5%91%A8%E5%BD%A4%E5%BD%A4%E3%80%91%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%94%B9%E8%BF%9B3/</id>
    <published>2020-05-27T10:34:19.831Z</published>
    <updated>2020-06-05T17:58:23.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求内容"><a href="#需求内容" class="headerlink" title="需求内容"></a>需求内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 分页加个页码</span><br><span class="line">2. 这个10出过了很多期的，最近的这一期130，4.10，到今天最新的一期不管数值多少，为止已经多少期没出了，求差值</span><br><span class="line">3. 把搜索的数字加个红色也行</span><br><span class="line"></span><br><span class="line">### 效果图</span><br><span class="line"></span><br><span class="line">![image](http:&#x2F;&#x2F;r.photo.store.qq.com&#x2F;psc?&#x2F;V13IdniL0W0T32&#x2F;TCfiP1YaPeRT4Jil9RANX0OntByQ9RopVFKqFo2EAAP.w*ru3lHqrrQXKPPvOiJcpxdOfhwHYah.is4YlEKT.jSTullaIqHR6PMItPvTZnk!&#x2F;r)</span><br><span class="line">![image](http:&#x2F;&#x2F;r.photo.store.qq.com&#x2F;psc?&#x2F;V13IdniL0W0T32&#x2F;TCfiP1YaPeRT4Jil9RANX6NdBhxBRYBUy.T6WIURM8FztiZEk0bzwnUWuk2wwu0zeYpSbcbz.bcVfsU6GZo8tyfIU60tglNtx0E4zdfuFgM!&#x2F;r)</span><br><span class="line">![image](http:&#x2F;&#x2F;r.photo.store.qq.com&#x2F;psc?&#x2F;V13IdniL0W0T32&#x2F;TCfiP1YaPeRT4Jil9RANX.hsLuSnbnm1WocRcndLv9YK0y2Ojuh2G*eAAF14QcltwhNkZ.r8foxuxlNiqT.LK0X4HY7fncWH*Ik9RrigLc8!&#x2F;r)</span><br><span class="line"></span><br><span class="line">### 接触docker并部署项目</span><br><span class="line"></span><br><span class="line">这边是将项目打包成jar包部署linux环境当中的docker容器内</span><br><span class="line"></span><br><span class="line">参考Blog：</span><br><span class="line">* &#96;&#96;&#96;https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;397929dbc27d</span><br></pre></td></tr></table></figure><p>相关命令：</p><p>docker ps -a<br>docker images<br>docker stop 镜像的名称<br>docker start 镜像的名称</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">432 </span> cd ../logs/</span><br><span class="line"><span class="symbol">433 </span> tail -<span class="number">300</span>f access.<span class="keyword">log</span></span><br><span class="line"><span class="symbol">434 </span> ../sbin/nginx -s quit</span><br><span class="line"><span class="symbol">435 </span> ../sbin/nginx -s <span class="keyword">stop</span></span><br><span class="line"><span class="symbol">436 </span> cd ../conf</span><br><span class="line"><span class="symbol">437 </span> vim nginx.conf</span><br><span class="line"><span class="symbol">438 </span> ../sbin/nginx -s reload</span><br><span class="line"><span class="symbol">439 </span> /<span class="keyword">usr</span>/local/nginx/sbin/nginx -c /<span class="keyword">usr</span>/local/nginx/conf/nginx.conf</span><br><span class="line"><span class="symbol">440 </span> ../sbin/nginx -s reload</span><br><span class="line"><span class="symbol">441 </span> vim nginx.conf</span><br><span class="line"><span class="symbol">442 </span> ../sbin/nginx -s reload</span><br><span class="line"><span class="symbol">443 </span> vim nginx.conf</span><br><span class="line"><span class="symbol">444 </span> ../sbin/nginx  -s reload</span><br><span class="line"><span class="symbol">445 </span> vim nginx.conf</span><br><span class="line"><span class="symbol">446 </span> cd </span><br><span class="line"><span class="symbol">447 </span> ll</span><br><span class="line"><span class="symbol">448 </span> cd apache-tomcat-<span class="number">8.5.51</span>/</span><br><span class="line"><span class="symbol">449 </span> ll</span><br><span class="line"><span class="symbol">450 </span> ccd logs/</span><br><span class="line"><span class="symbol">451 </span> ll</span><br><span class="line"><span class="symbol">452 </span> cd logs/</span><br><span class="line"><span class="symbol">453 </span> ll</span><br><span class="line"><span class="symbol">454 </span> cd ..</span><br><span class="line"><span class="symbol">455 </span> ll</span><br><span class="line"><span class="symbol">456 </span> cd ..</span><br><span class="line"><span class="symbol">457 </span> ll</span><br><span class="line"><span class="symbol">458 </span> more install.sh </span><br><span class="line"><span class="symbol">459 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">460 </span> cd /<span class="keyword">usr</span>/local/nginx/</span><br><span class="line"><span class="symbol">461 </span> ll</span><br><span class="line"><span class="symbol">462 </span> cd conf</span><br><span class="line"><span class="symbol">463 </span> more nginx.conf</span><br><span class="line"><span class="symbol">464 </span> vim nginx.conf</span><br><span class="line"><span class="symbol">465 </span> ../sbin/nginx -s reload</span><br><span class="line"><span class="symbol">466 </span> ll</span><br><span class="line"><span class="symbol">467 </span> ps -ef |grep  java</span><br><span class="line"><span class="symbol">468 </span> <span class="keyword">kill</span> -<span class="number">9</span> <span class="number">23983</span></span><br><span class="line"><span class="symbol">469 </span> ll</span><br><span class="line"><span class="symbol">470 </span> <span class="keyword">kill</span> -<span class="number">9</span> <span class="number">23983</span></span><br><span class="line"><span class="symbol">471 </span> ps -ef |grep  java</span><br><span class="line"><span class="symbol">472 </span> <span class="keyword">kill</span> -<span class="number">9</span> <span class="number">703</span></span><br><span class="line"><span class="symbol">473 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">474 </span> ll</span><br><span class="line"><span class="symbol">475 </span> <span class="keyword">mkdir</span> docker</span><br><span class="line"><span class="symbol">476 </span> ll</span><br><span class="line"><span class="symbol">477 </span> cd docker/</span><br><span class="line"><span class="symbol">478 </span> ll</span><br><span class="line"><span class="symbol">479 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">480 </span> cd ..</span><br><span class="line"><span class="symbol">481 </span> ll</span><br><span class="line"><span class="symbol">482 </span> cp Mamai-<span class="number">1.0</span>-SNAPSHOT.jar docker/</span><br><span class="line"><span class="symbol">483 </span> ll</span><br><span class="line"><span class="symbol">484 </span> cd docker/</span><br><span class="line"><span class="symbol">485 </span> ll</span><br><span class="line"><span class="symbol">486 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">487 </span> pwd</span><br><span class="line"><span class="symbol">488 </span> ll</span><br><span class="line"><span class="symbol">489 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">490 </span> docker build -t springbootdemo4docker .</span><br><span class="line"><span class="symbol">491 </span> docker images</span><br><span class="line"><span class="symbol">492 </span> docker <span class="keyword">run</span> -d -p <span class="number">8080</span>:<span class="number">8080</span> springbootdemo4docker</span><br><span class="line"><span class="symbol">493 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">494 </span> ps -ef |grep java</span><br><span class="line"><span class="symbol">495 </span> docker logs --tail <span class="number">300</span> -f demo</span><br><span class="line"><span class="symbol">496 </span> docker ps</span><br><span class="line"><span class="symbol">497 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">498 </span> netstat -na</span><br><span class="line"><span class="symbol">499 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">500 </span> ps -ef|grep java</span><br><span class="line"><span class="symbol">501 </span> ll</span><br><span class="line"><span class="symbol">502 </span> more Dockerfile </span><br><span class="line"><span class="symbol">503 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">504 </span> docker-compose exec java bash</span><br><span class="line"><span class="symbol">505 </span> cd /<span class="keyword">usr</span>/local/bin/</span><br><span class="line"><span class="symbol">506 </span> docker-compose exec java bash</span><br><span class="line"><span class="symbol">507 </span> ll</span><br><span class="line"><span class="symbol">508 </span> netstat -lnp|grep <span class="number">8080</span></span><br><span class="line"><span class="symbol">509 </span> ll</span><br><span class="line"><span class="symbol">510 </span> cd /<span class="keyword">usr</span>/local/nginx/conf</span><br><span class="line"><span class="symbol">511 </span> vim nginx.conf</span><br><span class="line"><span class="symbol">512 </span> ../sbin/nginx -s reload</span><br><span class="line"><span class="symbol">513 </span> vim nginx.conf</span><br><span class="line"><span class="symbol">514 </span> ../sbin/nginx -s reload</span><br><span class="line"><span class="symbol">515 </span> ll</span><br><span class="line"><span class="symbol">516 </span> cd apache-tomcat-<span class="number">8.5.51</span>/</span><br><span class="line"><span class="symbol">517 </span> ll</span><br><span class="line"><span class="symbol">518 </span> cd ..</span><br><span class="line"><span class="symbol">519 </span> ll</span><br><span class="line"><span class="symbol">520 </span> rm -rf apache-tomcat-<span class="number">8.5.51</span>/</span><br><span class="line"><span class="symbol">521 </span> ll</span><br><span class="line"><span class="symbol">522 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">523 </span> ll</span><br><span class="line"><span class="symbol">524 </span> wget https://mirrors.cnnic.cn/apache/tomcat/tomcat-<span class="number">9</span>/v9.<span class="number">0.7</span>/bin/apache-tomcat-<span class="number">9.0.7.</span>tar.gz</span><br><span class="line"><span class="symbol">525 </span> wget https://archive.apache.org/dist/tomcat/tomcat-<span class="number">8</span>/v8.<span class="number">0.23</span>/bin/apache-tomcat-<span class="number">8.0.23.</span>tar.gz</span><br><span class="line"><span class="symbol">526 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">527 </span> ll</span><br><span class="line"><span class="symbol">528 </span> tar -zxvf apache-tomcat-<span class="number">8.0.23.</span>tar.gz </span><br><span class="line"><span class="symbol">529 </span> ll</span><br><span class="line"><span class="symbol">530 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">531 </span> ll</span><br><span class="line"><span class="symbol">532 </span> cd apache-tomcat-<span class="number">8.0.23</span></span><br><span class="line"><span class="symbol">533 </span> ll</span><br><span class="line"><span class="symbol">534 </span> cd webapps/</span><br><span class="line"><span class="symbol">535 </span> ll</span><br><span class="line"><span class="symbol">536 </span> rm -rf docs/</span><br><span class="line"><span class="symbol">537 </span> rm -rf examples/</span><br><span class="line"><span class="symbol">538 </span> rm -rf host-manager/</span><br><span class="line"><span class="symbol">539 </span> rm -rf manager/</span><br><span class="line"><span class="symbol">540 </span> rm -rf ROOT/</span><br><span class="line"><span class="symbol">541 </span> ll</span><br><span class="line"><span class="symbol">542 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">543 </span> ll</span><br><span class="line"><span class="symbol">544 </span> cd ..</span><br><span class="line"><span class="symbol">545 </span> ll</span><br><span class="line"><span class="symbol">546 </span> cd work/</span><br><span class="line"><span class="symbol">547 </span> ll</span><br><span class="line"><span class="symbol">548 </span> cd ..</span><br><span class="line"><span class="symbol">549 </span> cd conf/</span><br><span class="line"><span class="symbol">550 </span> ll</span><br><span class="line"><span class="symbol">551 </span> vim server.xml </span><br><span class="line"><span class="symbol">552 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">553 </span> cd ..</span><br><span class="line"><span class="symbol">554 </span> cd webapps/</span><br><span class="line"><span class="symbol">555 </span> ll</span><br><span class="line"><span class="symbol">556 </span> pwd</span><br><span class="line"><span class="symbol">557 </span> cd ..</span><br><span class="line"><span class="symbol">558 </span> cd conf/</span><br><span class="line"><span class="symbol">559 </span> vim server.xml </span><br><span class="line"><span class="symbol">560 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">561 </span> ll</span><br><span class="line"><span class="symbol">562 </span> cd ..</span><br><span class="line"><span class="symbol">563 </span> ll</span><br><span class="line"><span class="symbol">564 </span> cd bin</span><br><span class="line"><span class="symbol">565 </span> ./startup.sh </span><br><span class="line"><span class="symbol">566 </span> cd ..</span><br><span class="line"><span class="symbol">567 </span> cd logs/</span><br><span class="line"><span class="symbol">568 </span> ll</span><br><span class="line"><span class="symbol">569 </span> ls</span><br><span class="line"><span class="symbol">570 </span> cd ..</span><br><span class="line"><span class="symbol">571 </span> ls</span><br><span class="line"><span class="symbol">572 </span> cd server</span><br><span class="line"><span class="symbol">573 </span> cd www</span><br><span class="line"><span class="symbol">574 </span> cd server</span><br><span class="line"><span class="symbol">575 </span> ls</span><br><span class="line"><span class="symbol">576 </span> cd tomcat</span><br><span class="line"><span class="symbol">577 </span> ls</span><br><span class="line"><span class="symbol">578 </span> cd bin</span><br><span class="line"><span class="symbol">579 </span> ls</span><br><span class="line"><span class="symbol">580 </span> cd apache-tomcat-<span class="number">8.5.12</span>/</span><br><span class="line"><span class="symbol">581 </span> ls</span><br><span class="line"><span class="symbol">582 </span> cd bin</span><br><span class="line"><span class="symbol">583 </span> ./startup.sh</span><br><span class="line"><span class="symbol">584 </span> ls</span><br><span class="line"><span class="symbol">585 </span> ./startup.sh</span><br><span class="line"><span class="symbol">586 </span> ./shutdown.sh</span><br><span class="line"><span class="symbol">587 </span> ./startup.sh</span><br><span class="line"><span class="symbol">588 </span> ll</span><br><span class="line"><span class="symbol">589 </span> cd apache-tomcat-<span class="number">8.0.23</span></span><br><span class="line"><span class="symbol">590 </span> ll</span><br><span class="line"><span class="symbol">591 </span> cd webapps/</span><br><span class="line"><span class="symbol">592 </span> ll</span><br><span class="line"><span class="symbol">593 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">594 </span> cd ..</span><br><span class="line"><span class="symbol">595 </span> cd webapps/</span><br><span class="line"><span class="symbol">596 </span> ll</span><br><span class="line"><span class="symbol">597 </span> cd myProject</span><br><span class="line"><span class="symbol">598 </span> ll</span><br><span class="line"><span class="symbol">599 </span> cd WEB-INF/</span><br><span class="line"><span class="symbol">600 </span> ll</span><br><span class="line"><span class="symbol">601 </span> cd classes/</span><br><span class="line"><span class="symbol">602 </span> ll</span><br><span class="line"><span class="symbol">603 </span> more application.properties </span><br><span class="line"><span class="symbol">604 </span> cd ..</span><br><span class="line"><span class="symbol">605 </span> ll</span><br><span class="line"><span class="symbol">606 </span> cd ..</span><br><span class="line"><span class="symbol">607 </span> ll</span><br><span class="line"><span class="symbol">608 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">609 </span> cd META-INF/</span><br><span class="line"><span class="symbol">610 </span> ll</span><br><span class="line"><span class="symbol">611 </span> cd ..</span><br><span class="line"><span class="symbol">612 </span> ll</span><br><span class="line"><span class="symbol">613 </span> cd WEB-INF/</span><br><span class="line"><span class="symbol">614 </span> ll</span><br><span class="line"><span class="symbol">615 </span> cd classes/</span><br><span class="line"><span class="symbol">616 </span> ll</span><br><span class="line"><span class="symbol">617 </span> cd templates/</span><br><span class="line"><span class="symbol">618 </span> ll</span><br><span class="line"><span class="symbol">619 </span> cd ..</span><br><span class="line"><span class="symbol">620 </span> ll</span><br><span class="line"><span class="symbol">621 </span> cd classes/</span><br><span class="line"><span class="symbol">622 </span> ll</span><br><span class="line"><span class="symbol">623 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">624 </span> ll</span><br><span class="line"><span class="symbol">625 </span> more application.properties </span><br><span class="line"><span class="symbol">626 </span> ll</span><br><span class="line"><span class="symbol">627 </span> cd templates/</span><br><span class="line"><span class="symbol">628 </span> ll</span><br><span class="line"><span class="symbol">629 </span> cd js/</span><br><span class="line"><span class="symbol">630 </span> ll</span><br><span class="line"><span class="symbol">631 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">632 </span> vim <span class="keyword">common</span>.js </span><br><span class="line"><span class="symbol">633 </span> cd .</span><br><span class="line"><span class="symbol">634 </span> cd ..</span><br><span class="line"><span class="symbol">635 </span> cd conf/</span><br><span class="line"><span class="symbol">636 </span> more server.xml </span><br><span class="line"><span class="symbol">637 </span> cd ..</span><br><span class="line"><span class="symbol">638 </span> cd webapps/</span><br><span class="line"><span class="symbol">639 </span> ll</span><br><span class="line"><span class="symbol">640 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">641 </span> cd myProject</span><br><span class="line"><span class="symbol">642 </span> ll</span><br><span class="line"><span class="symbol">643 </span> cd WEB-INF/</span><br><span class="line"><span class="symbol">644 </span> ll</span><br><span class="line"><span class="symbol">645 </span> cd ca</span><br><span class="line"><span class="symbol">646 </span> cd classes/</span><br><span class="line"><span class="symbol">647 </span> ll</span><br><span class="line"><span class="symbol">648 </span> cd templates/</span><br><span class="line"><span class="symbol">649 </span> ll</span><br><span class="line"><span class="symbol">650 </span> cd js/</span><br><span class="line"><span class="symbol">651 </span> ll</span><br><span class="line"><span class="symbol">652 </span> vim <span class="keyword">common</span>.js </span><br><span class="line"><span class="symbol">653 </span> ps -ef |grep java</span><br><span class="line"><span class="symbol">654 </span> netstat -lnp|grep <span class="number">8082</span></span><br><span class="line"><span class="symbol">655 </span> systemctl status firewalld</span><br><span class="line"><span class="symbol">656 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">657 </span> firewall-cmd --zone=public --add-port=<span class="number">80</span>/tcp --permanent</span><br><span class="line"><span class="symbol">658 </span> firewall-cmd --zone=public --add-port=<span class="number">8082</span>/tcp --permanent</span><br><span class="line"><span class="symbol">659 </span> firewall-cmd --reload</span><br><span class="line"><span class="symbol">660 </span> firewall-cmd --zone=public --query-port=<span class="number">8082</span>/tcp</span><br><span class="line"><span class="symbol">661 </span> history </span><br><span class="line"><span class="symbol">662 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">663 </span> ll</span><br><span class="line"><span class="symbol">664 </span> cd ..</span><br><span class="line"><span class="symbol">665 </span> cd bin/</span><br><span class="line"><span class="symbol">666 </span> ./shutdown.sh </span><br><span class="line"><span class="symbol">667 </span> netstat -lnp|grep <span class="number">8080</span></span><br><span class="line"><span class="symbol">668 </span> netstat -lnp|grep <span class="number">8082</span></span><br><span class="line"><span class="symbol">669 </span> <span class="keyword">kill</span> -<span class="number">9</span> <span class="number">1109</span></span><br><span class="line"><span class="symbol">670 </span> netstat -lnp|grep <span class="number">8080</span></span><br><span class="line"><span class="symbol">671 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">672 </span> cd ..</span><br><span class="line"><span class="symbol">673 </span> cd conf/</span><br><span class="line"><span class="symbol">674 </span> ll</span><br><span class="line"><span class="symbol">675 </span> vim server.xml </span><br><span class="line"><span class="symbol">676 </span> cd ..</span><br><span class="line"><span class="symbol">677 </span> cd bin/</span><br><span class="line"><span class="symbol">678 </span> ./startup.sh </span><br><span class="line"><span class="symbol">679 </span> netstat -lnp|grep <span class="number">8080</span></span><br><span class="line"><span class="symbol">680 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">681 </span> ll</span><br><span class="line"><span class="symbol">682 </span> cd ../logs/</span><br><span class="line"><span class="symbol">683 </span> more catalina.<span class="keyword">out</span> </span><br><span class="line"><span class="symbol">684 </span> cd ../webapps/</span><br><span class="line"><span class="symbol">685 </span> cd myProject</span><br><span class="line"><span class="symbol">686 </span> ll</span><br><span class="line"><span class="symbol">687 </span> cd WEB-INF/</span><br><span class="line"><span class="symbol">688 </span> ll</span><br><span class="line"><span class="symbol">689 </span> cd classes/</span><br><span class="line"><span class="symbol">690 </span> ll</span><br><span class="line"><span class="symbol">691 </span> cd templates/</span><br><span class="line"><span class="symbol">692 </span> ll</span><br><span class="line"><span class="symbol">693 </span> cd js/</span><br><span class="line"><span class="symbol">694 </span> ll</span><br><span class="line"><span class="symbol">695 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">696 </span> ll</span><br><span class="line"><span class="symbol">697 </span> vim <span class="keyword">common</span>.js </span><br><span class="line"><span class="symbol">698 </span> cd ..</span><br><span class="line"><span class="symbol">699 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">700 </span> ll</span><br><span class="line"><span class="symbol">701 </span> cd ..</span><br><span class="line"><span class="symbol">702 </span> cd bin/</span><br><span class="line"><span class="symbol">703 </span> ./shutdown.sh </span><br><span class="line"><span class="symbol">704 </span> ll</span><br><span class="line"><span class="symbol">705 </span> cd apache-tomcat-<span class="number">8.0.23</span></span><br><span class="line"><span class="symbol">706 </span> ll</span><br><span class="line"><span class="symbol">707 </span> cd webapps/</span><br><span class="line"><span class="symbol">708 </span> ll</span><br><span class="line"><span class="symbol">709 </span> rm -rf myProject</span><br><span class="line"><span class="symbol">710 </span> rm -rf myProject.war </span><br><span class="line"><span class="symbol">711 </span> cd ..</span><br><span class="line"><span class="symbol">712 </span> cd work/</span><br><span class="line"><span class="symbol">713 </span> ll</span><br><span class="line"><span class="symbol">714 </span> cd Catalina/</span><br><span class="line"><span class="symbol">715 </span> ll</span><br><span class="line"><span class="symbol">716 </span> cd localhost/</span><br><span class="line"><span class="symbol">717 </span> ll</span><br><span class="line"><span class="symbol">718 </span> rm -rf myProject/</span><br><span class="line"><span class="symbol">719 </span> ll</span><br><span class="line"><span class="symbol">720 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">721 </span> cd ../../../</span><br><span class="line"><span class="symbol">722 </span> ll</span><br><span class="line"><span class="symbol">723 </span> cd ..</span><br><span class="line"><span class="symbol">724 </span> cd </span><br><span class="line"><span class="symbol">725 </span> ll</span><br><span class="line"><span class="symbol">726 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">727 </span> history </span><br><span class="line"><span class="symbol">728 </span> ll</span><br><span class="line"><span class="symbol">729 </span> cd docker/</span><br><span class="line"><span class="symbol">730 </span> ll</span><br><span class="line"><span class="symbol">731 </span> docker <span class="keyword">run</span> -d -p <span class="number">8080</span>:<span class="number">8080</span> springbootdemo4docker</span><br><span class="line"><span class="symbol">732 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">733 </span>  docker build -t springbootdemo4docker .</span><br><span class="line"><span class="symbol">734 </span> ll</span><br><span class="line"><span class="symbol">735 </span> more Dockerfile </span><br><span class="line"><span class="symbol">736 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">737 </span> ll</span><br><span class="line"><span class="symbol">738 </span> docker build -t springbootdemo5docker .</span><br><span class="line"><span class="symbol">739 </span> docker build -t springbootdemo4docker .</span><br><span class="line"><span class="symbol">740 </span> service docker restart</span><br><span class="line"><span class="symbol">741 </span> docker build -t springbootdemo5docker .</span><br><span class="line"><span class="symbol">742 </span> docker images</span><br><span class="line"><span class="symbol">743 </span> docker <span class="keyword">run</span> -d -p <span class="number">8080</span>:<span class="number">8080</span> springbootdemo5docker</span><br><span class="line"><span class="symbol">744 </span> docker rmi <span class="number">05</span>c655fd2bd6</span><br><span class="line"><span class="symbol">745 </span> ps -ef |grep java</span><br><span class="line"><span class="symbol">746 </span> <span class="keyword">kill</span> -<span class="number">9</span> <span class="number">2632</span></span><br><span class="line"><span class="symbol">747 </span> <span class="keyword">kill</span> -<span class="number">9</span> <span class="number">2874</span></span><br><span class="line"><span class="symbol">748 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">749 </span> cd ..</span><br><span class="line"><span class="symbol">750 </span> ll</span><br><span class="line"><span class="symbol">751 </span> pwd</span><br><span class="line"><span class="symbol">752 </span> ll</span><br><span class="line"><span class="symbol">753 </span> rm -rf Mamai-<span class="number">1.0</span>-SNAPSHOT.jar </span><br><span class="line"><span class="symbol">754 </span> ll</span><br><span class="line"><span class="symbol">755 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">756 </span> pwd</span><br><span class="line"><span class="symbol">757 </span> ll</span><br><span class="line"><span class="symbol">758 </span> cd docker/</span><br><span class="line"><span class="symbol">759 </span> ll</span><br><span class="line"><span class="symbol">760 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">761 </span> ll</span><br><span class="line"><span class="symbol">762 </span> rm -rf Mamai-<span class="number">1.0</span>-SNAPSHOT.jar </span><br><span class="line"><span class="symbol">763 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">764 </span> cp ../Mamai-<span class="number">1.0</span>-SNAPSHOT.jar  Mamai-<span class="number">1.0</span>-SNAPSHOT.jar</span><br><span class="line"><span class="symbol">765 </span> ll</span><br><span class="line"><span class="symbol">766 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">767 </span> rm -rf Mamai-<span class="number">1.0</span>-SNAPSHOT.jar </span><br><span class="line"><span class="symbol">768 </span> cd ..</span><br><span class="line"><span class="symbol">769 </span> ll</span><br><span class="line"><span class="symbol">770 </span> cear</span><br><span class="line"><span class="symbol">771 </span> rm -rf Mamai-<span class="number">1.0</span>-SNAPSHOT.jar </span><br><span class="line"><span class="symbol">772 </span> ll</span><br><span class="line"><span class="symbol">773 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">774 </span> ll</span><br><span class="line"><span class="symbol">775 </span> tail -<span class="number">300</span>f tempMaima.txt </span><br><span class="line"><span class="symbol">776 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">777 </span> ll</span><br><span class="line"><span class="symbol">778 </span> cp Mamai-<span class="number">1.0</span>-SNAPSHOT.jar ./docker/</span><br><span class="line"><span class="symbol">779 </span> ll</span><br><span class="line"><span class="symbol">780 </span> cd docker/</span><br><span class="line"><span class="symbol">781 </span> ll</span><br><span class="line"><span class="symbol">782 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">783 </span> docker images</span><br><span class="line"><span class="symbol">784 </span> docker start <span class="number">05</span>c655fd2bd6</span><br><span class="line"><span class="symbol">785 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">786 </span> docker build -t springbootdemo6docker .</span><br><span class="line"><span class="symbol">787 </span> docker images</span><br><span class="line"><span class="symbol">788 </span> docker <span class="keyword">run</span> -d -p <span class="number">8080</span>:<span class="number">8080</span> springbootdemo6docker</span><br><span class="line"><span class="symbol">789 </span> docker images</span><br><span class="line"><span class="symbol">790 </span> ll</span><br><span class="line"><span class="symbol">791 </span> cd ..</span><br><span class="line"><span class="symbol">792 </span> ll</span><br><span class="line"><span class="symbol">793 </span> tail -<span class="number">300</span>f tempMaima.txt </span><br><span class="line"><span class="symbol">794 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">795 </span> ll</span><br><span class="line"><span class="symbol">796 </span> cd docker/</span><br><span class="line"><span class="symbol">797 </span> docker images</span><br><span class="line"><span class="symbol">798 </span> docker rmi05c655fd2bd6</span><br><span class="line"><span class="symbol">799 </span> docker rmi <span class="number">05</span>c655fd2bd6</span><br><span class="line"><span class="symbol">800 </span> docker rmi springbootdemo4docker:latest </span><br><span class="line"><span class="symbol">801 </span> docker rmi -f <span class="number">05</span>c655fd2bd6</span><br><span class="line"><span class="symbol">802 </span> docker rmi springbootdemo5docker:latest</span><br><span class="line"><span class="symbol">803 </span> docker rmi -f <span class="number">05</span>c655fd2bd6</span><br><span class="line"><span class="symbol">804 </span> docker images</span><br><span class="line"><span class="symbol">805 </span> ls</span><br><span class="line"><span class="symbol">806 </span> Mamai-<span class="number">1.0</span>-SNAPSHOT.jar.sh <span class="keyword">stop</span></span><br><span class="line"><span class="symbol">807 </span> Mamai-<span class="number">1.0</span>-SNAPSHOT <span class="keyword">stop</span></span><br><span class="line"><span class="symbol">808 </span> Mamai-<span class="number">1.0</span>-SNAPSHOT.jar <span class="keyword">stop</span></span><br><span class="line"><span class="symbol">809 </span> top</span><br><span class="line"><span class="symbol">810 </span> ls</span><br><span class="line"><span class="symbol">811 </span> java -jar Mamai-<span class="number">1.0</span>-SNAPSHOT.jar </span><br><span class="line"><span class="symbol">812 </span> ls</span><br><span class="line"><span class="symbol">813 </span> ps -ef</span><br><span class="line"><span class="symbol">814 </span> ls</span><br><span class="line"><span class="symbol">815 </span> java -jar Mamai-<span class="number">1.0</span>-SNAPSHOT.jar</span><br><span class="line"><span class="symbol">816 </span> ls</span><br><span class="line"><span class="symbol">817 </span> java -jar Mamai-<span class="number">1.0</span>-SNAPSHOT.jar</span><br><span class="line"><span class="symbol">818 </span> ls</span><br><span class="line"><span class="symbol">819 </span> java -jar Mamai-<span class="number">1.0</span>-SNAPSHOT.jar</span><br><span class="line"><span class="symbol">820 </span> ll</span><br><span class="line"><span class="symbol">821 </span> tail -<span class="number">300</span>f tempMaima.txt </span><br><span class="line"><span class="symbol">822 </span> netstat -lnp|grep <span class="number">8080</span></span><br><span class="line"><span class="symbol">823 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">824 </span> docker ps</span><br><span class="line"><span class="symbol">825 </span> ll</span><br><span class="line"><span class="symbol">826 </span> cd docker/</span><br><span class="line"><span class="symbol">827 </span> ll</span><br><span class="line"><span class="symbol">828 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">829 </span> docker ps</span><br><span class="line"><span class="symbol">830 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">831 </span> ps -ef |grep java</span><br><span class="line"><span class="symbol">832 </span> ps -ef |grep <span class="number">8080</span></span><br><span class="line"><span class="symbol">833 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">834 </span> history </span><br><span class="line"><span class="symbol">835 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">836 </span> cd /</span><br><span class="line"><span class="symbol">837 </span> ll</span><br><span class="line"><span class="symbol">838 </span> cd www/</span><br><span class="line"><span class="symbol">839 </span> ll</span><br><span class="line"><span class="symbol">840 </span> cd server/</span><br><span class="line"><span class="symbol">841 </span> ll</span><br><span class="line"><span class="symbol">842 </span> cd nginx/</span><br><span class="line"><span class="symbol">843 </span> ll</span><br><span class="line"><span class="symbol">844 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">845 </span> ll</span><br><span class="line"><span class="symbol">846 </span> cd bin</span><br><span class="line"><span class="symbol">847 </span> ll</span><br><span class="line"><span class="symbol">848 </span> cd sbin/</span><br><span class="line"><span class="symbol">849 </span> ll</span><br><span class="line"><span class="symbol">850 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">851 </span> ll</span><br><span class="line"><span class="symbol">852 </span> cd .</span><br><span class="line"><span class="symbol">853 </span> cd ..</span><br><span class="line"><span class="symbol">854 </span> cd conf/</span><br><span class="line"><span class="symbol">855 </span> ll</span><br><span class="line"><span class="symbol">856 </span> cd ..</span><br><span class="line"><span class="symbol">857 </span> cd sbin</span><br><span class="line"><span class="symbol">858 </span> ./nginx -c ../conf/nginx.conf</span><br><span class="line"><span class="symbol">859 </span> cd ../conf/</span><br><span class="line"><span class="symbol">860 </span> ll</span><br><span class="line"><span class="symbol">861 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">862 </span> ../sbin/nginx -c nginx.conf</span><br><span class="line"><span class="symbol">863 </span> pwd</span><br><span class="line"><span class="symbol">864 </span> tail -<span class="number">300</span>f nginx.conf</span><br><span class="line"><span class="symbol">865 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">866 </span> cd ..</span><br><span class="line"><span class="symbol">867 </span> cd sbin/</span><br><span class="line"><span class="symbol">868 </span> ./nginx  -s reload</span><br><span class="line"><span class="symbol">869 </span> ll</span><br><span class="line"><span class="symbol">870 </span> cd ..</span><br><span class="line"><span class="symbol">871 </span> ll</span><br><span class="line"><span class="symbol">872 </span> cd logs/</span><br><span class="line"><span class="symbol">873 </span> l</span><br><span class="line"><span class="symbol">874 </span> ll</span><br><span class="line"><span class="symbol">875 </span> tail -<span class="number">300</span>f <span class="keyword">error</span>.<span class="keyword">log</span> </span><br><span class="line"><span class="symbol">876 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">877 </span> cd ..</span><br><span class="line"><span class="symbol">878 </span> ll</span><br><span class="line"><span class="symbol">879 </span> cd ..</span><br><span class="line"><span class="symbol">880 </span> cd </span><br><span class="line"><span class="symbol">881 </span> docker images</span><br><span class="line"><span class="symbol">882 </span> docker image ls</span><br><span class="line"><span class="symbol">883 </span> systemctl daemon-reload</span><br><span class="line"><span class="symbol">884 </span> docker images</span><br><span class="line"><span class="symbol">885 </span> service docker status</span><br><span class="line"><span class="symbol">886 </span> service docker start</span><br><span class="line"><span class="symbol">887 </span> systemctl  docker start</span><br><span class="line"><span class="symbol">888 </span> systemctl docker status</span><br><span class="line"><span class="symbol">889 </span> systemctl restart docker</span><br><span class="line"><span class="symbol">890 </span> systemctl status docker</span><br><span class="line"><span class="symbol">891 </span> docker ps</span><br><span class="line"><span class="symbol">892 </span> docker images</span><br><span class="line"><span class="symbol">893 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">894 </span> docker images</span><br><span class="line"><span class="symbol">895 </span> docker ps -a</span><br><span class="line"><span class="symbol">896 </span> history </span><br><span class="line"><span class="symbol">897 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">898 </span> docker images</span><br><span class="line"><span class="symbol">899 </span> docker ps</span><br><span class="line"><span class="symbol">900 </span> docker ps -a</span><br><span class="line"><span class="symbol">901 </span> docker start gifted_hamilton</span><br><span class="line"><span class="symbol">902 </span> docker ps</span><br><span class="line"><span class="symbol">903 </span> ll</span><br><span class="line"><span class="symbol">904 </span> tail -<span class="number">300</span>f tempMaima.txt </span><br><span class="line"><span class="symbol">905 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">906 </span> history </span><br><span class="line"><span class="symbol">907 </span> ll</span><br><span class="line"><span class="symbol">908 </span> docker ps -a</span><br><span class="line"><span class="symbol">909 </span> docker <span class="keyword">stop</span> gifted_hamilton</span><br><span class="line"><span class="symbol">910 </span> pwd</span><br><span class="line"><span class="symbol">911 </span> ll</span><br><span class="line"><span class="symbol">912 </span> cd docker/</span><br><span class="line"><span class="symbol">913 </span> l</span><br><span class="line"><span class="symbol">914 </span> ll</span><br><span class="line"><span class="symbol">915 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">916 </span> ll</span><br><span class="line"><span class="symbol">917 </span> rm -rf Mamai-<span class="number">1.0</span>-SNAPSHOT.jar </span><br><span class="line"><span class="symbol">918 </span> ll</span><br><span class="line"><span class="symbol">919 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">920 </span> pwd</span><br><span class="line"><span class="symbol">921 </span> docker ps -a</span><br><span class="line"><span class="symbol">922 </span> ll</span><br><span class="line"><span class="symbol">923 </span> docker start gifted_hamilton</span><br><span class="line"><span class="symbol">924 </span> docker ps -a</span><br><span class="line"><span class="symbol">925 </span> ps -ef |grep java</span><br><span class="line"><span class="symbol">926 </span> ll</span><br><span class="line"><span class="symbol">927 </span> docker ps -a</span><br><span class="line"><span class="symbol">928 </span> docker <span class="keyword">stop</span> gifted_hamilton</span><br><span class="line"><span class="symbol">929 </span> cd docker/</span><br><span class="line"><span class="symbol">930 </span> ll</span><br><span class="line"><span class="symbol">931 </span> rm -rf Mamai-<span class="number">1.0</span>-SNAPSHOT.jar </span><br><span class="line"><span class="symbol">932 </span> ll</span><br><span class="line"><span class="symbol">933 </span> pwd</span><br><span class="line"><span class="symbol">934 </span> ll</span><br><span class="line"><span class="symbol">935 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">936 </span> docker ps -a</span><br><span class="line"><span class="symbol">937 </span> docker start gifted_hamilton</span><br><span class="line"><span class="symbol">938 </span> docker ps -a</span><br><span class="line"><span class="symbol">939 </span> docker <span class="keyword">stop</span> gifted_hamilton</span><br><span class="line"><span class="symbol">940 </span> docker ps -a</span><br><span class="line"><span class="symbol">941 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">942 </span> docker ps -a</span><br><span class="line"><span class="symbol">943 </span> docker rm gifted_hamilton</span><br><span class="line"><span class="symbol">944 </span> docker ps -a</span><br><span class="line"><span class="symbol">945 </span> docker images</span><br><span class="line"><span class="symbol">946 </span> docker rmi springbootdemo6docker</span><br><span class="line"><span class="symbol">947 </span> docker iamges</span><br><span class="line"><span class="symbol">948 </span> docker images</span><br><span class="line"><span class="symbol">949 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">950 </span> ll</span><br><span class="line"><span class="symbol">951 </span> more Dockerfile </span><br><span class="line"><span class="symbol">952 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">953 </span> docker build -t mamai .</span><br><span class="line"><span class="symbol">954 </span> docker images</span><br><span class="line"><span class="symbol">955 </span> cd ..</span><br><span class="line"><span class="symbol">956 </span> ll</span><br><span class="line"><span class="symbol">957 </span> cd docker/</span><br><span class="line"><span class="symbol">958 </span> ll</span><br><span class="line"><span class="symbol">959 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">960 </span> more Dockerfile </span><br><span class="line"><span class="symbol">961 </span> docker <span class="keyword">run</span> -d -p <span class="number">8080</span>:<span class="number">8080</span> mamai</span><br><span class="line"><span class="symbol">962 </span> docker ps -a</span><br><span class="line"><span class="symbol">963 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">964 </span> ll</span><br><span class="line"><span class="symbol">965 </span> cd .</span><br><span class="line"><span class="symbol">966 </span> c d..</span><br><span class="line"><span class="symbol">967 </span> cd ..</span><br><span class="line"><span class="symbol">968 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">969 </span> ll</span><br><span class="line"><span class="symbol">970 </span> rm -rf Ma</span><br><span class="line"><span class="symbol">971 </span> rm -rf Mamai-<span class="number">1.0</span>-SNAPSHOT.jar </span><br><span class="line"><span class="symbol">972 </span> ll</span><br><span class="line"><span class="symbol">973 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">974 </span> ll</span><br><span class="line"><span class="symbol">975 </span> rm -rf apache-tomcat-<span class="number">8.0.23</span></span><br><span class="line"><span class="symbol">976 </span> rm -rf apache-tomcat-<span class="number">8.0.23.</span>tar.gz </span><br><span class="line"><span class="symbol">977 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">978 </span> ll</span><br><span class="line"><span class="symbol">979 </span> more install.sh </span><br><span class="line"><span class="symbol">980 </span> <span class="keyword">clear</span></span><br><span class="line"><span class="symbol">981 </span> docker ps -a</span><br><span class="line"><span class="symbol">982 </span> docker <span class="keyword">stop</span> agitated_brown</span><br><span class="line"><span class="symbol">983 </span> ll</span><br><span class="line"><span class="symbol">984 </span> cd docker/</span><br><span class="line"><span class="symbol">985 </span> ll</span><br><span class="line"><span class="symbol">986 </span> rm -rf Mamai-<span class="number">1.0</span>-SNAPSHOT.jar </span><br><span class="line"><span class="symbol">987 </span> ll</span><br><span class="line"><span class="symbol">988 </span> docker  images</span><br><span class="line"><span class="symbol">989 </span> docker ps -a</span><br><span class="line"><span class="symbol">990 </span> docker start agitated_brown</span><br><span class="line"><span class="symbol">991 </span> docker ps -a</span><br><span class="line"><span class="symbol">992 </span> top</span><br><span class="line"><span class="symbol">993 </span> df -h</span><br><span class="line"><span class="symbol">994 </span> top</span><br><span class="line"><span class="symbol">995 </span> ll</span><br><span class="line"><span class="symbol">996 </span> cd docker/</span><br><span class="line"><span class="symbol">997 </span> ll</span><br><span class="line"><span class="symbol">998 </span> more Dockerfile </span><br><span class="line"><span class="symbol">999 </span> history</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;需求内容&quot;&gt;&lt;a href=&quot;#需求内容&quot; class=&quot;headerlink&quot; title=&quot;需求内容&quot;&gt;&lt;/a&gt;需求内容&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="前端" scheme="https://fengshana.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javaScript" scheme="https://fengshana.github.io/tags/javaScript/"/>
    
      <category term="docker" scheme="https://fengshana.github.io/tags/docker/"/>
    
      <category term="前端" scheme="https://fengshana.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="双色球" scheme="https://fengshana.github.io/tags/%E5%8F%8C%E8%89%B2%E7%90%83/"/>
    
  </entry>
  
  <entry>
    <title>深入理解java虚拟机-线程安全与锁优化</title>
    <link href="https://fengshana.github.io/2020/05/26/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA13/"/>
    <id>https://fengshana.github.io/2020/05/26/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA13/</id>
    <published>2020-05-26T14:41:37.497Z</published>
    <updated>2020-06-05T18:26:39.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入java虚拟机-第五部分-高效并发"><a href="#深入java虚拟机-第五部分-高效并发" class="headerlink" title="深入java虚拟机-第五部分-高效并发"></a>深入java虚拟机-第五部分-高效并发</h2><h3 id="第13章-线程安全与锁优化"><a href="#第13章-线程安全与锁优化" class="headerlink" title="第13章 线程安全与锁优化"></a>第13章 线程安全与锁优化</h3><p>并发处理 的 广泛应用 是使得 Amdah1定律 代替 摩尔定律 成为 计算机性能发展源动力 的根本原因，也是人类 “压榨” 计算机运算能力 的 最有力武器。</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在 软件业发展 的 初期，程序编写 都是以 算法 为核心的，<br>程序员会把 数据 和 过程 分别作为 独立的部分 来考虑，<br>数据 代表 问题空间 中的 客体，程序代码 则用于 处理这些数据，<br>这种 思维方式 直接站在 计算机的角度 去 抽象问题和解决问题，<br>称为 面向过程 的 编程思想。</p><p>与此同时，<br>面向对象 的 编程思想 是站在 现实世界的角度 去 抽象和解决问题，<br>它把 数据和行为 都看做是 对象的一部分，<br>这样可以让程序员能以 符合现实世界的 思维方式 来 编写和组织程序。</p><p>面向过程 的 编程思想 极大地 提升了 现代软件开发 的 生产效率 和 软件可以达到的规模，<br>但是 现实世界与计算机世界 之间不可避免地 存在一些差异。</p><p>例如，人们很难想象现实中的 对象 在一项工作进行期间，会被不停地中断和切换，对象的属性（数据）可能会在 中断期间 被修改和变“脏”，<br>而这些事件 在计算机世界中 则是很正常的事情。</p><p>有时候，良好的设计原则 不得不向现实做出一些让步，我们必须让 程序 在计算机中 正确无误地运行，<br>然后再考虑如何将 代码组织得更好，让 程序 运行得 更快。</p><p>对于这部分的主题“高效并发”来讲，首先需要保证 并发的正确性，然后在此基础上实现 高效。</p><p>本章先从 如何保证并发的正确性 和 如何实现线程安全讲起。</p><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>“线程安全”  这个名称，相信稍有经验的程序员都会听说过，甚至在 代码编写 和 走查的时候 可能还会将会挂在嘴边，<br>但是如何找到一个不太拗口的概念 来定义 线程安全 却不是一件容易的事情，<br>笔者尝试在Google中搜索它的概念，找到的是类似于 “如果一个对象可以安全地被多个线程同时使用，那它就是线程安全的”这样的定义——并不能说它不正确，但是人们无法从中获取到任何有用的信息。</p><p>（像我这种小白，也只是，听过，我可没有说过😶😶😶）</p><p>笔者认为《Java Concurrency In Practice》 的作者 Brian Goetz 对 “线程安全” 有一个比较恰当的定义：<br>“当 多个线程 访问 一个对象时，如果不用考虑这些 线程 在 运行时环境 下的 调度 和 交替执行，也不需要进行 额外的同步，或者在 调用方 进行任何其他的 协调操作，调用这个 对象的行为 都可以获得 正确的结果，那 这个对象 是 线程安全 的”。</p><p>这个定义比较 严谨，它要求 线程安全 的代码 都必须具备一个特征：<br>代码本身 封装 了所有必要的 正确性保障手段（如互斥同步等），<br>令 调用者 无需关心 多线程 的问题，更无须自己采取 任何措施 来 保证多线程的正确调用。</p><p>这点听起来简单，但其实并不容易做到，在大多数场景中，我们都会将这个定义弱化一些，如果把”调用这个对象的行为“限定为”单次调用“，<br>这个定义的其他描述也能够成立的话，我们就可以称它是 线程安全 了，为什么要 弱化 这个定义，现在暂且放下，稍后再详细探讨。</p><h5 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h5><p>我们已经有了 线程安全 的一个 抽象定义，<br>那接下来就讨论一下在 java语言 中，线程安全 具体是如何体现的？<br>有哪些操作是 线程安全 的？<br>我们这里讨论的 线程安全，就 限定与 多个线程之间 存在 共享数据访问 这个 前提，<br>因为如果一段代码 根本不会 与其他线程共享数据，那么从 线程安全 的 角度 来看，程序是 串行执行 还是 多线程执行 对它来说是完全没有区别的。</p><p>为了更加 深入地 理解 线程安全，在这里我们可以不把 线程安全 当做一个非真即假 的 二元排他项 来看待，<br>按照 线程安全 的 “安全程度” 由强至弱来排序，我们可以将Java语言中各种操作共享的数据分为以下5类：<br>不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><blockquote><p>这种划分方法也是 Brian Goetz在IBM developWorkers上发表的一篇论文中提出的，<br>这里写 “我们”  纯粹是笔者下笔行文中的语言用法。</p></blockquote><h6 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1.不可变"></a>1.不可变</h6><p>在Java语言中（特指JDK1.5以后，即 Java内存模型 被 修正以后的 Java语言），<br>不可变（Immutable） 的 对象 一定是 线程安全的，<br>无论是 对象的方法 还是 方法的调用者，都不需要再采取 任何的线程安全保障措施，</p><p>在12章我们谈到 final关键字 带来的 可见性 时曾经提到过这一点，<br>只要一个 不可变的对象 被正确地 构建出来（没有发生 this 引用逃逸 的情况），<br>那其外部的 可见状态 永远也不会改变，<br>永远也不会看到它在 多个线程之中 处于 不一致 的状态。</p><p>“不可变” 带来的 安全性 是 最简单和最纯粹的。</p><p>Java语言中，如果 共享数据 是一个基本数据类型，那么只要在 定义时 使用 final关键字 修饰它 就可以保证它是 不可变的。</p><p>如果 共享数据 是一个对象，那就需要保证 对象的行为 不会对其 状态 产生任何影响 才行，</p><p>如果读者还没想明白这句话，不妨想一想 java.lang.String 类的对象，它是一个典型的 不可变对象，<br>我们调用它的 substring()、replace()和concat() 这些方法都 不会影响它 原来的值，只会返回一个新构造的字符串对象。</p><p>保证对象行为 不影响 自己状态的途径 有很多种，<br>其中最简单的就是把对象中 带有状态的变量 都声明为 final，<br>这样在 构造函数 结束之后，它就是 不可变的，<br>例如代码清单13-1中java.lang.Integer 构造函数所示的，<br>它通过将 内部状态变量 value 定义为 final 来保障 状态不变。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">                                代码清单 13-1 JDK中Integer类的构造函数</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">/*<span class="strong">*</span></span><br><span class="line"><span class="strong">  *</span> The value of the &lt;code&gt;Integer&lt;/code&gt;.</span><br><span class="line"><span class="code">  * @serial</span></span><br><span class="line"><span class="code">  */</span></span><br><span class="line"><span class="code">  private final int value;</span></span><br><span class="line"></span><br><span class="line"><span class="code">  /**</span></span><br><span class="line"><span class="code">    * Constructs newly allocated &lt;code&gt;Integer&lt;/code&gt; object that</span></span><br><span class="line"><span class="code">    * represents the specified &lt;code&gt;int&lt;/code&gt; value.</span></span><br><span class="line"><span class="code">    *</span></span><br><span class="line"><span class="code">    * @param value the value to be represented by the &lt;code&gt;Integer&lt;/code&gt; object.</span></span><br><span class="line"><span class="code">    *</span></span><br><span class="line"><span class="code">    */</span></span><br><span class="line"><span class="code">    public Integer(int value)&#123;</span></span><br><span class="line"><span class="code">      this.value=value;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>在 Java API 中 符合 不可变要求 的类型，<br>除了上面提到的 String 之外，<br>常用的还有 枚举类型，以及 java.lang.Number的部分子类，<br>如Long和Double等数值包装类型，BigInteger和BigDecimal等大数据类型；</p><p>但同为 Number 的 子类型 的 原子类 AtomicInteger 和 AtomicLong 则并非不可变的，<br>读者不妨看看这两个原子类的源码，想一想为什么。</p><p>(emm，原因是不是那个value没有被标为final？Integer类当中的value被标记为final了，而AtomicInteger以及AtomicLong里面的value都没有被标记为final)</p><p>AtomicInteger类代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br></pre></td><td class="code"><pre><span class="line">                                代码清单 AtomicInteger类</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Written by Doug Lea with assistance from members of JCP JSR-166</span></span><br><span class="line"><span class="comment"> * Expert Group and released to the public domain, as explained at</span></span><br><span class="line"><span class="comment"> * http://creativecommons.org/publicdomain/zero/1.0/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">package java.util.concurrent.atomic;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntUnaryOperator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntBinaryOperator;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>An &#123;@code int&#125; value that may be updated atomically.  See </span>the</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@link java.util.concurrent.atomic&#125; package specification for</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>description of </span>the<span class="markdown"> properties of atomic variables. An</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code AtomicInteger&#125; is used in applications </span>such<span class="markdown"> as atomically</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>incremented counters, and cannot be used as </span>a<span class="markdown"> replacement for </span>an</span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@link java.lang.Integer&#125;. However, this class does extend</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;@code Number&#125; to allow uniform access by tools and utilities that</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>deal with numerically-based classes.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@since 1.5</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@author Doug Lea</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*/</span></span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> long serialVersionUID = <span class="number">6214790243416807050</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> long valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredField</span>("<span class="title">value</span>"));</span></span><br><span class="line"><span class="class">        &#125; <span class="title">catch</span> (<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile <span class="built_in">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Creates </span>a<span class="markdown"> new AtomicInteger with </span>the<span class="markdown"> given initial value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param initialValue </span>the<span class="markdown"> initial value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public AtomicInteger(<span class="built_in">int</span> initialValue) &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Creates </span>a<span class="markdown"> new AtomicInteger with initial value &#123;@code 0&#125;.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public AtomicInteger() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Gets </span>the<span class="markdown"> current value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> current value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> <span class="built_in">int</span> <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Sets to </span>the<span class="markdown"> given value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param newValue </span>the<span class="markdown"> new value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> <span class="keyword">void</span> <span class="keyword">set</span>(<span class="built_in">int</span> newValue) &#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Eventually sets to </span>the<span class="markdown"> given value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param newValue </span>the<span class="markdown"> new value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@since 1.6</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> <span class="keyword">void</span> lazySet(<span class="built_in">int</span> newValue) &#123;</span><br><span class="line">        unsafe.putOrderedInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Atomically sets to </span>the<span class="markdown"> given value and returns </span>the<span class="markdown"> old value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param newValue </span>the<span class="markdown"> new value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> previous value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> <span class="built_in">int</span> getAndSet(<span class="built_in">int</span> newValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Atomically sets </span>the<span class="markdown"> value to </span>the<span class="markdown"> given updated value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>if </span>the<span class="markdown"> current value &#123;@code ==&#125; </span>the<span class="markdown"> expected value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param expect </span>the<span class="markdown"> expected value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param update </span>the<span class="markdown"> new value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return &#123;@code true&#125; if successful. False return indicates that</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span></span>the<span class="markdown"> actual value was not equal to </span>the<span class="markdown"> expected value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> boolean compareAndSet(<span class="built_in">int</span> expect, <span class="built_in">int</span> update) &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Atomically sets </span>the<span class="markdown"> value to </span>the<span class="markdown"> given updated value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>if </span>the<span class="markdown"> current value &#123;@code ==&#125; </span>the<span class="markdown"> expected value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="xml"><span class="tag">&lt;</span></span></span>a<span class="markdown"><span class="xml"> href="package-summary.html#weakCompareAndSet"&gt;</span>May fail</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>spuriously and does not provide ordering guarantees<span class="xml"><span class="tag">&lt;/</span></span></span>a<span class="markdown"><span class="xml">&gt;</span>, </span>so<span class="markdown"> is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>only rarely </span>an<span class="markdown"> appropriate alternative to &#123;@code compareAndSet&#125;.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param expect </span>the<span class="markdown"> expected value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param update </span>the<span class="markdown"> new value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return &#123;@code true&#125; if successful</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> boolean weakCompareAndSet(<span class="built_in">int</span> expect, <span class="built_in">int</span> update) &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Atomically increments by one </span>the<span class="markdown"> current value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> previous value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> <span class="built_in">int</span> getAndIncrement() &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Atomically decrements by one </span>the<span class="markdown"> current value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> previous value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> <span class="built_in">int</span> getAndDecrement() &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Atomically adds </span>the<span class="markdown"> given value to </span>the<span class="markdown"> current value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param delta </span>the<span class="markdown"> value to add</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> previous value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> <span class="built_in">int</span> getAndAdd(<span class="built_in">int</span> delta) &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Atomically increments by one </span>the<span class="markdown"> current value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> updated value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> <span class="built_in">int</span> incrementAndGet() &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Atomically decrements by one </span>the<span class="markdown"> current value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> updated value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> <span class="built_in">int</span> decrementAndGet() &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">-1</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Atomically adds </span>the<span class="markdown"> given value to </span>the<span class="markdown"> current value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param delta </span>the<span class="markdown"> value to add</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> updated value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> <span class="built_in">int</span> addAndGet(<span class="built_in">int</span> delta) &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Atomically updates </span>the<span class="markdown"> current value with </span>the<span class="markdown"> results of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>applying </span>the<span class="markdown"> given function, returning </span>the<span class="markdown"> previous value. The</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>function </span>should<span class="markdown"> be side-effect-free, since it may be re-applied</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>when attempted updates fail due to contention among threads.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param updateFunction </span>a<span class="markdown"> side-effect-free function</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> previous value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@since 1.8</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> <span class="built_in">int</span> getAndUpdate(IntUnaryOperator updateFunction) &#123;</span><br><span class="line">        <span class="built_in">int</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = <span class="keyword">get</span>();</span><br><span class="line">            next = updateFunction.applyAsInt(prev);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Atomically updates </span>the<span class="markdown"> current value with </span>the<span class="markdown"> results of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>applying </span>the<span class="markdown"> given function, returning </span>the<span class="markdown"> updated value. The</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>function </span>should<span class="markdown"> be side-effect-free, since it may be re-applied</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>when attempted updates fail due to contention among threads.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param updateFunction </span>a<span class="markdown"> side-effect-free function</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> updated value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@since 1.8</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> <span class="built_in">int</span> updateAndGet(IntUnaryOperator updateFunction) &#123;</span><br><span class="line">        <span class="built_in">int</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = <span class="keyword">get</span>();</span><br><span class="line">            next = updateFunction.applyAsInt(prev);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Atomically updates </span>the<span class="markdown"> current value with </span>the<span class="markdown"> results of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>applying </span>the<span class="markdown"> given function to </span>the<span class="markdown"> current and given values,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>returning </span>the<span class="markdown"> previous value. The function </span>should<span class="markdown"> be</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>side-effect-free, since it may be re-applied when attempted</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>updates fail due to contention among threads.  The function</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>is applied with </span>the<span class="markdown"> current value as its first argument,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>and </span>the<span class="markdown"> given update as </span>the<span class="markdown"> second argument.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param x </span>the<span class="markdown"> update value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param accumulatorFunction </span>a<span class="markdown"> side-effect-free function of two arguments</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> previous value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@since 1.8</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> <span class="built_in">int</span> getAndAccumulate(<span class="built_in">int</span> x,</span><br><span class="line">                                      IntBinaryOperator accumulatorFunction) &#123;</span><br><span class="line">        <span class="built_in">int</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = <span class="keyword">get</span>();</span><br><span class="line">            next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Atomically updates </span>the<span class="markdown"> current value with </span>the<span class="markdown"> results of</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>applying </span>the<span class="markdown"> given function to </span>the<span class="markdown"> current and given values,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>returning </span>the<span class="markdown"> updated value. The function </span>should<span class="markdown"> be</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>side-effect-free, since it may be re-applied when attempted</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>updates fail due to contention among threads.  The function</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>is applied with </span>the<span class="markdown"> current value as its first argument,</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>and </span>the<span class="markdown"> given update as </span>the<span class="markdown"> second argument.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param x </span>the<span class="markdown"> update value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param accumulatorFunction </span>a<span class="markdown"> side-effect-free function of two arguments</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> updated value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@since 1.8</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">final</span> <span class="built_in">int</span> accumulateAndGet(<span class="built_in">int</span> x,</span><br><span class="line">                                      IntBinaryOperator accumulatorFunction) &#123;</span><br><span class="line">        <span class="built_in">int</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = <span class="keyword">get</span>();</span><br><span class="line">            next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Returns </span>the<span class="markdown"> String representation of </span>the<span class="markdown"> current value.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return </span>the<span class="markdown"> String representation of </span>the<span class="markdown"> current value</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="built_in">String</span> toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(<span class="keyword">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Returns </span>the<span class="markdown"> value of this &#123;@code AtomicInteger&#125; as </span>an<span class="markdown"> &#123;@code int&#125;.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="built_in">int</span> intValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Returns </span>the<span class="markdown"> value of this &#123;@code AtomicInteger&#125; as </span>a<span class="markdown"> &#123;@code long&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>after </span>a<span class="markdown"> widening primitive conversion.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@jls 5.1.2 Widening Primitive Conversions</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public long longValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> (long)<span class="keyword">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Returns </span>the<span class="markdown"> value of this &#123;@code AtomicInteger&#125; as </span>a<span class="markdown"> &#123;@code float&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>after </span>a<span class="markdown"> widening primitive conversion.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@jls 5.1.2 Widening Primitive Conversions</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public float floatValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> (float)<span class="keyword">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>Returns </span>the<span class="markdown"> value of this &#123;@code AtomicInteger&#125; as </span>a<span class="markdown"> &#123;@code double&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>after </span>a<span class="markdown"> widening primitive conversion.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@jls 5.1.2 Widening Primitive Conversions</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="built_in">double</span> doubleValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">double</span>)<span class="keyword">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>AtomicLong类代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line">                                代码清单 AtomicLong类</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Written by Doug Lea with assistance from members of JCP JSR-166</span></span><br><span class="line"><span class="comment"> * Expert Group and released to the public domain, as explained at</span></span><br><span class="line"><span class="comment"> * http://creativecommons.org/publicdomain/zero/1.0/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent.atomic;</span><br><span class="line"><span class="keyword">import</span> java.util.function.LongUnaryOperator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.LongBinaryOperator;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@code</span> long&#125; value that may be updated atomically.  See the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.util.concurrent.atomic&#125; package specification for</span></span><br><span class="line"><span class="comment"> * description of the properties of atomic variables. An</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> AtomicLong&#125; is used in applications such as atomically</span></span><br><span class="line"><span class="comment"> * incremented sequence numbers, and cannot be used as a replacement</span></span><br><span class="line"><span class="comment"> * for a &#123;<span class="doctag">@link</span> java.lang.Long&#125;. However, this class does extend</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Number&#125; to allow uniform access by tools and utilities that</span></span><br><span class="line"><span class="comment"> * deal with numerically-based classes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLong</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1927816293512124184</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapLong for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Records whether the underlying JVM supports lockless</span></span><br><span class="line"><span class="comment">     * compareAndSwap for longs. While the Unsafe.compareAndSwapLong</span></span><br><span class="line"><span class="comment">     * method works in either case, some constructions should be</span></span><br><span class="line"><span class="comment">     * handled at Java level to avoid locking user-visible locks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> VM_SUPPORTS_LONG_CAS = VMSupportsCS8();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns whether underlying JVM supports lockless CompareAndSet</span></span><br><span class="line"><span class="comment">     * for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> native <span class="keyword">boolean</span> VMSupportsCS8();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicLong<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredField</span>("<span class="title">value</span>"));</span></span><br><span class="line"><span class="class">        &#125; <span class="title">catch</span> (<span class="title">Exception</span> <span class="title">ex</span>) &#123;</span> <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicLong with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> AtomicLong(<span class="keyword">long</span> initialValue) &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicLong with initial value &#123;<span class="doctag">@code</span> 0&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> AtomicLong() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> get() &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> set(<span class="keyword">long</span> newValue) &#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Eventually sets to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> lazySet(<span class="keyword">long</span> newValue) &#123;</span><br><span class="line">        unsafe.putOrderedLong(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets to the given value and returns the old value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> getAndSet(<span class="keyword">long</span> newValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndSetLong(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment">     * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span></span><br><span class="line"><span class="comment">     * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> compareAndSet(<span class="keyword">long</span> expect, <span class="keyword">long</span> update) &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment">     * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;a href="package-summary.html#weakCompareAndSet"&gt;May fail</span></span><br><span class="line"><span class="comment">     * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is</span></span><br><span class="line"><span class="comment">     * only rarely an appropriate alternative to &#123;<span class="doctag">@code</span> compareAndSet&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> weakCompareAndSet(<span class="keyword">long</span> expect, <span class="keyword">long</span> update) &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> getAndIncrement() &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically decrements by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> getAndDecrement() &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">-1</span>L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically adds the given value to the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> getAndAdd(<span class="keyword">long</span> delta) &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> incrementAndGet() &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>L) + <span class="number">1</span>L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically decrements by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> decrementAndGet() &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">-1</span>L) - <span class="number">1</span>L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically adds the given value to the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> addAndGet(<span class="keyword">long</span> delta) &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment">     * applying the given function, returning the previous value. The</span></span><br><span class="line"><span class="comment">     * function should be side-effect-free, since it may be re-applied</span></span><br><span class="line"><span class="comment">     * when attempted updates fail due to contention among threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateFunction a side-effect-free function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> getAndUpdate(LongUnaryOperator updateFunction) &#123;</span><br><span class="line">        <span class="keyword">long</span> prev, next;</span><br><span class="line">        do &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = updateFunction.applyAsLong(prev);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment">     * applying the given function, returning the updated value. The</span></span><br><span class="line"><span class="comment">     * function should be side-effect-free, since it may be re-applied</span></span><br><span class="line"><span class="comment">     * when attempted updates fail due to contention among threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateFunction a side-effect-free function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> updateAndGet(LongUnaryOperator updateFunction) &#123;</span><br><span class="line">        <span class="keyword">long</span> prev, next;</span><br><span class="line">        do &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = updateFunction.applyAsLong(prev);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment">     * applying the given function to the current and given values,</span></span><br><span class="line"><span class="comment">     * returning the previous value. The function should be</span></span><br><span class="line"><span class="comment">     * side-effect-free, since it may be re-applied when attempted</span></span><br><span class="line"><span class="comment">     * updates fail due to contention among threads.  The function</span></span><br><span class="line"><span class="comment">     * is applied with the current value as its first argument,</span></span><br><span class="line"><span class="comment">     * and the given update as the second argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x the update value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accumulatorFunction a side-effect-free function of two arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> getAndAccumulate(<span class="keyword">long</span> x,</span><br><span class="line">                                       LongBinaryOperator accumulatorFunction) &#123;</span><br><span class="line">        <span class="keyword">long</span> prev, next;</span><br><span class="line">        do &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = accumulatorFunction.applyAsLong(prev, x);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment">     * applying the given function to the current and given values,</span></span><br><span class="line"><span class="comment">     * returning the updated value. The function should be</span></span><br><span class="line"><span class="comment">     * side-effect-free, since it may be re-applied when attempted</span></span><br><span class="line"><span class="comment">     * updates fail due to contention among threads.  The function</span></span><br><span class="line"><span class="comment">     * is applied with the current value as its first argument,</span></span><br><span class="line"><span class="comment">     * and the given update as the second argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x the update value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accumulatorFunction a side-effect-free function of two arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> accumulateAndGet(<span class="keyword">long</span> x,</span><br><span class="line">                                       LongBinaryOperator accumulatorFunction) &#123;</span><br><span class="line">        <span class="keyword">long</span> prev, next;</span><br><span class="line">        do &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = accumulatorFunction.applyAsLong(prev, x);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the String representation of the current value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the String representation of the current value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> Long.toString(get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> AtomicLong&#125; as an &#123;<span class="doctag">@code</span> int&#125;</span></span><br><span class="line"><span class="comment">     * after a narrowing primitive conversion.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@jls</span> 5.1.3 Narrowing Primitive Conversions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> intValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> AtomicLong&#125; as a &#123;<span class="doctag">@code</span> long&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> longValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> AtomicLong&#125; as a &#123;<span class="doctag">@code</span> float&#125;</span></span><br><span class="line"><span class="comment">     * after a widening primitive conversion.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@jls</span> 5.1.2 Widening Primitive Conversions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> floatValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>)get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> AtomicLong&#125; as a &#123;<span class="doctag">@code</span> double&#125;</span></span><br><span class="line"><span class="comment">     * after a widening primitive conversion.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@jls</span> 5.1.2 Widening Primitive Conversions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> doubleValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h6 id="2-绝对线程安全"><a href="#2-绝对线程安全" class="headerlink" title="2.绝对线程安全"></a>2.绝对线程安全</h6><p>绝对的 线程安全 完全满足 Brian Goetz 给出的 线程安全 的定义，<br>这个 定义 其实是很 严格的，<br>一个类 要达到 “不管 运行时环境 如何， 调用者 都不需要 任何额外的 同步措施” 通常需要付出很大的，甚至有时候是不切实际的代价。</p><p>在 Java API中 标注自己是 线程安全的类，大多数都不是 绝对的线程安全。</p><p>我们可以通过 Java API中 一个不是 “绝对线程安全” 的线程安全类 来看看这里的 “绝对” 是什么意思。</p><p>如果说 java.util.Vector 是一个 线程安全 的 容器，<br>相信所有的Java程序员对此都不会有异议，因为它的 add()、get()和size() 这类方法都是被 synchronized 修饰的，<br>尽管这样 效率很低，但确实是 安全的。</p><p>但是，即使它 所有的方法 都被 修饰成 同步，也不意味着 调用它的时候永远都不需要 同步手段了，<br>请看一下代码清单13-2中的测试代码。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">                                代码清单 <span class="number">13</span><span class="number">-2</span> 对Vector线程安全的测试</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; <span class="built_in">vector</span> = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">      <span class="built_in">vector</span>.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="built_in">vector</span>.<span class="built_in">remove</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>((<span class="built_in">vector</span>.<span class="built_in">get</span>(i)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  removeThread.start();</span><br><span class="line">  printThread.start();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//不要同时产生过多的线程，否则会导致操作系统假死</span></span><br><span class="line">  <span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"Thread-132"</span> java.lang.ArrayIndexOutOfBoundsException:</span><br><span class="line">Array index out <span class="keyword">of</span> range:<span class="number">17</span></span><br><span class="line">  at java.util.<span class="module-access"><span class="module"><span class="identifier">Vector</span>.</span></span>remove(<span class="module-access"><span class="module"><span class="identifier">Vector</span>.</span></span>java:<span class="number">777</span>)</span><br><span class="line">  at org.fenixsoft.mulithread.<span class="module-access"><span class="module"><span class="identifier">VectorTest$1</span>.</span></span>run(<span class="module-access"><span class="module"><span class="identifier">VectorTest</span>.</span></span>java:<span class="number">21</span>)</span><br><span class="line">  at java.lang.<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>run(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>java:<span class="number">662</span>)</span><br></pre></td></tr></table></figure><p>很明显，尽管这里使用到的 Vector的get()、remove()和size() 方法都是 同步的，<br>但是在 多线程 的环境下，如果不在 方法调用端 做额外的同步措施 的话，<br>使用这段代码 仍然是不安全的，因为如果另一个线程 恰好在错误的时间里 删除了一个元素，<br>导致序号 i 已经不再可用的话，<br>再用 i 访问数组就会 抛出一个ArrayIndexOutOfBoundsException</p><p>如果要保证这段代码能正确执行下去，我们不得不把 removeThread和printThread 的定义改成如代码清单13-3所示的样子。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                                代码清单 <span class="number">13</span><span class="number">-3</span> 必须加入同步 以保证Vector访问的线程安全性</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</span><br><span class="line">    synchronized(<span class="built_in">vector</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="built_in">vector</span>.<span class="built_in">remove</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</span><br><span class="line">    synchronized(<span class="built_in">vector</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>((<span class="built_in">vector</span>.<span class="built_in">get</span>(i)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h6 id="3-相对线程安全"><a href="#3-相对线程安全" class="headerlink" title="3.相对线程安全"></a>3.相对线程安全</h6><p>相对的 线程安全 就是我们 通常意义上 所讲的 线程安全，<br>它需要 保证 对这个对象 单独的操作 是 线程安全的，<br>我们在 调用的时候 不需要做 额外的保障措施，但是对于一些 特定顺序 的 连续调用，<br>就可能需要在 调用端 使用 额外的同步手段 来保证 调用的正确性。</p><p>上面代码清单13-2和代码清单13-3就是 相对线程安全的 明显的 案例。</p><p>在Java语言中，大部分的 线程安全类 都属于这种类型，例如 Vector、HashTable、Collections的synchronizedCollection() 方法包装的集合 等。</p><h6 id="4-线程兼容"><a href="#4-线程兼容" class="headerlink" title="4.线程兼容"></a>4.线程兼容</h6><p>线程兼容 是指 对象本身 并不是 线程安全的，<br>但是可以通过在 调用端 正确地 使用 同步手段 来保证对象 在并发环境中 可以安全地使用，<br>我们平常说 一个类不是线程安全的，绝大多数时候指的是这一种情况。</p><p>Java API中大部分的类 都是属于 线程兼容的，如与前面的 Vector和HashTable 相对应的集合类 ArrayList和HashMap 等。</p><h6 id="5-线程对立"><a href="#5-线程对立" class="headerlink" title="5.线程对立"></a>5.线程对立</h6><p>线程对立 是指无论 调用端 是否采取了 同步措施，<br>都无法在 多线程环境中 并发使用的代码。</p><p>由于Java语言天生就具备 多线程特性，线程对立 这种 排斥多线程的代码 时很少出现的，而且通常都是 有害的，应当尽量避免。</p><p>一个线程对立 的例子是 Thread 类的 suspend() 和 resume() 方法，<br>如果有两个线程 同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，<br>如果并发进行的话，无论调用时 是否进行了同步，目标线程都是存在 死锁风险 的，<br>如果 suspend() 中断的线程 就是 即将要执行 resume() 的那个线程，那就肯定要产生 死锁 了。</p><p>也正是由于这个原因， suspend() 和 resume() 方法已经被 JDK 声明废弃（@Deprecated）了。</p><p>常见的 线程对立 的操作还有 System.setIn()、System.setOut() 和 System.runFinalizersOnExit()等。</p><h5 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h5><p>了解了 什么是线程安全 之后，紧接着的一个问题就是我们应该 如何实现线程安全，<br>这听起来似乎是一件由代码如何编写来决定的事情，确实，如何实现线程安全 与 代码编写 有很大的关系，<br>但 虚拟机 提供的 同步和锁机制 也起到了非常重要的作用。</p><p>本节中，代码编写如何实现线程安全 和 虚拟机如何实现同步与锁 这两者都会有所涉及，相对而言更偏重后者一些，<br>只要读者了解了 虚拟机线程安全手段 的运作过程，自己去思考代码如何编写并不是一件困难的事情。</p><p>（周大大，你是认真的吗？😭😭😭 说出这句话的时候，考虑过像我这种小白的感受吗？🙃🙃🙃）</p><h6 id="1-互斥同步"><a href="#1-互斥同步" class="headerlink" title="1.互斥同步"></a>1.互斥同步</h6><p>互斥同步（Mutual Exclusion &amp; Synchronization） 是常见的一种 并发正确性保障手段。</p><p>同步 是指在 多个线程 并发访问 共享数据时，保证 共享数据 在同一个时刻 只被一个（或者是一些，使用信号量的时候）线程使用。</p><p>而 互斥 是 实现同步 的 一种手段，<br>临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的 互斥实现方式。</p><p>因此，在这4个字里面，互斥 是 因， 同步 是 果；互斥 是 方法，同步 是 目的。</p><p>在 Java 中，最基本的 同步互斥 手段就是 synchronized关键字，<br>synchronized关键字 经过 编译 之后， 会在 同步块 的前后 分别形成 monitorenter和monitorexit 这两个字节码指令，<br>这两个字节码 都需要一个 reference 类型的参数来指明要 锁定和解锁 的对象。</p><p>如果Java程序中的 synchronized明确指定了 对象参数，那就是 这个对象的reference；<br>如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的 对象实例 或 Class对象 来作为 锁对象。</p><p>根据 虚拟机规范 的要求，<br>在 执行 monitorenter 指令时，<br>首先 要尝试 获取 对象的锁。</p><p>如果 这个对象 没被 锁定，<br>或者 当前线程 已经拥有了 那个对象的锁，<br>把 锁 的 计数器 加1，<br>相应的，<br>在 执行 monitorexit 指令时 会将 锁计数器 减1，<br>当计数器为0时，锁 就 释放。</p><p>如果 获取 对象锁 失败，那 当前线程 就要 阻塞等待，直到 对象锁 被 另外一个线程 释放为止。</p><p>在 虚拟机规范 对 monitorenter和monitorexit 的行为描述中，有两点是需要特别注意的。</p><p>首先，synchronized同步块 对 同一条线程 来说 是可重入的，不会出现 自己把自己 锁死的问题。</p><p>其次，同步块 在 已进入的线程 执行完之前，会 阻塞 后面其他线程的进入。</p><p>第12章讲过，Java的线程 是映射到 操作系统 的 原生线程 之上的，如果要 阻塞或唤醒 一个线程，都需要 操作系统来帮忙完成，<br>这就需要从 用户态 转换到 核心态 中，因此 状态转换 需要耗费 很多的处理器时间。</p><p>对于 代码简单的 同步块（如被 synchronized修饰的 getter() 或 setter() 方法），<br>状态转换 消耗的时间 有可能比 用户代码 执行的时间 还要长。</p><p>所以 synchronized 是Java语言中一个 重量级（Heavyweight）的操作，有经验的程序员都会在 确实必要 的情况下 才使用这种操作。</p><p>而 虚拟机本身 也会进行一些 优化，<br>譬如在通知 操作系统阻塞线程 之前 加入一段 自旋等待过程，避免频繁地 切入到 核心态 之中。</p><p>除了 synchronized 之外，我们还可以使用 java.util.concurrent(下文称J.U.C) 包中的 重入锁（ReentrantLock） 来 实现同步，<br>在基本用法上， ReentrantLock与synchronized 很相似，<br>它们都具备一样的 线程重入特性，只是代码写法上有点区别，<br>一个表现为 API层面的 互斥锁（ lock()和unlock()方法 配合 try/finally语句块 来完成），<br>另一个表现为 原生语法层面的互斥锁。</p><p>不过，相比 synchronized，ReentrantLock 增加了一些 高级功能，<br>主要有以下3项：<br>等待可中断、可实现公平锁、以及 锁可以绑定多个条件。</p><p>等待可中断 是指 当持有锁的线程 长期不释放锁 的时候，正在 等待的线程 可以选择放弃等待，改为处理其他事情，可中断特性 对处理执行时间非常长的 同步块 很有帮助。</p><p>公平锁 是指 多个线程 在等待 同一个锁 时，必须按照 申请锁 的时间顺序 来依次 获得锁；<br>而 非公平锁 则不保证 这一点，<br>在 锁 被释放时，任何一个 等待锁的线程 都有机会 获得锁。<br>synchronized 中 的 锁 是非公平的，ReentrantLock 默认情况下  也是非公平的，但可以通过 带布尔值 的 构造函数 要求使用 公平锁。</p><p>锁绑定多个条件 是指 一个ReentrantLock对象 可以同时 绑定多个Condition对象，<br>而在 synchronized中， 锁对象 的 wait()和notify()或notifyAll()方法 可以实现一个 隐含的条件，<br>如果要和 多于一个的条件关联的时候， 就不得不 额外地添加一个锁，<br>而 ReentrantLock 则无需这样做，只需要 多次调用 newCondition()方法 即可。</p><p>如果需要使用上述功能，选用 ReentrantLock 是一个很好的选择，<br>那如果 是基于 性能考虑呢？<br>关于 synchronized和ReentrantLock 的 性能问题，<br>Brian Goetz对这两种锁在 JDK1.5与单核处理器，以及 JDK1.5与双Xeon处理器 环境下做了一组 吞吐量对比的实验，实验结果如图13-1和图13-2所示。</p><blockquote><p>本例中的数据及图片来源于 Brian Goetz 为 IBM developerWorks 撰写的论文：《Java theory and practice:More flexible, scalable locking in JDK5.0》，<br>原文地址是：<code>http://www.ibm.com/developerworks/java/library/j-jtp10264/?S_TACT= 105AGX53&amp;S_CMP=cn-a-j</code>。</p></blockquote><p>（该链接有效，但是，我看的很是艰难😭😭😭😭救救这苦命的孩子吧，就像当初接入paypal支付🙃🙃🙃🙃）</p><p>从图13-1和图13-2可以看出，<br>多线程环境下 synchronized的吞吐量下降得 非常严重，<br>而 ReentrantLock 则能基本保持在同一个 比较稳定的水平 上。</p><p>与其说 ReentrantLock 性能好，还不如说 synchronized 还有非常大的优化余地。</p><p>后续的技术发展也证明了这一点，JDK1.6中加入了很多针对 锁的优化措施（13.3节我们就会讲解这些 优化措施），<br>JDK1.6发布之后，人们就发现 synchronized与ReentrantLock 的 性能 基本上是 完全持平 了。</p><p>因此，如果读者的程序 是使用 JDK1.6 或以上 部署 的话，<br>性能因素 就不再是 选择ReentrantLock 的理由了，<br>虚拟机 在 未来的性能改进中 肯定也会更加偏向于 原生的synchronized，<br>所以还是提倡在 synchronized 能实现需求的情况下，优先考虑使用 synchronized 来进行 同步。</p><h6 id="2-非阻塞同步"><a href="#2-非阻塞同步" class="headerlink" title="2.非阻塞同步"></a>2.非阻塞同步</h6><p>互斥同步 最主要的问题 就是 进行线程 阻塞和唤醒 所带来的的 性能问题，<br>因此这种 同步也称为 阻塞同步（Blocking Synchronization）。</p><p>从 处理问题的方式 上说，<br>互斥同步 属于一种 悲观的 并发策略，总是认为 只要不去做 正确的 同步措施（例如加锁），那就肯定会出现问题，<br>无论 共享数据 是否真的会出现竞争，它都要 进行加锁<br>（这里讨论的是 概念模型，实际上 虚拟机 会优化很大一部分 不必要的 加锁）、<br>用户态和心态转换、维护锁计数器 和 检查 是否有 被阻塞的线程 需要唤醒 等操作。</p><p>（这也就是所谓的 总有刁民想害朕 了）</p><p>随着 硬件指令集 的发展，我们有了另外一个选择：基于 冲突检测 的 乐观并发策略，<br>通俗地说，就是先进行操作，<br>如果没有其他线程 争用共享数据，那操作就成功了；<br>如果 共享数据 有争用，产生了 冲突，那就再采取其他的 补偿措施（最常见的补偿措施就是 不断地重试，直到成功为止），<br>这种 乐观的并发策略 的许多实现 都不需要把 线程挂起，因此这种 同步操作 称为 非阻塞同步（Non-Blocking Synchronization）。</p><p>为什么笔者说使用 乐观并发策略 需要 “硬件指令集的发展” 才能进行呢？</p><p>因为我们需要 操作和冲突检测 这两个步骤 具备 原子性，靠什么来保证呢？</p><p>如果这里 再使用 互斥同步 来保证就失去意义了，所以我们只能靠 硬件 来完成这件事情，<br>硬件 保证一个从 语义 上看起来需要多次操作的性能 只通过 一条处理器指令 就能完成，这类指令常用的有：</p><p>(我大概一辈子也用不到这些个东西)</p><ul><li>测试并设置（Test-and-Set）</li><li>获取并增加（Fetch-and-Increment）</li><li>交换（Swap）</li><li>比较并交换（Compare-and-Swap，下文称 CAS）</li><li>加载链接/条件存储（Load-Linked/Store-Conditional，下文称LL/SC）</li></ul><p>(但是还是得努力去试试。不怕一万就怕万一。)</p><p>其中，前面的3条 是20世纪就已经存在于 大多数指令集之中的 处理器指令，</p><p>后面的两条是 现代处理器 新增的，而且这两条指令的 目的和功能 是类似的。</p><p>在 IA64、x86 指令集 中有 cmpxchg指令 完成 CAS功能，<br>在 sparc-TSO 也有 casa指令 实现，而在 ARM 和 PowerPC 架构下，则需要使用 一对 ldrex/strex 指令 来完成 LL/SC 的功能。</p><p>CAS指令 需要有3个操作数，分别是 内存位置（在Java中可以简单理解为 变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。</p><p>CAS指令 执行时，当且仅当 V 符合 旧预期值A 时，处理器 用 新值B 更新 V的值，否则它就不执行更新，<br>但是无论 是否更新了 V的值，都会返回 V的旧值，上述的处理过程是一个 原子操作。</p><p>在 JDK1.5 之后，Java程序 中才可以使用 CAS 操作，<br>该操作由 sun.misc.Unsafe类 里面的 compareAndSwapInt() 和 compareAndSwapLong() 等几个方法包装提供，<br>虚拟机 在 内部 对这些方法做了特殊处理，<br>即时编译出来的结果 就是一条 平台相关的 处理器CAS指令，没有方法调用的过程，或者可以认为是无条件 内联 进去了。</p><blockquote><p>这种被 虚拟机 特殊处理 的方法称为 固有函数（Intrinsics），类似的 固有函数 还有Math.sin()等。</p></blockquote><p>由于 Unsafe类 不是提供给 用户程序 调用的类（Unsafe.getUnsafe()的代码中 限制了只有 启动类加载器（Bootstrap ClassLoader） 加载的Class 才能访问它），<br>因此，如果不采用 反射手段 ， 我们只能通过其他的 Java API来间接使用它，如 J.U.C包 里面的 整数原子类，其中的 compareAndSet()和getAndIncrement() 等方法都是用了 Unsafe类 的 CAS操作。</p><p>我们不妨拿一段在第12章中没有解决的问题代码来看看 如何使用CAS操作来避免阻塞同步 ，代码如代码清单12-1所示。</p><p>我们曾经通过这段20个线程 自增10000次 的代码来证明 volatile变量不具备原子性，那么如何才能让它 具备原子性 呢？</p><p>把 “race++”操作或increase() 方法用 同步块 包裹起来当然是一个办法，但是如果改成如代码清单13-4所示的代码，那效率将会提高许多。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">                                代码清单 <span class="number">13</span><span class="number">-4</span> Atomic的原子自增运算</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Atomic 变量自增运算测试</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @author zzm</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger race = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">      race.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws Exception</span>&#123;</span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++)&#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">          @Override</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++)&#123;</span><br><span class="line">              increase();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threads[i].start();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">          thread.<span class="built_in">yield</span>();</span><br><span class="line"></span><br><span class="line">      System.out.<span class="built_in">println</span>(race);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p>200000</p><p>使用 AtomicInteger 代替 int 后，程序输出了正确的结果，<br>一切都要归功于 incrementAndGet()方法 的 原子性。<br>它的实现 其实非常 简单，如代码清单13-5所示。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">                                代码清单 13-5 incrementAndGet()方法的JDK源码</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">/*<span class="strong">*</span></span><br><span class="line"><span class="strong">  *</span> Atomically  increment by one the current value.</span><br><span class="line"><span class="code">  * @return the updated value</span></span><br><span class="line"><span class="code">  */</span></span><br><span class="line"><span class="code">  public final int incrementAndGet()&#123;</span></span><br><span class="line"><span class="code">    for(;;)&#123;</span></span><br><span class="line"><span class="code">      int current = get();</span></span><br><span class="line"><span class="code">      int next = current + 1;</span></span><br><span class="line"><span class="code">      if(compareAndSet(current, next))&#123;</span></span><br><span class="line"><span class="code">        return next;</span></span><br><span class="line"><span class="code">      &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">  &#125;</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>incrementAndGet()方法 在一个 无限循环 中，<br>不断尝试 将一个比当前值 大1的新值 赋值给自己。<br>如果失败了，那说明在执行 “获取-设置” 操作的时候 值已经有了修改，<br>于是 再次循环 进行下一次操作，直到设置成功为止。</p><p>尽管 CAS 看起来很美，但显然这种操作无法涵盖 互斥同步的所有使用场景，<br>并且 CAS 从语义上来说 并不是完美的，存在这样一个 逻辑漏洞：<br>如果一个 变量V 初次读取的时候是 A值，<br>并且在准备赋值的时候 检查到它仍然为A值，<br>那我们就能说它的值 没有被其他线程改变过了吗？<br>如果在这段期间 它的值曾经被改成了B， 后来又被改回A，<br>那 CAS操作 就会误认为它 从来没有被改变过。</p><p>这个 漏洞 称为 CAS操作 的 “ABA问题”。</p><p>J.U.C包 为了解决这个问题，提供了一个带有标记的 原子引用类“AtomicStampedReference”，<br>它可以通过控制 变量值的版本 来保证 CAS的正确性。</p><p>不过目前来说这个类 比较“鸡肋”，大部分情况下 ABA问题 不会影响 程序并发的正确性，<br>如果需要 解决ABA问题，改用传统的 互斥同步 可能会比 原子类更高效。</p><h6 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3.无同步方案"></a>3.无同步方案</h6><p>要保证 线程安全，并不是一定就要进行 同步，两者没有 因果关系。</p><p>同步 只是保证 共享数据争用时的正确性 的手段，<br>如果一个方法 本来就不涉及 共享数据，<br>那它自然就无需 任何同步措施 去保证 正确性，<br>因此会有一些代码天生就是 线程安全的，笔者简单地介绍其中的两类。</p><p><strong>可重入代码（Reentrant Code）</strong>:<br>这种代码也叫做 纯代码（Pure Code），<br>可以在 代码执行的任何时刻 中断它，<br>转而去 执行另外一段代码（包括 递归调用它本身），<br>而在 控制权 返回后，<br>原来的程序 不会出现任何错误。</p><p>相对 线程安全 来说，<br>可重入性 是更基本的特性，<br>它可以保证 线程安全，<br>即所有的 可重入 的代码都是 线程安全的，<br>但是并非所有的 线程安全 的代码都是 可重入的。</p><p>可重入代码 有一些 共同的特征，<br>例如 不依赖存储在堆上的数据 和 公用的系统资源、用到的状态量 都由参数中传入、不调用非可重入的方法等。</p><p>我们可以通过一个简单的原则来判断 代码是否具备可重入性：<br>如果一个方法，它的返回结果是可以 预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足 可重入性 的要求，当然也就是 线程安全的。</p><p><strong>线程本地存储（Thread Local Storage）</strong>:<br>如果一段代码中 所需要的数据 必须与 其他代码 共享，<br>那就看看这些 共享数据的代码 是否能保证 在同一个线程中 执行？<br>如果能保证，我们就可以把 共享数据的可见范围 限制在 同一个线程之内，<br>这样，无须 同步  也能保证 线程之间 不出现 数据争用 的问题。</p><p>符合这种特点的应用并不少见，<br>大部分使用 消费队列的架构模式（如“生产者-消费者”模式）都会将 产品的消费过程 尽量在 一个线程中 消费完，<br>其中最重要的一个应用实例就是 经典Web交互模型 中的 “一个请求对应一个服务器线程”（Thread-per-Request） 的处理方式，<br>这种 处理方式的广泛应用 使得很多 Web服务端应用 都可以使用 线程本地存储 来解决 线程安全问题。</p><p>Java语言中，<br>如果 一个变量 要被 多线程 访问，可以使用 volatile关键字 声明它为 “易变的”；<br>如果 一个变量 要被 某个线程 独享，Java中就没有类似C++中 __declspec(thread)这样的关键字，<br>不过还是可以通过 java.lang.ThreadLocal类 来实现 线程本地存储 的功能。</p><blockquote><p>在 Visual C++ 中是 “<strong>declspec(thread)”关键字，而在 GCC 中是“</strong>thread”。</p></blockquote><p>每一个线程的 Thread对象中都有一个 ThreadLocalMap对象，<br>这个对象 存储了一组 以 ThreadLocal.threadLocalHashCode 为 键 ，以 本地线程变量 为 值 的 K-V值对，<br>ThreadLocal对象 就是 当前线程的ThreadLocalMap的 访问入口，<br>每一个 ThreadLocal对象 都包含了 一个独一无二的 threadLocalHashCode值，<br>使用这个值 就可以在线程 K-V值对 中找回 对应的本地线程变量。</p><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><p>高效并发 是从 JDK1.5到JDK1.6的一个 重要改进，<br>HotSpot虚拟机 开发团队在这个版本上花费了大量的精力去实现 各种锁优化技术，<br>如 适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，<br>这些技术都是为了 在线程之间 更高效地 共享数据，<br>以及 解决竞争问题，<br>从而 提高程序的执行效率。</p><h5 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h5><p>前面我们讨论 互斥同步 的时候，<br>提到了 互斥同步 对性能最大的影响 是阻塞的实现，<br>挂起线程 和 恢复线程 的操作都需要 转入内核态 中完成，<br>这些操作给系统的 并发性能 带来了很大的压力。</p><p>同时，虚拟机 的开发团队也注意到在许多应用上，<br>共享数据的锁定状态 只会持续很短的一段时间，<br>为了这段时间 去挂起和恢复线程 并不值得。</p><p>如果 物理机器 有一个以上的 处理器，<br>能让 两个或两个以上的线程 同时并行执行，<br>我们就可以让  后面请求锁的那个线程 “稍等一下”，<br>但不放弃 处理器的执行时间，<br>看看 持有锁的线程 是否很快就会释放锁。</p><p>为了让线程等待，我们只需让 线程执行一个忙循环（自旋），这项技术就是所谓的 自旋锁。</p><p>自旋锁 在 JDK1.4.2 中就已经引入，<br>只不过 默认 是 关闭的，<br>可以使用 -XX:+UseSpinning 参数来开启，<br>在 JDK1.6 中就已经改为 默认开启了。</p><p>自旋等待 不能代替 阻塞，<br>且先不说对 处理器数量的要求，<br>自旋等待 本身虽然 避免了线程切换的开销，<br>但它是要 占用处理器时间的，<br>因此，如果 锁 被占用的时间 很短，自旋等待 的 效果就会非常好，<br>反之，如果 锁 被占用的时间 很长，那么 自旋的线程 只会 白白消耗处理器资源，<br>而不会做 任何有用的工作，<br>反而会带来 性能上的浪费。</p><p>因此，自旋等待的时间 必须要有 一定的限度，<br>如果 自旋超过了限定的次数 仍然没有 成功获得锁，<br>就应当使用 传统的方式 去挂起线程了。</p><p>自旋次数 的 默认值 是 10次，用户可以使用参数-XX:PreBlockSpin 来更改。</p><p>在 JDK1.6 中引入了 自适应的自旋锁。</p><p>自适应 意味着 自旋的时间 不再固定了，<br>而是由 前一次在同一个锁上的自旋时间 及 锁的拥有者的状态 来决定。</p><p>如果在 同一个锁对象上，<br>自旋等待 刚刚成功获得过锁，并且 持有锁的线程 正在运行中，<br>那么 虚拟机 就会认为 这次自旋 也很有可能再次成功，<br>进而它将 允许 自旋等待 持续相对更长的时间，比如100个循环。</p><p>另外，如果 对于某个锁，自旋 很少成功获得过，<br>随着 程序运行和性能监控信息 的 不断完善，<br>虚拟机 对 程序锁 的 状况预测 就会越来越准确，<br>虚拟机 就会变得 越来越“聪明”了。</p><h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除 是指 虚拟机 即时编译器 在运行时，<br>对一些代码上 要求 同步，但是被检测到 不可能存在共享数据竞争的锁 进行 消除。</p><p>锁消除 的 主要判定依据 来源于 逃逸分析 的 数据支持（第11章已经讲解过 逃逸分析技术），<br>如果判断 在一段代码中，堆 上的所有 数据 都不会 逃逸出去 从而被 其他的线程访问到，<br>那就可以把它们当做 堆上数据对待，<br>认为它们是 线程私有的，同步加锁 自然也就无须运行。</p><p>也许读者会有疑问， 变量 是否逃逸，<br>对于 虚拟机 来说需要使用 数据流分析 来确定，<br>但是程序员自己应该时很清楚的，怎么会在 明知道不存在数据争用的情况下 要求同步呢？<br>答案是有许多 同步措施 并不是程序员自己加的，<br>同步的代码 在java程序中的 普遍程度 也许超过了大部分读者的想象。</p><p>我们来看看代码清单13-6中的例子，这段非常简单的代码 仅仅是输出3个字符串相加的结果，<br>无论是 源码字面上 还是 程序语义上 都没有同步。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">                                代码清单 13-6 一段看起来没有同步的代码</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">public String concatString(String s1,String s2,String s3)&#123;</span><br><span class="line"><span class="code">  return s1+s2+s3;</span></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>我们也知道，<br>由于 String是一个不可变的类，对字符串的连接操作 总是通过生成 新的String对象 来进行的，<br>因此 Javac编译器 会对 String连接 做 自动优化。</p><p>在 JDK1.5 之前，会转化为 StringBuffer对象的连续append()操作，<br>在 JDK1.5及以后的版本中，会转为 StringBuilder对象的连续append()操作，<br>即代码清单13-6中的代码 可能会变成代码清单 13-7的样子。</p><blockquote><p>客观地说，既然谈到 锁消除与逃逸分析，那 虚拟机 就不可能是 JDK1.5之前的版本，实际上会转化为 非线程安全的StringBuilder 来完成字符串拼接，并不会加锁， 但这也不影响笔者用这个例子证明 Java对象中同步的普遍性。</p></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">                                代码清单 13-7 Javac转化后的字符串连接操作</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">public String concatString(String s1,String s2,String s3)&#123;</span><br><span class="line"><span class="code">  StringBuffer sb = new StringBuffer();</span></span><br><span class="line"><span class="code">  sb.append(s1);</span></span><br><span class="line"><span class="code">  sb.append(s2);</span></span><br><span class="line"><span class="code">  sb.append(s3);</span></span><br><span class="line"><span class="code">  return sb.toString();</span></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>现在大家还认为这段代码没有涉及同步吗？<br>每个 StringBuffer.append() 方法中都有一个 同步块，锁就是sb对象。<br>虚拟机 观察 变量sb，很快就会发现它的 动态作用域 被限制在 concatString()方法内部。</p><p>也就是说，sb的所有引用 永远不会 “逃逸” 到 concatString() 方法之外，<br>其他线程 无法访问 到 它，<br>因此，虽然这里有锁，但是可以被 安全地消除掉，<br>在 即时编译 之后，这段代码就会忽略掉 所有的同步块 而直接执行了。</p><h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>原则上，我们在编写代码的时候，总是推荐将 同步块的作用范围 限制得 尽量小——只在 共享数据的实际作用域 中才进行同步，<br>这样是为了 使得需要 同步的操作数量 尽可能 变小，<br>如果存在 锁竞争，那等待 锁的线程 也能尽快拿到锁。</p><p>大部分情况下，上面的原则都是正确的，<br>但是如果 一系列的连续的动作 都对 同一个对象 反复加锁和解锁，<br>甚至 加锁操作 是出现在 循环体中的，<br>那即是没有 线程竞争，频繁地进行互斥同步操作 也会导致 不必要的性能损耗。</p><p>代码清单13-7中 连续的append()方法就属于这类情况。</p><p>如果 虚拟机 探测到有这样 一串零碎的操作 都对 同一个对象加锁，<br>将会把 加锁同步的范围 扩展（粗化）到 整个操作序列的外部，<br>以代码清单13-7为例，就是扩展到第一个append()操作之前 直至 最后一个append()操作之后，<br>这样只需要 加锁一次 就可以了。</p><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>轻量级锁 是 JDK1.6之中 加入的 新型锁机制，<br>它名字中的 “轻量级” 是 相对于 使用 操作系统互斥量来实现的传统锁 而言的，<br>因此 传统的锁机制 就称为 “重量级”锁。</p><p>首先需要强调的一点是， 轻量级锁 并不是用来 代替 重量级锁 的，<br>它的本意 是在 没有多线程竞争的前提下，<br>减少 传统的重量级锁 使用 操作系统互斥量 产生的性能消耗。</p><p>要理解 轻量级锁，<br>以及后面会讲到的 偏向锁的原理和运作过程，<br>必须从 HotSpot虚拟机的对象（对象头部分）的内存布局开始介绍。</p><p>HotSpot虚拟机的对象头（Object Header）分为两部分信息，<br>第一部分 用于存储 对象自身的 运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age）等，<br>这部分数据的长度 在32位和64位的 虚拟机中 分别为 32bit和64bit，官方称它为 “Mark Word”，<br>它是 实现轻量级锁 和 偏向锁 的 关键。</p><p>另一部分 用于存储 指向方法区对象 类型数据的指针，<br>如果是数组对象的话，还会有一个额外的部分 用于存储 数组长度。</p><p>对象头信息 是与 对象自身定义的 数据无关的 额外存储成本，<br>考虑到 虚拟机的空间效率，<br>Mark Word 被设计成一个 非固定的数据结构 以便在 极小的空间内 存储尽量多的信息，<br>它会根据对象的状态 复用 自己的 存储空间。</p><p>例如，在32位的HotSpot虚拟机中 对象未被锁定的状态下，<br>Mark Word的 32bit空间的 25bit 用于存储 对象哈希码（HashCode），<br>4bit 用于存储 对象分代年龄，<br>2bit 用于存储 锁标志位，<br>1bit 固定为 0，<br>在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下 对象的存储内容 见表13-1。</p><table>  <thead>    <tr>      <th colspan="2">表 13-1 HotSpot虚拟机对象头 Mark Word</th>    </tr>  </thead>  <tr>    <th>存储内容</th>    <th>标志位</th>    <th>状态</th>  </tr>  <tr>    <td>对象哈希码、对象分代年龄</td>    <td>01</td>    <td>未锁定</td>  </tr>    <tr>    <td>指向锁记录的指针</td>    <td>00</td>    <td>轻量级锁定</td>  </tr>    <tr>    <td>指向重量级锁的指针</td>    <td>10</td>    <td>膨胀（重量级锁定）</td>  </tr>   <tr>    <td>空，不需要记录信息</td>    <td>11</td>    <td>GC标记</td>  </tr>   <tr>    <td>偏向线程ID、偏向时间戳、对象分代年龄</td>    <td>01</td>    <td>可偏向</td>  </tr></table><p>简单地介绍了 对象的内存布局 后，<br>我们把话题返回到 轻量级锁的执行过程上。</p><p>在代码进入 同步块 的时候，<br>如果此 同步对象 没有被 锁定（锁标志位 为“01”状态），<br>虚拟机 首先将 在当前线程的 栈帧 中 建立一个名为 锁记录（Lock Record）的空间，<br>用于存储 锁对象目前的Mark Word的拷贝<br>（官方把这份拷贝加了一个 Displaced前缀，即 Displaced Mark Word），<br>这时候 线程堆栈 与 对象头的状态 如图13-3所示。</p><p>然后，<br>虚拟机 将使用 CAS操作 尝试将 对象的Mark Word 更新为指向 Lock Record的指针。</p><p>如果这个更新动作 成功了，那么这个线程 就拥有了 该对象的锁，<br>并且 对象Mark Word 的 锁标志位（Mark Word的最后2bit）将转变为“00”，<br>即表示此对象处于 轻量级锁定状态，<br>这时候 线程堆栈与对象头的状态 如图13-4所示。</p><blockquote><p>图13-3和图13-4来源于 HotSpot虚拟机的一位Senior Staff Engineer——Paul Hohensee所写的PPT “The Hotspot Java Virtual Machine”。</p></blockquote><p>如果这个更新动作 失败了，虚拟机 首先会检查 对象的Mark Word 是否指向 当前线程的栈帧，<br>如果只说明 当前线程已经拥有了这个对象的锁，那就可以直接 进入同步块 继续执行，<br>否则说明 这个锁对象 已经被其他线程 抢占了。</p><p>如果有两条以上的 线程 争用同一个锁，<br>那 轻量级锁 就不再有效，要 膨胀 为 重量级锁，<br>锁标志 的 状态值 变为 “10“，<br>Mark Word中存储的 就是指向 重量级锁（互斥量）的指针，<br>后面 等待锁的线程 也要进入 阻塞状态。</p><p>上面描述的是 轻量级锁的枷锁过程，<br>它的 解锁过程 也是通过 CAS操作来进行的，<br>如果 对象的Mark Word 仍然指向这 线程的锁记录，<br>那就用 CAS操作 把 对象的Mark Word 和 线程中复制的Displaced Mark Word替换回来，<br>如果替换成功，整个同步过程就完成了。<br>如果替换失败，说明有其他线程 尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</p><p>轻量级锁 能提升 程序同步性能 的依据是 “对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，<br>这是一个经验数据。</p><p>如果没有竞争，轻量级锁使用 CAS操作 避免了使用 互斥量的开销，<br>但如果存在 锁竞争，除了互斥量的开销以外，还额外发生了 CAS操作，<br>因此在 有竞争的情况下， 轻量级锁 会比 传统的重量级锁 更慢。</p><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁 也是 JDK1.6 中引入的一项 锁优化，<br>它的目的是 消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。</p><p>如果说 轻量级锁 是在 无竞争的情况下 使用 CAS操作 去 消除同步使用的互斥量，<br>那 偏向锁 就是在 无竞争的情况下 想把 整个同步都消除掉，连CAS操作都不做了。</p><p>偏向锁的 “偏”，就是偏心的“偏”、偏袒的“偏”，<br>它的意思是 这个锁 会偏向于 第一个 获得它的线程，<br>如果在接下来的执行过程中，该锁 没有被其他的 线程获取，则持有 偏向锁的 线程 将永远不需要再进行 同步。</p><p>如果读者读懂了前面 轻量级锁 中 关于对象头Mark Word与线程之间 的 操作过程，<br>那 偏向锁的原理 理解起来就会很简单。</p><p>假设当前 虚拟机 启用了 偏向锁（启用参数 -XX:+UseBiasedLocking，这是 JDK1.6的默认值），<br>那么，当 锁对象 第一次 被线程获取的时候，虚拟机 将会把 对象头中的 标志位 设为 “01”，即偏向模式。</p><p>如果使用 CAS操作 把 获取到这个锁的线程的ID 记录在 对象的Mark Word之中，<br>如果 CAS操作 成功<br>持有 偏向锁的线程 以后每次进入这个锁 相关的同步块时，虚拟机都可以不再进行 任何同步操作<br>（例如 LOcking、Unlocking 及对 Mark Word的Update 等）。</p><p>当有 另外一个线程 去尝试 获取这个锁时，<br>偏向模式 就 宣告结束。</p><p>根据 锁对象 目前是否处于 被锁定 的状态，<br>撤销 偏向（Revoke Bias）后 恢复到 未锁定（标志位为 “01”） 或 轻量级锁定（标志位为“00”）的状态，<br>后续的同步操作 就如上面介绍的 轻量级锁那样执行。</p><p>偏向锁、轻量级锁的状态转化 及 对象的Mark Word的关系如图13-5 所示。</p><p>偏向锁 可以提高 带有 同步 但 无竞争的 程序性能。</p><p>它同样是一个带有 效益权衡（Trade Off）性质的优化，<br>也就是说，它并不一定总是对 程序运行 有利，<br>如果 程序中大多数的锁 总是被 多个不同的线程 访问，<br>那 偏向模式就是多余的。</p><p>在具体问题具体分析的前提下，有时候使用参数 -XX:-UseBiasedLocking 来 禁止偏向锁优化 反而可以 提升性能。</p><h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h4><p>本章介绍了 线程安全 所涉及的 概念和分类、同步实现的方式 及 虚拟机的底层运作原理，<br>并且介绍了 虚拟机 为了实现高效并发 所采取的的 一系列 锁优化措施。</p><p>许多资深的程序员都说过，能够写出 高伸缩性的并发程序 是一门艺术，<br>而 了解并发 在系统底层 是如何实现的，则是 掌握这门艺术的 前提条件，<br>也是成长为 高级程序员的必备知识之一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深入java虚拟机-第五部分-高效并发&quot;&gt;&lt;a href=&quot;#深入java虚拟机-第五部分-高效并发&quot; class=&quot;headerlink&quot; title=&quot;深入java虚拟机-第五部分-高效并发&quot;&gt;&lt;/a&gt;深入java虚拟机-第五部分-高效并发&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
    
      <category term="面试" scheme="https://fengshana.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="虚拟机" scheme="https://fengshana.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机-Java内存模型与线程</title>
    <link href="https://fengshana.github.io/2020/05/26/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA12/"/>
    <id>https://fengshana.github.io/2020/05/26/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA12/</id>
    <published>2020-05-26T14:39:02.793Z</published>
    <updated>2020-06-05T18:03:34.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入java虚拟机-第五部分-高效并发"><a href="#深入java虚拟机-第五部分-高效并发" class="headerlink" title="深入java虚拟机-第五部分-高效并发"></a>深入java虚拟机-第五部分-高效并发</h2><h3 id="第12章-Java内存模型与线程"><a href="#第12章-Java内存模型与线程" class="headerlink" title="第12章 Java内存模型与线程"></a>第12章 Java内存模型与线程</h3><p><strong>并发处理的广泛应用</strong> 是使得 <strong>Amdah1定律 代替 摩尔定律</strong> 成为<strong>计算机性能发展源动力</strong> 的根本原因， 也是人类 “压榨” 计算机运算能力的最有利武器。  </p><blockquote><p><strong>Amdah1定律</strong> 代替 <strong>摩尔定律</strong> 成为 <strong>计算机性能发展源动力</strong> 的<strong>根本原因</strong>： <strong>并发处理的广泛应用</strong>。</p></blockquote><blockquote><p><strong>Amdah1定律</strong></p><ul><li>通过系统中 <strong>并行化与串行化</strong> 的 <strong>比重</strong> 来 <strong>描述</strong> <strong>多处理器系统</strong> 能获得的 <strong>运算加速能力</strong>；</li></ul></blockquote><blockquote><p><strong>摩尔定律</strong></p><ul><li>则用于 <strong>描述</strong> <strong>处理器</strong> <strong>晶体管数量</strong> 与 <strong>运行效率</strong> 之间的<strong>发展关系</strong>。</li></ul></blockquote><blockquote><p>这两个<strong>定律</strong> 的 <strong>更替</strong> 代表了：近年来 <strong>硬件发展</strong> 从追求 <strong>处理器频率</strong> 到 追求 <strong>多核心并行处理</strong> 的<strong>发展过程</strong>；</p></blockquote><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>多任务处理</strong> 在 <strong>现代计算机操作系统</strong> 中 几乎已是一项必备的技能了。  </p><blockquote><p><strong>现代计算机操作系统</strong> 中，<strong>多任务处理</strong> 几乎已是一项必备的技能。</p></blockquote><p>在许多情况下，让 <strong>计算机</strong> <strong>同时去做几件事情</strong>， 不仅是因为 <strong>计算机的运算能力强大</strong> 了，还要一个很重要的原因是 <strong>计算机的运算速度</strong> 与 <strong>它的存储和通信子系统速度</strong> 的 <strong>差距太大</strong>，<br><strong>大量的时间</strong>都<strong>花费</strong>在<strong>磁盘I/O</strong> 、<strong>网络通信</strong>或者 <strong>数据库访问</strong>上。</p><blockquote><p>让计算机同时去做几件事情的原因：</p><ul><li>计算机的<strong>运算能力</strong>强大</li><li>计算机的 <strong>运算速度</strong> 与 它的 <strong>存储和通信子系统</strong> <strong>速度</strong> 的<strong>差距太大</strong>；</li><li>为了<strong>避免</strong>大量的<strong>时间</strong>都<strong>花费</strong>在 <strong>磁盘I/O</strong>、<strong>网络通信</strong>、<strong>访问数据库</strong>上;</li></ul></blockquote><p>如果不希望 <strong>处理器</strong> 在<strong>大部分时间</strong>里都处于 <strong>等待其他资源的状态</strong>，<br>就必须 使用一些手段 去把 <strong>处理器的预算能力</strong> <strong>压榨</strong> 出来，<br>否则就会<strong>造成</strong>很大的<strong>浪费</strong>，<br>而让<strong>计算机</strong> <strong>同时处理几项任务</strong> 则是最容易想到、也被证明 是非常有效的“压榨”手段；</p><blockquote><p><strong>处理器</strong> 在<strong>大部分时间</strong>里 都处于 <strong>等待其他资源的状态</strong></p></blockquote><blockquote><p>解决 处理器在大部分时间里 都处于 等待其他资源的状态 的手段 or 如何将 处理器的预算能力 压榨出来：</p><ul><li>让计算机 同时处理几项任务（最容易想到、也被证明是非常有效的“压榨”手段）</li></ul></blockquote><p>除了充分利用 <strong>计算机处理器的能力</strong> 外，<strong>一个服务端</strong> <strong>同时</strong>对 <strong>多个客户端提供服务</strong> 则是另一个更<strong>具体的并发应用场景</strong>。</p><blockquote><p>具体的<strong>并发应用场景</strong>：</p><ul><li>一个服务端 同时对 多个客户端 提供服务。</li><li>充分利用计算机处理器的能力（让计算机同时处理几项任务）；</li></ul></blockquote><p><strong>衡量</strong> <strong>一个服务性能</strong> 的 <strong>高低好坏</strong>，<br><strong>每秒事务处理数（Transactions Per Second， TPS）是最重要的指标之一</strong>，<br>它代表着 <strong>一秒内</strong>  <strong>服务端</strong> <strong>平均</strong> <strong>能响应</strong> <strong>的请求总数</strong>，<br>而 <strong>TPS 值</strong> 与 <strong>程序的 并发能力</strong> 又有 非常<strong>密切</strong>的<strong>关系</strong>。</p><blockquote><p><strong>每秒事务处理数（Transactions Per Second ，TPS）</strong></p><ul><li>每秒事务处理数（Transactions Per Second ，TPS）是 <strong>衡量</strong>一个服务<strong>性能高低好坏</strong>的最重要<strong>指标</strong>之一</li><li>每秒事务处理数（Transactions Per Second ，TPS） 代表着 <strong>一秒内 服务端的 平均 能响应 的 请求总数</strong>；</li><li>每秒事务处理数（Transactions Per Second ，TPS）与 <strong>程序的并发能力</strong> 有着非常<strong>密切</strong>的<strong>关系</strong>。</li></ul></blockquote><p>对于 <strong>计算量相同</strong> 的任务， <strong>程序线程</strong> <strong>并发协调</strong> 得 越<strong>有条不紊</strong>，<strong>效率</strong>自然就会<strong>提高</strong>；<br>反之，<strong>线程之间</strong> <strong>频繁阻塞</strong> 甚至 <strong>死锁</strong>，将会大大 <strong>降低</strong> <strong>程序</strong> 的 <strong>并发能力</strong>。</p><blockquote><p>计算量相同的任务，线程之间状态不同将导致不同的结果：</p><ul><li>程序线程 并发协调 有条不紊，效率提高；</li><li>线程之间 频繁阻塞 甚至 死锁，将会大大 降低 程序 的 并发 能力；</li></ul></blockquote><p><strong>服务端</strong> 是 java语言 最擅长的领域之一，这个领域的应用 占了 Java应用中最大的一块份额，</p><blockquote><p>必须以 <strong>代码的总体规模</strong> 来<strong>衡量</strong>， <strong>服务端应用</strong> <strong>不能</strong>与 <strong>JavaCard、移动终端</strong> 这些领域去比 <strong>绝对数量</strong>。</p></blockquote><p>不过 如何写好 并发应用程序 却又是 服务端程序开发的难点之一， 处理好并发方面的问题 通常需要更多的 编码经验 来支持。  </p><blockquote><p><strong>服务端 领域的应用</strong> 占用了java应用 中最大的一块份额。<br>服务端 程序开发的难点之一：如何写好 并发应用程序；<br>处理好并发方面的问题：通常需要更多的 编码经验 来支持；</p></blockquote><p>幸好 <strong>java语言和虚拟机</strong> 提供了许多工具，把 <strong>并发编程</strong> 的门槛 降低了不少。<br>并且各种 <strong>中间件服务器</strong>、<strong>各类框架</strong> 都努力地替程序员 <strong>处理尽可能多的线程并发细节</strong>，<br>使得程序员 在编码时能 <strong>更关注业务逻辑</strong>，<br>而 <strong>不是花费大部分时间</strong>去 <strong>关注此服务</strong> <strong>会同时被多少人调用</strong>、<strong>如何协调硬件资源</strong>。</p><blockquote><p>java语言和虚拟机 提供的许多 工具，降低了 并发编程 的 门槛。<br>各种中间件服务器、各类框架的好处：</p><ul><li>各种 中间件服务器、各类框架 处理尽可能多的线程并发细节；</li><li>程序员能够关注业务逻辑，避免花费大部分时间去 关注此服务 会同时被多少人调用、如何协调硬件资源等</li></ul></blockquote><p>无论<strong>语言、中间件和框架</strong> 如何先进，开发人员都<strong>不能期望 它们能独立完成所有并发处理的事情</strong>，了解 并发的内幕 也是 称为一个高级程序员 不可缺少的课程。<br>（🙃尽管我是如此垃圾，但是我依然热爱—–个屁🙃）</p><blockquote><p>不能去期望 某种语言、中间件或者框架 能够独立完成所有并发处理的事情。</p></blockquote><p>“<strong>高效并发</strong>” 是本书 讲解java虚拟机的最后一部分，<br>将会向读者介绍  <strong>虚拟机</strong>  如何实现 <strong>多线程、多线程之间</strong> 由于 <strong>共享</strong> 和 <strong>竞争数据</strong> 而 <strong>导致的</strong> 一系列 <strong>问题</strong> 及 <strong>解决方案</strong>。</p><h4 id="硬件的效率-与-一致性"><a href="#硬件的效率-与-一致性" class="headerlink" title="硬件的效率 与 一致性"></a>硬件的效率 与 一致性</h4><p>在正式讲解 <strong>java虚拟机并发相关</strong> 的知识之前，我们先花费一点时间去了解一下 <strong>物理计算机</strong>中的 <strong>并发问题</strong>，<br><strong>物理机</strong>遇到的 <strong>并发问题</strong> 与 <strong>虚拟机中的情况</strong> 有不少<strong>相似</strong>之处，<br><strong>物理机</strong> 对 <strong>并发的处理方案</strong> 对于 <strong>虚拟机的实现</strong> 也有相当大的参考意义。</p><blockquote><p>物理机与虚拟机</p><ul><li>物理机 遇到的 并发问题 与 虚拟机中的情况 有不少相似之处；</li><li>物理机 对 并发的处理方案 对于 虚拟机的实现 也有相当大的参考意义。</li></ul></blockquote><p>“让 <strong>计算机</strong> <strong>并发执行</strong> <strong>若干个</strong> <strong>运算任务</strong>” 与 “更<strong>充分</strong> 地 <strong>利用</strong> <strong>计算机处理器的效能</strong>” 之间的因果关系，看起来顺理成章，<br>实际上他们之间的关系 并没有想象中的那么简单，<br>其中一个 重要的<strong>复杂性</strong> 来源是 绝大多数的 <strong>运算任务</strong> 都 <strong>不可能</strong> <strong>只靠</strong> <strong>处理器“计算”</strong> 就能完成，<br><strong>处理器</strong> 至少 要与 <strong>内存交互</strong>，<br>如读取运算数据、存储运算结果等，<br>这个<strong>I/O</strong>操作是很<strong>难消除</strong>的<br>（<strong>无法仅靠寄存器</strong>来<strong>完成</strong>所有运算<strong>任务</strong>）。  </p><p>由于 <strong>计算机的存储设备</strong> 与 <strong>处理器的运算速度</strong> 有几个数量级的差距，<br>所以 <strong>现代计算机系统</strong> 都不得不加入 一层 <strong>读写速度</strong> <strong>尽可能接近</strong> <strong>处理器运算速度</strong> 的 <strong>高速缓存（Cache）</strong> 来作为 <strong>内存与处理器</strong> 之间的<strong>缓冲</strong>：<br>将运算需要使用的<strong>数据</strong> <strong>复制</strong>到 <strong>缓存</strong>中，<br>让<strong>运算</strong>能<strong>快速进行</strong>，<br>当<strong>运算结束</strong>后 再从 <strong>缓存</strong> <strong>同步</strong>回 <strong>内存</strong>之中，<br>这样 <strong>处理器</strong> 就 <strong>无需等待</strong> 缓慢的 <strong>内存读写</strong> 了。</p><blockquote><p>“让计算机 并发执行 若干个运算任务” 与 “更充分地利用计算机处理器的效能”之间因果关系的复杂性来源</p><ol><li>绝大多数的运算任务都不可能只靠 处理器“计算” 就能完成</li><li>处理器 至少 要与 内存交互（如读取运算数据、存储运算结果等）；这个I/O操作是很难消除的；</li><li>无法仅靠寄存器来完成所有运算任务；</li><li>计算机的存储设备 与 处理器的运算速度 有几个数量级的 差距。</li><li>现代计算机系统中加入了 一层 (读写速度尽可能接近处理器运算速度) 的 高速缓存（Cache） 来作为 <strong>内存与处理器之间的缓冲</strong>：<ul><li>将 运算 所需要使用到的 数据 复制到 缓存 中；</li><li>让运算能快速进行；</li><li>当运算结束后，再从 缓存 同步 回 内存 之中；</li><li>这样处理器 就无需等待 缓慢的 内存读写 了；</li></ul></li></ol></blockquote><p>基于 <strong>高速缓存</strong> 的 <strong>存储交互</strong> 很好地解决了 <strong>处理器 与 内存 的速度矛盾</strong>，<br>但是也为 计算机系统 带来更高的<strong>复杂度</strong>，<br>因为它引入了一个新的问题： <strong>缓存一致性（Cache Coherence）</strong>。  </p><blockquote><p>高速缓存 的 存储交互 优缺点：</p><ul><li>优点：解决了 处理器与内存 之间的 速度矛盾；</li><li>缺点：带来了新问题-缓存一致性（Cache Coherence）</li></ul></blockquote><p>在 <strong>多处理器系统</strong> 中，每个 <strong>处理器</strong> 都有 自己的 <strong>高速缓存</strong>，而它们又 <strong>共享</strong> <strong>同一主内存（Main Memory）</strong>。</p><p>当 <strong>多个处理器的运算任务</strong> 都设计 <strong>同一块</strong> <strong>主内存区域</strong> 时，<br> 将可能导致 <strong>各自的缓存数据不一致</strong>，<br> 如果真的发生这种情况，那同步回到 主内存时 以谁的缓存数据为准呢？  </p><p>为了<strong>解决一致性的问题</strong>，<br>需要 各个 <strong>处理器</strong> <strong>访问缓存</strong> 时 都 <strong>遵循</strong> 一些 <strong>协议</strong>，<br>在<strong>读写</strong>时 要<strong>根据协议</strong> 来进行<strong>操作</strong>，<br>这类协议有 MSI、MESI（Illinois Protocl）、MOSI、Synapse、Firefly 及 Dragon Protocol 等。  </p><p>在本章中将会多次提到的 “<strong>内存模型</strong>” 一词，<br>可以理解为 在<strong>特定的操作协议</strong>下，对 <strong>特定的内存或高速缓存</strong> 进行 <strong>读写访问的过程抽象</strong>。  </p><p><strong>不同架构的物理机器</strong> 可以拥有 <strong>不一样的内存模型</strong>，<br>而 <strong>java虚拟机</strong> 也有自己的<strong>内存模型</strong>，<br>并且这里介绍的 <strong>内存访问操作</strong> 与 <strong>硬件的缓存访问操作</strong>具有很高的<strong>可比性</strong>。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---------               -----------                ----------------               ------</span><br><span class="line">|<span class="string"> 处理器 </span>|<span class="string"> &lt;----------&gt; </span>|<span class="string"> 高速缓存 </span>|<span class="string">  &lt;----------&gt; </span>|<span class="string">      缓存     </span>|<span class="string">  &lt;----------&gt; </span>|<span class="string"> 主 </span>|</span><br><span class="line">---------               -----------               |<span class="string">               </span>|<span class="string">               </span>|<span class="string">    </span>|</span><br><span class="line">---------               -----------               |<span class="string">               </span>|<span class="string">               </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string"> 处理器 </span>|<span class="string"> &lt;----------&gt; </span>|<span class="string"> 高速缓存 </span>|<span class="string">  &lt;----------&gt; </span>|<span class="string">     一致性    </span>|<span class="string">  &lt;----------&gt; </span>|<span class="string"> 内 </span>|</span><br><span class="line">---------               -----------               |<span class="string">               </span>|<span class="string">               </span>|<span class="string">    </span>|</span><br><span class="line">---------               -----------               |<span class="string">               </span>|<span class="string">               </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string"> 处理器 </span>|<span class="string"> &lt;----------&gt; </span>|<span class="string"> 高速缓存 </span>|<span class="string">  &lt;----------&gt; </span>|<span class="string">      协议     </span>|<span class="string">  &lt;----------&gt; </span>|<span class="string"> 存 </span>|</span><br><span class="line">---------               -----------                ----------------               ------</span><br></pre></td></tr></table></figure><p>除了 <strong>增加</strong> <strong>高速缓存</strong> 之外，<br>为了使得 <strong>处理器内部 的 运算单位</strong> 能尽量被 <strong>充分使用</strong>，<br><strong>处理器</strong> 可能会对 <strong>输入代码</strong> 进行 <strong>乱序执行（Out-Of-Order Execution）优化</strong>，<br><strong>处理器</strong> 会在 <strong>计算之后</strong> 将<strong>乱序执行的结果</strong> <strong>重组</strong>，<br>保证 <strong>该结果 与 顺序执行 的结果是一致的</strong>，<br>但 <strong>并不保证 程序中 各个语句 计算的先后顺序 与 输入代码中的顺序 一致</strong>，<br>因此 ，<br>如果<strong>存在 一个计算任务 依赖 另外一个 计算任务的 中间结果</strong>，<br>那么其 <strong>顺序性并不能靠 代码的先后顺序 来保证</strong>。  </p><p>与 <strong>处理器的乱序执行优化</strong> 类似，<br><strong>java虚拟机</strong> 的 <strong>即时编译器</strong> 中也有类似的 <strong>指令重排序（Instruction Reorder）优化</strong>。</p><blockquote><p>处理器内部 的 运算单位，如何尽可能被 充分利用？</p><ul><li>增加高速缓存</li><li>乱序执行（Out-Of-Order Execution）优化<ul><li>处理器 可能会对 输入代码 进行 乱序执行（Out-Of-Order Execution）优化</li><li>处理器 会在 计算之后 将 乱序执行的结果 重组</li><li>保证 该结果 与 顺序执行 的结果 是一致的；</li><li>但并 不保证 程序中各个语句计算的先后顺序 与 输入代码中的顺序 一致；</li><li>如果存在 一个计算任务 依赖 另外一个计算任务的 中间结果，那么其顺序性 并不能依靠 代码的先后顺序 来保证。</li></ul></li></ul></blockquote><h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p><strong>Java虚拟机规范</strong> 中试图定义一种  <strong>Java内存模型（Java Memory Model，JMM）</strong><br>来 <strong>屏蔽掉</strong> 各种 <strong>硬件和操作系统</strong> 的 <strong>内存访问差异</strong>，<br>以 <strong>实现</strong> 让 <strong>Java程序</strong> 在 <strong>各种平台</strong> 下都能达到<strong>一致的内存访问效果</strong>。</p><blockquote><p>本书中的 Java内存模型 都特指 目前正在使用的，即在 JDK1.2 之后建立起来并在 JDK1.5 中完备过的内存模型。</p></blockquote><p>在此之前，主流程序语言（C/C++等） <strong>直接使用</strong> <strong>物理硬件和操作系统的内存模型</strong>，<br>因此，会由于<strong>不同平台上内存模型的差异</strong>，有可能导致程序在一套平台上并发完全<strong>正常</strong>，而在另外一套平台上并发访问却经常<strong>出错</strong>，因此在某些场景就必须针对不同的平台来编写程序。</p><p><strong>定义Java内存模型</strong> 并非一件容易的事情，<br>这个模型必须定义得<strong>足够严谨</strong>，才能让Java的 <strong>并发内存访问操作</strong> <strong>不会产生歧义</strong>；<br>但是，也必须定义得<strong>足够宽松</strong>，使得 虚拟机的实现 有足够的自由空间 去利用 硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来 获取 更好的执行速度。<br>经过长时间的验证和修补，在 JDK1.5（实现了JSR-133）发布后，Java内存模型已经成熟和完善起来了。</p><blockquote><p>JSR-133：Java Memory Model and Thread Specification Revision （Java内存模型和线程规范修订）。</p></blockquote><h5 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h5><p>Java内存模型 的 主要目标 是 定义程序中 各个变量的 访问规则，即在 虚拟机中 将 变量存储到内存 和 从内存中取出变量 这样的底层细节。  </p><p>此处的 变量（Variables）与Java编程中所说的变量 有区别，它 包括了 实例字段、静态字段和构成数组对象的元素，但不包括 局部变量与方法参数，<br>因为后者是 线程私有的，不会被共享，自然就不会存在竞争问题。</p><blockquote><p>此处请读者注意区分概念：<br>如果 局部变量 是一个 reference 类型，它 引用的对象 在 Java堆中 可被 各个线程共享，但是 reference 本身在 Java栈的 局部变量表中，它是线程私有的。</p></blockquote><p>为了获得较好的 执行效能，Java内存模型 并没有限制 执行引擎 使用处理器的 特定寄存器 或 缓存 来和主内存进行交互，也没有限制 即时编译器 进行调整代码执行顺序 这类优化措施。</p><p>Java内存模型 规定了 所有的变量 都 存储在主内存（Main Memory）中（此处的 主内存 与介绍 物理硬件时的主内存 名字一样，两者也可以互相类比，但 此处仅是 虚拟机内存 的一部分）。</p><p>每条线程 还有自己的 工作内存（Working Memory， 可与前面讲的 处理器高速缓存 类比），线程 的 工作内存 中 保存了 被该线程 使用到的 变量 的 主内存 副本拷贝，线程 对 变量 的所有操作（读取、赋值等） 都 必须在工作内存中进行， 而不能直接读写主内存中的变量。  </p><blockquote><p>有不少读者会对这段描述中的 “拷贝副本” 提出疑问，<br>如 “假设线程中访问一个10MB的对象，也会把这10MB的内存复制一份拷贝出来吗？”<br>事实上并不会如此，这个对象的引用、对象中某个在线程访问到的字段 是有可能存在拷贝的，但 不会有 虚拟机 实现成 把整个对象拷贝一次。</p></blockquote><blockquote><p>根据 Java虚拟机规范 的规定<br>volatile变量 依然有工作内存的拷贝<br>但是由于 它 特殊的操作顺序性规定（后文会讲到），<br>所以看起来如同直接在主内存中读写访问一般，因此这里的描述对于 volatile也并不存在例外。</p></blockquote><p>不同的 线程之间 也无法 直接访问 对方工作内存中的 变量，线程间 变量值的传递 均需要 通过主内存来完成，线程、主内存、工作内存三者的交互关系；  </p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">------------              -----------                ----------------               ------</span><br><span class="line">|<span class="string"> Java线程 </span>|<span class="string"> &lt;----------&gt; </span>|<span class="string"> 工作内存 </span>|<span class="string">  &lt;----------&gt; </span>|<span class="string">      Save     </span>|<span class="string">  &lt;----------&gt; </span>|<span class="string"> 主 </span>|</span><br><span class="line">------------              -----------               |<span class="string">       和      </span>|<span class="string">               </span>|<span class="string">    </span>|</span><br><span class="line">------------              -----------               |<span class="string">               </span>|<span class="string">               </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string"> Java线程 </span>|<span class="string"> &lt;----------&gt; </span>|<span class="string"> 工作内存 </span>|<span class="string">  &lt;----------&gt; </span>|<span class="string">     Load      </span>|<span class="string">  &lt;----------&gt; </span>|<span class="string"> 内 </span>|</span><br><span class="line">------------              -----------               |<span class="string">               </span>|<span class="string">               </span>|<span class="string">    </span>|</span><br><span class="line">------------              -----------               |<span class="string">               </span>|<span class="string">               </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string"> Java线程 </span>|<span class="string"> &lt;----------&gt; </span>|<span class="string"> 工作内存 </span>|<span class="string">  &lt;----------&gt; </span>|<span class="string">      操作     </span>|<span class="string">  &lt;----------&gt; </span>|<span class="string"> 存 </span>|</span><br><span class="line">------------              -----------                ----------------               ------</span><br></pre></td></tr></table></figure><p>这里所讲的 主内存、工作内存 与本书第2章所讲的Java内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分，<br>这两者基本上是没有关系的，<br>如果两者一定要勉强对应起来，<br>那从 变量、主内存、工作内存 的定义来看，<br>主内存 主要对应于 Java堆中的对象实例数据部分，<br>而 工作内存 则对应于 虚拟机栈中的部分区域。<br>从更低层次上说，<br>主内存 就直接对应于 物理硬件的内存 ，而为了 获取更好的运行速度，<br>虚拟机（甚至是硬件系统本身的优化措施）可能会让 工作内存 优先存储于 寄存器和高速缓存中，因为程序运行时 主要访问读写的 是工作内存。</p><blockquote><p>除了 实例数据，Java堆 还保存了 对象的其他信息<br>对于 HotSpot虚拟机 来讲，</p><ul><li>有 Mark Word（存储对象哈希码、GC标志、GC年龄、同步锁等信息）</li><li>Klass Point(指向存储类型元数据的指针)</li><li>及一些用于字节对齐补白的填充数据（如果实例数据刚好满足8字节对齐的话，则可以不存在补白）</li></ul></blockquote><h5 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h5><p>关于 主内存 与 工作内存 之间的 具体的 交互协议，<br>即 一个变量 如何从 主内存 拷贝到 工作内存、 如何从 工作内存 同步 回 主内存 之类的 实现细节，<br>Java内存模型 定义了以下 8种操作 来完成，<br>虚拟机实现时 必须保证 下面提及的每一种操作 都是 原子的、不可再分的（对于 double 和 long 类型的变量来说，load、store、read 和 write 操作在某些平台上允许有例外，这个问题在12.3.4节再讲）</p><blockquote><p>基于理解难度和严谨性考虑，最新的 JSR-133 文档中，已经放弃采用这8种操作去 定义Java内存模型的访问协议（仅是 描述方式 改变了，Java内存模型 并没有改变）。</p></blockquote><table>  <tr>    <th>operation</th>    <th>名称</th>    <th>作用变量</th>    <th>描述</th>  </tr>  <tr>    <td>lock</td>    <td>(锁定)</td>    <td>作用于 主内存 的 变量</td>    <td>它把 一个 变量 标识为 一条线程 独占 的 状态。</td>  </tr>  <tr>    <td>unlock</td>    <td>(解锁)</td>    <td>作用于 主内存 的 变量</td>    <td>它把 一个 处于锁定状态 的变量 释放出来，释放后的变量 才可以 被 其他线程 锁定。</td>  </tr>  <tr>    <td>read</td>    <td>(读取)</td>    <td>作用于 主内存 的 变量</td>    <td>它把 一个 变量的值 从 主内存 传输到 线程的工作内存中，以便随后的 load动作 使用。</td>  </tr>  <tr>    <td>load</td>    <td>(载入)</td>    <td>作用于 工作内存 的 变量</td>    <td>它把 read操作 从 主内存 中得到的 变量值 放入 工作内存 的变量副本 中。</td>  </tr>   <tr>    <td>use</td>    <td>(使用)</td>    <td>作用于 工作内存 的 变量</td>    <td>它把 工作内存中 一个变量的值 传递给 执行引擎，每当 虚拟机 遇到一个 需要使用到变量的值 的字节码指令时 将会执行这个操作。</td>  </tr>   <tr>    <td>assign</td>    <td>(赋值)</td>    <td>作用于 工作内存 的 变量</td>    <td>它把 一个 从执行引擎 接收到的值 赋给 工作内存的变量，每当 虚拟机 遇到 一个给变量赋值的字节码指令 时 执行这个操作。</td>  </tr>  <tr>    <td>store</td>    <td>(存储)</td>    <td>作用于 工作内存 的 变量</td>    <td>它把 工作内存 中 一个变量的值 传送到 主内存 中，以便 随后的write操作 使用。</td>  </tr>    <tr>    <td>write</td>    <td>(写入)</td>    <td>作用于 主内存 的 变量</td>    <td>它把 store操作 从 工作内存 中得到的 变量的值 放入 主内存 的 变量 中。</td>  </tr></table><p>如果要把 一个变量 从 主内存 复制到 工作内存，那就要 顺序地 执行 read和load 操作；<br>如果要把 变量 从 工作内存 同步回 主内存，就要 顺序地 执行 store和write 操作。</p><p>注意， Java内存模型 只要求上述 两个操作 必须按顺序执行，而没有保证是 连续执行。</p><p>也就是说，read和load之间，store和write之间 是可插入其他指令的，<br>如对主内存中的变量 a、b进行访问时，一种可能出现顺序是 read a、read b、load b、 load a。<br>除此之外，Java内存模型 还规定了 在执行上述8中基本操作时 必须满足如下规则：</p><ul><li>不允许 read和load、store和write 操作之一 单独出现；<ul><li>即 不允许 一个变量 从主内存读取了 但工作内存不接受；</li><li>或者从工作内存发起回写了 但主内存不接受的情况出现。</li></ul></li><li>不允许 一个线程 丢弃 它的 最近的 assign操作；<ul><li>即 变量 在 工作内存 中 改变了 之后 必须把 该变化 同步回 主内存。</li></ul></li><li>不允许 一个线程 无原因地（没有发生过任何assign操作）把 数据 从 线程的工作内存 同步回 主内存。</li><li>一个 新的变量 只能在 主内存 中“诞生”， 不允许 在工作内存中 直接使用 一个未被初始化（load或assign）的变量；<ul><li>换句话说，就是对 一个变量 实施 use、store操作之前，必须先执行过了 assign或load 操作；</li></ul></li><li>一个变量 在 同一时刻 只允许 一条线程 对其进行 lock操作，但 lock操作 可以被 同一条线程 执行多次，多次执行lock后，只有执行相同次数的 unlock操作，变量才会被解锁；</li><li>如果对 一个变量 执行 lock操作，那将会 清空工作内存 中 此变量的值，在 执行引擎 使用这个变量前，需要重新执行 load或assign操作 初始化变量的值。</li><li>如果 一个变量 事先没有被 lock操作 锁定，那就不允许 对它执行 unlock操作，也不允许去 unlock 一个被其他线程锁定住的 变量。</li><li>对 一个变量 执行 unlock操作 之前，必须先把 此变量 同步回 主内存 中（执行 store、write操作）；</li></ul><p>这 8种内存访问操作 以及 上述规则限定，再加上稍后介绍的对 volatile 的一些特殊规定，就已经完全确定了 java程序中 哪些内存访问操作 在并发下 是安全的。</p><p>由于这种定义 相当严谨 但又十分 烦琐（我觉得周大大这里可能是想打繁琐？），实践起来很麻烦，<br>所以 在12.3.6节中笔者将介绍这种定义的 一个等效判断原则 —– 先行发生原则，用来确定 一个访问 在并发环境下 是否 安全。</p><h5 id="对于-volatile-型变量的-特殊规则"><a href="#对于-volatile-型变量的-特殊规则" class="headerlink" title="对于 volatile 型变量的 特殊规则"></a>对于 volatile 型变量的 特殊规则</h5><p>关键字 volatile 可以说是 Java虚拟机 提供的 最轻量级 的 同步机制，<br>但是它 并不容易 完全被正确、 完整地理解，以至于许多程序员都习惯不去使用它，<br>遇到需要处理 多线程数据 竞争问题 的时候 一律使用 synchronized 来进行 同步。<br>（然而我也不是习惯不习惯的问题，是我根本不会用synchronized，不懂多线程并发这一块，根本没入门的问题）</p><p>了解 volatile变量的语义 对后面了解 多线程操作的其他特性 很有意义，<br>在本节中 我们将 多花费一些时间去弄清楚 volatile的语义 到底是什么。</p><p>Java内存模型 对 volatile 专门定义了 一些 特殊的访问规则，<br>在介绍 这些比较 拗口的规则定义 之前，笔者先用 不那么正式 但 通俗易懂的 语言 来介绍一下 这个关键字的作用。<br>（好人一生平安<del>~</del> 虽然我也不一定能看懂你通俗易懂的语言）</p><p>当 一个变量 定义为 volatile 之后，它 将具备 两种特性，<br>第一 是保证 此变量 对 所有线程 的 可见性，<br>这里的 “可见性” 是指当 一条线程 修改了 这个 变量的值，新值 对于 其他线程 来说 是可以立即得知的。<br>而 普通变量 不能做到这一点， 普通变量 的 值 在线程间 传递 均需要通过 主内存 来完成，<br>例如，线程A 修改 一个普通变量的值，然后 向 主内存 进行 回写，另外一条线程B 在线程A 回写完成 了之后 再从 主内存 进行 读取 操作，新变量值 才会对线程B可见。</p><p>（诶诶诶，这个我看懂了，可能原因在于我看了视频的原因，我怎么可以这么蠢。。。。）</p><p>关于 volatile变量的可见性，经常会被开发人员误会，认为以下描述成立：“volatile变量 对所有线程 是 立即可见 的，对 volatile变量 所有的 写操作 都能 立刻反应 到 其他线程之中，换句话说， volatile变量 在 各个线程中 是 一致的，所以基于 volatile变量 的 运算 在并发下 是安全的”。  </p><p>这句话的论据部分 并没有错， 但是其论据 并不能得出 “基于 volatile变量 的 运算 在并发下 是安全的”这个结论。  </p><p>（emm，我觉得论据部分也有点毛病，<br>个人观点：”volatile变量 对所有线程 是 立即可见的”， 立即可见吗？<br>不是之前说 普通变量的值在线程间传递均需要通过主内存来完成吗，<br>那既然是要通过主内存来完成的话，那是不是就需要执行那8个操作其中的read读取操作以及load、use操作等；<br>然后论据部分当中的 “对volatile变量 所有的 写操作 都能 立刻反应 到其他线程之中” 细品一下哦，能立刻反应？<br>不是8个操作当中工作内存的赋值操作assign这种的操作一旦有了还需要同步回主内存的吗？<br>也就是执行store以及write操作，以及立刻反映到其他线程之中难道不要 其他线程又要去清空其工作内存当中的该变量然后重新进行read、load….操作之类的？<br>还是说emm，<br>工作内存与主内存之间的这个交互非常快？快到那几个操作所需花费时间可以忽略不计所以说 立即可见、立即反应？<br>害，主要是自己也不懂，看了书和视频之后吧有问题也没有人可以解答下….〒▽〒）</p><p>volatile变量 在 各个线程的 工作内存 中不存在一致性问题<br>（在 各个线程的 工作内存中，volatile变量 也可以存在 不一致的 情况，但由于 每次使用之前 都要先刷新，执行引擎 看不到 不一致的情况，因此可以认为 不存在一致性问题），<br>但是Java里面的运算 并非 原子操作，导致 volatile变量 的运算 在 并发下一样是不安全的，</p><p>我们可以 通过一段简单的演示来说明原因，请看代码清单12-1 中演示的例子。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">                                代码清单 <span class="number">12</span><span class="number">-1</span> <span class="keyword">volatile</span> 的运算</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * volatile 变量自增运算测试</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @author zzm</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> &#123;</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++)&#123;</span><br><span class="line">          threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">                increase();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">            Thread.<span class="built_in">yield</span>();</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(race);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>这段代码 发起了20个线程，每个线程 对 race变量 进行10000次自增操作，如果这段代码能够 正确并发 的话，最后输出的结果应该是200000。</p><p>读者运行完这段代码之后，并不会获得期望的结果，而且会发现 每次运行程序，输出的结果都不一样，都是一个小于 200000的数字，这是为什么呢？</p><p>问题就出现在 自增运算 “race++”之中，<br>我们用 Javap 反编译 这段代码之后，会得到代码清单12-2，<br>发现只有一行代码的 increase() 方法在 Class文件 中是由 4条字节码指令构成的（return 指令不是由 race++ 产生的，这条指令可以不计算），<br>从 字节码层面上 很容易就分析出 并发失败 的原因了：<br>当 getstatic指令 把 race 的值 取到 操作栈顶时，volatile关键字 保证了 race的值 在此时是正确的的，<br>但是在执行 iconst_1、iadd这些指令的时候，<br>其他线程 可能已经把 race的值 加大了，<br>而在 操作栈顶 的值 就变成了 过期的数据，<br>所以 putstatic 指令执行后就可能把 较小的 race值 同步回 主内存之中。</p><p>（恭喜我，竟然又看懂了这一段通俗易懂的话，原因可能在于我看了视频的缘故。。。）  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                                代码清单 <span class="number">12</span><span class="number">-2</span> VolatileTest 的字节码</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> static <span class="built_in">void</span> increase();</span><br><span class="line">  Code:</span><br><span class="line">    Stack=<span class="number">2</span>, Locals=<span class="number">0</span>, Args_size=<span class="number">0</span></span><br><span class="line">    <span class="number">0</span>：   getstatic      #<span class="number">13</span>; <span class="comment">//Field race:I</span></span><br><span class="line">    <span class="number">3</span>：   iconst_1</span><br><span class="line">    <span class="number">4</span>：   iadd</span><br><span class="line">    <span class="number">5</span>：   putstatic      #<span class="number">13</span>; <span class="comment">//Field race:I</span></span><br><span class="line">    <span class="number">8</span>：   <span class="keyword">return</span></span><br><span class="line">  LineNumberTable:</span><br><span class="line">    Line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">    Line <span class="number">15</span>: <span class="number">8</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>客观地说，笔者在此使用 字节码 来分析 并发问题，仍然是 不严谨的，<br>因为即使 编译出来 只有一条字节码指令， 也不意味着 执行这条指令就是 一个原子操作。  </p><p>一条字节码指令 在 解释执行 时，解释器将要运行许多代码才能实现 它的语义，<br>如果是 编译执行，一条字节码指令 也可能 转化成若干条 本地机器码指令，<br>此处使用 -XX:+PrintAssembly 参数输出 反汇编 来分析会 更严谨 一些，<br>但考虑到读者阅读的方便，并且字节码已经能说明问题，所以此处使用字节码分析。</p><p>（我觉得这个考虑到读者方便，可能是考虑到了像我这种小白到时候看不懂，就解释的也就越讲越多越讲越多。。。。 真是太贴心了，贴心的暖宝宝）</p><p>由于 volatile变量 只能保证 可见性，<br>在不符合 以下两条规则的运算场景中，我们仍然要通过 加锁（使用 synchronized或java.util.concurrent中的原子类）来保证原子性。</p><ul><li>运算结果 并不依赖 变量 的当前值，或者 能够确保 只有单一的线程修改 变量的值。</li><li>变量 不需要 与 其他的状态变量 共同参与 不变约束。</li></ul><p>而在像 如下的代码清代12-3所示的 这类场景就很适合使用 volatile变量 来控制并发，当 shutdown() 方法被调用时，能保证 所有线程 中执行的 doWork() 方法都立即停下来。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">                                代码清单 12-3 volatile 的使用场景</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">volatile boolean shutdownRequested;</span><br><span class="line"></span><br><span class="line">public void shutdown()&#123;</span><br><span class="line"><span class="code">      shutdownRequested = true;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void doWork()&#123;</span><br><span class="line"><span class="code">      while(!shutdownRequested)&#123;</span></span><br><span class="line"><span class="code">        // do stuff</span></span><br><span class="line"><span class="code">      &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>使用 volatile变量 的第二个语义 是 禁止指令重排序优化，<br>普通的变量 仅仅 会保证 在该方法的执行过程中 所有依赖 赋值结果 的地方 都能获取到 正确的结果，<br>而不能 保证 变量赋值 操作的顺序 与 程序代码中的执行顺序 一致。  </p><p>因为 在一个线程的方法 执行过程中 无法感知到这点，<br>这也就是 Java内存模型 中描述的所谓的 “线程内 表现为 串行 的语义”（Within-Tread As-If-Serial Semantics）。</p><p>上面的描述仍然不太容易理解，我们还是继续通过一个例子来看看为何 指令重排序 会 干扰 程序的并发执行，<br>演示程序如代码清单12-4所示。<br>（周大大真是说到我的心坎里去了，真是太为我这种人考虑了，岂止是不太容易理解！！简直，我都不好意思说自己是中国人了。害；╮(╯▽╰)╭）</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">                                代码清单 12-4 指令重排序</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">Map configOptions;</span><br><span class="line"></span><br><span class="line">char[] configText;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此 变量 必须定义为 volatile</span></span><br><span class="line">volatile boolean initialized = false;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下代码在 线程A 中执行</span></span><br><span class="line"><span class="comment">// 模拟 读取配置信息，当读取完成后 将 initialized 设置为 true 以通知其他线程 配置可用</span></span><br><span class="line">configOptions = new HashMap();</span><br><span class="line">configText =  readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = true;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下代码在 线程B 中执行</span></span><br><span class="line"><span class="comment">// 等待 initialized 为 true，代表 线程A 已经把配置信息 初始化完成</span></span><br><span class="line">while (!initialized)&#123;</span><br><span class="line"><span class="code">  sleep();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 线程A 中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>代码清单12-4中的程序是一段 伪代码，其中描述的场景十分常见，只是我们在处理配置文件时一般不会出现并发而已。  </p><p>如果定义 initialized变量 没有使用 volatile修饰，<br>就可能会由于 指令重排序的优化，<br>导致位于 线程A 中的最后一句代码 “initialized=true”被提前执行（这里虽然使用Java作为伪代码，但所指的 重排序优化 是 机器级 的 优化 操作，提前执行 是指 这句话对应的 汇编代码 被 提前执行），<br>这样在 线程B 中使用配置信息的代码 就可能出现错误，<br>而 volatile关键字 则可以避免此类情况的发生。</p><blockquote><p>volatile 屏蔽 指令重排序 的语义 在JDK1.5 才被完全修复，此前的JDK中 即使将变量声明为 volatile 也仍然不能完全避免 重排序 所导致的问题<br>(主要是 volatile变量 前后的代码 仍然存在 重排序 问题)，这点 也是在 JDK1.5 之前的Java中 无法安全地使用 DCL（双锁检测）来实现单例模式的原因。</p></blockquote><p>指令重排序 是 并发编程 中最容易让开发人员产生疑惑的地方，除了上面伪代码的例子之外，<br>笔者再举一个可以实际操作运行的例子来分析 volatile关键字 是如何 禁止指令重排序优化的。  </p><p>代码清单12-5是一段标准的 DCL单例代码，可以观察 加入volatile和未加入volatile关键字 所生成 汇编代码 的差别<br>（如何获得JIT的汇编代码，请参考4.2.7节）。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">                                代码清单 12-5 DCL单例模式</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">public class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">        synchronized ( Singleton.class )&#123;</span><br><span class="line">          <span class="keyword">if</span>(instance ==<span class="literal">null</span> )&#123;</span><br><span class="line">           <span class="built_in"> instance </span>= new Singleton();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">      Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>编译后，这段代码对 instance变量 赋值部分 如代码清单12-6所示。</p><p>(卧槽，我有病我为什么要抄这个代码清单12-6…)</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                                代码清单 <span class="number">12</span><span class="number">-6</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">0x01a3de0f</span>: mov       $<span class="number">0x3375cdb0</span>,%esi           ; ...beb0cd75 <span class="number">33</span></span><br><span class="line">                                                 ;    &#123;oop(<span class="string">'Singleton'</span>)&#125;</span><br><span class="line"><span class="number">0x01a3de14</span>: mov       %eax,<span class="number">0x150</span>(%esi)           ; ..<span class="number">.89865001</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0x01a3de1a</span>: shr       $<span class="number">0x9</span>,%esi                  ; ...clee09</span><br><span class="line"><span class="number">0x01a3de1d</span>: movb      $<span class="number">0x0</span>,<span class="number">0x1104800</span>(%esi)       ; ...c6860048 <span class="number">100100</span></span><br><span class="line"><span class="number">0x01a3de24</span>: lock  add1 $<span class="number">0x0</span>,(%esp)               ; ...f0830424 <span class="number">00</span></span><br><span class="line">                                                 ; *putstatic instance</span><br><span class="line">                                                 ; -</span><br><span class="line">Singleton::<span class="symbol">getInstance@</span><span class="number">24</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>通过 对比 就会发现， 关键变化 在于有 volatile修饰的变量，<br>赋值后（前面 mov %eax,0x150(%esi) 这句便是赋值操作） 多执行了一个” lock add1 $0x0,(%esp)” 操作，<br>这个操作相当于一个 内存屏障 （Memory Barrier 或 Memory Fence，指 重排序时 不能把 后面的指令 重排序到 内存屏障 之前的位置），<br>只有一个 CPU 访问 内存时，并不需要 内存屏障；<br>但如果有 两个或更多CPU 访问 同一块 内存，且 其中有一个在 观测 另一个，就需要 内存屏障 来保证 一致性了。</p><p>这句 指令 中的 “add1 $0x0,(%esp)”（把 ESP寄存器 的 值 加 0）显然是一个 空操作<br>（采用这个 空操作 而不是 空操作指令nop 是因为 IA32手册规定 lock前缀 不允许 配合 nop指令 使用），<br>关键在于 lock前缀，查询 IA32手册，<br>它的作用是使得 本CPU 的 Cache 写入了 内存，<br>该 写入动作 也会引起 别的CPU 或者 别的内核 无效化（Invalidate）其Cache，<br>这种操作相当于对 Cache中的变量 做了一次 前面介绍 Java内存模式 中所说的 ”store“和”write“操作。<br>所以通过这样一个 空操作，可让前面 volatile变量 的 修改 对 其他CPU 立即可见。</p><blockquote><p>Doug Lea 列出了各种处理器架构下的 内存屏障指令（<code>http://g.oswego.edu/d1/jmm/cookbook.html</code>）</p></blockquote><blockquote><p>这个 <code>http://g.oswego.edu/d1/jmm/cookbook.html</code> 我试了下访问不通；…</p></blockquote><p>（看到这些文字🙃，莫名我🙃就想起了高中的数学🙃还有大学的高等数学🙃。还想起了那个斐波拉契数列还有那个KMP模式匹配算法🙃，卧槽🙃）</p><blockquote><p>🙃🙃🙃捋一捋🙃🙃🙃</p><ul><li>加了volatile和不加volatile的区别：“0x01a3de24: lock  add1 $0x0,(%esp)               ; …f0830424 00”这一行代码是否存在</li><li>“0x01a3de14: mov       %eax,0x150(%esi)           ; …89865001 0000”这一句是赋值操作，相当于“instance = new Singleton();”这句话？</li><li>“add1 $0x0,(%esp)”相当于一个内存屏障；</li><li>内存屏障（Memory Barrier或 Memory Fence）作用：重排序时，不能把 后面的指令 重排序到 内存屏障 之前的位置<ul><li>举个例子，就好比emm之前那个代码块，两个线程，线程A与线程B；线程A负责读取配置信息；线程B等待线程A初始化配置信息完成；完成之后进行使用线程A初始化好的配置信息；在这当中如果线程A当中“initialized=true”这句话提前执行，那么就会导致线程B的判断失误不会再执行sleep()，从而执行下面的doSomethingWithConfig()方法；而此时执行这个方法就有可能会出错；</li></ul></li><li>“add1 $0x0,(%esp)”当中的esp指的是ESP寄存器</li><li>“add1 $0x0,(%esp)”该指令为一个空操作<ul><li>该 空操作 导致 本CPU 的 Cache 写入了 内存；</li><li>本CPU的Cache写入内存 相当于 Cache中的变量 做了一次“store”与“write”，也就是 同步回内存 的意思；</li><li>通过将 本CPU的Cache写入内存 的该空操作，从而使得volatile变量 的修改对其他CPU立即可见</li><li>这个空操作是不是也就是一个刷新的操作？类似？</li><li>意思也就是说这个ESP寄存器的值不是加0吗，那这个ESP寄存器的值这个应该是一个常量，然后加这个0对这个常量并不会起到什么影响，但是当中会有一个写操作，也就是assign这个操作；因为执行8个操作中其中的规则有一条是：不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存。</li><li>所以会去通过这样一个空操作，让前面的 volatile变量 的修改 对其他CPU立即可见</li><li>对了，这个CPU，其他CPU也就相当于是主内存了是吧</li></ul></li></ul></blockquote><p>那为何说 它禁止指令重排序 呢？<br>从 硬件架构 上讲，指令重排序 是指 CPU 采用了 允许将 多条指令 不按 程序规定的顺序 分开发送给 各相应 电路单元 处理。<br>但并不是说 指令任意重排， CPU 需要能 正确处理 指令 依赖情况 以保障 程序 能得出 正确的执行结果。</p><p>譬如<br>指令1 把 地址A 中的 值 加10，<br>指令2 把 地址A 中的 值 乘以2，<br>指令3 把 地址B 中的 值 减去3，<br>这时 指令1和指令2 是有依赖的，<br>它们之间的顺序 不能重排——–（A+10）<em>2和 A</em>2+10显然不相等，<br>但指令3 可以重排到指令1、2之前或者中间，<br>只要保证CPU执行后面 依赖到A、B值的操作时能获取到正确的A和B值即可。</p><p>所以在 本内CPU中（这个地方，本内？emm，是否是想说的是本内存or 本CPU啊？），重排序看起来依然是有序的。<br>因此， lock add1 $0x0,(%esp) 指令 把 修改 同步 到 内存时，意味着所有之前的 操作 都已经 执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。</p><p>解决了 volatile 的语义问题，再来看看在众多保障并发安全的工具中选用 volatile 的意义——-它能让我们的代码比使用其他的同步工具会更快吗？</p><p>在某些情况下，volatile 的 同步机制 的性能 确实要优于 锁（使用 synchronized 关键字 或 java.util.concurrent包里面的锁），<br>但是由于 虚拟机 对 锁 实行的许多 消除和优化，使得我们很难量化地认为 volatile 就会比 synchronized 快多少。  </p><p>如果让 volatile 自己与自己比较，那可以确定一个原则：<br>volatile变量 读操作的性能消耗 比 普通变量几乎没有什么差别，但是 写操作 则可能 会慢一些；<br>因为它需要 在本地代码中 插入许多 内存屏障指令 来保证 处理器 不发生 乱序执行。</p><p>不过即便如此，大多数场景下 volatile 的总开销 仍然要比 锁 低，<br>我们在 volatile与锁 中选择的唯一依据仅仅是 volatile的语义 能否满足使用场景的需求。</p><p>在本节的最后，我们回头看一下 Java内存模型 中对 volatile变量 定义的特殊规则。</p><p>假定 T 表示一个线程，V 和 W 分别表示 两个 volatile型变量，那么在进行read、load、use、assign、store和write 操作时需要满足如下规则：</p><ul><li>只有当 线程 T 对 变量 V 执行的前一个动作是 load 的时候，线程 T 才能对 变量 V 执行 use动作；<ul><li>并且，只有当 线程 T 对 变量 V 执行的 后一个动作 是 use 的时候，线程 T 才能对 变量 V 执行 load 动作。</li><li>线程 T 对 变量 V 的 use动作 可以认为是 和线程 T 对 变量 V 的 load、read动作相关联，必须连续一起出现<ul><li>（这条 规则 要求在 工作内存 中，每次使用 V 前都必须先从 主内存 刷新最新的值，用于保证 能看见 其他线程 对 变量 V 所做的修改后的值）。</li></ul></li></ul></li><li>只有当 线程 T 对 变量 V 执行的前一个动作是 assign 的时候，线程 T 才能对 变量 V 执行 store 动作；<ul><li>并且，只有当 线程 T 对变量 V 执行的 后一个动作 是 store 的时候可以认为是和 线程 T 对 变量 V 的store、write动作相关联，必须 连续 一起出现<ul><li>（这条 规则 要求在 工作内存中，每次修改 V 后都必须立刻 同步回 主内存 中，用于保证 其他线程 可以看到 自己对变量 V 所做的修改）</li></ul></li></ul></li><li>假定 动作 A 是 线程 T 对 变量 V 实施的 use 或 assign 动作；<br>假定 动作 F 是和 动作 A 相关联的 load 或 store 动作，<br>假定 动作 P 是和 动作 F 相关联的 read 或 write 动作；<br>类似的，<br>假定 动作 B 是 线程 T 对 变量 W 实施的 use 或 assign 动作，<br>假定 动作 G 是和动作 B 相关联的 load 或 store 动作，<br>假定 动作 Q 是和动作 G 相应的对 变量 W 的 read或write 动作。<br>如果 A 先于 B，那么 P 先于 Q<ul><li>（这条 规则 要求 volatile 修饰的变量 不会被 指令重排序优化，保证 代码的执行顺序 和 程序的顺序 相同）</li></ul></li></ul><blockquote><p>理解为就好像是一个要 read-load-use 努力刷新；一个assign-store-write 努力更新一样</p></blockquote><h5 id="对于-long-和-double-型变量的特殊规则"><a href="#对于-long-和-double-型变量的特殊规则" class="headerlink" title="对于 long 和 double 型变量的特殊规则"></a>对于 long 和 double 型变量的特殊规则</h5><p>java内存模型 要求 lock、unlock、read、load、use、assign、store、write 这个 8个操作 都具有 原子性，<br>但是对于 64位的数据类型（ long 和 double ），在模型中特别定义了一条相对宽松的规定：允许 虚拟机 将 没有被 volatile 修饰的 64位数据的 读写操作 划分为 两次32位的操作 来进行，即允许 虚拟机 实现选择 可以 不保证64位数据类型的 load、store、read和write这个4个操作的原子性，<br>这点就是所谓的 long和double 的非原子性协定（Nonatomic Treatment of double and long Variables）。</p><p>如果有 多个线程 共享一个 并未声明为 volatile的 long 或 double 类型的变量，并且同时对它们进行 读取和修改 操作，<br>那么 某些线程 可能会 读取到一个 既非原值，也不是其他线程修改值的 代表了 “半个变量”的数值。</p><p>不过这种读取到 “半个变量”的情况 非常罕见（在目前 商用java虚拟机 中不会出现），<br>因为 java内存模型 虽然允许虚拟机不把 long和double 变量的 读写 实现成原子操作，<br>但允许 虚拟机 选择把这些操作实现为 具有原子性的操作，而且还 “强烈建议” 虚拟机 这样实现。</p><p>在实际开发中，目前各种平台下的 商用虚拟机 几乎都选择把 64位数据的读写操作 作为 原子操作 来对待，<br>因此我们在编写代码时 一般不需要把用到的 long和double 变量专门声明为 volatile。</p><h5 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h5><p>介绍完 Java内存模型 的 相关操作和规则，<br>我们再整体回顾一下 这个模型的特征。</p><p>Java内存模型 是围绕着在 并发过程中 如何处理原子性、可见性和有序性 这3个特征来建立的，<br>我们逐个来看一下哪些操作实现了这3个特性。</p><p><strong>原子性（Atomicity）</strong>：由 Java内存模型 来直接保证的 原子性变量操作 包括 read、load、assign、use、store和write</p><p>我们大致可以认为 基本数据类型的访问读写 是具备原子性的（例外就是 long和double 的非原子性协定，读者只要知道这件事情就可以了，无需太过在意这些几乎不会发生的例外情况）</p><p>如果 应用场景 需要一个 更大范围的 原子性保证（经常会遇到），Java内存模型还提供了了 lock和unlock 操作来满足这种需求， </p><p>尽管 虚拟机 未把 lock和unlock 操作直接开放给用户使用，但是却提供了 更高层次的字节码指令 monitorenter和monitorexit 来 隐式地 使用这两个操作，这两个字节码指令反映到Java代码中 就是 同步块—–synchronized关键字，因此 synchronized 块之间的操作也具备原子性。</p><p><strong>可见性（Visibility）</strong>：可见性 是指当 一个线程 修改了 共享变量的值，其他线程 能够 立即得知 这个修改。</p><p>上文在讲解 volatile变量 的时候我们已详细讨论过这一点。</p><p>Java内存模型 是通过在 变量修改后 将 新值 同步回 主内存，在变量读取前 从 主内存 刷新变量值 这种依赖主内存作为 传递媒介 的方式来实现可见性的，无论是 普通变量 还是 volatile变量 都是如此</p><p>普通变量与volatile变量 的区别是：volatile 的 特殊规则 保证了 新值 能立即 同步到 主内存，以及每次 使用前 立即从 主内存刷新。</p><p>因此，可以说 volatile 保证了 多线程操作时 变量的可见性，而 普通变量 则不能保证这一点。</p><p>除了 volatile 之外，Java还有两个关键字 能实现可见性，即 synchronized 和 final。</p><p>同步块 的 可见性 是由 “对一个 变量 执行 unlock 操作之前， 必须先把 此变量 同步回 主内存中（执行store、write操作）”这条规则获得的，</p><p>而 final 关键字 的可见性是指：被 final 修饰的字段 在构造器中 一旦初始化完成， 并且构造器 没有把“this”的引用 传递出去（this引用逃逸 是一件很危险的事情，其他线程 有可能 通过这个引用 访问到 “初始化了一半” 的对象），那在 其他线程 中就能看见 final字段的值。</p><p>如代码清单12-7所示，变量i和j都具备可见性，它们无需同步 就能被 其他线程正确访问。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">                                代码清单 12-7 final 与可见性</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">public static final int i;</span><br><span class="line"></span><br><span class="line">public final int j;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line"><span class="code">  i = 0;</span></span><br><span class="line"><span class="code">  // do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="code">  // 也可以选择在 构造函数中 初始化</span></span><br><span class="line"><span class="code">  j = 0;</span></span><br><span class="line"><span class="code">  // do something</span></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><strong>有序性（Ordering）</strong>：Java内存模型 的 有序性 在前面讲解 volatile 时也详细地讨论过了，<br>Java程序 中  天然的有序性 可以总结为一句话：</p><p>如果在 本线程 内观察，所有的操作 都是 有序的；<br>如果在 一个线程中 观察 另一个线程，所有的操作都是 无序的。</p><p>前半句是指 “线程内 表现为 串行的语义”（Within-Thread As-If-Serial Semantics），<br>后半句是指 “指令重排序”现象和 “工作内存与主内存同步延迟”现象。</p><p>Java语言 提供了 volatile和synchronized 两个关键字 来 保证 线程之间 操作的 有序性，<br>volatile关键字 本身就包含了 禁止指令重排序 的语义，<br>而 synchronized 则是由 “一个变量在同一时刻只允许一条线程 对其进行 lock 操作”这条规则获得的，这条规则 决定了 持有同一个锁的两个同步块 只能 串行地进入；</p><p>介绍完 并发 中 3种 重要的特性后，读者有没有发现 synchronized关键字 在需要这3种特性的时候 都可以作为其中一种的 解决方案？<br>看起来很“万能”吧。<br>的确，大部分的 并发控制 操作都能使用 synchronized 来完成。<br>synchronized 的“万能” 也间接造就了 它被程序员滥用的 局面，越“万能”的 并发控制，通常会伴随着越大的 性能影响，<br>这点我们将在第13章讲解 虚拟机锁优化时在介绍。  </p><h5 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h5><p>如果 Java内存模型 中所有的 有序性 都仅仅依靠 volatile 和 synchronized 来完成，那么有一些操作将会变得很 烦琐，<br>但是我们在编写Java并发代码的时候并没有感觉到这一点，<br>这是因为Java语言中有一个 “先行发生”（happens-before） 的 原则。<br>这个原则非常重要，它是 判断 数据是否竞争、线程是否安全 的 主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决 并发环境下 两个操作之间是否可能存在冲突的所有问题。</p><p>现在就来看看 “先行发生”原则 指的是什么。<br>先行发生 是 Java内存模型 中定义的 两项操作 之间的 偏序关系，<br>如果说 操作A 先行发生于 操作B，其实就是说 发生在操作B 之前，操作A 产生的影响 能被 操作B 观察到，“影响” 包括 修改了内存中共享变量的值、发送了消息、调用了方法等。<br>这句话不难理解，但它 意味着什么呢？<br>我们可以举个例子来说明一下，如代码清单12-8中所示的这3句伪代码。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">                                代码清单 12-8 先行发生原则示例1</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 以下操作在 线程A 中执行</span></span><br><span class="line">i = 1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作在 线程B 中执行</span></span><br><span class="line">j = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作在 线程C 中执行</span></span><br><span class="line">i = 2;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>假设 线程A 中的操作 “i=1;” 先行发生于 线程B 的操作“j=i“ ，<br>那么可以确定在 线程B 的操作执行后，变量j的值一定等于1，<br>得出这个结论的依据有两个：<br>一是根据 先行发生原则， “i=1”的结果可以被观察到；<br>二是 线程C 还没“登场”， 线程A 操作结束之后没有其他线程 会修改变量i的值。</p><p>现在再来考虑 线程C，我们依然保持 线程A 和 线程B 之间的 先行发生关系，<br>而 线程C 出现在 线程A 和 线程B 的操作之间，<br>但是 线程C 与 线程B 没有 先行发生关系，<br>那 j 的值会是多少呢?</p><p>答案是不确定！<br>1和2都有可能，因为 线程C 对 变量i 的影响 可能会被 线程B 观察到，<br>也可能不会， 这时候 线程B 就存在 读取到 过期数据的风险，不具备 线程安全性。</p><p>下面是 Java内存模型 下一些“天然的”先行发生关系，<br>这些 先行发生关系 无需任何 同步器 协助，可以在编码中直接使用。</p><p>如果 两个操作 之间的关系不在此列，并且无法从下列规则推导出来的话，它们就 没有顺序性保障，虚拟机 可以对它们 随意地 进行 重排序。</p><p><strong>程序次序规则（Program Order Rule）</strong>：<br>在 一个线程 内，按照 程序代码 顺序，书写在前面的操作 先行发生于 书写在后面的操作。<br>准确地说，应该是 控制流顺序 而不是 程序代码顺序， 应为要考虑 分支、循环 等结构。</p><p><strong>*管程锁定规则（Monitor Lock Rule）</strong>：<br>一个 unlock操作 先行发生于 后面对 同一个锁 的 lock操作。<br>这里必须强调的是 同一个锁，而 “后面” 是指 时间上的先后顺序。</p><p><strong>volatile 变量规则（Volatile Variable Rule）</strong>：<br>对 一个 volatile变量 的 写操作 先行发生于 后面对这个变量的 读操作，<br>这里的 “后面”同样是指 时间上的先后顺序。</p><p><strong>线程启动规则（Thread Start Rule）</strong>：<br>Thread 对象的 start() 方法 先行发生于 此线程的每一个动作。</p><p><strong>线程终止规则（Thread Termination Rule）</strong>：<br>线程 中的 所有操作 都 先行发生于 对此线程的 终止检测，<br>我们可以通过 Thread.join()方法结束、Thread.isAlive()的返回值 等手段 检测到 线程已经终止执行。</p><p><strong>线程中断规则（Thread Interruption Rule）</strong>：<br>对 线程 interrupt() 方法的调用 先行发生于 被 中断线程的代码 检测到 中断事件 的发生，可以通过 Thread.interrupted()方法 检测到 是否有中断发生。</p><p><strong>对象终结规则（Finalizer Rule）</strong>:<br>一个对象的 初始化 完成（构造函数执行结束） 先行发生于 它的 finalize() 方法的开始。</p><p><strong>传递性（Transitivity）</strong>:<br>如果 操作A 先行发生于 操作B，操作B 先行发生于 操作C，那就可以得出 操作A 先行发生于 操作C 的结论。</p><p>Java语言 无须 任何同步手段保障 就能成立的 先行发生规则 就只有上面这些了，<br>笔者演示一下 如何使用这些规则去判定 操作间是否具备顺序性，<br>对于 读写共享变量 的操作来说，就是 线程是否安全，<br>读者还可以从下面这个例子中感受一下 “时间上的先后顺序” 与 “先行发生” 之间有什么不同。<br>演示例子如代码清单12-9所示。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">                                代码清单 12-9 先行发生原则示例2</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">private int  value = 0;</span><br><span class="line"></span><br><span class="line">public void setValue(int value)&#123;</span><br><span class="line"><span class="code">  this.value=value;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getValue()&#123;</span><br><span class="line"><span class="code">  return value;</span></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>代码清单12-9中显示的是一组再普通不过的 getter/setter 方法，<br>假设存在 线程A和B， 线程A先（时间上的先后）调用了 “setValue”，<br>然后 线程B 调用了 同一个对象 的“getValue()”，那么 线程B 收到的返回值 是什么？</p><p>我们依次分析一下 先行发生原则 中的各项规则，<br>由于 两个方法 分别由 线程A和线程B 调用，不在一个线程中，所以 程序次序规则 在这里不适用；</p><p>由于 没有同步块，自然就不会发生 lock和unlock 操作，所以 管程锁定规则 不适用；</p><p>由于 value变量 没有被 volatile关键字 修饰，所以 volatile变量规则 不适用；</p><p>后面的 线程启动、终止、中断规则和对象终结规则 也和这里完全没有关系。</p><p>因为 没有一个适用的 先行发生原则，所以最后一条 传递性 也无从谈起，</p><p>因此我们可以判定尽管 线程A 在操作时间上 先于 线程B，但是无法确定 线程B 中“getValue()”方法返回的结果，<br>换句话说，这里面的操作不是 线程安全的。</p><p>那怎么修复这个问题呢？</p><p>我们至少有两种比较简单的方案可以选择：<br>要么把 getter/setter 方法都定义为 synchronized 方法，这样就可以田勇 管程锁定规则；</p><p>要么把 value 定义为 volatile变量，由于 setter方法 对 value的修改 不依赖 value的原值，满足 volatile关键字使用场景，<br>这样就可以 套用volatile变量规则 来实现 先行发生关系。</p><p>通过上面的例子，我们可以得出结论：<br>一个操作 “时间上的先发生” 不代表这个操作 会是 “先行发生”，<br>那如果 一个操作 “先行发生” 是否就能推导 这个操作 必定是 “时间上的先发生” 呢？</p><p>很遗憾，这个推论也是不成立的，一个典型的例子就是多次提到的 “指令重排序”，<br>演示例子如代码清单12-10所示。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">                                代码清单 12-10 先行发生原则示例3</span></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 以下操作在同一个线程中执行</span></span><br><span class="line">int i = 1;</span><br><span class="line">int j = 2;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>代码清单12-10的 两条赋值语句 在 同一个线程 之中，<br>根据 程序次序规则， “int i=1” 的操作 先行发生于 “int j=2”，<br>但是 “int j=2”的代码完全可能先被 处理器 执行，这并不影响 先行发生原则的正确性，因为我们在 这条线程 之中没有办法感知到这点。</p><p>上面两个例子综合起来证明了一个结论：时间先后顺序 与 先行发生原则 之间基本没有太大的关系，所以我们衡量 并发安全问题 的时候不要受到 时间顺序的干扰，一切必须以 先行发生原则 为准。</p><h4 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h4><p>并发 不一定要 依赖 多线程（如PHP中很常见的 多进程并发），<br>但是在Java里面谈论 并发，大多数都与 线程 脱不开关系。</p><p>既然我们这本书探讨的话题是 Java虚拟机的特性，那讲到 Java线程，我们就从 Java线程 在 虚拟机中的实现 开始讲起。</p><h5 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h5><p>我们知道，线程 是比 进程 更轻量级 的 调度执行单位，<br>线程的引入 ，可以把 一个进程的 资源分配 和 执行调度 分开，各个线程 既可以 共享进程资源（内存地址、文件I/O等），又可以独立调度（线程 是 CPU 调度 的 基本单位）。</p><p>主流的 操作系统 都提供了 线程实现，Java语言则提供了 在不同硬件和操作系统平台下 对线程操作的统一处理，<br>每个已经执行 start()且还未结束的 java.lang.Thread类的实例，就代表了 一个线程。</p><p>我们注意到 Thread类与大部分的 Java API 有显著的区别，<br>他的所有关键方法都是 声明为Native的。</p><p>在 Java API中，一个 Native 方法 往往意味着 这个方法没有使用 或 无法使用 平台无关的手段来实现（当然也可能是为了 执行效率 而使用 Native 方法， 不过，通常 最高效率的手段 也就是 平台相关的手段）。</p><p>正因为如此，作者把本节的标题定为 “线程的实现” 而不是 “Java线程的实现”。</p><p>实现线程 主要有3中方式：<br>使用 内核线程 实现、<br>使用 用户线程 实现<br>和使用 用户线程 加 轻量级进程 混合实现。</p><h6 id="1-使用内核线程实现"><a href="#1-使用内核线程实现" class="headerlink" title="1.使用内核线程实现"></a>1.使用内核线程实现</h6><p>内核线程 （Kernel-Level Thread，KLT） 就是直接由 操作系统内核（Kernel，下称内核）支持的线程，<br>这种线程 由 内核 来完成 线程切换，<br>内核 通过操纵 调度器（Scheduler）对 线程 进行 调度 ，<br>并负责将 线程的任务 映射到各个 处理器 上。</p><p>每个 内核线程 可以视为 内核 的一个分身，<br>这样 操作系统 就有能力 同时处理多件事情，支持多线程 的 内核 就叫做 多线程内核（Multi-Threads Kernel）。</p><p>程序 一般不会直接去使用 内核线程，而是去使用 内核线程 的一种高级接口—-轻量级进程（Light Weight Process，LWP），<br>轻量级进程 就是我们通常意义上所讲的 线程，<br>由于 每个轻量级进程 都有一个 内核线程 支持，因此只有先支持 内核线程，才能有 轻量级进程。</p><p>这种 轻量级进程 与 内核线程 之间 1:1的关系 称为 一对一的线程模型，如图12-3所示。</p><p>（实活实说，这个图太难了🙃🙃🙃我画不出🙃🙃🙃）</p><p>由于 内核线程 的支持，每个 轻量级进程 都成为一个 独立的 调度单元，<br>即使有一个 轻量级进程 在系统调用中 阻塞了，也不会影响 整个进程继续工作，<br>但是 轻量级进程 具有它的局限性：<br>首先，由于是基于 内核线程 实现的，所以各种线程操作，如 创建、析构及同步，都需要进行 系统调用。<br>而系统调用的代价相对较高，需要在 用户态（User Mode）和内核态（Kernel Mode） 中 来回切换。<br>其次，每个轻量级进程 都需要有一个 内核线程 的支持，因此 轻量级进程 要消耗一定的 内核资源（如 内核线程 的 栈空间），<br>因此 一个系统 支持轻量级进程 的 数量 是有限的。</p><h6 id="2-使用用户线程实现"><a href="#2-使用用户线程实现" class="headerlink" title="2.使用用户线程实现"></a>2.使用用户线程实现</h6><p>从 广义 上来讲，一个线程 只要不是 内核线程，就可以认为是 用户线程（User Thread，UT），<br>因此，从这个定义上来讲，轻量级进程 也属于 用户线程，但 轻量级进程 的实现 始终是建立在 内核之上的，许多操作都要进行 系统调用，效率会受到限制。</p><p>而 狭义的 用户线程 指的是 完全建立在 用户空间的 线程库 上，系统内核 不能感知 线程存在的实现。</p><p>用户线程 的 建立、同步、销毁和调度 完全在 用户态 中完成，不需要 内核的帮助。</p><p>如果程序 实现得当，这种线程 不需要切换到 内核态，因此操作 可以使 非常快速且低消耗的，<br>也可以支持规模更大的线程数量，部分高性能 数据库中的多线程 就是由 用户线程 实现的。<br>这种 进程 与 用户线程 之间 1:N 的关系 称为 一对多的线程模型，如图12-4所示。</p><p>（不画图了自己去买书看看🙃🙃🙃）</p><p>使用 用户线程 的 优势 在于 不需要系统内核支援，劣势 也在于 没有系统内核的支援，所有的 线程操作 都需要 用户程序 自己处理。</p><p>线程的 创建、切换和调度 都是需要考虑的问题，而且由于 操作系统 只把 处理器资源 分配到 进程，<br>那诸如 “阻塞如何处理”、‘多处理器系统中如何将线程映射到其他处理器上“这类问题解决起来将会 异常困难，甚至不可能完成。</p><p>言而使用 用户线程实现的程序 一般都比较复杂，除了以前在不支持多线程的操作系统中（如DOS）的多线程程序 与 少数有特殊需求的程序外，<br>现在使用用户线程的程序越来越少了，Java、Ruby等语言都曾经使用过用户线程，最终又都放弃使用它。</p><blockquote><p>此处讲的“复杂”与“程序自己完成线程操作”，并不限制 程序中 必须编写了复杂的实现用户线程的代码，<br>使用用户线程的程序，很多都依赖特定的线程库来完成基本的线程操作，这些复杂性 都 封装在 线程库 之中。</p></blockquote><p>（🙃🙃🙃表示像我这种俗人估计一辈子都用不到用户线程以及内核线程，而且估计我用到了我也不知道）</p><h6 id="3-使用用户线程加轻量级进程混合实现"><a href="#3-使用用户线程加轻量级进程混合实现" class="headerlink" title="3.使用用户线程加轻量级进程混合实现"></a>3.使用用户线程加轻量级进程混合实现</h6><p>线程 除了 依赖 内核线程 实现 和 完全由 用户程序 自己实现 之外，还有一种将 内核线程与用户线程 一起使用的实现方式。</p><p>在这种混合实现下，既存在 用户线程，也存在 轻量级进程。</p><p>用户线程 还是完全建立在 用户空间 中，因此 用户线程 的 创建、切换、析构等操作依然廉价，并且可以支持 大规模的用户线程并发。</p><p>而操作系统提供支持的 轻量级进程 则作为用户线程和内核线程之间的 桥梁，这样可以使用 内核提供的线程调度功能及处理器映射，<br>并且 用户线程的系统调用 要通过 轻量级线程 来完成，大大降低了 整个线程 被完全阻塞 的风险。</p><p>在这种 混合模式中，用户线程和轻量级进程 的数量 是 不定的，即为 N:M 的关系，如图12-5所示，这种就是 多对多的线程模型。</p><p>许多 UNIX系列 的 操作系统， 如 Solaris、HP-UX 等都提供了 N:M 的线程模型 实现。</p><h6 id="4-Java线程的实现"><a href="#4-Java线程的实现" class="headerlink" title="4.Java线程的实现"></a>4.Java线程的实现</h6><p>Java线程 在 JDK1.2 之前，是基于称为 “绿色线程”（Green Threads）的 用户线程 实现的，<br>而在 JDK1.2 中，线程模型 替换为 基于操作系统 原生线程模型 来实现。</p><p>因此，在目前的JDK版本中，操作系统 支持怎样的 线程模型，很大程度上 决定了 Java虚拟机的线程 是怎样 映射的，<br>这点在 不同的平台商 没有办法 达成一致，虚拟机规范 中也并未限定 Java线程 需要使用哪种 线程模型 来实现。</p><p>线程模型 只对 线程的 并发规模和操作成本 产生影响，对Java程序的 编码和运行过程 来说，这些差异都是透明的。</p><p>对于 Sun JDK来说，它的 Windows版本和Linux版都是使用 一对一的线程模型 实现的，<br>一条Java线程 就 映射到 一条轻量级进程之中，因为 Windows和Linux 系统提供的线程模型就是 一对一的。</p><blockquote><p>Windows下由 纤程包（Fiber Package），Linux下也有 NGPT（在2.4内核的年代）来实现 N:M 模型，但是他们都没有成为主流。</p></blockquote><p>而在 Solaris平台 中，<br>由于 操作系统 的 线程特性 可以同时 支持  一对一（通过Bound Threads或Alternate Libthread 实现）及 多对多（通过 LWP/Thread Based Synchronization 实现） 的线程模型，<br>因此在 Solaris 版的JDK中 也对应提供了 两个平台专有的 虚拟机参数： -XX:+UseLWPSynchronization(默认值) 和 -XX:+UseBoundThreads 来明确指定虚拟机使用哪种 线程模型。</p><h5 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h5><p>线程调度 是指 系统 为 线程 分配 处理器使用权 的过程，<br>主要调度方式有两种，分别是 协同式线程调度（Cooperative Threads-Scheduling） 和 抢占式线程调度（Preemptive Threads-Scheduling）。</p><p>如果使用 协同式调度的多线程系统，线程的执行时间 由 线程本身 来控制，线程 把 自己的工作执行完了之后，要主动通知 系统 切换到 另外一个线程上。</p><p>协同式多线程 的 最大好处 是 实现简单，而且由于 线程要把自己的事情干完后才会进行 线程切换，切换操作 对 线程自己是可知的，所以没有什么 线程同步 的问题。</p><p>Lua语言中的 “协同例程” 就是这类实现。</p><p>它的 坏处 也很明显：线程执行时间 不可控制，甚至如果一个线程编写 有问题， 一直不告知系统进性 线程切换，那么程序就会 一直阻塞 在那里。</p><p>很久以前的 Windows3.x系统 就是使用 协同式 来实现 多进程多任务 的，相当不稳定，一个进程 坚持不让出 CPU 执行时间 就可能导致整个系统 崩溃。</p><p>如果使用 抢占式调度的多线程系统，那么 每个线程 将由 系统 来分配 执行时间，线程的切换不由 线程本身 来决定（在Java中，Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。</p><p>在这种实现 线程调度 的方式下，线程的执行时间 是 系统 可控的，也不会有 一个线程 导致 整个进程阻塞 的问题，<br>Java使用的 线程调度方式 就是 抢占式调度。</p><blockquote><p>在JDK后续版本中 有可能会提供 协程（Coroutines）方式 来进行 多任务处理，相关资料可参见：<code>http://wikis.sum.com/display/mlvm/Coroutines</code>。</p></blockquote><p>与前面所说的 Windows3.x 的例子相对，在 Windows9x/NT 内核中就是使用 抢占式 来实现 多线程的，当一个进程出了问题，我们还可以使用 任务管理器 把这个 进程 “杀掉”，而不至于导致 系统崩溃。</p><p>虽然 Java线程调度 是系统自动完成的，<br>但是我们还是可以 “建议” 系统给某些 线程 多分配一点 执行时间，另外的一些线程则可以少分配一点——这一项操作可以通过设置 线程优先级 来完成。</p><p>Java语言 一共设置了 10个级别 的 线程优先级（ Thread.MIN_PRIORITY 至 Thread.MAX_PRIORITY ），在两个线程同时处于 Ready 状态时，优先级越高的 线程 越容易被 系统 选择执行。</p><p>不过，线程优先级 并不是 太靠谱，原因是 Java的线程 是通过 映射到 系统的 原生线程 上来实现的，<br>所以 线程调度 最终还是取决于 操作系统，虽然现在很多操作系统都提供 线程优先级 的概念，<br>但是并不见得能与 Java线程的优先级 一一对应，<br>如Solaris中 有 2147483648（2^32）中优先级，但Windows中就只有7中，比Java线程优先级多的系统还好说，中间留下一点空位就可以了，<br>但比Java线程优先级少的系统，就不得不出现几个 优先级相同的情况了。</p><p>表12-1 显示了 Java线程优先级 与 Windows线程优先级 之间的对应关系，<br>Windows平台的JDK中 使用了除 THREAD_PRIORITY_IDLE 之外的其余6种线程优先级。</p><table>  <thead>    <tr>      <th colspan="2">表 12-1 Java线程优先级与Windows线程优先级之间的对应关系</th>    </tr>  </thead>  <tr>    <th>Java线程优先级</th>    <th>Windows线程优先级</th>  </tr>  <tr>    <td>1（Thread.MIN_PRIORITY）</td>    <td>THREAD_PRIORITY_LOWEST</td>  </tr>    <tr>    <td>2</td>    <td>THREAD_PRIORITY_LOWEST</td>  </tr>    <tr>    <td>3</td>    <td>THREAD_PRIORITY_BELOW_NORMAL</td>  </tr>   <tr>    <td>4</td>    <td>THREAD_PRIORITY_BELOW_NORMAL</td>  </tr>   <tr>    <td>5</td>    <td>THREAD_PRIORITY_NORMAL</td>  </tr>   <tr>    <td>6</td>    <td>THREAD_PRIORITY_ABOVE_NORMAL</td>  </tr>    <tr>    <td>7</td>    <td>THREAD_PRIORITY_ABOVE_NORMAL</td>  </tr>    <tr>    <td>8</td>    <td>THREAD_PRIORITY_HIGHEST</td>  </tr>   <tr>    <td>9</td>    <td>THREAD_PRIORITY_HIGHEST</td>  </tr>   <tr>    <td>10（Thread.MAX_PRIORITY）</td>    <td>THREAD_PRIORITY_CRITICAL</td>  </tr></table><p>上文说到 “线程优先级并不是太靠谱”，不仅仅是说 在一些平台上 不同的优先级 实际会变得相同 这一点，还有其他情况 让我们不能太依赖 优先级：<br>优先级可能会被 系统 自行改变。<br>例如，在Windows系统中 存在一个称为 “优先级推进器”(Priority Boosting，当然它可以被关闭掉)的功能，<br>它的大致作用就是 当系统 发现 一个线程 执行得 特别“勤奋努力”的话，可能会越过 线程优先级 去为它 分配执行时间。<br>因此，我们不能在程序中 通过 优先级 来完全准确地 判断一组状态都为 Ready的线程 将会先执行哪一个。</p><h5 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h5><p>Java语言 定义了 5中线程状态，在 任意一个时间点， 一个线程只能 有且只有 其中的一种状态，这5种状态分别如下。</p><p>新建（New）：创建后 尚未启动 的线程 处于这种 状态。</p><p>运行（Runnable）：Runnable包括了 操作系统 线程状态中的 Running和Ready，也就是处于此状态的 线程 有可能正在执行，也有可能正在等待着 CPU 为它分配执行时间。</p><p>无限期等待（Waiting）：处于这种状态的 线程 不会被 分配CPU执行时间，它们要等待被 其他线程 显式地 唤醒。<br>以下方法会让线程陷入无限期的等待状态：</p><ul><li>没有设置 Timeout 参数的 Object.wait() 方法</li><li>没有设置 Timeout 参数的 Thread.join() 方法</li><li>LockSupport.park() 方法</li></ul><p>限期等待（Timed Waiting）：处于这种状态的 线程 也不会被分配 CPU执行时间，不过 无需等待被其他线程 显式地 唤醒，在一定时间之后 它们会由系统 自动唤醒。<br>以下方法会让线程 进入 限期等待 状态：</p><ul><li>Thread.sleep()方法</li><li>设置了 Timeout 参数的 Object.wait() 方法</li><li>设置了 Timeout 参数的 Thread.join() 方法</li><li>LockSupport.parkNanos()方法</li><li>LockSupport.parkUtil()方法</li></ul><p>阻塞（Blocked）：线程被 阻塞 了，<br>“阻塞状态”与“等待状态” 的区别是：<br>“阻塞状态”在等待着获取到一个 排他锁，这个事件 将在 另外一个线程 放弃这个锁的时候 发生；<br>而 “等待状态” 则是在 等待一段时间，或者唤醒动作的发生。<br>在程序等待进入 同步区域 的时候，线程将进入这种状态。</p><p>结束（Terminated）：已终止 线程 的 线程状态，线程已经 结束执行。</p><p>上述5种状态 在遇到 特定事件 发生的时候 将会 互相转换，它们的 转换关系 如图12-6 所示。</p><h5 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h5><p>本章中，我们首先了解了 虚拟机Java内存模型 的结构及操作，<br>然后讲解了 原子性、可见性、有序性 在 Java内存模型 中的体现，<br>最后介绍了 先行发生原则 的规则及使用。</p><p>另外，我们还了解了 线程 在 Java语言之中 是如何实现的。</p><p>关于 “高效并发” 这个话题，在本章中 主要介绍了 虚拟机如何实现“并发”，在第13章中，我们的主要关注点将是 虚拟机如何实现“高效”，<br>及 虚拟机对我们编写的并发代码 提供了什么样的 优化手段。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深入java虚拟机-第五部分-高效并发&quot;&gt;&lt;a href=&quot;#深入java虚拟机-第五部分-高效并发&quot; class=&quot;headerlink&quot; title=&quot;深入java虚拟机-第五部分-高效并发&quot;&gt;&lt;/a&gt;深入java虚拟机-第五部分-高效并发&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
    
      <category term="虚拟机" scheme="https://fengshana.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="面试" scheme="https://fengshana.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="虚拟机" scheme="https://fengshana.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>流程图-markdown美人鱼🧜‍♀️图表</title>
    <link href="https://fengshana.github.io/2020/05/21/%E3%80%90%E7%90%90%E7%A2%8E%E9%9A%8F%E7%AC%94%E3%80%91/%E3%80%90%E6%B5%81%E7%A8%8B%E5%9B%BE%E3%80%91%E7%BE%8E%E4%BA%BA%E9%B1%BC/"/>
    <id>https://fengshana.github.io/2020/05/21/%E3%80%90%E7%90%90%E7%A2%8E%E9%9A%8F%E7%AC%94%E3%80%91/%E3%80%90%E6%B5%81%E7%A8%8B%E5%9B%BE%E3%80%91%E7%BE%8E%E4%BA%BA%E9%B1%BC/</id>
    <published>2020-05-20T19:31:58.233Z</published>
    <updated>2020-06-05T18:02:51.833Z</updated>
    
    <content type="html"><![CDATA[<p>🌟🌟🌟<br>😄刚刚找到两个找表情包Emoji的地方，嘿嘿😉，终于可以不用是颜文字了😉；（刚刚试了有些反应不出来…🙃,但是可以进行copy，paste啊哈哈哈🧙‍♀️ 🧙‍♀️ 🧙‍♀️ ）<br>参考blog: <code>https://segmentfault.com/q/1010000021180710/</code></p><ul><li>💫 <code>https://unicode.org/emoji/charts/full-emoji-list.html</code></li><li>💫 <code>https://emoji.muan.co/</code></li><li>💫 <code>https://www.webfx.com/tools/emoji-cheat-sheet/</code></li></ul><hr><p>参考blog: <code>http://kkpattern.github.io/2015/05/15/Embed-Chart-in-Jekyll.html</code></p><p>mermaid.full.min.js:  </p><ul><li><p>使用的是：<code>https://www.bootcdn.cn/mermaid/0.2.4/</code></p></li><li><p><code>https://cdn.bootcdn.net/ajax/libs/mermaid/0.2.4/mermaid.full.min.js</code></p></li><li><p>我是采用的hexo的next主题所以找到自己的 theme/next/layout/layout.swig 当中进行编辑</p>  <figure class="highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="keyword">set</span></span> html_class = 'theme-next ' + theme.scheme %&#125;</span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="keyword">if</span></span> theme.motion.enable %&#125;</span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="keyword">set</span></span> html_class = html_class + ' use-motion' %&#125;</span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="keyword">endif</span></span> %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">class</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; html_class | lower &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">lang</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; config.language &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="keyword">include</span></span> '_partials/head.swig' %&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span></span><span class="template-tag">&#123;% <span class="name"><span class="keyword">block</span></span> title %&#125;</span><span class="template-tag">&#123;% <span class="name"><span class="keyword">endblock</span></span> %&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="keyword">include</span></span> '_third-party/analytics/index.swig' %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/minigrid@3.1.1/dist/minigrid.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/photos/photos.css"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/photos/photo.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--把script粘到这里就差不多了--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcdn.net/ajax/libs/mermaid/0.2.4/mermaid.full.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">........</span></span><br></pre></td></tr></table></figure></li></ul><p>然后就可以愉快的使用了流程图了；终于不用傻逼式截图或者自己画了；害；  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"mermaid"</span>&gt;</span><br><span class="line">graph TD;</span><br><span class="line">    A<span class="comment">--&gt;B;</span></span><br><span class="line">    A<span class="comment">--&gt;C;</span></span><br><span class="line">    B<span class="comment">--&gt;D;</span></span><br><span class="line">    C<span class="comment">--&gt;D;</span></span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>上述代码放在了代码块<code>内容</code>当中显示；<br>下面就是上述代码直接粘在了markdown文件当中然后显示出来的内容；</p><div class="mermaid">graph TD;    A-->B;    A-->C;    B-->D;    C-->D;</div><p>现在得好好学学怎么画流程图了；哈哈哈哈<del>~</del></p><p>插入一下<strong>流程图mermaid语法</strong>，<br>参考blog 👇</p><ul><li><code>https://www.jianshu.com/p/9810ba886955</code></li><li><code>https://blog.csdn.net/wangyaninglm/article/details/52887045</code></li></ul><p><strong>方向控制</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">流程图分为竖向和横向两大类，竖向包括自上而下和自下而上两种顺序，横向包括从右到左和从左到右两种顺序。</span><br><span class="line">其对应语法分别为：graph TB/graph BT/graph RL/graph LR。</span><br><span class="line"></span><br><span class="line">TB - <span class="built_in">top</span> <span class="built_in">bottom</span>（自上而下）</span><br><span class="line">BT - <span class="built_in">bottom</span> <span class="built_in">top</span>（自下而上）</span><br><span class="line">RL - <span class="built_in">right</span> <span class="built_in">left</span>（从右到左）</span><br><span class="line">LR - <span class="built_in">left</span> <span class="built_in">right</span>（从左到右）</span><br><span class="line">TD: 默认方向，从上到下</span><br></pre></td></tr></table></figure><p>测试下；</p><div class="mermaid">graph LR;    subgraph      A[h_user user:id:3506728370       :name ]-->B[春晚];    C[h_user user:id:3506728370       :fans ]-->D[12210862];    E[h_user user:id:3506728370       :blogs ]-->F[83];    end</div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;🌟🌟🌟&lt;br&gt;😄刚刚找到两个找表情包Emoji的地方，嘿嘿😉，终于可以不用是颜文字了😉；（刚刚试了有些反应不出来…🙃,但是可以进行copy，paste啊哈哈哈🧙‍♀️ 🧙‍♀️ 🧙‍♀️ ）&lt;br&gt;参考blog: &lt;code&gt;https://segmen
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://fengshana.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="流程图" scheme="https://fengshana.github.io/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    
  </entry>
  
</feed>
