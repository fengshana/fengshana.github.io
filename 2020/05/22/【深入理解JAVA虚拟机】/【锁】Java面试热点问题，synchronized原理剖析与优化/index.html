<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script>
	(function(){
		if(''){
			if (prompt('请输入文章密码','') !== ''){
				alert('密码错误！');
				history.back();
			}
		}
	})();
</script>









<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #A0A0A0; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #A0A0A0, 0 0 5px     #A0A0A0; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #A0A0A0;    /*上边框颜色*/
        border-left-color: #A0A0A0;    /*左边框颜色*/
    }
</style>

<meta name="theme-color" content="#222">










<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
    
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/fsn-16x16.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/fsn-32x32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/fsn-16x16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/fsn-16x16.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="面试,锁,synchronized," />





  <link rel="alternate" href="/atom.xml" title="✨Fsn✨" type="application/atom+xml" />






<meta name="description" content="前言观看笔记：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1aJ411V763?from&#x3D;search&amp;seid&#x3D;6293835933701781647   观看了这个视频之后，我建议啊😉，可以去看下那个《深入java虚拟机》这本书，因为这个课讲的内容跟这本书当中的第13章 线程安全与锁优化，内容十分相似；所以我认为可以当做是课后复习书的那种；我也是经过了对比两者的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试热点问题，synchronized原理剖析与优化">
<meta property="og:url" content="https://fengshana.github.io/2020/05/22/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="✨Fsn✨">
<meta property="og:description" content="前言观看笔记：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1aJ411V763?from&#x3D;search&amp;seid&#x3D;6293835933701781647   观看了这个视频之后，我建议啊😉，可以去看下那个《深入java虚拟机》这本书，因为这个课讲的内容跟这本书当中的第13章 线程安全与锁优化，内容十分相似；所以我认为可以当做是课后复习书的那种；我也是经过了对比两者的">
<meta property="og:image" content="http://r.photo.store.qq.com/psc?/V13IdniL3IuSOB/TCfiP1YaPeRT4Jil9RANX4vLl8AstIRGl9P8oTiaYxMydq3nKZRukFcfX8VESLmsBdLaQnizkJqmwuNgIhy5oXCRrbdw7oeBbu09AWBNcVI!/r">
<meta property="article:published_time" content="2020-05-22T14:17:09.479Z">
<meta property="article:modified_time" content="2020-06-05T18:58:04.903Z">
<meta property="article:author" content="Fsn✨🧙‍♀️✨">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="锁">
<meta property="article:tag" content="synchronized">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://r.photo.store.qq.com/psc?/V13IdniL3IuSOB/TCfiP1YaPeRT4Jil9RANX4vLl8AstIRGl9P8oTiaYxMydq3nKZRukFcfX8VESLmsBdLaQnizkJqmwuNgIhy5oXCRrbdw7oeBbu09AWBNcVI!/r">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fengshana.github.io/2020/05/22/【深入理解JAVA虚拟机】/【锁】Java面试热点问题，synchronized原理剖析与优化/"/>









  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "07d52b28"
    });
  daovoice('update');
  </script>

  <title>Java面试热点问题，synchronized原理剖析与优化 | ✨Fsn✨</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2a839053bb6194637483460a0f428730";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.js"></script>
<script src="https://unpkg.com/minigrid@3.1.1/dist/minigrid.min.js"></script>
<link rel="stylesheet" href="/photos/photos.css">
<script type="text/javascript" src="/photos/photo.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/mermaid/0.2.4/mermaid.full.min.js"></script>


<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">✨Fsn✨</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-camera">
          <a href="/photos/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-camera"></i> <br />
            
            相册
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sentence">
          <a href="/shuoshuo" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-commenting"></i> <br />
            
            小心情
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>







 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>[🌿诗酒年华🌻]</h1>
    <p id="poem">挑选中🌺...🍃🍂</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '🍃《' + result.data.origin.title + '》🍂'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>

        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fengshana.github.io/2020/05/22/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fsn✨🧙‍♀️✨">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/fsn.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="✨Fsn✨">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java面试热点问题，synchronized原理剖析与优化</h1>
        

        <div class="post-meta">
		

          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-22T22:17:09+08:00">
                2020-05-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-06-06T02:58:04+08:00">
                2020-06-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  15.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  60
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="http://r.photo.store.qq.com/psc?/V13IdniL3IuSOB/TCfiP1YaPeRT4Jil9RANX4vLl8AstIRGl9P8oTiaYxMydq3nKZRukFcfX8VESLmsBdLaQnizkJqmwuNgIhy5oXCRrbdw7oeBbu09AWBNcVI!/r " rel="gallery_ckb2kyv1g00f5w0um1rpw8f2o"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="http://r.photo.store.qq.com/psc?/V13IdniL3IuSOB/TCfiP1YaPeRT4Jil9RANX4vLl8AstIRGl9P8oTiaYxMydq3nKZRukFcfX8VESLmsBdLaQnizkJqmwuNgIhy5oXCRrbdw7oeBbu09AWBNcVI!/r " itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：<code>https://www.bilibili.com/video/BV1aJ411V763?from=search&amp;seid=6293835933701781647</code>  </p>
<p>观看了这个视频之后，我建议啊😉，可以去看下那个《<strong>深入java虚拟机</strong>》这本书，因为这个课讲的内容跟这本书当中的<strong>第13章 线程安全与锁优化</strong>，内容十分相似；所以我认为可以当做是课后复习书的那种；<br>我也是经过了对比两者的内容才这么觉得；因为真的很相似；<br>包括后面举的string的那个例子；<br>为了我更深刻的记忆；我决定我还是仔细看一遍这一部分内容；<br>（现在看来其实就是<strong>第五部分 高效并发</strong> 跟该课程视频讲的 非常非常相同了；）</p>
<h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typora-root-ur<span class="variable">l:</span> img</span><br><span class="line">typora-<span class="keyword">copy</span>-images-<span class="keyword">to</span>: img</span><br></pre></td></tr></table></figure>

<h3 id="深入学习并发编程中的synchronized"><a href="#深入学习并发编程中的synchronized" class="headerlink" title="深入学习并发编程中的synchronized"></a>深入学习并发编程中的synchronized</h3><blockquote>
<p>课程背景  </p>
</blockquote>
<p><strong>第一</strong>： <strong>并发编程</strong>是java知识体系当中比较重要而且比较是比较难的一块内容。  </p>
<p>因为<strong>并发编程</strong>涉及的知识面比较广，然后比较抽象不好理解，<br>因此如果我们想很好的掌握并发编程这块内容，其实是有一定难度的。<br><strong>synchronized的原理</strong>以及其<strong>优化</strong>了解少。  </p>
<p><strong>第二</strong>： <strong>并发编程</strong>在实际企业开发当中也是会遇到的，一个比较重要的比较棘手的问题。  </p>
<p>举个例子，铁道售票的12306网站，<br>在<strong>一个时间段</strong>内，可能有<strong>大量</strong>的用户过来进行买票，那么此时就需要进行保证卖出去的<strong>票的数量</strong>是<strong>正确</strong>的，既<strong>不能超卖</strong>也<strong>不能少卖</strong>。<br>另外还要保证整个执行过程的卖票的<strong>执行效率</strong>是比较<strong>高</strong>的。  </p>
<p>那么可以通过<strong>synchronized</strong>来进行<strong>保证卖票的数量</strong>是<strong>正确</strong>的，既<strong>不会超卖</strong>也<strong>不会少卖</strong>。  </p>
<p>但是又要去考虑这个<strong>性能问题</strong>，那么就可以看到<strong>synchronized</strong>在实际的企业开发当中也是一个棘手的问题。  </p>
<p><strong>第三</strong>： <strong>并发编程</strong>现在是一个热点面试题。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;synchronized和Lock有什么区别？</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;etc...</span><br></pre></td></tr></table></figure>

<p>面试官通过并发面试题来考查面试者的<strong>并发编程</strong>掌握情况，<br>来判断面试者是否能够满足企业需要，<br>另外也能够判断面试者的技术水平。  </p>
<blockquote>
<p>课程介绍</p>
</blockquote>
<p>深入学习<strong>并发编程</strong>中的<strong>synchronized</strong></p>
<ul>
<li>第一章：<strong>并发编程</strong>中的<strong>三个问题</strong><ul>
<li><strong>可见性</strong><ul>
<li>案例：<ul>
<li><font style="color:red;">共享变量</font>;</li>
<li>一个<font style="color:red;">线程A</font>不断地来<font style="color:red;">读</font>这个<font style="color:red;">共享变量的值</font>；</li>
<li>再用另一个<font style="color:red;">线程B</font>对该<font style="color:red;">共享变量的取值</font>进行<font style="color:red;">修改</font>；</li>
<li>可以观测到另一个<font style="color:red;">线程B</font>对该<font style="color:red;">共享变量的修改</font>；</li>
<li><font style="color:red;">A线程</font>并<font style="color:red;">不能够感知得到</font>；</li>
<li>这就出现了<strong>可见性</strong>问题</li>
</ul>
</li>
<li>目标<ul>
<li>学习什么是<strong>可见性</strong>问题</li>
</ul>
</li>
<li><strong>可见性</strong>概念<ul>
<li><strong>可见性（VIsibility）：是指当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。</strong></li>
</ul>
</li>
<li><strong>可见性</strong>演示<ul>
<li>案例演示：<ul>
<li>一个A线程根据boolean类型的标记flag；while循环；</li>
<li>另一个B线程改变这个flag变量的值；</li>
<li>而第一个while循环的A线程并不会停止循环。</li>
</ul>
</li>
</ul>
</li>
<li>小结<ul>
<li>什么是<strong>可见性</strong>?<br><strong>可见性（Visibility）：是指当一个线程对共享变量进行了修改，那么另外的线程可以理解看到修改后的最新值</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>原子性</strong><ul>
<li>案例：<br>使用i++，<br>通过5个线程分别来进行执行1000次i++，<br>最终可以发现加出来的效果并非是5000，<br>可能会少于5000，<br>那么这个问题的原因就在于<strong>i++</strong>并<strong>不是一个原子操作</strong>，<br>到时会通过<strong>java反汇编</strong>的方式来进行演示分析这个i++其实有4条指令</li>
<li>目标<ul>
<li>学习什么是原子性问题</li>
</ul>
</li>
<li><strong>原子性</strong>概念<ul>
<li><strong>原子性（Atomicity）：指在一次操作或多次操作中，呀么所有的操作全部得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</strong></li>
</ul>
</li>
<li><strong>原子性</strong>演示<ul>
<li>案例演示：5个线程各执行1000次i++</li>
</ul>
</li>
</ul>
</li>
<li><strong>有序性</strong><ul>
<li>一般来想的是程序会按照<strong>编写的代码的顺序</strong>来进行执行，<br>那么实际上<strong>程序</strong>会去做一些<strong>优化措施</strong>，<br>为了让代码的<strong>执行效率更高</strong>一点，<br>会做<strong>编译器和运行期的优化</strong>操作，<br>这其中也是用到了一个案例，</li>
<li><em>有序性问题*</em>有可能会被<strong>重排序</strong>，<br>那么导致在<strong>多线程</strong>的情况下，</li>
<li><em>数据*</em>会出现<strong>错乱</strong>。</li>
<li>目标<ul>
<li>学习什么是<strong>有序性</strong>问题</li>
</ul>
</li>
<li><strong>有序性</strong>概念<ul>
<li><strong>有序性（Ordering）: 是指程序代码在执行过程中的先后顺序，由于java在编译器以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序。</strong></li>
</ul>
</li>
<li><strong>有序性</strong>演示<ul>
<li>jcstress是java并发压测工具….</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第二章：<strong>java内存模型</strong>（<strong>JMM</strong>）（开始解决问题）<ul>
<li><strong>计算机结构</strong><ul>
<li>（<strong>CPU</strong>、<strong>内存</strong>、<strong>缓存</strong>由此来引出<strong>java内存模型</strong>，<strong>主内存</strong>、<strong>工作内存</strong>如何<strong>操作变量</strong>）</li>
</ul>
</li>
<li><strong>java内存模型</strong><ul>
<li><strong>主内存</strong>与<strong>工作内存</strong>之间的<strong>交互</strong></li>
</ul>
</li>
</ul>
</li>
<li>第三章：<strong>synchronized</strong>保证<strong>三大特性</strong><ul>
<li><strong>synchronized</strong>与<strong>原子性</strong><ul>
<li>目标</li>
<li>使用<strong>synchronized</strong>保证<strong>原子性</strong></li>
<li><strong>synchronized保证原子性的原理</strong></li>
<li>小结</li>
</ul>
</li>
<li><strong>synchronized</strong>与<strong>可见性</strong></li>
<li><strong>synchronized</strong>与<strong>有序性</strong></li>
</ul>
</li>
<li>第四章：<strong>synchronized</strong>的<strong>特性</strong>（<strong>同步锁机制</strong>，<strong>synchronized</strong>作为锁的特性）<ul>
<li><strong>可重入特性</strong><ul>
<li>指的是当一个线程进入到一个同步代码块当中时，</li>
<li>获取了某一个锁之后，</li>
<li>还能够再次进入同步代码块获取同一把锁。</li>
<li>即可以重新再进入。</li>
</ul>
</li>
<li><strong>不可中断特性</strong></li>
</ul>
</li>
<li>第五章：<strong>synchronized</strong>的原理<ul>
<li><strong>javap</strong> 反汇编</li>
<li>深入JVM源码<ul>
<li>目标</li>
<li><strong>monitor监视器锁</strong></li>
<li><strong>monitor竞争</strong></li>
<li><strong>monitor等待</strong></li>
<li><strong>monitor释放</strong></li>
<li><strong>monitor</strong>是<strong>重量级锁</strong></li>
</ul>
</li>
</ul>
</li>
<li>第六章：<strong>JDK6 synchronized优化</strong><ul>
<li><strong>CAS</strong></li>
<li><strong>java对象</strong>的<strong>布局</strong><ul>
<li><strong>锁升级</strong>过程</li>
</ul>
</li>
<li><strong>偏向锁</strong></li>
<li><strong>轻量级锁</strong></li>
<li><strong>重量级锁</strong></li>
<li><strong>锁消除</strong></li>
<li><strong>锁粗化</strong></li>
<li>平时写代码如何对<strong>synchronized优化</strong><ul>
<li><strong>减少synchronized的范围</strong></li>
<li><strong>降低synchronized锁的粒度</strong></li>
<li><strong>读写分离</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h2><p>第一章：<strong>并发编程</strong>中的<strong>三个问题</strong> (可见性、原子性、有序性)</p>
<p>在使用<strong>多线程</strong>进行<strong>并发编程</strong>的时候，如果存在有<strong>多个线程</strong>来<strong>操作共享数据</strong>，<br>那么很有可能这个<strong>共享数据的值</strong>会出现<strong>错乱</strong>。<br>那么以上称之为 <strong>线程安全问题</strong>。<br>那么导致 <strong>线程安全问题</strong>的<strong>根本原因</strong>有这三种：</p>
<ul>
<li><strong>可见性</strong></li>
<li><strong>原子性</strong></li>
<li><strong>有序性</strong></li>
</ul>
<p>在讲解<strong>可见性</strong>概念之前，要注意几个<strong>前提条件</strong>：<br><strong>1、</strong>  如果只有一个线程操作，那么就肯定不会存在线程之间的<strong>可见性</strong>问题。<br><strong>2、</strong> 还需要存在有<strong>共享数据</strong>，如果没有共享数据，那么也不会存在有可见性问题。<br><strong>可见性（Visibility）</strong>：是指一个线程对共享变量进行修改，另一个线程立即得到修改后的最新值。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>学习什么是<strong>可见性问题</strong></p>
<h3 id="可见性概念"><a href="#可见性概念" class="headerlink" title="可见性概念"></a>可见性概念</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 可见性演示</span><br><span class="line"></span><br><span class="line">案例演示：</span><br><span class="line">一个线程A根据boolean类型的标记flag，while循环；</span><br><span class="line">另一个线程B改变这个flag变量的值；</span><br><span class="line">那么线程A并不会停止循环。</span><br></pre></td></tr></table></figure>
<p>package com.xxx.concurrent_problem;</p>
<p>/**<br>  案例演示：<br>          一个线程对共享变量的修改，另一个线程不能立即得到最新值<br>*/<br>public class Test01Visibility{<br>    //多个线程都会访问的数据，我们成为线程的共享数据<br>    private static boolean run = false;</p>
<pre><code>public static void main(String[] args) throws InterruptedException{
  //t1线程不断的来读取run共享变量的取值
  Thread t1 = new Thread(() -&gt; {
    while(run){

    }
  });
  t1.start();

  Thread.sleep(1000);

  //t2线程对该共享变量的取值进行修改
  Thread t2 = new Thread(() -&gt; {
    run =  false;
    System.out.println(&quot;时间到，线层2设置为false&quot;);
  });
  t2.start();

  //可以观测得到t2线程对run共享变量的修改，t1线程并不能够读取到更改了之后的值；这就出现了可见性问题
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>package com.xxx.demo01_concurrent_problem;</p>
<p>/*<br>  目标：演示可见性问题<br>    1. 创建一个共享变量<br>    2. 创建一条线程不断读取共享变量<br>    3. 创建一条线程修改共享变量<br>*/<br>public class Test01Visibility{<br>  // 1. 创建一个共享变量；静态的成员变量；boolean类型名为flag；<br>  private static boolean flag = true;</p>
<p>  public static void main(String[] args){<br>    /* 2. 创建一条线程不断读取共享变量<br>          采用lambda表达式的方式进行创建线程<br>    <em>/<br>    new Thread(()-&gt;{<br>      while(flag){<br>        /</em> 循环，如果该布尔类型变量的值为true则一直循环否则结束循环；<br>           在循环当中千万不要进行打印，打印了的话就看不到效果了<br>        */</p>
<pre><code>  }
}).start();

Thread.sleep(2000);//沉睡两秒钟；让效果更加明显；这样则更加明显的来分析问题

/* 3. 创建一条线程修改共享变量
   放到lambda表达式中
*/
new Thread(()-&gt;{

  // 将flag改为false；并且输出打印；
  flag = false;
  System.out.println(&quot;线程修改了变量的值为false&quot;);
}).start();</code></pre><p>  /**<br>  分析一下这段代码：<br>  程序从main方法开始执行；<br>  开启了线程A不断读取共享变量的取值进行循环；<br>  开启了线程B去进行修改共享变量的值并打印；</p>
<p>  多线程执行具有 fu jin/fu ji(我没听清)性，<br>  有可能先进行跑A线程也有可能跑B线程；<br>  如果先跑B线程那么则看不到A线程当中的循环；<br>  为了让这个效果更佳明显一点；<br>  所以后加了一个Thread.sleep(2000);</p>
<p>  首先执行main方法的时候；<br>  会创建出一个线程A；<br>  这个线程A会来进行读取共享变量A的取值；<br>  则读取到flag共享变量的取值为true；<br>  那么该while循环则将会一直进行循环；<br>  那么当主线程沉睡了两秒之后，又会启动一个新线程B；<br>  新线程B将flag共享变量的取值变为了false；</p>
<p>  问题就在于分析<br>  线程A当中通过flag来进行while循环当中的该flag共享变量<br>  是否也从一开始的取值true到后期的线程B当中对共享变量flag取值进行修改为false<br>  是否也是同时进行了更改取值true为false；<br>  如果线程A当中的共享变量flag的取值与线程B操作共享变量flag的取值同时进行了更改；<br>  那么线程A当中根据flag取值进行while循环的循环操作就会停下来；<br>  如果没有进行修改线程A当中的flag共享变量<br>  那么线程A当中的flag共享变量的取值就将还会是true，<br>  即while循环根据flag共享变量的取值true继续其循环操作；</p>
<p>  效果：<br>  等待两秒之后，输出了线程B当中的打印 “线程修改了变量的值为false”；<br>  然而但是运行Run的的红灯仍然开启显示在运行着；</p>
<p>  那么这个就意味着；<br>  上面的那个线程A还在while(true)执行当中；<br>  也就是线程A当中的共享变量<br>  没有受到线程B当中操作共享变量flag取值从true变为false操作的影响；<br>  flag在线程A当中取值依然还是true；<br>  所以while循环根据该flag共享变量的取值依旧在进行着循环操作。<br>  即线程A当中认为flag共享变量依旧是true，所以并没有去进行停止while循环。</p>
<p>  这个时候就可以进行观察得到 可见性问题；<br>  下面的线程B对共享变量flag取值的修改，而上面的线程A并没有立即得到最新的结果；</p>
<p>  最后做个小结：<br>  当并发编程时，如果有多线程来进行操作共享变量；<br>  一个线程来进行读取操作；<br>  一个线程来进行写操作；<br>  那么这个当中就可能会出现 线程安全问题；<br>  即一个线程B进行修改，而另外一个线程A并没有得到修改后的最新取值；<br>  */<br>  }<br>}</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 小结</span><br><span class="line"></span><br><span class="line">什么是**可见性**？</span><br><span class="line"></span><br><span class="line">```可见性（Visibility）：是指当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。</span><br></pre></td></tr></table></figure>

<h2 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h2><p>现在来看并发编程中的第二个问题：<strong>原子性</strong>问题；<br>前期讲的是并发编程中的第一个问题<strong>可见性</strong>问题；<br>后期要讲的是并发编程中的第三个问题<strong>有序性</strong>问题；<br>学习分两步第一步介绍<strong>原子性的概念</strong>；<br>第二步通过一个案例来进行演示<strong>原子性问题</strong>；</p>
<h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>学习什么是<strong>原子性问题</strong></p>
<h3 id="原子性概念"><a href="#原子性概念" class="headerlink" title="原子性概念"></a>原子性概念</h3><p>原子性的前提：</p>
<p><strong>1.</strong> 需要存在有<strong>多个线程</strong>；如果是一个线程，没有竞争的这种情况是看不出来问题所在的；<br><strong>2.</strong> 依然还是需要存在<strong>共享变量</strong>；即到时候多个线程来对共享变量来进行操作；</p>
<figure class="highlight plain"><figcaption><span>在一次或多次操作中，要么所有的操作都执行 并且 不会受 其他因素干扰 而 中断，要么所有的操作都不执行；```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 原子性演示</span><br><span class="line"></span><br><span class="line">案例演示：5个线程各执行1000次i++</span><br></pre></td></tr></table></figure>
<p>package com.xxx.demo01_concurrent_problem;</p>
<p>import java.util.ArrayList;</p>
<p>/**<br>    案例演示：5个线程各执行1000次 i++;<br>*/<br>public class Test02Atomicity{<br>  private static int number = 0;<br>  public static void main(String[] args) throws InterruptedException{</p>
<pre><code>//5个线程都执行1000次i++
Runnable increment = () -&gt; {
  for( int i = 0 ; i &lt; 1000; i++){
    number++;
  }
};

//5个线程
ArrayList&lt;Thread&gt; ts = new ArrayList&lt;&gt;();
for(int i = 0; i &lt; 5 ; i++){
  Thread t = new Thread(increment);
  t.start();
  ts.add(t);
}

for(Thread t : ts){
  t.join();
}

/* 最终的效果即，加出来的效果不是5000，可能会少于5000
    那么原因就在于i++并不是一个原子操作
    到时候会通过java反汇编的方式来进行演示和分析，这个i++其实有4条指令
*/
System.out.println(&quot;number = &quot;+ number);</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>package com.xxx.demo01_concurrent_problem;</p>
<p>/*<br>  目标：演示原子性问题<br>      1. 定义一个共享变量 number<br>      2. 对number进行 1000次的++操作<br>      3. 使用5个线程来进行操作<br>*/<br>public class Test02Atomicity{<br>  // 1. 定义一个共享变量 number；先赋值为0<br>  private static int number = 0;</p>
<p>  public static void main(String[] args) throws InterruptedException{</p>
<p>  /* 存在有5个线程需要来对number共享变量1000次的++操作<br>     2. 对number进行1000的++操作<br>     做任务；使用lambda表达式来进行编写<br>  */<br>  Runnable increment = () -&gt; {<br>    for(int i=0; i&lt; 1000; i++){<br>      number++;<br>    }<br>  };</p>
<p>  List<Thread> ts = new ArrayList<Thread>();</Thread></Thread></p>
<p>  // 3. 使用5个线程来进行<br>  for(int i = 0; i&lt; 5;i++){</p>
<pre><code>// 该5个线程所做的事情即为 上面的increment所实现的run()
Thread t = new Thread(increment);
t.start();

ts.add(t);</code></pre><p>  }</p>
<pre><code>for(Thread t : list){
  t.join();
}

// 打印number的取值
System.out.println(&quot;number = &quot;+ number);

/**
由于有可能存在 主线程跑得更快；
所以就有可能出现5个线程其run()当中的for循环没有跑完就有可能去执行输出number的取值了；
为了一定要让5个线程当中的for循环跑完然后再来取number的取值；
这个时候使用join的操作；
先把这个5个线程放置到ArrayList集合ts当中；
最后在打印之前遍历一下list集合ts；
得到每个线程让其执行join();
按照分析；每个线程都执行1000次number++；
正常来说最后输出打印这个number时的打印结果应当为5000；
那么这个运行结果有可能是5000也有可能会小于5000；

效果：
number = 5000
多运行几次
number = 4542（这次运行之后就会发现number的取值少了很多）
那么为什么会出现number取值少了很多的这种情况呢？
那么这是由于 i++（number++）这是多个操作；
而且其是通过多线程来进行操作的；
并没有来进行保证 i++(number++)这个操作的一个原子性；
那么这个时候通过javap反汇编的方式来查看i++(number++)到底是由几个部分来组成的；
找到编译后的结果（工程名/target/classes/com.xxx.demo01_concurrent_problem/Test02Atomicity.class）
找到该文件之后通过使用Windows PowerShell打开或者是通过CMD等命令行进行打开也可以；
键入命令：javap 可以对该字节码文件Test02Atomicity.class进行反汇编；
从而看到一些字节码的指令；

javap -p -v .\Test02Atomicity.class
# -p 即显示私有的；-v 即详细信息也显示出来；

通过反汇编之后可以看到很多的代码；
*/</code></pre><p>  }<br>}</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用**javap 反汇编**<span class="class"><span class="keyword">class</span>文件，得到下面的 字节码指令：</span></span><br></pre></td></tr></table></figure>
<p>private static void lambda$main();<br>  Code:<br>     0: iconst_0<br>     1: istore_0<br>     2: iload_0<br>     3: sipush        1000<br>     6: if_           23<br>     9: getstatic     #12               // Field number:I<br>    12: iconst_1<br>    13: iadd<br>    14: putstatic     #12               // Field number:I<br>    17: linc          0, 1<br>    20: goto<br>    23: return</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*反汇编*</span><span class="strong">*内容：</span></span><br></pre></td></tr></table></figure>
<pre><code>offset_delta = 27</code></pre><p>  Exception:<br>    throws java.lang.InterruptedException</p>
<h1 id="通过反汇编可以看到lambda表达式的代码在此处"><a href="#通过反汇编可以看到lambda表达式的代码在此处" class="headerlink" title="通过反汇编可以看到lambda表达式的代码在此处"></a>通过反汇编可以看到lambda表达式的代码在此处</h1><p>private static void lambda$main$0()<br>  descriptor: ()V<br>  flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC<br>  Code:<br>    stack=2, loclas=1, args_size=0<br>        0: iconst_0<br>        1: istore_0<br>        2: iload_0<br>        3: sipush       1000<br>        6: if_icmpge    23<br>        9: getstatic    #18         // Field number:I<br>       12: iconst_1<br>       13: iadd<br>       14: putstatic    #18         // Field number:I<br>       17: iinc         0,1<br>       20: goto<br>       23: return<br>      LineNumberTable:<br>        line 18: 0<br>        line 19: 9<br>        line 18: 17<br>        line 21: 23<br>      LocalVariableTable:<br>        Start  Length   Slot   Name   Signature<br>            2      21      0      1   I<br>      StackMapTable: number_of_entries = 2<br>        frame_type = 252 /* append <em>/<br>          offset_delta = 2<br>          locals = [ int ]<br>        frame_type = 250 /</em> chop */<br>          offset_delta = 20<br>  static {}:<br>    descriptor: ()V<br>    flags: ACC_STATIC<br>    Code:<br>      stack=1,  locals=0, args_size=0<br>          0: iconst_0<br>          1: putstatic  #18         // Field number:I<br>          4: return<br>…</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中，对于 number++ 而言（number为静态变量 ），实际会产生如下的JVM字节码指令：</span><br><span class="line">&gt; <span class="number">9</span>: getstatic     #<span class="number">18</span>     <span class="comment">// Field number:I</span></span><br><span class="line">&gt; <span class="number">12</span>: iconst_1</span><br><span class="line">&gt; <span class="number">13</span>: iadd</span><br><span class="line">&gt; <span class="number">14</span>: putstatic    #<span class="number">18</span>     <span class="comment">// Field number:I</span></span><br><span class="line"></span><br><span class="line">&gt; 代码当中的</span><br><span class="line">&gt; number++;</span><br><span class="line">对应反汇编代码当中的<span class="number">4</span>句</span><br><span class="line">&gt; <span class="number">9</span>: getstatic     #<span class="number">18</span>     <span class="comment">// Field number:I</span></span><br><span class="line">&gt; <span class="number">12</span>: iconst_1</span><br><span class="line">&gt; <span class="number">13</span>: iadd</span><br><span class="line">&gt; <span class="number">14</span>: putstatic    #<span class="number">18</span>     <span class="comment">// Field number:I</span></span><br><span class="line"></span><br><span class="line">即 ```number++``` 是由**四条字节码指令**组成的；</span><br><span class="line">那么其中在**一个线程**下是没有问题的；</span><br><span class="line">但如果是放在**多线程**的情况下那么就是有问题的；</span><br><span class="line">当前来进行分析下这个**原子性问题**：</span><br><span class="line">程序有主方法main方法开始进行执行的；</span><br></pre></td></tr></table></figure>
<p>public class Test02Atomicity{<br>  // 1. 定义一个共享变量number<br>  private static int number = 0;</p>
<p>  public static void main(String[] args) throws InterruptedException{<br>    // 2. 对number进行1000的++操作<br>    Runnable increment = ()-&gt;{<br>      for(int i = 0; i&lt; 1000; i++){</p>
<pre><code>number++;</code></pre><p>/**</p>
<hr>
<p>|           |             |                                        |<br>|           |             | 9: getstatic    #18  // Field number:I |<br>| number++; |===========》|12: iconst_1                            |<br>|           |             |13: iadd                                |<br>|           |             |14: putstatic    #18  // Field number:I |<br>|           |             |                                        |</p>
<hr>
<p>*/</p>
<pre><code>  }
};

List&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();
// 3. 使用5个线程来进行
for(int i = 0 ; i&lt; 5; i++){
  Thread t = new Thread(increment);
  t.start();
  list.add(t);
}

for(Thread t: list){
  t.join();
}

System.out.println(&quot;number = &quot; + number);</code></pre><p>  }</p>
<p>  /**<br>  以下进行约定：红色的箭头代表主线程<br>  那么主线程先会进行执行（main()）；<br>  Runnable该语句先不会进行执行（Runnable increment=()-&gt;{…};）；<br>  然后走下面的执行语句创建list集合（List<Thread> list=new ArrayList<Thread>();)）<br>  以及for循环5次创建生成5个Thread线程；<br>  然后这个时候每个线程才会去执行上面的Runnable；<br>  5个线程分析起来有点麻烦；<br>  当前在for()循环创建生成5个线程途中，<br>  那么此时当前假设已经创建生成线程Thread A与线程Thread B；</Thread></Thread></p>
<p>  那么此时在Thread A与Thread B同时都运行start()方法的时候<br>  那么就都将会去执行Runnable当中的run()方法即循环1000次的number++操作；<br>  那么假设此时的number取值为0；<br>  假设线程Thread A先进行走，那么即循环1000次执行number++；<br>  那么这每一次的number++都是在执行字节码的那4条指令；<br>  即<br>  9:  getstatic #18<br>  12: iconst_1<br>  13: iadd<br>  14: putstatic #18<br>  #9: getstatic该指令即为取到共享变量number的取值，此时为0<br>  #12: 字节码指令继续往下执行一步，iconst_1该字节码指令的含义为是在准备一个常量1<br>  #13: 假设再往下走一步执行字节码指令iadd；那么该指令执行后会让12: iconst_1 准备的常量1与9: getstatic #18 获取得到的number 该共享变量的取值进行相加操作；最终的结果是1；</p>
<p>  但是注意假设此时并没有真正发生赋值操作，即运算出结果为1；<br>  但是并没有赋值给number该共享变量的取值上；<br>  然后此时CPU切换到另外一个线程上面去即线程B上去执行了；<br>  那么此时另外一个线程，即线程B，也进入了for循环来执行number++操作；<br>  那么线程B也有四条字节码指令需要进行执行；</p>
<p>  先执行字节码指令的第一条指令 9: getstatic #18 获取得到共享变量number的取值，<br>  目前该共享变量的取值是没有线程进行改变的；<br>  即也就是说线程A刚刚在操作number++字节码指令操作的步骤三时只是运算得出运算结果为1；<br>  但是并没有进行赋值就进行了CPU切换到了线程B上，<br>  所以相对于线程B当前的共享变量number来说，线程B认为number共享变量的取值是0；<br>  那么当getstatic获取得到共享变量number的取值之后，<br>  然后执行字节码指令的第二条指令 12: iconst_1 即同样是准备一个常量1；<br>  再执行字节码指令的第三条指令 13: iadd 这个时候同样是将number++操作当中的第一条字节码指令当中9: getstatic #18 获取得到的 共享变量number的取值与 number++操作当中的第二条指令 12: iconst_1 所准备的常量1 这两者进行相加操作；<br>  运算结果得到1；<br>  假设线程B再继续往下走，<br>  那么此时到了number++操作所对应字节码指令的第四个指令了；<br>  即14: putstatic   #18 ；<br>  那么该指令执行之后就会将指令三当中得到的结果1赋值给共享变量number的取值，<br>  而number变量的取值此时从0变为1；<br>  那么此时该线程的一次number++执行完成；</p>
<p>  假设CPU又切换到前一条线程，即线程A；<br>  那么在切换到线程B之前，<br>  线程A的number++操作的4条字节码指令已经执行完了前三条即iadd执行运算得出运算结果为1；<br>  那么此时当CPU又切换回线程A则继续执行number++操作字节码指令的第四条指令即14: putstatic #18该指令；<br>  则该指令同样是需要进行put即给共享变量number进行赋值操作；<br>  即将A线程运算得到的1赋值给已经被线程B之前赋值好number为1的共享变量取值为1；<br>  所以当前共享变量number的取值依旧是1；<br>  那么这个时候就看到了，两个线程执行number++；<br>  按道理其值应该是2；<br>  那么因为number++的字节码指令这4条字节码指令没有保证其一个原子性；<br>  所以发现导致最后的结果number只加了1；<br>  就让数据产生了错误；<br>  那么这个问题的原因就在于让两个线程来进行操作number++；<br>  而number++的字节码指令又是多条指令（4条指令）；<br>  其中一个线程执行到一半的时候；<br>  CPU又切换到另外一个线程，即另外一个线程又来执行了；<br>  即第二个线程干扰了第一个线程的执行从而导致执行结果的错误；<br>  即没有保证原子性；（即没有使得应该的结果正确）</p>
<p>  小结：<br>  在并发编程的时候，很有可能会出现原子性问题；<br>  当一个线程对共享变量操作到一半的时候，<br>  另外一个线程也有可能来对共享变量来进行操作；<br>  那么此时另外一个线程就有可能会干扰前一个线程的操作；<br>  让前一个线程的操作没有保证其原子性；<br>  */<br>}</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">由此可见 number++ 是由多条*<span class="strong">*字节码*</span><span class="strong">*语句组成，</span></span><br><span class="line"><span class="strong">以上*</span><span class="strong">*多条指令*</span>* 在*<span class="strong">*一个线程的情况下*</span>* 是不会出问题的，</span><br><span class="line">但是在*<span class="strong">*多线程情况下*</span><span class="strong">*就可能会出现问题。</span></span><br><span class="line"><span class="strong">比如一个线程在执行 13: iadd 时，</span></span><br><span class="line"><span class="strong">另一个线程又执行 9: getstatic，</span></span><br><span class="line"><span class="strong">会导致两次 number++，实际上只加了1。</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">### 小结</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">什么是*</span><span class="strong">*原子性*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">```原子性（Atomicity）: 在一次的操作或多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</span></span><br></pre></td></tr></table></figure>

<h2 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h2><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><p>学习什么是<strong>有序性问题</strong></p>
<h3 id="有序性概念"><a href="#有序性概念" class="headerlink" title="有序性概念"></a>有序性概念</h3><p>有序性（Ordering）：是指程序代码在执行过程中的先后顺序，由于java在编译器以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码的顺序。</p>
<h3 id="有序性演示"><a href="#有序性演示" class="headerlink" title="有序性演示"></a>有序性演示</h3><p>jcstress 是java并发压测工具： <code>https://wiki.openjdk.java.net/display/CodeTools/jcstress</code></p>
<p>修改pom文件，添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jcstress<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcstress-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jcstress.version<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码<br>Test03Orderliness.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@OutCome</span>(id = &#123;<span class="string">"1"</span> , <span class="string">"4"</span>&#125;, expect =  Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>)</span><br><span class="line"><span class="meta">@OutCome</span>(id = <span class="number">0</span>, expect = EXPECT.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger"</span>)</span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Orderliness</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程一 执行的代码</span></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程二 执行的代码</span></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">      ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（有序性问题，有可能重排序从而导致在多线程的情况下，数据出现错乱问题。）</p>
<p>I_Result 是一个对象，有一个属性r1 用来保存结果，在多线程情况下可能出现几种结果？</p>
<p>情况1：线程1先执行actor1，这时 ready=false，所以进入else分支结果为1。</p>
<h2 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h2><p>第二章：Java内存模型（JMM）</p>
<p>在介绍 Java内存模型之前，先来看一下到底什么是计算机内存模型。</p>
<h3 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h3><p>学习计算机的主要组成<br>学习缓存的作用</p>
<h3 id="计算机结构简介"><a href="#计算机结构简介" class="headerlink" title="计算机结构简介"></a>计算机结构简介</h3><p>1945年6月，美籍 匈牙利 科学家 冯 诺依曼 最先提出把 计算机分作 五部分：计算器、控制器、存储器、输入和输出设备。<br>由于他对 现代计算机技术的特殊贡献，因此 冯 诺依曼 又被称为 “现代计算机之父”。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">--------------     -----------------        -------------</span><br><span class="line">|<span class="string"> 输入设备</span>|<span class="string"> ------→ </span>|<span class="string">    存储器    </span>|<span class="string"> -------→ </span>|<span class="string"> 输出设备 </span>|</span><br><span class="line">------------       -----------------         ------------</span><br><span class="line">     ↑                |<span class="string">  ↑    </span>|<span class="string">  ↑                 ↑</span></span><br><span class="line"><span class="string">     </span>|<span class="string">                </span>|<span class="string">  </span>|<span class="string">    </span>|<span class="string">  </span>|<span class="string">                 </span>|</span><br><span class="line">     |<span class="string">       ---------</span>|<span class="string">--</span>|<span class="string">----</span>|<span class="string">--</span>|<span class="string">----------       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">        </span>|<span class="string">  </span>|<span class="string">    </span>|<span class="string">  </span>|<span class="string">         </span>|<span class="string">       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">        ↓  </span>|<span class="string">    ↓  </span>|<span class="string">         </span>|<span class="string">       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">   ----------  -----------   </span>|<span class="string">       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">   </span>|<span class="string"> 运算器 </span>|<span class="string">   </span>|<span class="string"> 控制器 </span>|<span class="string">----</span>|<span class="string">-------</span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">   ----------  -----------   </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">                    </span>|<span class="string">        </span>|</span><br><span class="line">     --------|<span class="string">---------------------        </span>|</span><br><span class="line">             |<span class="string">                        CPU  </span>|</span><br><span class="line">             -------------------------------</span><br></pre></td></tr></table></figure>

<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>中央处理器（CPU，central processing unit）是计算机系统的运算和控制核心。<br>计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>计算机中所有程序的运行 都是在 内存中 进行的， 内存的作用是 用于暂时存放 CPU的运算数据，以及与 硬盘等 外部存储器 交换的数据。</p>
<p>CPU自产生以来，在逻辑结构、运行效率以及功能外延上取得了巨大发展。<br>但受制于 制造工艺以及成本等的限制，计算机的内存反倒在访问速度上并没有多大的突破，<br>因此CPU的处理速度和内存的访问速度之间的差距越拉越大，通常这种差距可以达到上千倍，极端情况下甚至会在上万倍以上。<br>这就导致CPU每次操作内存都要耗费很多等待时间。<br>内存的读写速度成为了计算机运行的瓶颈。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>由于CPU和内存两边速度 严重的不对等，会导致CPU资源受到大量的限制，降低CPU整体的吞吐量，于是就有了在CPU与主内存之间增加缓存的设计，现在缓存的数量都可以增加到3级了，最靠近CPU的缓存称为L1，然后依次是L2，L3和主内存，CPU缓存模型如图 下图所示。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                    单CPU双核的缓存结构</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|<span class="string">--------------------------------------------</span>|</span><br><span class="line">|<span class="string">      -----------          -------------    </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">  Core1  </span>|<span class="string">           </span>|<span class="string">  Core 2  </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">      -----------          -------------    </span>|</span><br><span class="line">|<span class="string">           ↓                     ↓          </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">  L1 Cache </span>|<span class="string">         </span>|<span class="string"> L1 Cache </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">           ↓                    ↓           </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">  L2 Cache </span>|<span class="string">         </span>|<span class="string"> L2 Cache </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">           ↓                    ↓           </span>|</span><br><span class="line">|<span class="string">     ------------------------------------   </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">          L3   Cache             </span>|<span class="string">   </span>|</span><br><span class="line">|<span class="string">     ------------------------------------   </span>|</span><br><span class="line">|<span class="string">                       </span>|<span class="string">                    </span>|</span><br><span class="line">|<span class="string">-----------------------</span>|<span class="string">---------------------</span></span><br><span class="line"><span class="string">                        ↓</span></span><br><span class="line"><span class="string">     ------------------------------------</span></span><br><span class="line"><span class="string">     </span>|<span class="string">              Memory              </span>|</span><br><span class="line">     ------------------------------------</span><br></pre></td></tr></table></figure>

<p>CPU Cache 分成了三个级别：L1、L2、L3。<br>级别越小越接近CPU，速度也更快，同时也代表着容量越小。</p>
<ol>
<li>L1是最接近CPU的，它容量最小，例如32k，速度最快，每个核上都有一个L1 Cache。</li>
<li>L2 Cache更大一些，例如256k，速度要慢一些，一般情况下每个核上都有一个独立的L2 Cache。</li>
<li>L3 Cache是三级缓存中最大的一级，例如12MB，同时也是缓存中最慢的一级，在同一个CPU插槽之间的核共享一个L3 Cache。</li>
</ol>
<p>Cache的出现是为了解决 CPU直接访问内存效率低下问题的，<br>程序在运行的过程中，CPU接收到指令后，它会最先向CPU中的一级缓存（L1 Cache）去寻找相关的数据，<br>如果命中缓存，CPU进行计算时就可以直接对CPU Cache中的数据进行读取和写入，<br>当运算结束之后，再将CPU Cache中的最新数据刷新到主内存当中，<br>CPU 通过直接访问Cache的方式 代替直接访问主内存的方式 极大地提高了 CPU的吞吐能力。  </p>
<p>但是由于 一级缓存（L1 Cache）容量较小，所以不可能每次都命中，这时 CPU 会继续向下一级的二级缓存（L2 Cache）寻找，<br>同样的道理，当所需要的数据在二级缓存中也没有的话，会继续转向L3 Cache、内存（主存）和硬盘。  </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>说出计算机的主要组成</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU</span><br><span class="line">内存</span><br><span class="line">缓存</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>为什么会出现缓存？</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## java内存模型</span><br><span class="line"></span><br><span class="line">### 目标</span><br><span class="line"></span><br><span class="line">学习java内存模型的概念和作用</span><br><span class="line"></span><br><span class="line">java内存模型（即 java Memory Model，简称JMM）。</span><br><span class="line"></span><br><span class="line">（java内存模型 和 以前学习的栈、堆、方法区、原空间这样的java内存结构是不一样的）</span><br><span class="line"></span><br><span class="line">很多小伙伴 将 “java内存结构” 与 “java内存模型”混淆。</span><br><span class="line"></span><br><span class="line">关于 “java内存模型”的权威解释，请参考 &#96;&#96;&#96;https:&#x2F;&#x2F;download.oracle.com&#x2F;otn-pub&#x2F;jcp&#x2F;memory_model-1.0-pfd-spec-oth-JSpec&#x2F;memory_model-1_0-pfd-spec.pdf</span><br></pre></td></tr></table></figure>

<p>Java 内存模型，是 Java虚拟机规范 中 所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。</p>
<p>JMM是一套规范， 描述了 Java程序中 各种变量（线程共享变量）的访问规则，以及在 JVM中 将变量 存储到 内存和从内存中读取变量 这样的底层细节，具体如下。</p>
<p>（学习主内存和工作内存，以及它们是如何操作这些共享变量的）</p>
<ul>
<li>主内存<ul>
<li>主内存是 所有线程都共享的，都能访问的。所有的共享变量都存储于主内存。</li>
</ul>
</li>
<li>工作内存<ul>
<li>每一个线程有自己的工作内存，工作内存只存储 该线程 对共享变量的副本。 线程对变量的所有的操作（读、取）都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方 工作内存中的 变量。</li>
</ul>
</li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">                    Java Memory Model(Java 内存模型)</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    --------------------------          ----------------------------</span><br><span class="line">    |<span class="string">        线程1           </span>|<span class="string">           </span>|<span class="string">          线程2           </span>|</span><br><span class="line">    |<span class="string">                        </span>|<span class="string">           </span>|<span class="string">                          </span>|</span><br><span class="line">    |<span class="string">  -------------------   </span>|<span class="string">           </span>|<span class="string">  --------------------    </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string">  线程1工作内存    </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string">  线程2工作内存    </span>|<span class="string">    </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string">                  </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string">                   </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string"> ---------------- </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string"> ----------------  </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string"> </span>|<span class="string"> 共享变量x副本 </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string"> 共享变量x副本 </span>|<span class="string">  </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string"> ---------------- </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string"> ----------------- </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string">                  </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string">                   </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  --------------------  </span>|<span class="string">           </span>|<span class="string">  ---------------------   </span>|</span><br><span class="line">                ↑                                      ↑</span><br><span class="line">                |<span class="string">                                      </span>|</span><br><span class="line">                |<span class="string">←---------------JMM控制--------------→</span>|</span><br><span class="line">                |<span class="string">                                      </span>|</span><br><span class="line">                ↓                                      ↓</span><br><span class="line">   --------------------------------------------------------------------</span><br><span class="line">   |<span class="string">                            主内存                                </span>|</span><br><span class="line">   |<span class="string">  ------------------      ------------------     --------------   </span>|</span><br><span class="line">   |<span class="string">  </span>|<span class="string">   共享变量x    </span>|<span class="string">       </span>|<span class="string">   共享变量 y   </span>|<span class="string">      </span>|<span class="string"> 共享变量z  </span>|<span class="string">  </span>|</span><br><span class="line">   |<span class="string">  ------------------      -------------------    ---------------  </span>|</span><br><span class="line">   |<span class="string">                                                                  </span>|</span><br><span class="line">   --------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h3 id="Java内存模型的作用"><a href="#Java内存模型的作用" class="headerlink" title="Java内存模型的作用"></a>Java内存模型的作用</h3><h2 id="主内存与工作内存之间的数据交互过程"><a href="#主内存与工作内存之间的数据交互过程" class="headerlink" title="主内存与工作内存之间的数据交互过程"></a>主内存与工作内存之间的数据交互过程</h2><h2 id="synchronized保证原子性"><a href="#synchronized保证原子性" class="headerlink" title="synchronized保证原子性"></a>synchronized保证原子性</h2><p>（通过synchronized关键字和内存模型来详细的分析原子性问题，以及如何来进行解决原子性问题，如何解决可见性问题以及有序性问题等）</p>
<p>第三章：synchronized保证三大特性</p>
<p>synchronized 能够保证在 同一时刻 最多只有一个线程执行该段代码，已达到保证并发安全的效果。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">synchronized</span><span class="params">( 锁对象 )</span></span>&#123;</span><br><span class="line">  <span class="comment">// 受保护资源 / 临界区资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 与 原子性</p>
<h3 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h3><p>学习使用 synchronized 保证原子性的原理</p>
<h3 id="使用-synchronized-保证原子性"><a href="#使用-synchronized-保证原子性" class="headerlink" title="使用 synchronized 保证原子性"></a>使用 synchronized 保证原子性</h3><p>案例演示：5个线程各执行1000次 i++；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo02_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：5个线程各执行1000次 i++;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Atomicity</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">      Runnable increment = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Test01Atomicity<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">              number++;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      ArrayList&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList();</span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; <span class="number">50</span> ; i++)&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">        t.start();</span><br><span class="line">        ts.add(t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Thread t : ts)&#123;</span><br><span class="line">        t.join();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"number = "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">    synchronized( Test01Atomicity.<span class="keyword">class</span> )&#123;</span><br><span class="line">      number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized-保证原子性的原理"><a href="#synchronized-保证原子性的原理" class="headerlink" title="synchronized 保证原子性的原理"></a>synchronized 保证原子性的原理</h3><p>对 number++ ，增加同步代码块后，保证同一时间 只有 一个线程操作 number++; 就不会出现安全问题。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>synchronized 保证原子性的原理</p>
<figure class="highlight plain"><figcaption><span>number++; 增加同步代码块后，保证同一时间只有一个线程操作 number++;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## synchronized保证可见性</span><br><span class="line"></span><br><span class="line">### 目标</span><br><span class="line"></span><br><span class="line">学习使用 synchronized 保证可见性的原理</span><br><span class="line"></span><br><span class="line">### 使用synchronized保证可见性</span><br><span class="line"></span><br><span class="line">案例演示： 一个线程根据 boolean类型的标记flag，while循环，另一个线程改变这个flag变量的值，根据boolean 类型的标记flag进行while循环的那个线程 并不会停止循环。</span><br></pre></td></tr></table></figure>
<p>package com.xxx.demo02_concurrent_problem;</p>
<p>/**<br>    案例演示：<br>      一个线程根据 boolean 类型的标记flag，while循环，另一个线程改变这个flag变量的值，<br>      根据boolean 类型的标记flag进行while循环的那个线程 并不会停止循环。<br>  */<br>  public class Test01Visibility {<br>    // 多个线程都会访问的数据，我们称为 线程的共享变量<br>    private static boolean run = true;<br>    public static void main(String[] args) throws InterruptedException{<br>      Thread t1 = new Thread(() -&gt; {<br>        while(run){<br>          //增加对象共享数据的打印，println是同步方法<br>          System.out.println(“run = “ + run);<br>        }<br>      });</p>
<pre><code>  t1.start();

  Thread.sleep(1000);

  Thread t2 = new Thread(() -&gt; {
    run = false;
    System.out.println(&quot;时间到，线程2设置为 false&quot;);
  });
}</code></pre><p>  }</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### synchronized 保证可见性的原理</span><br><span class="line"></span><br><span class="line">## synchronized保证有序性</span><br><span class="line"></span><br><span class="line">synchronized 与 有序性</span><br><span class="line"></span><br><span class="line">### 目标</span><br><span class="line"></span><br><span class="line">学习使用 synchronized 保证有序性的原理</span><br><span class="line"></span><br><span class="line">### 为什么要重排序</span><br><span class="line"></span><br><span class="line">重排序 是指 编译器 和 处理器 为了优化程序性能 而对 指令序列 进行 重新排序 的一种手段。  </span><br><span class="line"></span><br><span class="line">### <span class="keyword">as</span>-<span class="keyword">if</span>-serial语义</span><br><span class="line"></span><br><span class="line"><span class="keyword">as</span>-<span class="keyword">if</span>-serial 语义的意思是：</span><br><span class="line"></span><br><span class="line">不管怎么 重排序（编译器和处理器 为了提高 并行度），单线程程序的执行结果不能被改变。</span><br><span class="line">编译器、runtime和处理器 都必须遵守 <span class="keyword">as</span>-<span class="keyword">if</span>-serial 语义。</span><br><span class="line"></span><br><span class="line">以下数据有依赖关系，不能 重排序。</span><br><span class="line"></span><br><span class="line">写后读：</span><br></pre></td></tr></table></figure>
<p>int a = 1;<br>int b = a;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">写后写：</span><br></pre></td></tr></table></figure>
<p>int a = 1;<br>int a = 2;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">读后写：</span><br></pre></td></tr></table></figure>
<p>int a = 1;<br>int b = a;<br>int a = 2;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">编译器 和 处理器不会对 存在数据依赖关系的 操作 做重排序，</span><br><span class="line">因为这种 重排序 会改变执行结果。</span><br><span class="line"></span><br><span class="line">但是，如果操作之间 不存在数据依赖关系，这些操作就可能被 编译器和处理器 重排序。</span><br></pre></td></tr></table></figure>
<p>int a = 1;</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## synchronized的可重入特性</span><br><span class="line"></span><br><span class="line">第四章：synchronized的特性</span><br><span class="line"></span><br><span class="line">（synchronized属于同步锁机制，第四章介绍synchronized作为锁的两个特性：<span class="number">1</span>、 可重入性（当一个线程执行到同步代码块，获取了某一个锁之后，还能够再次进入同步代码块当中，获取同样的一把锁，这个是可以的，可以重新再次进入，将分析其原理以及其可重入性的好处）； <span class="number">2</span>、不可中断性（synchronized是不可中断的：当一个线程进入了同步代码块，那么另外一个线程只能够在外面进行等待，这个处于等待的线程会一直处于等待状态，不会中断，所以也就叫做不可中断，另外还会通过ReentrantLock的代码来进行演示ReentrantLock是可以进行中断的））</span><br><span class="line"></span><br><span class="line">可重入特性</span><br><span class="line"></span><br><span class="line">### 目标</span><br><span class="line"></span><br><span class="line">了解什么是可重入</span><br><span class="line">了解可重入的原理</span><br><span class="line"></span><br><span class="line">### 什么是可重入</span><br><span class="line"></span><br><span class="line">指的是 同一个线程的 可以多次获得 同一把锁。</span><br><span class="line"></span><br><span class="line">(当一个线程执行到同步代码块获取到某一个锁之后，还能再次进入同步代码块，获取同样的一把锁，这是可以的，可以重新再进入)</span><br></pre></td></tr></table></figure>
<p>package com.xxx.demo03_synchronized_nature;</p>
<p>/*<br>  可重入特性<br>    指的是 同一个线程获得锁之后，可以直接再次获取该锁。<br>*/<br>  public class Demo01{<br>    public static void main(String[] args){<br>      Runnable sellTicket =  new Runnable(){<br>        @Override<br>        public void run(){<br>          synchronized(Demo01.class){<br>            System.out.println(“我是run”);<br>            test01();<br>          }<br>        }</p>
<pre><code>    public void test01(){
      synchronized(Demo01.class){
        System.out.println(&quot;我是test01&quot;);
      }
    }
  };

  new Thread(sellTicket).start();
  new Thread(sellTicket).start();
}</code></pre><p>  }</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 可重入原理</span><br><span class="line"></span><br><span class="line">加锁次数 计数器（recursions 变量）</span><br><span class="line"></span><br><span class="line">### 可重入的好处</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 避免死锁</span><br><span class="line"><span class="number">2.</span> 更好的封装代码</span><br><span class="line"></span><br><span class="line">### 小结</span><br><span class="line"></span><br><span class="line">什么是可重入</span><br><span class="line">```指的是 同一个线程的 可以 多次 获得 同一把锁</span><br></pre></td></tr></table></figure>

<p>可重入的原理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## synchronized的不可中断性</span><br><span class="line"></span><br><span class="line">### 目标</span><br><span class="line"></span><br><span class="line">了解什么是不可中断</span><br><span class="line"></span><br><span class="line">### 什么时候不可中断</span><br><span class="line"></span><br><span class="line">一旦这个锁 被别人 获得了，如果里另一个锁想获得锁，只能等待或者阻塞，直到别的线程释放这个锁，如果别人永远不释放锁，这个线程只能永远等下去，很执着！</span><br><span class="line"></span><br><span class="line">### synchronized 不可中断演示</span><br><span class="line"></span><br><span class="line">synchronized 是不可中断，处于阻塞状态的线程会一直等待锁。</span><br><span class="line"></span><br><span class="line">(当一个线程进入一个同步代码块，那么另外一个线程只能在外面等待，这个处于等待的线程将会一直等待，不会中断，所以就叫做不可中断)</span><br></pre></td></tr></table></figure>
<p>public class Demo02_Uninterruptible{<br>  private static final Object o1 = new Object();</p>
<p>  public static void main(String[] args) throws InterruptedException{<br>    Runnable runnable =  () - {<br>      synchronized( 01 ){<br>        String name = Thread.currentThread().getName();<br>        try{<br>            System.out.println(name + “start”);<br>        }catch(InterruptedException e){<br>            System.out.println(name + “interrupted”);<br>            e.printStackTrace();<br>        }<br>      }<br>    };</p>
<pre><code>Thread t1 = new Thread(runnable);
Thread t2 = new Thread(runnable);</code></pre><p>  }<br>}</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### ReentrantLock可中断演示</span><br><span class="line"></span><br><span class="line">ReentrantLock可中断</span><br></pre></td></tr></table></figure>
<p>package com.xxx.demo03_synchronized_nature;</p>
<p>import java.util.concurrent.TimeUnit;<br>import java.util.concurrent.locks.Lock;<br>import java.util.concurrent.locks.ReentrantLock;</p>
<p>public class Demo03_INterruptible{<br>    private static final Lock o1 = new ReentrantLock();</p>
<pre><code>public static void main(String[] args) throws InterruptedException{
  Runnable runnable = () -&gt; {
    String name =  Thread.currentThread().getName();
    boolean isLock = false;
    try{
        isLock = o1.tryLock( 3, TimeUnit.SECONDS);
        if(isLock){
          System.out.println(name + &quot;lock&quot;);
          Thread.sleep(1000000);
        }
    }catch(InterruptedException e){
      System.out.println(name + &quot;interrupted&quot;);
    }finally{
        if(isLock){
          o1.unlock();
          System.out.println(name + &quot;unlock&quot;);
        }else{
          System.out.println(name + &quot;指定时间内没有得到锁，中断，不等了，可以接着做其他事情。&quot;);
        }
    }
  };
}</code></pre><p>}</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## javap反汇编学习synchronized的原理</span><br><span class="line"></span><br><span class="line">第五章：synchronized原理</span><br><span class="line"></span><br><span class="line">（较难的一块，由浅入深，涉及*<span class="strong">*synchronized的原理*</span><span class="strong">*讲解；）</span></span><br><span class="line"><span class="strong">&gt; *</span> 首先会通过*<span class="strong">*javap反汇编*</span><span class="strong">*的方式，</span></span><br><span class="line"><span class="strong">*</span><span class="strong">*synchronized*</span><span class="strong">*其实被转换成了*</span><span class="strong">*两条字节码指令*</span><span class="strong">*，</span></span><br><span class="line"><span class="strong">分别是*</span><span class="strong">*monitorenter*</span><span class="strong">*以及*</span><span class="strong">*monitorexit*</span><span class="strong">*；</span></span><br><span class="line"><span class="strong">然后会通过Oracle的官方文档即*</span><span class="strong">*JVM规范*</span><span class="strong">*来对*</span><span class="strong">*字节码指令*</span>* *<span class="strong">*monitorenter*</span><span class="strong">*以及*</span><span class="strong">*monitorexit*</span><span class="strong">*的一个简单的介绍，</span></span><br><span class="line"><span class="strong">介绍这*</span><span class="strong">*两个指令*</span><span class="strong">*时如何来进行*</span><span class="strong">*加锁和解锁*</span><span class="strong">*的，</span></span><br><span class="line"><span class="strong">通过*</span><span class="strong">*字节码指令*</span><span class="strong">*来介绍*</span><span class="strong">*synchronized*</span><span class="strong">*属于比较深入，</span></span><br><span class="line"><span class="strong">但是有并不是特别的深入，</span></span><br><span class="line"><span class="strong">那么为了更加深层次的理解*</span><span class="strong">*synchronized的底层机制*</span><span class="strong">*，</span></span><br><span class="line"><span class="strong">将会深入*</span><span class="strong">*JVM的源码*</span><span class="strong">*来进行源码分析。</span></span><br><span class="line"><span class="strong">&gt; *</span> *<span class="strong">*JVM底层*</span><span class="strong">*是使用*</span><span class="strong">*c、c++*</span><span class="strong">*所编写的；</span></span><br><span class="line"><span class="strong">*</span><span class="strong">*synchronized*</span><span class="strong">*是一个*</span><span class="strong">*关键字*</span><span class="strong">*，</span></span><br><span class="line"><span class="strong">*</span><span class="strong">*底层*</span><span class="strong">*由*</span><span class="strong">*c、c++*</span><span class="strong">*来编写。</span></span><br><span class="line"><span class="strong">会进行分析这一块的代码；</span></span><br><span class="line"><span class="strong">到时候就可以清晰的知道*</span><span class="strong">*synchronized*</span><span class="strong">*的一个清晰的*</span><span class="strong">*底层结构*</span><span class="strong">*以及如何*</span><span class="strong">*获得锁*</span><span class="strong">*、*</span><span class="strong">*等待锁*</span><span class="strong">*以及如何*</span><span class="strong">*释放锁*</span><span class="strong">*的；</span></span><br><span class="line"><span class="strong">&gt; *</span> 另外还会去介绍*<span class="strong">*synchronized*</span><span class="strong">*为什么是一个*</span><span class="strong">*重量级的锁*</span><span class="strong">*，</span></span><br><span class="line"><span class="strong">以及*</span><span class="strong">*synchronized*</span><span class="strong">*为什么会*</span><span class="strong">*开销比较大*</span><span class="strong">*；</span></span><br><span class="line"><span class="strong">因为*</span><span class="strong">*synchronized*</span><span class="strong">*是一个*</span><span class="strong">*重量级的锁*</span><span class="strong">*，</span></span><br><span class="line"><span class="strong">所以其*</span><span class="strong">*效率不高*</span><span class="strong">*，</span></span><br><span class="line"><span class="strong">那么在第六章就会来进行介绍*</span><span class="strong">*JDK6*</span><span class="strong">*当中对*</span><span class="strong">*synchronized*</span><span class="strong">*的一个*</span><span class="strong">*优化措施*</span><span class="strong">*，*</span><span class="strong">*synchronized*</span><span class="strong">*的涉及到一个叫做*</span><span class="strong">*CAS操作*</span><span class="strong">*，</span></span><br><span class="line"><span class="strong">那么就会先去进行介绍*</span><span class="strong">*CAS*</span><span class="strong">*的一个*</span><span class="strong">*原理*</span><span class="strong">*，</span></span><br><span class="line"><span class="strong">那么其实*</span><span class="strong">*CAS*</span><span class="strong">*也属于一个*</span><span class="strong">*原子操作*</span><span class="strong">*，</span></span><br><span class="line"><span class="strong">可以将*</span><span class="strong">*CAS操作*</span><span class="strong">*看做是一个*</span><span class="strong">*轻量级的synchronized*</span><span class="strong">*，</span></span><br><span class="line"><span class="strong">它能够*</span><span class="strong">*保证变量修改*</span><span class="strong">*的这样一个*</span><span class="strong">*原子操作*</span><span class="strong">*；</span></span><br><span class="line"><span class="strong">介绍了*</span><span class="strong">*CAS*</span><span class="strong">*之后就将会介绍*</span><span class="strong">*锁升级*</span><span class="strong">*的一个*</span><span class="strong">*过程*</span><span class="strong">*，</span></span><br><span class="line"><span class="strong">*</span><span class="strong">*锁升级*</span><span class="strong">*是由 *</span><span class="strong">*无锁-→偏向锁-→轻量级锁-→重量级锁*</span>* ；</span><br><span class="line">&gt; * 由浅入深的来进行学习，那么存在这么多锁就会存在一个问题；</span><br><span class="line">如何来得知是*<span class="strong">*属于哪一种锁*</span><span class="strong">*，</span></span><br><span class="line"><span class="strong">那么这个时候会先进行了解*</span><span class="strong">*JAVA对象的布局*</span><span class="strong">*；</span></span><br><span class="line"><span class="strong">以前对java对象的理解是这样的-→java对象是存在在堆中，然后有一块空间可以来进行存放其对象当中的成员变量；</span></span><br><span class="line"><span class="strong">那么介绍的*</span><span class="strong">*java对象布局*</span><span class="strong">*，其当中不仅会有*</span><span class="strong">*java对象的实例数据*</span><span class="strong">*还会有*</span><span class="strong">*对象头*</span><span class="strong">*以及一些*</span><span class="strong">*对齐数据*</span><span class="strong">*；</span></span><br><span class="line"><span class="strong">那么*</span><span class="strong">*锁升级过程*</span><span class="strong">*中的这些*</span><span class="strong">*锁*</span><span class="strong">*是*</span><span class="strong">*存在于对象头当中的Mark Word*</span><span class="strong">*当中的，</span></span><br><span class="line"><span class="strong">到时候通过c++的源码来进行详细分析；</span></span><br><span class="line"><span class="strong">&gt; *</span> 另外*<span class="strong">*JDK6*</span><span class="strong">*还对*</span><span class="strong">*synchronized*</span><span class="strong">*做了一些*</span><span class="strong">*锁消除和锁粗化的优化*</span><span class="strong">*操作，</span></span><br><span class="line"><span class="strong">经过对*</span><span class="strong">*synchronized的原理*</span><span class="strong">*的学习之后就可以总结出写代码应该如何对*</span><span class="strong">*synchronized优化*</span><span class="strong">*，写出更*</span><span class="strong">*高效*</span><span class="strong">*更*</span><span class="strong">*好*</span><span class="strong">*的代码；</span></span><br><span class="line"><span class="strong">那么会从以下几个方面进行来介绍；</span></span><br><span class="line"><span class="strong">第一个：*</span><span class="strong">*减少synchronized的范围*</span><span class="strong">*；</span></span><br><span class="line"><span class="strong">第二个：*</span><span class="strong">*降低synchronized锁的粒度*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">（这当中有一个经典的例子就是*</span><span class="strong">*HashTable*</span><span class="strong">*，*</span><span class="strong">*HashTable*</span><span class="strong">*会*</span><span class="strong">*锁*</span><span class="strong">*住所有的*</span><span class="strong">*数据*</span><span class="strong">*；而后又推出了一个叫做*</span><span class="strong">*ConcurrentHashMap*</span><span class="strong">*，那么*</span><span class="strong">*ConcurrentHashMap*</span>* *<span class="strong">*只*</span><span class="strong">*会*</span><span class="strong">*锁*</span><span class="strong">*住*</span><span class="strong">*一个桶*</span><span class="strong">*当中的*</span><span class="strong">*数据*</span><span class="strong">*）；</span></span><br><span class="line"><span class="strong">第三个：通过*</span><span class="strong">*读写分离*</span><span class="strong">*的方式来进行*</span><span class="strong">*提高效率*</span><span class="strong">*；</span></span><br><span class="line"><span class="strong">以上就是*</span><span class="strong">*synchronized*</span><span class="strong">*课程的主要内容；</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">javap 反汇编</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">### 目标</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">通过 javap 反汇编学习 synchronized的原理</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">编写一个简单的synchronized代码，如下：</span></span><br></pre></td></tr></table></figure>
<p>package com.xxx.demo04_synchronized_monitor;</p>
<p>class Increment implements Runnable{<br>  public static int number = 0;<br>  private static Object obj = new Object();</p>
<p>  @Override<br>  public void run(){<br>    for(int i = 0; i &lt; 1000; i++){<br>      synchronized( obj ){<br>        number ++;<br>      }<br>    }<br>  }</p>
<p>  public synchronized void test(){<br>    System.out.println(“a”);<br>  }<br>};</p>
<p>public class Demo01{<br>  public static void main(String[] args) throws InterruptedException{<br>      Runnable increment = new Increment();<br>      Thread t = new Thread(increment);<br>      t.start();</p>
<pre><code>System.out.println(&quot;number = &quot; + Increment.number);</code></pre><p>  }<br>}</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要看 synchronized的原理，但是 synchronized是一个关键字，看不到源码。</span><br><span class="line"></span><br><span class="line">可以将<span class="keyword">class</span>文件进行反汇编。  </span><br><span class="line"></span><br><span class="line"><span class="symbol">JDK</span>自带的一个工具: <span class="symbol">javap</span>，对字节码进行反汇编，查看字节码指令。</span><br><span class="line"></span><br><span class="line">在<span class="symbol">DOS</span>命令行输入：</span><br></pre></td></tr></table></figure>
<p>javap -p -v -c<br>C:\Users\13666\IdeaProjects\Xxx\Synchronized\target\classes\com\xxx\demo04_synchronized_monitor\Increment.class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反汇编后的效果如下：</span><br></pre></td></tr></table></figure>
<p>class com.xxx.demo04_synchronized_monitor.Increment implements java.lang.Runnable{<br>  public static int number;</p>
<p>  private static java.lang.Object obj;</p>
<p>  com.xxx.demo04_synchronized_monitor.Increment();<br>    Code:<br>      0 : aload_0<br>      1 : invokespecial   #1       // Method java/lang/Object.”<init>“:()v<br>      4 : return</init></p>
<p>  public void run();<br>    Code:<br>      0 : iconst_0<br>      1 : istore_1<br>      2 : iload_1<br>      3 : sipush    1000<br>      6 : if_icmpge 39<br>      9 : getstatic #2           // Field obj:Ljava/lang/Object<br>      12: dup<br>      13: astore_2<br>      14: monitorenter<br>      15: getstatic #3           // Field number:I<br>      18: iconst_1<br>      19: iadd<br>      20: putstatic #3           // Field number:I<br>      23: aload_2<br>      24: monitorexit<br>      25: goto      33<br>      28: astore_3<br>      29: aload_2<br>      30: monitorexit<br>      31: aload_3<br>      32: athrow<br>      33: iinc      1,  1<br>      36: goto      2<br>      39: return<br>   Exception table:<br>        from   to  target type<br>          15   25    29    any<br>          28   31    28    any</p>
<p>  public synchronized void test();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC, ACC_SYNCHRONIZED<br>    Code:<br>        stack=2,  locals=1,  args_size=1<br>            0: getstatic     #4              // Field<br>java/lang/System.out:Ljava/io/PrintStream:<br>            3: ldc           #5              // String a<br>            5: invokevirtual #6              // Method java/io/PrintStream.println:(Ljava/lang.String;)V<br>            8: return<br>        LineNumberTable:<br>          line 16: 0<br>          line 17: 8<br>        LocalVariableTable:<br>          Start     Length    Slot  Name  Signature<br>            0          9       0     this   Lcom/xxx/demo04_synchronized_monitor/Increment;</p>
<p>  static {};<br>    Code:<br>       0: iconst_0<br>       1: putstatic       #3       // Field number:I<br>       4: new             #4       // class java/lang/Object<br>       7: dup<br>       8: invokespecial   #1       // Method java/lang/Object.”<init>“:()V<br>      11: putstatic       #2       // Field obj:Ljava/lang/Object<br>      14: return<br>}</init></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### monitorenter</span></span><br><span class="line"></span><br><span class="line">首先来看一下JVM规范中对于 monitorenter 和 monitorexit 的描述：</span><br><span class="line"></span><br><span class="line">```https:<span class="regexp">//</span>docs.oracle.com<span class="regexp">/javase/</span>specs<span class="regexp">/jvms/</span>se8<span class="regexp">/html/</span>jvms-<span class="number">6</span>.html<span class="comment">#jvms-6.5.monitorenter</span></span><br></pre></td></tr></table></figure>

<p>(<code>https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</code>)</p>
<blockquote>
<p>Each object is associlated with a monitor.<br>A monitor is locked if and only if it has an owner.<br>The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p>
</blockquote>
<ul>
<li>If the entry count of the monitor associated with objectref is zero,<br>the thread enters the monitor and sets its entry count to one.<br>The thread is then the owner of the monitor.</li>
<li>If the thread already owns the monitor associated with objectref,<br>it reenters the monitor, incrementing its entry count.</li>
<li>If another thread already owns the monitor associated with objectref,<br>the thread blocks until the monitor’s entry count is zero,<br>then tries again to gain ownership.</li>
</ul>
<p>翻译过来：<br>  每一个对象 都会和 一个监视器monitor关联。<br>  监视器被占用时会被锁住，其他线程无法来获取该monitor。<br>  当JVM执行某个线程的某个方法内部的monitorenter时，它会尝试去获取当前对象对应的monitor的所有权。<br>  其过程如下：</p>
<ol>
<li>若monitor的进入数为0，线程可以进入 monitor，并将 monitor的进入数 置为1。 当前线程成为 monitor的 owner（所有者）。</li>
<li>若线程已拥有 monitor的所有权，允许它 重入 monitor，则进入monitor的进入数加1。</li>
<li>若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，直到monitor的进入数变为0，才能重新尝试获取monitor的所有权。</li>
</ol>
<p>monitorenter线程获取锁，宁进入同步代码块。<br>同时只能有一个线程获取锁。</p>
<p>monitorenter 插入在同步代码块的开始位置，当底代码执行到该指令时，将会尝试获取该对象monitor的所有权，即尝试获得该对象的锁。</p>
<h3 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h3><p>首先来看一下 JVM规范 中对于 monitorenter和monitorexit的描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced ny objectref.</span><br><span class="line">  The thread decrements the entry count of the monitor associated with objectref.</span><br><span class="line">  iIf as a result the value of the entry count is zero , the thread exits the monitor and is no longer its owner.</span><br><span class="line">  Other threads that are blocking to enter the monitor are allowed to attempt to do so.</span><br><span class="line"></span><br><span class="line">翻译过来：</span><br><span class="line"></span><br><span class="line">1. 能执行 monitorexit 指令的线程 一定是 拥有当前对象的 monitor的所有权的线程。</span><br><span class="line">2. 执行 monitorexit时 会将 monitor的进入数减1。 当monitor的进入数减为0时，当前线程退出monitor，不再拥有monitor的所有权，此时其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。</span><br><span class="line"></span><br><span class="line">## 面试题：synchronized与Lock的区别</span><br><span class="line"></span><br><span class="line">## 深入JVM源码-monitor监视器锁</span><br><span class="line"></span><br><span class="line">深入JVM源码</span><br><span class="line"></span><br><span class="line">### 目标</span><br><span class="line"></span><br><span class="line">通过JVM源码 分析 synchronized的原理</span><br><span class="line"></span><br><span class="line">### monitor监视器锁</span><br><span class="line"></span><br><span class="line">(JVM底层由C++实现)</span><br><span class="line"></span><br><span class="line">可以看出 无论是 synchronized代码块 还是 synchronized方法，</span><br><span class="line">其线程安全的语义实现 最终依赖一个叫 monitor的东西，那么这个神秘的东西是什么呢？</span><br><span class="line">下面来详细介绍一下。</span><br><span class="line"></span><br><span class="line">在HotSpot虚拟机中，monitor是由ObjectMonitor实现的。</span><br><span class="line">其源码是用c、c++来实现的，位于HotSpot虚拟机源码 ObjectMonitor.hpp文件中（src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.hpp）。</span><br><span class="line">ObjectMonitor主要数据结构如下：</span><br></pre></td></tr></table></figure>
<p>ObjectMonitor() {<br>  _header              = NULL;<br>  _count               = 0;<br>  _waiters             = 0;<br>  _recursions          = 0; // 线程的重入次数<br>  _object              = NULL; //存储该monitor的对象<br>  _owner               = NULL; //标识拥有该monitor的线程<br>  _WaitSet             = NULL; //处于wait状态的线程，会被加入到_WaitSet<br>  _WaitSetLock         = 0;<br>  _Responsible         = NULL;<br>  _succ                = NULL;<br>  _cxq                 = NULL; // 多线程竞争锁时的单项列表<br>  FreeNext             = NULL;<br>  _EntryList           = NUll; //处于等待锁block状态的线程，会被加入到该列表<br>  _SpinFreq            = 0;<br>  _SpinClock           = 0;<br>  OwnerIsThread        = 0;<br>}</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>. _owner: 初始化为NUll，当有线程占有该<span class="literal">monitor</span>时，owner标记为该线程的唯一表示。当线程释放<span class="literal">monitor</span>时，owner又恢复到NULL。owner是一个临界资源，JVM是通过CAS操作来保证其线程安全的。</span><br><span class="line"><span class="number">2</span>. _cxq: 竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。_cxq是一个临界资源，JVM通过CAS原子指令来修改_cxq队列。 修改前 _cxq的旧值 填入了 <span class="keyword">node</span><span class="title">的next</span>字段， _cxq指向新值（新线程）。因此 _cxq是一个后进先出的stack(栈)。</span><br><span class="line"><span class="number">3</span>. _EntryList: _cxq队列中 有资格成为 候选资源的 线程 会被移动到该队列中。</span><br><span class="line"><span class="number">4</span>. _WaitSet: 因为调用wait方法而被阻塞的 线程会被放在该队列中。</span><br><span class="line"></span><br><span class="line">每一个java对象都可以与一个监视器 <span class="literal">monitor</span>关联，</span><br><span class="line">可以把它理解成为一把锁，</span><br><span class="line">当一个线程想要执行一段被synchronized圈起来的同步方法或者代码块时，</span><br><span class="line">该线程得 先获取到 synchronized修饰的对象 对应的<span class="literal">monitor</span>。</span><br><span class="line"></span><br><span class="line">java代码里不会 显式地去创造这么一个 <span class="literal">monitor</span>对象，</span><br><span class="line">也无需创建，</span><br><span class="line">事实上可以这么理解：</span><br><span class="line"><span class="literal">monitor</span>并不是随着对象创建而创建的。</span><br><span class="line">是通过 synchronized 修饰符 告诉 JVM 需要为 某个对象创建关联的 <span class="literal">monitor</span>对象。</span><br><span class="line">每个线程都存在两个ObjectMonitor对象列表，分别为 free和 used列表。</span><br><span class="line">同时JVM中也维护着 global locklist。</span><br><span class="line">当线程需要 ObjectMonitor对象时，首先从线程自身的free表中申请，若存在则使用，若不存在则从 globallist 中申请。</span><br><span class="line"></span><br><span class="line">ObjectMonitor 的数据结构包含三种队列： _cxq、_WaitSet和 _EntryList，他们之间的关系转换可以用下图表示：</span><br><span class="line"></span><br><span class="line"><span class="comment">## 深入JVM源码-monitor竞争</span></span><br><span class="line"></span><br><span class="line">synchronized为什么是重量级锁，为什么开销比较大？</span><br><span class="line">synchronized是重量级的锁，效率不高。  </span><br><span class="line">synchronized的优化涉及到一个叫做CAS的操作。  </span><br><span class="line">CAS也属于一个原子操作，可以将其看做是一个轻量级的synchronized。</span><br><span class="line"></span><br><span class="line"><span class="literal">monitor</span>竞争</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 执行 monitorenter时，会调用 InterpreterRuntime.cpp</span><br><span class="line"></span><br><span class="line">（位于：src/share/vm/interpreterRuntime.cpp）的InterpreterRuntime::monitorenter 函数。</span><br><span class="line"></span><br><span class="line">具体代码可参见 HotSpot源码。</span><br></pre></td></tr></table></figure>
<p>IRT_ENTRY_NO_ASYNC(void, InterpreterRuntime:monitorenter(JavaThread*  thread, BasicObjectLock* elem))<br>#ifdef ASSERT<br>  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);<br>#endif<br>  if(PrintBiasedLockingStatistics){<br>    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());<br>  }<br>  Handle h_obj(thread, elem-&gt;obj());<br>  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),<br>          “must be NULL or an object”);<br>  if(UseBiasedLocking){<br>    //Retry fast entry if bias is revoked to avoid unnecessary inflation<br>    ObjectSynchronizer::fast_entry(h_obj, elem-&gt;lock(), true, CHECK);<br>  }else{<br>    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);<br>  }<br>  assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj)),<br>          “must be NULL or an object”);</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2.</span> 对于重量级锁，monitorenter的函数中会调用ObjectSynchronizer::slow_enter</span><br><span class="line"><span class="number">3.</span> 最终调用 ObjectMonitor::enter(位于：src<span class="meta-keyword">/share/</span>vm<span class="meta-keyword">/runtime/</span>objectMonitor.cpp)，源码如下：</span><br></pre></td></tr></table></figure>
<p>void ATTR ObjectMonitor::enter(TRAPS){<br>  // The following code is ordered to check the most common cases first<br>  // and to reduce RTS-&gt;RTO cache line upgrades on SPARC and IA32 processors.<br>  Thread * const Self = THREAD;<br>  void * cur ;</p>
<p>  //通过 CAS 操作尝试把 monitor 的 _owner 字段设置为当前线程<br>  cur = Atomic::cmpxchg_ptr(Self, &amp;_owner, NULL);<br>  if(cur == NULL){<br>    // Either ASSERT _recursions == 0 or explicitly Set _recursions = 0.<br>    assert (_recursions == 0 ,   “invariant”) ;<br>    assert (_owner      == Self, “invariant”) ;<br>    // CONSIDER: set or assert OwnerIsThread == 1<br>    return ;<br>  }</p>
<p>  //线程重入；recursions++<br>  if(cur == Self){<br>    // TODO: : check for integer overflow! BUGID 6557169<br>    _recursions ++;<br>    return ;<br>  }</p>
<p>  // 省略一些代码<br>  for (;;){<br>    jt-&gt;set_suspend_equivalent();<br>    // cleared by handle_special_suspend_equivalent_condition()<br>    // or java_suspend_self()</p>
<pre><code>// 如果获取锁失败，则等待锁的释放
EnterI(THREAD);

if(!ExitSuspendEquivalent(jt)) break;


//
// we have acquired the contended monitor, but while we were
// waiting another thread suspended us. We don&apos;t want to enter
// the monitor while suspend because that would surprise the
// thread that suspended us.
//

  _recursions = 0;
_succ = NULL;
exit(false, Self);

jt-&gt;java_suspend_self();</code></pre><p>  }<br>  Self-&gt;set_current_pending_monitor(NULL);<br>}</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">此处省略锁的自旋优化等操作，统一放在后面synchronized优化中说。</span><br><span class="line">以上代码的具体流程概括如下：</span><br><span class="line"></span><br><span class="line">## 深入JVM源码-monitor等待</span><br><span class="line"></span><br><span class="line">### monitor是重量级锁</span><br><span class="line"></span><br><span class="line">在虚拟机规范对 monitorenter 和 monitorexit 的行为描述中，</span><br><span class="line">有两点是需要特别注意的。  </span><br><span class="line"></span><br><span class="line">首先，synchronized同步块 对 同一条线程来说是可重入的，不会出现自己把自己锁死的问题。</span><br><span class="line"></span><br><span class="line">其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。  </span><br><span class="line"></span><br><span class="line">第<span class="number">12</span>章讲过，java的线程 是 映射到 操作系统的 原生线程 之上的，</span><br><span class="line">如果要 阻塞或唤醒 一个线程，都需要操作系统来帮忙完成， 这就需要从用户态转换到核心态中，因此 状态转换需要耗费很多的处理器时间。</span><br><span class="line"></span><br><span class="line">对于代码简单的同步块（如被synchronized修饰的 getter()或setter()方法），</span><br><span class="line">状态转换消耗的时间 有可能比 用户代码执行的时间还要长。</span><br><span class="line"></span><br><span class="line">所以 synchronized 是java语言中一个重量级（Heavyweight）的操作，有经验的程序员都会在确实必要的情况下才使用这种操作。  </span><br><span class="line"></span><br><span class="line">而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态之中。  </span><br><span class="line"></span><br><span class="line">可以看到ObjectMonitor的函数调用中会涉及到 Atomic::cmpxchg_ptr，Atomic::inc_prt等内核函数，这个时候就会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。</span><br><span class="line"></span><br><span class="line">用户态和内核态是什么东西呢？  </span><br><span class="line">要想了解用户态和内核态还需要先了解一下Linux系统的体系架构：</span><br><span class="line"></span><br><span class="line">## 深入JVM源码-monitor释放</span><br><span class="line"></span><br><span class="line">## 深入JVM源码-monitor是重量级锁</span><br><span class="line"></span><br><span class="line">## synchronized优化_CAS_AtomicInteger使用</span><br><span class="line"></span><br><span class="line">第六章：JDK6 synchronized优化</span><br><span class="line"></span><br><span class="line">CAS</span><br><span class="line"></span><br><span class="line">### 目标</span><br><span class="line"></span><br><span class="line">学习CAS的作用</span><br><span class="line">学习CAS的原理</span><br><span class="line"></span><br><span class="line">### CAS概述和作用</span><br><span class="line"></span><br><span class="line">CAS的全称是 Compare And Swap（比较再交换）。</span><br><span class="line">是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。</span><br><span class="line"></span><br><span class="line">CAS的作用是：CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理器保证。  </span><br><span class="line"></span><br><span class="line">(可以看做是一个轻量级的synchronized，它能保证变量修改的原子操作)</span><br><span class="line"></span><br><span class="line">#### CAS和volatile实现无锁并发</span><br></pre></td></tr></table></figure>
<p>package com.xxx.demo05_cas;</p>
<p>import java.util.ArrayList;<br>import java.util.concurrent.atomic.AtomicInteger;</p>
<p>public class Demo01{<br>  public static void main(String[] args)throws InterruptedException{<br>    AtomicInteger atomicInteger = new AtomicInteger();<br>    Runnable mr = ()-&gt;{<br>      for(int i = 0; i &lt; 1000; i++){<br>        atomicInteger.incrementAndGet();<br>      }<br>    };</p>
<pre><code>ArrayList&lt;Thread&gt; ts = new ArrayList&lt;&gt;();
for( int i=0; i &lt; 5 ; i++){
  Thread t = new Thread(mr);
  t.start();
  ts.add(t);
}

for(Thread t:ts){
    t.join();
}

System.out.println(&quot;number = &quot; + atomicInteger.get());</code></pre><p>  }<br>}</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## synchronized优化_CAS原理</span><br><span class="line"></span><br><span class="line">CAS 原理</span><br><span class="line"></span><br><span class="line">通过刚才 AtomicInteger 的源码可以看到， Unsafe类提供了原子操作。</span><br><span class="line"></span><br><span class="line">### Unsafe类介绍</span><br><span class="line"></span><br><span class="line">Unsafe类使java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。  </span><br><span class="line">过渡的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。  </span><br><span class="line">Unsafe对象不能直接调用，只能通过反射获得。  </span><br><span class="line"></span><br><span class="line">### Unsafe实现CAS</span><br><span class="line"></span><br><span class="line">### 乐观锁和悲观锁</span><br><span class="line"></span><br><span class="line">悲观锁 从悲观的角度出发：</span><br><span class="line"></span><br><span class="line">总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞。</span><br><span class="line">因此synchronized也将其称之为悲观锁。</span><br><span class="line">JDK中的ReentrantLock也是一种悲观锁。</span><br><span class="line">性能较差！</span><br><span class="line"></span><br><span class="line">乐观锁从乐观的角度出发：</span><br><span class="line">总是假设最好的情况，每次去拿数据的会后都认为别人不会修改，就算改了也没关系，再重试即可。</span><br><span class="line">所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如果没有人修改则更新，如果有人修改则重试。</span><br><span class="line"></span><br><span class="line">CAS这种机制也可以将其称之为乐观锁，综合性能较好！</span><br><span class="line"></span><br><span class="line">&gt; CAS获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰，结合CAS和volatile可以实现无锁并发，适用于竞争不激烈，多核CPU的场景下。</span><br><span class="line">&gt; <span class="number">1.</span> 因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。</span><br><span class="line">&gt; <span class="number">2.</span> 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</span><br><span class="line"></span><br><span class="line">### 小结</span><br><span class="line"></span><br><span class="line">CAS的作用是什么？</span><br><span class="line"></span><br><span class="line">```CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理器保证。</span><br></pre></td></tr></table></figure>

<p>CAS的原理是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;如果内存地址V和旧的预期值A相等就修改内存地址值为B</span><br></pre></td></tr></table></figure>

<h2 id="synchronized优化锁升级过程"><a href="#synchronized优化锁升级过程" class="headerlink" title="synchronized优化锁升级过程"></a>synchronized优化锁升级过程</h2><h2 id="synchronized优化-对象的布局"><a href="#synchronized优化-对象的布局" class="headerlink" title="synchronized优化-对象的布局"></a>synchronized优化-对象的布局</h2><p>Java对象的布局</p>
<h3 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h3><p>学习java对象的布局</p>
<p>术语参考：<code>http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</code></p>
<p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>当一个线程尝试访问 synchronized修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？是存在在锁对象的对象头中的。</p>
<p>Hotspot采用 instanceOopDesc和arrayOopDesc来描述对象头: arrayOopDesc对象用来描述数组类型。<br>instanceOopDesc的定义的在Hotspot源码的 instanceOop.hpp 文件中，另外， arrayOopDesc的定义对应 arrayOop.hpp。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">instanceOopDesc</span> :</span> <span class="keyword">public</span> oopDesc&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// aligned header size.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">header_size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">sizeof</span>(instanceOopDesc)/HeapWordSize; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If compressed. the offset of the fields of the instance may not be aligned.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">base_offset_in_bytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">/* offset computation code breaks if useCompressedClassPointers</span></span><br><span class="line"><span class="comment">         only is true</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> (UseCompressedOops &amp;&amp; UseCompressedClassPointers) ? klass_gap_offset_in_bytes() : <span class="keyword">sizeof</span>(instanceOopDesc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">contains_field_offset</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">int</span> nonstatic_field_size)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> base_in_bytes = base_offset_in_bytes();</span><br><span class="line">      <span class="keyword">return</span> (offset &gt;= base_in_bytes &amp;&amp; (offset-base_in_bytes) &lt; nonstatic_field_size = heapOopSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。</p>
<p>Mark Word对应的类型是markOop。<br>源码位于 <code>markOop.hpp</code> 中。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/<span class="strong">*</span></span><br><span class="line"><span class="strong">Bit-format of an object header (most significant first , big endian layout below):</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">32 bits:</span></span><br><span class="line"><span class="strong">---------</span></span><br><span class="line"><span class="strong">          hash:25 --------------&gt;| age:4   biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="strong">          JavaThread*</span>:23 epoch:2   age:4   biased<span class="emphasis">_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="emphasis">          size；32 -------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="emphasis">          PromotedObject*:29 ------------&gt; promo_</span>bits:3 ------&gt;| (CMS promoted object)</span><br><span class="line"></span><br><span class="line">64 bits:</span><br><span class="line">----------</span><br><span class="line"><span class="strong">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="synchronized优化-偏向锁"><a href="#synchronized优化-偏向锁" class="headerlink" title="synchronized优化-偏向锁"></a>synchronized优化-偏向锁</h2><h3 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h3><p>高效并发是从JDK1.5到JDK1.6的一个重要改进。<br>HotSpot虚拟机开发团队在这个版本上花费了大量的精力趋实现各种锁优化技术，<br>如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，<br>这些技术都是为了 在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<p>无锁–→偏向锁–→轻量级锁–→重量级锁</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><h3 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h3><p>学习偏向锁的原理和好处</p>
<h3 id="什么是偏向锁"><a href="#什么是偏向锁" class="headerlink" title="什么是偏向锁"></a>什么是偏向锁</h3><p>偏向锁是JDK6中的重要引进，因为HotSpot作者经过研究实践发现，<br>在大多数情况下，锁不仅不存在多线程竞争而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。<br>减少不必要的CAS操作。</p>
<p>偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及ThreadID即可。</p>
<h2 id="synchronized优化-轻量级锁"><a href="#synchronized优化-轻量级锁" class="headerlink" title="synchronized优化-轻量级锁"></a>synchronized优化-轻量级锁</h2><h2 id="synchronized优化-自旋锁"><a href="#synchronized优化-自旋锁" class="headerlink" title="synchronized优化-自旋锁"></a>synchronized优化-自旋锁</h2><h2 id="synchronized优化-锁消除"><a href="#synchronized优化-锁消除" class="headerlink" title="synchronized优化-锁消除"></a>synchronized优化-锁消除</h2><h3 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h3><p>学习锁消除的原理</p>
<p>锁消除 是指 虚拟机 即时编译器（JIT）在 运行时，<br>对一些代码上要求同步，但是被检测到 不可能存在共享数据竞争的锁 进行消除。</p>
<p>锁消除 的主要判定依据 来源于 逃逸分析的数据支持，<br>如果判断在一段代码中，堆上的所有数据 都不会逃逸出去 从而被其他线程 访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，<br>同步加锁 自然就无需进行。</p>
<p>变量是否逃逸，对于虚拟机来说 需要使用 数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在 明知道不存在数据争用的情况下 要求同步呢？</p>
<p>实际上有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的想象。<br>下面这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">    concatString(<span class="string">"aa"</span> , <span class="string">"bb"</span> , <span class="string">"cc"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">concatString</span><span class="params">(<span class="keyword">String</span> s1, <span class="keyword">String</span> s2, <span class="keyword">String</span> s3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后：</p>
<h2 id="synchronized优化-锁粗化"><a href="#synchronized优化-锁粗化" class="headerlink" title="synchronized优化-锁粗化"></a>synchronized优化-锁粗化</h2><p>锁粗化</p>
<h3 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h3><p>学习锁粗化的原理</p>
<p>原则上，在编写代码的时候，总是推荐将 同步亏啊的作用范围 限制得尽量小，<br>只在共享数据的实际作用域中 才进行同步，<br>这样是为了使得需要同步的操作数量 尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>大部分情况下，上面的原则都是正确地，但是如果一些列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能消耗。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">new</span> StringBuffer()</span><br><span class="line">          .<span class="built_in">append</span>(<span class="string">"aa"</span>).<span class="built_in">append</span>(<span class="string">"bb"</span>).<span class="built_in">append</span>(<span class="string">"cc"</span>).toString();</span><br><span class="line">    </span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"aa"</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"bb"</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"cc"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果虚拟机检测到有这样一串 零碎小的操作 都是用一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，这样只需要加锁一次就可以了。</p>
<h2 id="平时写代码如何对synchronized优化"><a href="#平时写代码如何对synchronized优化" class="headerlink" title="平时写代码如何对synchronized优化"></a>平时写代码如何对synchronized优化</h2><h3 id="减少synchronized的范围"><a href="#减少synchronized的范围" class="headerlink" title="减少synchronized的范围"></a>减少synchronized的范围</h3><p>同步代码块中尽量短，禁烧同步代码块中代码的执行时间，减少锁的竞争。</p>
<h3 id="降低synchronized锁的粒度"><a href="#降低synchronized锁的粒度" class="headerlink" title="降低synchronized锁的粒度"></a>降低synchronized锁的粒度</h3><p>将一个锁拆分为多个锁提高并发度</p>
<p>HashTable：锁定整个哈希表，一个操作正在进行时，其他操作也同时锁定，效率低下：</p>
<p>ConcurrentHashMap：局部锁定，只锁定桶，当对当前元素锁定时，其他元素不锁定。</p>
<p>LinkedBlockingQueue入队和出队使用不同的锁，相对于读写只有一个锁效率要高。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------</span><br><span class="line">|<span class="string"> 元素1 </span>|<span class="string"> 元素2 </span>|<span class="string"> 元素3 </span>|<span class="string"> 元素4 </span>|<span class="string"> 元素5 </span>|</span><br><span class="line">----↑------------------------------↑-----</span><br><span class="line">    |<span class="string">                              </span>|</span><br><span class="line">take添加元素使用一把锁objb          put添加元素使用一把锁objA</span><br></pre></td></tr></table></figure>

<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>ConcurrentHashMap: CopyOnWriteArrayList和ConyOnWriteSet</p>
<p>读取时不加锁，写入和删除时加锁</p>

      
    </div>
    
    
    



<div>
    
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>Java面试热点问题，synchronized原理剖析与优化📝</a></p>
  <p><span>文章作者:</span>Fsn✨🧙‍♀️✨</a></p>
  <p><span>发布时间:</span>2020年05月22日 - 22:17:09🌞</p>
  <p><span>最后更新:</span>2020年06月06日 - 02:58:04🌜</p>
  <p><span>原始链接:</span><a href="/2020/05/22/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/" title="Java面试热点问题，synchronized原理剖析与优化">https://fengshana.github.io/2020/05/22/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://fengshana.github.io/2020/05/22/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。🎄	</p>  
</div>
<style>
</style>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        //swal({   
          //title: "",   
         // text: '<div style="width:300px;height:100px;font-size:14px;">道友，复制成功了哟(＾Ｕ＾)ノ~</div>',   
          //html: true,
          //timer: 500,   
        //showConfirmButton: false
        //});
      });
      new ClipboardJS('.fa-clipboard', {
          target: function(trigger) {
              $('<div>').appendTo('body').addClass('alert alert-success').html('🤠道友ᕦ(･ㅂ･)ᕤ，🥭复制成功了哟(^_−)☆').show().delay(1500).fadeOut();
              return trigger.nextElementSibling;
            }
      });
    }));  
</script>


    
</div>



    








<div>
  
    <div>
    
        <br/>
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------🍓🍇本文结束🤞感谢道友的阅读🍍🍒-------------</div>
    
</div>
  
</div>












    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>🥕🍆坚持原创技术分享🐳，🌽🥬您的支持将鼓励我继续创作！🐬</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatreward.png" alt="Fsn✨🧙‍♀️✨ 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipayreward.png" alt="Fsn✨🧙‍♀️✨ 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    










    <footer class="post-footer">
      
        <div class="post-tags" style="text-align:center">
          
            <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">🌟面试</i></a>
          
            <a href="/tags/%E9%94%81/" rel="tag">🌟锁</i></a>
          
            <a href="/tags/synchronized/" rel="tag">🌟synchronized</i></a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/21/%E3%80%90%E7%90%90%E7%A2%8E%E9%9A%8F%E7%AC%94%E3%80%91/%E3%80%90%E6%B5%81%E7%A8%8B%E5%9B%BE%E3%80%91%E7%BE%8E%E4%BA%BA%E9%B1%BC/" rel="next" title="流程图-markdown美人鱼🧜‍♀️图表">
                👈 流程图-markdown美人鱼🧜‍♀️图表
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/26/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA12/" rel="prev" title="深入理解Java虚拟机-Java内存模型与线程">
                深入理解Java虚拟机-Java内存模型与线程 👉
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80ODk3My8yNTQ2Nw=="></div>
    </div>

  
  
  

  
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/fsn.jpg"
                alt="Fsn✨🧙‍♀️✨" />
            
              <p class="site-author-name" itemprop="name">Fsn✨🧙‍♀️✨</p>
              <p class="site-description motion-element" itemprop="description">🌈勿忘初心💫 🌞，🌜方得始终⭐</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!--<a href="/archives/%7C%7Carchive">-->
                <a href="/archives/">
              
                  <span class="site-state-item-count">151</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">81</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/fengshana" target="_blank" title="GitHub">
                      
                        <i 

                          
                          class="fa fa-fw fa-github">
                          
                         
                        
                        </i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://space.bilibili.com/475144966" target="_blank" title="Bilibili">
                      
                        <i 

                          
                            class="">🏃‍♂️
                          
                         
                        
                        </i>Bilibili</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#课程介绍"><span class="nav-number">2.</span> <span class="nav-text">课程介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#深入学习并发编程中的synchronized"><span class="nav-number">2.1.</span> <span class="nav-text">深入学习并发编程中的synchronized</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可见性问题"><span class="nav-number">3.</span> <span class="nav-text">可见性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标"><span class="nav-number">3.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可见性概念"><span class="nav-number">3.2.</span> <span class="nav-text">可见性概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子性问题"><span class="nav-number">4.</span> <span class="nav-text">原子性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-1"><span class="nav-number">4.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性概念"><span class="nav-number">4.2.</span> <span class="nav-text">原子性概念</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通过反汇编可以看到lambda表达式的代码在此处"><span class="nav-number"></span> <span class="nav-text">通过反汇编可以看到lambda表达式的代码在此处</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#有序性问题"><span class="nav-number">1.</span> <span class="nav-text">有序性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-2"><span class="nav-number">1.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序性概念"><span class="nav-number">1.2.</span> <span class="nav-text">有序性概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序性演示"><span class="nav-number">1.3.</span> <span class="nav-text">有序性演示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机结构"><span class="nav-number">2.</span> <span class="nav-text">计算机结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-3"><span class="nav-number">2.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机结构简介"><span class="nav-number">2.2.</span> <span class="nav-text">计算机结构简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU"><span class="nav-number">2.3.</span> <span class="nav-text">CPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存"><span class="nav-number">2.4.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存"><span class="nav-number">2.5.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">2.6.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java内存模型的作用"><span class="nav-number">2.7.</span> <span class="nav-text">Java内存模型的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主内存与工作内存之间的数据交互过程"><span class="nav-number">3.</span> <span class="nav-text">主内存与工作内存之间的数据交互过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized保证原子性"><span class="nav-number">4.</span> <span class="nav-text">synchronized保证原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-4"><span class="nav-number">4.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-synchronized-保证原子性"><span class="nav-number">4.2.</span> <span class="nav-text">使用 synchronized 保证原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-保证原子性的原理"><span class="nav-number">4.3.</span> <span class="nav-text">synchronized 保证原子性的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-1"><span class="nav-number">4.4.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitorexit"><span class="nav-number">4.5.</span> <span class="nav-text">monitorexit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化锁升级过程"><span class="nav-number">5.</span> <span class="nav-text">synchronized优化锁升级过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-对象的布局"><span class="nav-number">6.</span> <span class="nav-text">synchronized优化-对象的布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-5"><span class="nav-number">6.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象头"><span class="nav-number">6.2.</span> <span class="nav-text">对象头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mark-Word"><span class="nav-number">6.3.</span> <span class="nav-text">Mark Word</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-偏向锁"><span class="nav-number">7.</span> <span class="nav-text">synchronized优化-偏向锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#锁升级过程"><span class="nav-number">7.1.</span> <span class="nav-text">锁升级过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁"><span class="nav-number">7.2.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-6"><span class="nav-number">7.3.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是偏向锁"><span class="nav-number">7.4.</span> <span class="nav-text">什么是偏向锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-轻量级锁"><span class="nav-number">8.</span> <span class="nav-text">synchronized优化-轻量级锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-自旋锁"><span class="nav-number">9.</span> <span class="nav-text">synchronized优化-自旋锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-锁消除"><span class="nav-number">10.</span> <span class="nav-text">synchronized优化-锁消除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-7"><span class="nav-number">10.1.</span> <span class="nav-text">目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-锁粗化"><span class="nav-number">11.</span> <span class="nav-text">synchronized优化-锁粗化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-8"><span class="nav-number">11.1.</span> <span class="nav-text">目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平时写代码如何对synchronized优化"><span class="nav-number">12.</span> <span class="nav-text">平时写代码如何对synchronized优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#减少synchronized的范围"><span class="nav-number">12.1.</span> <span class="nav-text">减少synchronized的范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#降低synchronized锁的粒度"><span class="nav-number">12.2.</span> <span class="nav-text">降低synchronized锁的粒度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写分离"><span class="nav-number">12.3.</span> <span class="nav-text">读写分离</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      


      
<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
<div class="widget-wrap">
    <div id="myCanvasContainer" class="widget tagcloud">
        <canvas width="300" height="300" id="resCanvas" style="width=100%; background-color:transparent;">
            <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ArrayList/" rel="tag">ArrayList</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B-%E6%A0%91/" rel="tag">B+树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B%E6%A0%91/" rel="tag">B树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CORS/" rel="tag">CORS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git%E5%B7%A5%E4%BD%9C%E6%B5%81/" rel="tag">Git工作流</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HASH%E8%A1%A8/" rel="tag">HASH表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">JVM虚拟机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MICROSERVICES/" rel="tag">MICROSERVICES</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql%E7%B4%A2%E5%BC%95/" rel="tag">MySql索引</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/" rel="tag">Oracle</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PayPal/" rel="tag">PayPal</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/" rel="tag">RabbitMQ实战指南</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" rel="tag">Redis设计与实现</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SendGrid/" rel="tag">SendGrid</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SprigBoot/" rel="tag">SprigBoot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/" rel="tag">Spring技术内幕</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sql/" rel="tag">Sql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vuejs/" rel="tag">Vuejs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaScript/" rel="tag">javaScript</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdk8/" rel="tag">jdk8</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/motto/" rel="tag">motto</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oss/" rel="tag">oss</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/synchronized/" rel="tag">synchronized</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/" rel="tag">tomcat</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%B2/" rel="tag">串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BF%A1666/" rel="tag">信666</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BF%A1666%E5%B7%A5%E4%BD%9C%E4%BA%A4%E6%8E%A5/" rel="tag">信666工作交接</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E9%A1%B5/" rel="tag">分页</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">前端面试题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E8%89%B2%E7%90%83/" rel="tag">双色球</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%A3%E8%AF%AD/" rel="tag">口语</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE/" rel="tag">图</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" rel="tag">存储过程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/" rel="tag">微信公众号</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E6%80%81/" rel="tag">心态</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E6%80%81%E8%AF%BE%E7%A8%8B/" rel="tag">心态课程</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E6%83%85/" rel="tag">心情</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%AF%E4%BB%98/" rel="tag">支付</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" rel="tag">数据库优化</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9F%A5%E6%89%BE/" rel="tag">查找</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" rel="tag">栈与队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/" rel="tag">流程图</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90/" rel="tag">理解分析</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%90%86%E8%B4%A2/" rel="tag">理财</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%90%86%E8%B4%A2%E5%AD%A6%E4%B9%A0/" rel="tag">理财学习</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%B4%E6%92%AD/" rel="tag">直播</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%8E%A5%E7%8F%AD%E4%BA%BA/" rel="tag">社会主义接班人</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" rel="tag">红黑树</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="tag">线性表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8B%B1%E8%AF%AD/" rel="tag">英语</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%8D%E6%B1%87/" rel="tag">词汇</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1/" rel="tag">邮件服务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%86%E8%B5%AB/" rel="tag">领赫</a><span class="tag-list-count">11</span></li></ul>
        </canvas>
    </div>
</div>



    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">🌱2019 🍄 🌳

<span itemprop="copyrightYear">2020</span>
  <span class="with-love">
  <!--user-->
    🍉
  </span>
 
 <span class="author" itemprop="copyrightHolder">Fsn✨🧙‍♀️✨</span>

  





  <script async src="http://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
 
     🏃‍♂️ 
    <span class="post-meta-item-icon">
      📈
    </span>
    
      <span class="post-meta-item-text">小屋💒总字数：</span>
    
	<span title="Site words total count">
     525.7k🌟 </span>
    <!--<span title="symbols_count_time.count_total">1m</span>-->
  
</div>



  <!-- <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>-->






<!--



 -->
 






        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-beta.2/lazyload.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  













  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  
  <script type="text/javascript" src="/js/src/exturl.js?v=5.1.4"></script>


  
  
  
  <!-- 
  
  -->
  <link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>

  <!-- 代码块复制功能    <script src="dist/clipboard.min.js"></script>-->
  <script type="text/javascript" src="/js/src/clipboard.min.js"></script>
  <script type="text/javascript" src="/js/src/clipboard-use.js"></script>
  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":250,"vOffset":-10},"mobile":{"show":false},"log":false,"tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>

<!--崩溃欺骗 <script type="text/javascript" src="/js/src/crash_cheat.js"></script> -->




