<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script>
	(function(){
		if(''){
			if (prompt('请输入文章密码','') !== ''){
				alert('密码错误！');
				history.back();
			}
		}
	})();
</script>









<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #A0A0A0; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #A0A0A0, 0 0 5px     #A0A0A0; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #A0A0A0;    /*上边框颜色*/
        border-left-color: #A0A0A0;    /*左边框颜色*/
    }
</style>

<meta name="theme-color" content="#222">










<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
    
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/fsn-16x16.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/fsn-32x32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/fsn-16x16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/fsn-16x16.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="面试,锁,synchronized," />





  <link rel="alternate" href="/atom.xml" title="✨Fsn✨" type="application/atom+xml" />






<meta name="description" content="前言观看笔记：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1aJ411V763?from&#x3D;search&amp;seid&#x3D;6293835933701781647 观看了这个视频之后，我建议啊😉，可以去看下那个《深入java虚拟机》这本书，因为这个课讲的内容跟这本书当中的第13章 线程安全与锁优化，内容十分相似；所以我认为可以当做是课后复习书的那种；我也是经过了对比两者的内容">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试热点问题，synchronized原理剖析与优化">
<meta property="og:url" content="https://fengshana.github.io/2020/06/09/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="✨Fsn✨">
<meta property="og:description" content="前言观看笔记：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1aJ411V763?from&#x3D;search&amp;seid&#x3D;6293835933701781647 观看了这个视频之后，我建议啊😉，可以去看下那个《深入java虚拟机》这本书，因为这个课讲的内容跟这本书当中的第13章 线程安全与锁优化，内容十分相似；所以我认为可以当做是课后复习书的那种；我也是经过了对比两者的内容">
<meta property="og:image" content="http://r.photo.store.qq.com/psc?/V13IdniL3IuSOB/TCfiP1YaPeRT4Jil9RANXzmjoHDataiLY6YkNXKGW21wQYIfUNQG2kiyAd2Y8tHYhCJmrYnKYmc.yoDJEiJQacaZqoup9r9VgJxjeAxZUsE!/r">
<meta property="article:published_time" content="2020-06-08T20:20:50.000Z">
<meta property="article:modified_time" content="2020-06-08T20:12:36.233Z">
<meta property="article:author" content="Fsn✨🧙‍♀️✨">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="锁">
<meta property="article:tag" content="synchronized">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://r.photo.store.qq.com/psc?/V13IdniL3IuSOB/TCfiP1YaPeRT4Jil9RANXzmjoHDataiLY6YkNXKGW21wQYIfUNQG2kiyAd2Y8tHYhCJmrYnKYmc.yoDJEiJQacaZqoup9r9VgJxjeAxZUsE!/r">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fengshana.github.io/2020/06/09/【深入理解JAVA虚拟机】/【锁】Java面试热点问题，synchronized原理剖析与优化/"/>









  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "07d52b28"
    });
  daovoice('update');
  </script>

  <title>Java面试热点问题，synchronized原理剖析与优化 | ✨Fsn✨</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2a839053bb6194637483460a0f428730";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  
  <!-- Google AdSense start -->
  <script data-ad-client="ca-pub-3892229323208960" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- Google AdSense end -->

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.js"></script>
<script src="https://unpkg.com/minigrid@3.1.1/dist/minigrid.min.js"></script>
<link rel="stylesheet" href="/photos/photos.css">
<script type="text/javascript" src="/photos/photo.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/mermaid/0.2.4/mermaid.full.min.js"></script>


<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">✨Fsn✨</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-camera">
          <a href="/photos/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-camera"></i> <br />
            
            相册
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sentence">
          <a href="/shuoshuo" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-commenting"></i> <br />
            
            小心情
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>


<!-- Fsn -->
<script type="text/javascript">
WIDGET = {FID: 'o6km9Rzhmn'}
</script>
<script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>




 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>[🌿诗酒年华🌻]</h1>
    <p id="poem">挑选中🌺...🍃🍂</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '🍃《' + result.data.origin.title + '》🍂'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>

        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fengshana.github.io/2020/06/09/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fsn✨🧙‍♀️✨">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/fsn.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="✨Fsn✨">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java面试热点问题，synchronized原理剖析与优化</h1>
        

        <div class="post-meta">
		

          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-09T04:20:50+08:00">
                2020-06-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-06-09T04:12:36+08:00">
                2020-06-09
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  73.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  282
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="http://r.photo.store.qq.com/psc?/V13IdniL3IuSOB/TCfiP1YaPeRT4Jil9RANXzmjoHDataiLY6YkNXKGW21wQYIfUNQG2kiyAd2Y8tHYhCJmrYnKYmc.yoDJEiJQacaZqoup9r9VgJxjeAxZUsE!/r " rel="gallery_ckbxb1ole00gsc4um6ex16j9z"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="http://r.photo.store.qq.com/psc?/V13IdniL3IuSOB/TCfiP1YaPeRT4Jil9RANXzmjoHDataiLY6YkNXKGW21wQYIfUNQG2kiyAd2Y8tHYhCJmrYnKYmc.yoDJEiJQacaZqoup9r9VgJxjeAxZUsE!/r " itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：<code>https://www.bilibili.com/video/BV1aJ411V763?from=search&amp;seid=6293835933701781647</code></p>
<p>观看了这个视频之后，我建议啊😉，可以去看下那个《<strong>深入java虚拟机</strong>》这本书，因为这个课讲的内容跟这本书当中的<strong>第13章 线程安全与锁优化</strong>，内容十分相似；所以我认为可以当做是课后复习书的那种；<br>我也是经过了对比两者的内容才这么觉得；因为真的很相似；<br>包括后面举的string的那个例子；<br>为了我更深刻的记忆；我决定我还是仔细看一遍这一部分内容；<br>（现在看来其实就是<strong>第五部分 高效并发</strong> 跟该课程视频讲的 非常非常相同了；）</p>
<p>为了做完这点屁笔记，熬的我真是老眼昏花；<br>我可真是太讨厌做笔记了；</p>
<h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typora-root-ur<span class="variable">l:</span> img</span><br><span class="line">typora-<span class="keyword">copy</span>-images-<span class="keyword">to</span>: img</span><br></pre></td></tr></table></figure>

<h3 id="深入学习并发编程中的synchronized"><a href="#深入学习并发编程中的synchronized" class="headerlink" title="深入学习并发编程中的synchronized"></a>深入学习并发编程中的synchronized</h3><blockquote>
<p>课程背景  </p>
</blockquote>
<p><strong>第一</strong>： <strong>并发编程</strong>是java知识体系当中比较重要而且比较是比较难的一块内容。  </p>
<p>因为<strong>并发编程</strong>涉及的知识面比较广，然后比较抽象不好理解，<br>因此如果我们想很好的掌握并发编程这块内容，其实是有一定难度的。<br><strong>synchronized的原理</strong>以及其<strong>优化</strong>了解少。  </p>
<p><strong>第二</strong>： <strong>并发编程</strong>在实际企业开发当中也是会遇到的，一个比较重要的比较棘手的问题。  </p>
<p>举个例子，铁道售票的12306网站，<br>在<strong>一个时间段</strong>内，可能有<strong>大量</strong>的用户过来进行买票，那么此时就需要进行保证卖出去的<strong>票的数量</strong>是<strong>正确</strong>的，既<strong>不能超卖</strong>也<strong>不能少卖</strong>。<br>另外还要保证整个执行过程的卖票的<strong>执行效率</strong>是比较<strong>高</strong>的。  </p>
<p>那么可以通过<strong>synchronized</strong>来进行<strong>保证卖票的数量</strong>是<strong>正确</strong>的，既<strong>不会超卖</strong>也<strong>不会少卖</strong>。  </p>
<p>但是又要去考虑这个<strong>性能问题</strong>，那么就可以看到<strong>synchronized</strong>在实际的企业开发当中也是一个棘手的问题。  </p>
<p><strong>第三</strong>： <strong>并发编程</strong>现在是一个热点面试题。  </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>当中出现了异常，会不会释放锁？</span><br><span class="line"><span class="keyword">synchronized</span>和Lock有什么区别？</span><br><span class="line"><span class="keyword">synchronized</span>和<span class="keyword">volatile</span>有什么区别？</span><br><span class="line">etc...</span><br></pre></td></tr></table></figure>

<p>面试官通过并发面试题来考查面试者的<strong>并发编程</strong>掌握情况，<br>来判断面试者是否能够满足企业需要，<br>另外也能够判断面试者的技术水平。  </p>
<blockquote>
<p>课程介绍</p>
</blockquote>
<p>深入学习<strong>并发编程</strong>中的<strong>synchronized</strong></p>
<ul>
<li>第一章：<strong>并发编程</strong>中的<strong>三个问题</strong><ul>
<li><strong>可见性</strong><ul>
<li>案例：<ul>
<li><font style="color:red;">共享变量</font>;</li>
<li>一个<font style="color:red;">线程A</font>不断地来<font style="color:red;">读</font>这个<font style="color:red;">共享变量的值</font>；</li>
<li>再用另一个<font style="color:red;">线程B</font>对该<font style="color:red;">共享变量的取值</font>进行<font style="color:red;">修改</font>；</li>
<li>可以观测到另一个<font style="color:red;">线程B</font>对该<font style="color:red;">共享变量的修改</font>；</li>
<li><font style="color:red;">A线程</font>并<font style="color:red;">不能够感知得到</font>；</li>
<li>这就出现了<strong>可见性</strong>问题</li>
</ul>
</li>
<li>目标<ul>
<li>学习什么是<strong>可见性</strong>问题</li>
</ul>
</li>
<li><strong>可见性</strong>概念<ul>
<li><strong>可见性（VIsibility）：是指当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。</strong></li>
</ul>
</li>
<li><strong>可见性</strong>演示<ul>
<li>案例演示：<ul>
<li>一个A线程根据boolean类型的标记flag；while循环；</li>
<li>另一个B线程改变这个flag变量的值；</li>
<li>而第一个while循环的A线程并不会停止循环。</li>
</ul>
</li>
</ul>
</li>
<li>小结<ul>
<li>什么是<strong>可见性</strong>?<br><strong>可见性（Visibility）：是指当一个线程对共享变量进行了修改，那么另外的线程可以理解看到修改后的最新值</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>原子性</strong><ul>
<li>案例：<br>使用i++，<br>通过5个线程分别来进行执行1000次i++，<br>最终可以发现加出来的效果并非是5000，<br>可能会少于5000，<br>那么这个问题的原因就在于<strong>i++</strong>并<strong>不是一个原子操作</strong>，<br>到时会通过<strong>java反汇编</strong>的方式来进行演示分析这个i++其实有4条指令</li>
<li>目标<ul>
<li>学习什么是原子性问题</li>
</ul>
</li>
<li><strong>原子性</strong>概念<ul>
<li><strong>原子性（Atomicity）：指在一次操作或多次操作中，呀么所有的操作全部得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</strong></li>
</ul>
</li>
<li><strong>原子性</strong>演示<ul>
<li>案例演示：5个线程各执行1000次i++</li>
</ul>
</li>
</ul>
</li>
<li><strong>有序性</strong><ul>
<li>一般来想的是程序会按照<strong>编写的代码的顺序</strong>来进行执行，<br>那么实际上<strong>程序</strong>会去做一些<strong>优化措施</strong>，<br>为了让代码的<strong>执行效率更高</strong>一点，<br>会做<strong>编译器和运行期的优化</strong>操作，<br>这其中也是用到了一个案例，</li>
<li><em>有序性问题*</em>有可能会被<strong>重排序</strong>，<br>那么导致在<strong>多线程</strong>的情况下，</li>
<li><em>数据*</em>会出现<strong>错乱</strong>。</li>
<li>目标<ul>
<li>学习什么是<strong>有序性</strong>问题</li>
</ul>
</li>
<li><strong>有序性</strong>概念<ul>
<li><strong>有序性（Ordering）: 是指程序代码在执行过程中的先后顺序，由于java在编译器以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序。</strong></li>
</ul>
</li>
<li><strong>有序性</strong>演示<ul>
<li>jcstress是java并发压测工具….</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第二章：<strong>java内存模型</strong>（<strong>JMM</strong>）（开始解决问题）<ul>
<li><strong>计算机结构</strong><ul>
<li>（<strong>CPU</strong>、<strong>内存</strong>、<strong>缓存</strong>由此来引出<strong>java内存模型</strong>，<strong>主内存</strong>、<strong>工作内存</strong>如何<strong>操作变量</strong>）</li>
</ul>
</li>
<li><strong>java内存模型</strong><ul>
<li><strong>主内存</strong>与<strong>工作内存</strong>之间的<strong>交互</strong></li>
</ul>
</li>
</ul>
</li>
<li>第三章：<strong>synchronized</strong>保证<strong>三大特性</strong><ul>
<li><strong>synchronized</strong>与<strong>原子性</strong><ul>
<li>目标</li>
<li>使用<strong>synchronized</strong>保证<strong>原子性</strong></li>
<li><strong>synchronized保证原子性的原理</strong></li>
<li>小结</li>
</ul>
</li>
<li><strong>synchronized</strong>与<strong>可见性</strong></li>
<li><strong>synchronized</strong>与<strong>有序性</strong></li>
</ul>
</li>
<li>第四章：<strong>synchronized</strong>的<strong>特性</strong>（<strong>同步锁机制</strong>，<strong>synchronized</strong>作为锁的特性）<ul>
<li><strong>可重入特性</strong><ul>
<li>指的是当一个线程进入到一个同步代码块当中时，</li>
<li>获取了某一个锁之后，</li>
<li>还能够再次进入同步代码块获取同一把锁。</li>
<li>即可以重新再进入。</li>
</ul>
</li>
<li><strong>不可中断特性</strong></li>
</ul>
</li>
<li>第五章：<strong>synchronized</strong>的原理<ul>
<li><strong>javap</strong> 反汇编</li>
<li>深入JVM源码<ul>
<li>目标</li>
<li><strong>monitor监视器锁</strong></li>
<li><strong>monitor竞争</strong></li>
<li><strong>monitor等待</strong></li>
<li><strong>monitor释放</strong></li>
<li><strong>monitor</strong>是<strong>重量级锁</strong></li>
</ul>
</li>
</ul>
</li>
<li>第六章：<strong>JDK6 synchronized优化</strong><ul>
<li><strong>CAS</strong></li>
<li><strong>java对象</strong>的<strong>布局</strong><ul>
<li><strong>锁升级</strong>过程</li>
</ul>
</li>
<li><strong>偏向锁</strong></li>
<li><strong>轻量级锁</strong></li>
<li><strong>重量级锁</strong></li>
<li><strong>锁消除</strong></li>
<li><strong>锁粗化</strong></li>
<li>平时写代码如何对<strong>synchronized优化</strong><ul>
<li><strong>减少synchronized的范围</strong></li>
<li><strong>降低synchronized锁的粒度</strong></li>
<li><strong>读写分离</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h2><p>第一章：<strong>并发编程</strong>中的<strong>三个问题</strong> (可见性、原子性、有序性)</p>
<p>在使用<strong>多线程</strong>进行<strong>并发编程</strong>的时候，如果存在有<strong>多个线程</strong>来<strong>操作共享数据</strong>，<br>那么很有可能这个<strong>共享数据的值</strong>会出现<strong>错乱</strong>。<br>那么以上称之为 <strong>线程安全问题</strong>。<br>那么导致 <strong>线程安全问题</strong>的<strong>根本原因</strong>有这三种：</p>
<ul>
<li><strong>可见性</strong></li>
<li><strong>原子性</strong></li>
<li><strong>有序性</strong></li>
</ul>
<p>在讲解<strong>可见性</strong>概念之前，要注意几个<strong>前提条件</strong>：<br><strong>1、</strong>  如果只有一个线程操作，那么就肯定不会存在线程之间的<strong>可见性</strong>问题。<br><strong>2、</strong> 还需要存在有<strong>共享数据</strong>，如果没有共享数据，那么也不会存在有可见性问题。<br><strong>可见性（Visibility）</strong>：是指一个线程对共享变量进行修改，另一个线程立即得到修改后的最新值。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>学习什么是<strong>可见性问题</strong></p>
<h3 id="可见性概念"><a href="#可见性概念" class="headerlink" title="可见性概念"></a>可见性概念</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可见性（<span class="keyword">Visibility</span>）：是指当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。</span><br></pre></td></tr></table></figure>

<h3 id="可见性演示"><a href="#可见性演示" class="headerlink" title="可见性演示"></a>可见性演示</h3><p>案例演示：<br>一个线程A根据boolean类型的标记flag，while循环；<br>另一个线程B改变这个flag变量的值；<br>那么线程A并不会停止循环。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">          一个线程对共享变量的修改，另一个线程不能立即得到最新值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Visibility</span>&#123;</span></span><br><span class="line">    <span class="comment">//多个线程都会访问的数据，我们成为线程的共享数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="built_in">run</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException</span>&#123;</span><br><span class="line">      <span class="comment">//t1线程不断的来读取run共享变量的取值</span></span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">run</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      t1.start();</span><br><span class="line"></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//t2线程对该共享变量的取值进行修改</span></span><br><span class="line">      Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="built_in">run</span> =  <span class="literal">false</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"时间到，线层2设置为false"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">      t2.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//可以观测得到t2线程对run共享变量的修改，t1线程并不能够读取到更改了之后的值；</span></span><br><span class="line">      <span class="comment">//这就出现了可见性问题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo01_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  目标：演示可见性问题</span></span><br><span class="line"><span class="comment">    1. 创建一个共享变量</span></span><br><span class="line"><span class="comment">    2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">    3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test01Visibility&#123;</span><br><span class="line">  <span class="comment">// 1. 创建一个共享变量；静态的成员变量；boolean类型名为flag；</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)&#123;</span><br><span class="line">    <span class="comment">/* 2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">          采用lambda表达式的方式进行创建线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        <span class="comment">/* 循环，如果该布尔类型变量的值为true则一直循环否则结束循环；</span></span><br><span class="line"><span class="comment">           在循环当中千万不要进行打印，打印了的话就看不到效果了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    沉睡两秒钟；</span></span><br><span class="line"><span class="comment">    让效果更加明显；</span></span><br><span class="line"><span class="comment">    这样则更加明显的来分析问题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">       放到lambda表达式中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将flag改为false；并且输出打印；</span></span><br><span class="line">      flag = <span class="keyword">false</span>;</span><br><span class="line">      System.out.<span class="keyword">println</span>(<span class="string">"线程修改了变量的值为false"</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  分析一下这段代码：</span></span><br><span class="line"><span class="comment">  程序从main方法开始执行；</span></span><br><span class="line"><span class="comment">  开启了线程A不断读取共享变量的取值进行循环；</span></span><br><span class="line"><span class="comment">  开启了线程B去进行修改共享变量的值并打印；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  多线程执行具有 fu jin/fu ji(我没听清)性，</span></span><br><span class="line"><span class="comment">  有可能先进行跑A线程也有可能跑B线程；</span></span><br><span class="line"><span class="comment">  如果先跑B线程那么则看不到A线程当中的循环；</span></span><br><span class="line"><span class="comment">  为了让这个效果更佳明显一点；</span></span><br><span class="line"><span class="comment">  所以后加了一个Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  首先执行main方法的时候；</span></span><br><span class="line"><span class="comment">  会创建出一个线程A；</span></span><br><span class="line"><span class="comment">  这个线程A会来进行读取共享变量A的取值；</span></span><br><span class="line"><span class="comment">  则读取到flag共享变量的取值为true；</span></span><br><span class="line"><span class="comment">  那么该while循环则将会一直进行循环；</span></span><br><span class="line"><span class="comment">  那么当主线程沉睡了两秒之后，又会启动一个新线程B；</span></span><br><span class="line"><span class="comment">  新线程B将flag共享变量的取值变为了false；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  问题就在于分析</span></span><br><span class="line"><span class="comment">  线程A当中通过flag来进行while循环当中的该flag共享变量</span></span><br><span class="line"><span class="comment">  是否也从一开始的取值true到后期的线程B当中对共享变量flag取值进行修改为false</span></span><br><span class="line"><span class="comment">  是否也是同时进行了更改取值true为false；</span></span><br><span class="line"><span class="comment">  如果线程A当中的共享变量flag的取值与线程B操作共享变量flag的取值同时进行了更改；</span></span><br><span class="line"><span class="comment">  那么线程A当中根据flag取值进行while循环的循环操作就会停下来；</span></span><br><span class="line"><span class="comment">  如果没有进行修改线程A当中的flag共享变量</span></span><br><span class="line"><span class="comment">  那么线程A当中的flag共享变量的取值就将还会是true，</span></span><br><span class="line"><span class="comment">  即while循环根据flag共享变量的取值true继续其循环操作；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  效果：</span></span><br><span class="line"><span class="comment">  等待两秒之后，输出了线程B当中的打印 “线程修改了变量的值为false”；</span></span><br><span class="line"><span class="comment">  然而但是运行Run的的红灯仍然开启显示在运行着；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  那么这个就意味着；</span></span><br><span class="line"><span class="comment">  上面的那个线程A还在while(true)执行当中；</span></span><br><span class="line"><span class="comment">  也就是线程A当中的共享变量</span></span><br><span class="line"><span class="comment">  没有受到线程B当中操作共享变量flag取值从true变为false操作的影响；</span></span><br><span class="line"><span class="comment">  flag在线程A当中取值依然还是true；</span></span><br><span class="line"><span class="comment">  所以while循环根据该flag共享变量的取值依旧在进行着循环操作。</span></span><br><span class="line"><span class="comment">  即线程A当中认为flag共享变量依旧是true，所以并没有去进行停止while循环。</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  这个时候就可以进行观察得到 可见性问题；</span></span><br><span class="line"><span class="comment">  下面的线程B对共享变量flag取值的修改，而上面的线程A并没有立即得到最新的结果；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  最后做个小结：</span></span><br><span class="line"><span class="comment">  当并发编程时，如果有多线程来进行操作共享变量；</span></span><br><span class="line"><span class="comment">  一个线程来进行读取操作；</span></span><br><span class="line"><span class="comment">  一个线程来进行写操作；</span></span><br><span class="line"><span class="comment">  那么这个当中就可能会出现 线程安全问题；</span></span><br><span class="line"><span class="comment">  即一个线程B进行修改，而另外一个线程A并没有得到修改后的最新取值；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>什么是<strong>可见性</strong>？</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可见性（<span class="keyword">Visibility</span>）：是指当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。</span><br></pre></td></tr></table></figure>

<h2 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h2><p>现在来看并发编程中的第二个问题：<strong>原子性</strong>问题；<br>前期讲的是并发编程中的第一个问题<strong>可见性</strong>问题；<br>后期要讲的是并发编程中的第三个问题<strong>有序性</strong>问题；<br>学习分两步第一步介绍<strong>原子性的概念</strong>；<br>第二步通过一个案例来进行演示<strong>原子性问题</strong>；</p>
<h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>学习什么是<strong>原子性问题</strong></p>
<h3 id="原子性概念"><a href="#原子性概念" class="headerlink" title="原子性概念"></a>原子性概念</h3><p>原子性的前提：</p>
<p><strong>1.</strong> 需要存在有<strong>多个线程</strong>；如果是一个线程，没有竞争的这种情况是看不出来问题所在的；<br><strong>2.</strong> 依然还是需要存在<strong>共享变量</strong>；即到时候多个线程来对共享变量来进行操作；</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">原子性（Atomicity）: 在一次或多次操作中，要么所有的操作都执行 并且 不会受 其他因素干扰 而 中断，要么所有的操作都不执行；</span></span><br></pre></td></tr></table></figure>

<h3 id="原子性演示"><a href="#原子性演示" class="headerlink" title="原子性演示"></a>原子性演示</h3><p>案例演示：5个线程各执行1000次i++</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo01_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    案例演示：5个线程各执行1000次 i++;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> class Test02Atomicity&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5个线程都执行1000次i++</span></span><br><span class="line">    Runnable increment = () -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        number++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5个线程</span></span><br><span class="line">    ArrayList&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">      t.start();</span><br><span class="line">      ts.<span class="built_in">add</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t : ts)&#123;</span><br><span class="line">      t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 最终的效果即，加出来的效果不是5000，可能会少于5000</span></span><br><span class="line"><span class="comment">        那么原因就在于i++并不是一个原子操作</span></span><br><span class="line"><span class="comment">        到时候会通过java反汇编的方式来进行演示和分析，这个i++其实有4条指令</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"number = "</span>+ number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo01_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  目标：演示原子性问题</span></span><br><span class="line"><span class="comment">      1. 定义一个共享变量 number</span></span><br><span class="line"><span class="comment">      2. 对number进行 1000次的++操作</span></span><br><span class="line"><span class="comment">      3. 使用5个线程来进行操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02Atomicity</span>&#123;</span></span><br><span class="line">  <span class="comment">// 1. 定义一个共享变量 number；先赋值为0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 存在有5个线程需要来对number共享变量1000次的++操作</span></span><br><span class="line"><span class="comment">     2. 对number进行1000的++操作</span></span><br><span class="line"><span class="comment">     做任务；使用lambda表达式来进行编写</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  Runnable increment = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">      number++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 使用5个线程来进行</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该5个线程所做的事情即为 上面的increment所实现的run()</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    ts.add(t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t : <span class="built_in">list</span>)&#123;</span><br><span class="line">      t.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印number的取值</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"number = "</span>+ number);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    由于有可能存在 主线程跑得更快；</span></span><br><span class="line"><span class="comment">    所以就有可能出现5个线程其run()当中的for循环没有跑完就有可能去执行输出number的取值了；</span></span><br><span class="line"><span class="comment">    为了一定要让5个线程当中的for循环跑完然后再来取number的取值；</span></span><br><span class="line"><span class="comment">    这个时候使用join的操作；</span></span><br><span class="line"><span class="comment">    先把这个5个线程放置到ArrayList集合ts当中；</span></span><br><span class="line"><span class="comment">    最后在打印之前遍历一下list集合ts；</span></span><br><span class="line"><span class="comment">    得到每个线程让其执行join();</span></span><br><span class="line"><span class="comment">    按照分析；每个线程都执行1000次number++；</span></span><br><span class="line"><span class="comment">    正常来说最后输出打印这个number时的打印结果应当为5000；</span></span><br><span class="line"><span class="comment">    那么这个运行结果有可能是5000也有可能会小于5000；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    效果：</span></span><br><span class="line"><span class="comment">    number = 5000</span></span><br><span class="line"><span class="comment">    多运行几次</span></span><br><span class="line"><span class="comment">    number = 4542（这次运行之后就会发现number的取值少了很多）</span></span><br><span class="line"><span class="comment">    那么为什么会出现number取值少了很多的这种情况呢？</span></span><br><span class="line"><span class="comment">    那么这是由于 i++（number++）这是多个操作；</span></span><br><span class="line"><span class="comment">    而且其是通过多线程来进行操作的；</span></span><br><span class="line"><span class="comment">    并没有来进行保证 i++(number++)这个操作的一个原子性；</span></span><br><span class="line"><span class="comment">    那么这个时候通过javap反汇编的方式来查看i++(number++)到底是由几个部分来组成的；</span></span><br><span class="line"><span class="comment">    找到编译后的结果（工程名/target/classes/com.xxx.demo01_concurrent_problem/Test02Atomicity.class）</span></span><br><span class="line"><span class="comment">    找到该文件之后通过使用Windows PowerShell打开或者是通过CMD等命令行进行打开也可以；</span></span><br><span class="line"><span class="comment">    键入命令：javap 可以对该字节码文件Test02Atomicity.class进行反汇编；</span></span><br><span class="line"><span class="comment">    从而看到一些字节码的指令；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    javap -p -v .\Test02Atomicity.class</span></span><br><span class="line"><span class="comment">    # -p 即显示私有的；-v 即详细信息也显示出来；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    通过反汇编之后可以看到很多的代码；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<strong>javap 反汇编</strong>class文件，得到下面的 字节码指令：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="built_in">void</span> lambda$main();</span><br><span class="line">  Code:</span><br><span class="line">     <span class="number">0</span>: iconst_0</span><br><span class="line">     <span class="number">1</span>: istore_0</span><br><span class="line">     <span class="number">2</span>: iload_0</span><br><span class="line">     <span class="number">3</span>: sipush        <span class="number">1000</span></span><br><span class="line">     <span class="number">6</span>: if_           <span class="number">23</span></span><br><span class="line">     <span class="number">9</span>: getstatic     #<span class="number">12</span>               <span class="comment">// Field number:I</span></span><br><span class="line">    <span class="number">12</span>: iconst_1</span><br><span class="line">    <span class="number">13</span>: iadd</span><br><span class="line">    <span class="number">14</span>: putstatic     #<span class="number">12</span>               <span class="comment">// Field number:I</span></span><br><span class="line">    <span class="number">17</span>: linc          <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="number">20</span>: goto</span><br><span class="line">    <span class="number">23</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><strong>反汇编</strong>内容：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    offset_delta = <span class="number">27</span></span><br><span class="line">  Exception:</span><br><span class="line">    throws java.lang.InterruptedException</span><br><span class="line"></span><br><span class="line"># 通过反汇编可以看到lambda表达式的代码在此处</span><br><span class="line"><span class="keyword">private</span> static <span class="built_in">void</span> lambda$main$<span class="number">0</span>()</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, loclas=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_0</span><br><span class="line">        <span class="number">2</span>: iload_0</span><br><span class="line">        <span class="number">3</span>: sipush       <span class="number">1000</span></span><br><span class="line">        <span class="number">6</span>: if_icmpge    <span class="number">23</span></span><br><span class="line">        <span class="number">9</span>: getstatic    #<span class="number">18</span>         <span class="comment">// Field number:I</span></span><br><span class="line">       <span class="number">12</span>: iconst_1</span><br><span class="line">       <span class="number">13</span>: iadd</span><br><span class="line">       <span class="number">14</span>: putstatic    #<span class="number">18</span>         <span class="comment">// Field number:I</span></span><br><span class="line">       <span class="number">17</span>: iinc         <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">       <span class="number">20</span>: goto</span><br><span class="line">       <span class="number">23</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">18</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">17</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">23</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length   Slot   Name   Signature</span><br><span class="line">            <span class="number">2</span>      <span class="number">21</span>      <span class="number">0</span>      <span class="number">1</span>   I</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">252</span> <span class="comment">/* append */</span></span><br><span class="line">          offset_delta = <span class="number">2</span></span><br><span class="line">          locals = [ <span class="built_in">int</span> ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">20</span></span><br><span class="line">  static &#123;&#125;:</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>,  locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">          <span class="number">0</span>: iconst_0</span><br><span class="line">          <span class="number">1</span>: putstatic  #<span class="number">18</span>         <span class="comment">// Field number:I</span></span><br><span class="line">          <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中，对于 number++ 而言（number为静态变量 ），实际会产生如下的JVM字节码指令：</p>
<blockquote>
<p>9: getstatic     #18     // Field number:I<br>12: iconst_1<br>13: iadd<br>14: putstatic    #18     // Field number:I</p>
</blockquote>
<blockquote>
<p>代码当中的<br>number++;<br>对应反汇编代码当中的4句<br>9: getstatic     #18     // Field number:I<br>12: iconst_1<br>13: iadd<br>14: putstatic    #18     // Field number:I</p>
</blockquote>
<p>即 <code>number++</code>是由<strong>四条字节码指令</strong>组成的；<br>那么其中在<strong>一个线程</strong>下是没有问题的；<br>但如果是放在<strong>多线程</strong>的情况下那么就是有问题的；<br>当前来进行分析下这个<strong>原子性问题</strong>：<br>程序有主方法main方法开始进行执行的；</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">public class Test02Atomicity&#123;</span><br><span class="line">  // <span class="number">1</span>. 定义一个共享变量<span class="keyword">number</span></span><br><span class="line">  private static int <span class="keyword">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  public static void main(<span class="keyword">String</span>[] args) throws InterruptedException&#123;</span><br><span class="line">    // <span class="number">2</span>. 对<span class="keyword">number</span>进行<span class="number">1000</span>的++操作</span><br><span class="line">    Runnable increment = ()-&gt;&#123;</span><br><span class="line">      for(int i = <span class="number">0</span>; i<span class="tag">&lt; 1000; i++)&#123;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        number++;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">/**</span></span><br><span class="line"><span class="tag">-------------             ------------------------------------------</span></span><br><span class="line"><span class="tag">|           |             |                                        |</span></span><br><span class="line"><span class="tag">|           |             | 9: getstatic    #18  // Field number:I |</span></span><br><span class="line"><span class="tag">| number++; |===========》|12: iconst_1                            |</span></span><br><span class="line"><span class="tag">|           |             |13: iadd                                |</span></span><br><span class="line"><span class="tag">|           |             |14: putstatic    #18  // Field number:I |</span></span><br><span class="line"><span class="tag">|           |             |                                        |</span></span><br><span class="line"><span class="tag">-------------             ------------------------------------------</span></span><br><span class="line"><span class="tag">*/</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">      &#125;</span></span><br><span class="line"><span class="tag">    &#125;;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    List&lt;Thread&gt;</span> list = new ArrayList<span class="tag">&lt;Thread&gt;</span>();</span><br><span class="line">    // <span class="number">3</span>. 使用<span class="number">5</span>个线程来进行</span><br><span class="line">    for(int i = <span class="number">0</span> ; i<span class="tag">&lt; 5; i++)&#123;</span></span><br><span class="line"><span class="tag">      Thread t = new Thread(increment);</span></span><br><span class="line"><span class="tag">      t.start();</span></span><br><span class="line"><span class="tag">      list.add(t);</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    for(Thread t: list)&#123;</span></span><br><span class="line"><span class="tag">      t.join();</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    System.out.println("number = " + number);</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  /**</span></span><br><span class="line"><span class="tag">  以下进行约定：红色的箭头代表主线程</span></span><br><span class="line"><span class="tag">  那么主线程先会进行执行（main()）；</span></span><br><span class="line"><span class="tag">  Runnable该语句先不会进行执行（Runnable increment=()-&gt;</span>&#123;...&#125;;）；</span><br><span class="line">  然后走下面的执行语句创建list集合（List<span class="tag">&lt;Thread&gt;</span> <span class="attr">list=</span>new ArrayList<span class="tag">&lt;Thread&gt;</span>();)）</span><br><span class="line">  以及for循环<span class="number">5</span>次创建生成<span class="number">5</span>个Thread线程；</span><br><span class="line">  然后这个时候每个线程才会去执行上面的Runnable；</span><br><span class="line">  <span class="number">5</span>个线程分析起来有点麻烦；</span><br><span class="line">  当前在for()循环创建生成<span class="number">5</span>个线程途中，</span><br><span class="line">  那么此时当前假设已经创建生成线程Thread A与线程Thread B；</span><br><span class="line">  </span><br><span class="line">  那么此时在Thread A与Thread B同时都运行<span class="literal">start</span>()方法的时候</span><br><span class="line">  那么就都将会去执行Runnable当中的run()方法即循环<span class="number">1000</span>次的<span class="keyword">number</span>++操作；</span><br><span class="line">  那么假设此时的<span class="keyword">number</span>取值为<span class="number">0</span>；</span><br><span class="line">  假设线程Thread A先进行走，那么即循环<span class="number">1000</span>次执行<span class="keyword">number</span>++；</span><br><span class="line">  那么这每一次的<span class="keyword">number</span>++都是在执行字节码的那<span class="number">4</span>条指令；</span><br><span class="line">  即</span><br><span class="line">  <span class="number">9</span>:  getstatic <span class="comment">#18</span></span><br><span class="line">  <span class="number">12</span>: iconst_1</span><br><span class="line">  <span class="number">13</span>: iadd</span><br><span class="line">  <span class="number">14</span>: putstatic <span class="comment">#18</span></span><br><span class="line">  <span class="comment">#9: getstatic该指令即为取到共享变量number的取值，此时为0</span></span><br><span class="line">  <span class="comment">#12: 字节码指令继续往下执行一步，iconst_1该字节码指令的含义为是在准备一个常量1</span></span><br><span class="line">  <span class="comment">#13: 假设再往下走一步执行字节码指令iadd；那么该指令执行后会让12: iconst_1 准备的常量1与9: getstatic #18 获取得到的number 该共享变量的取值进行相加操作；最终的结果是1；</span></span><br><span class="line">  </span><br><span class="line">  但是注意假设此时并没有真正发生赋值操作，即运算出结果为<span class="number">1</span>；</span><br><span class="line">  但是并没有赋值给<span class="keyword">number</span>该共享变量的取值上；</span><br><span class="line">  然后此时CPU切换到另外一个线程上面去即线程B上去执行了；</span><br><span class="line">  那么此时另外一个线程，即线程B，也进入了for循环来执行<span class="keyword">number</span>++操作；</span><br><span class="line">  那么线程B也有四条字节码指令需要进行执行；</span><br><span class="line">  </span><br><span class="line">  先执行字节码指令的第一条指令 <span class="number">9</span>: getstatic <span class="comment">#18 获取得到共享变量number的取值，</span></span><br><span class="line">  目前该共享变量的取值是没有线程进行改变的；</span><br><span class="line">  即也就是说线程A刚刚在操作<span class="keyword">number</span>++字节码指令操作的步骤三时只是运算得出运算结果为<span class="number">1</span>；</span><br><span class="line">  但是并没有进行赋值就进行了CPU切换到了线程B上，</span><br><span class="line">  所以相对于线程B当前的共享变量<span class="keyword">number</span>来说，线程B认为<span class="keyword">number</span>共享变量的取值是<span class="number">0</span>；</span><br><span class="line">  那么当getstatic获取得到共享变量<span class="keyword">number</span>的取值之后，</span><br><span class="line">  然后执行字节码指令的第二条指令 <span class="number">12</span>: iconst_1 即同样是准备一个常量<span class="number">1</span>；</span><br><span class="line">  再执行字节码指令的第三条指令 <span class="number">13</span>: iadd 这个时候同样是将<span class="keyword">number</span>++操作当中的第一条字节码指令当中<span class="number">9</span>: getstatic <span class="comment">#18 获取得到的 共享变量number的取值与 number++操作当中的第二条指令 12: iconst_1 所准备的常量1 这两者进行相加操作；</span></span><br><span class="line">  运算结果得到<span class="number">1</span>；</span><br><span class="line">  假设线程B再继续往下走，</span><br><span class="line">  那么此时到了<span class="keyword">number</span>++操作所对应字节码指令的第四个指令了；</span><br><span class="line">  即<span class="number">14</span>: putstatic   <span class="comment">#18 ；</span></span><br><span class="line">  那么该指令执行之后就会将指令三当中得到的结果<span class="number">1</span>赋值给共享变量<span class="keyword">number</span>的取值，</span><br><span class="line">  而<span class="keyword">number</span>变量的取值此时从<span class="number">0</span>变为<span class="number">1</span>；</span><br><span class="line">  那么此时该线程的一次<span class="keyword">number</span>++执行完成；</span><br><span class="line"></span><br><span class="line">  假设CPU又切换到前一条线程，即线程A；</span><br><span class="line">  那么在切换到线程B之前，</span><br><span class="line">  线程A的<span class="keyword">number</span>++操作的<span class="number">4</span>条字节码指令已经执行完了前三条即iadd执行运算得出运算结果为<span class="number">1</span>；</span><br><span class="line">  那么此时当CPU又切换回线程A则继续执行<span class="keyword">number</span>++操作字节码指令的第四条指令即<span class="number">14</span>: putstatic <span class="comment">#18该指令；</span></span><br><span class="line">  则该指令同样是需要进行put即给共享变量<span class="keyword">number</span>进行赋值操作；</span><br><span class="line">  即将A线程运算得到的<span class="number">1</span>赋值给已经被线程B之前赋值好<span class="keyword">number</span>为<span class="number">1</span>的共享变量取值为<span class="number">1</span>；</span><br><span class="line">  所以当前共享变量<span class="keyword">number</span>的取值依旧是<span class="number">1</span>；</span><br><span class="line">  那么这个时候就看到了，两个线程执行<span class="keyword">number</span>++；</span><br><span class="line">  按道理其值应该是<span class="number">2</span>；</span><br><span class="line">  那么因为<span class="keyword">number</span>++的字节码指令这<span class="number">4</span>条字节码指令没有保证其一个原子性；</span><br><span class="line">  所以发现导致最后的结果<span class="keyword">number</span>只加了<span class="number">1</span>；</span><br><span class="line">  就让数据产生了错误；</span><br><span class="line">  那么这个问题的原因就在于让两个线程来进行操作<span class="keyword">number</span>++；</span><br><span class="line">  而<span class="keyword">number</span>++的字节码指令又是多条指令（<span class="number">4</span>条指令）；</span><br><span class="line">  其中一个线程执行到一半的时候；</span><br><span class="line">  CPU又切换到另外一个线程，即另外一个线程又来执行了；</span><br><span class="line">  即第二个线程干扰了第一个线程的执行从而导致执行结果的错误；</span><br><span class="line">  即没有保证原子性；（即没有使得应该的结果正确）</span><br><span class="line"></span><br><span class="line">  小结：</span><br><span class="line">  在并发编程的时候，很有可能会出现原子性问题；</span><br><span class="line">  当一个线程对共享变量操作到一半的时候，</span><br><span class="line">  另外一个线程也有可能来对共享变量来进行操作；</span><br><span class="line">  那么此时另外一个线程就有可能会干扰前一个线程的操作；</span><br><span class="line">  让前一个线程的操作没有保证其原子性；</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见 number++ 是由多条<strong>字节码</strong>语句组成，<br>以上<strong>多条指令</strong> 在<strong>一个线程的情况下</strong> 是不会出问题的，<br>但是在<strong>多线程情况下</strong>就可能会出现问题。<br>比如一个线程在执行 13: iadd 时，<br>另一个线程又执行 9: getstatic，<br>会导致两次 number++，实际上只加了1。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>什么是<strong>原子性</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">原子性（Atomicity）: 在一次的操作或多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</span></span><br></pre></td></tr></table></figure>

<h2 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h2><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><p>学习什么是<strong>有序性问题</strong></p>
<p>学习分成两步；<br>第一步：学习有序性的概念；<br>第二步：通过一个案例来演示有序性问题<br>有序性（Ordering）：是指程序中代码的执行顺序<br>一般会认为编写代码的顺序就是代码最终的执行顺序；<br>那么实际上并不一定是这样的；<br>为了提高程序的执行效率；java在编译时和运行时会对代码进行优化，会导致程序最终的执行顺序不一定就是编写代码时的顺序。<br>接下来通过一个案例来演示有序性问题；</p>
<h3 id="有序性概念"><a href="#有序性概念" class="headerlink" title="有序性概念"></a>有序性概念</h3><p>有序性（Ordering）：是指程序代码在执行过程中的先后顺序，由于java在编译器以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码的顺序。</p>
<h3 id="有序性演示"><a href="#有序性演示" class="headerlink" title="有序性演示"></a>有序性演示</h3><p><strong>jcstress</strong> 是java并发压测工具： </p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>wiki.openjdk.java.net<span class="regexp">/display/</span>CodeTools<span class="regexp">/jcstress</span></span><br></pre></td></tr></table></figure>

<p>修改pom文件，添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jcstress<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcstress-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jcstress.version<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码<br>Test03Orderliness.java</p>
<figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@OutCome</span>(id = &#123;<span class="string">"1"</span> , <span class="string">"4"</span>&#125;, expect =  Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>)</span><br><span class="line"><span class="meta">@OutCome</span>(id = <span class="number">0</span>, expect = EXPECT.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger"</span>)</span><br><span class="line"><span class="meta">@State</span></span><br><span class="line">public class Test03Orderliness&#123;</span><br><span class="line">    int num = <span class="number">0</span>;</span><br><span class="line">    boolean ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    /* 线程一 执行的代码；先进行判断ready的值然后进行相关操作；</span><br><span class="line">       I_Result为并发压测工具自带的类；</span><br><span class="line">       <span class="meta">@Actor</span>注解：表示到时候有多个线程来执行这两个方法；</span><br><span class="line">       <span class="meta">@JCStressTest</span>注解：表示用这个并发压测工具来对这个类的方法进行测试</span><br><span class="line">       <span class="meta">@OutCome</span>注解：对输出结果的处理；</span><br><span class="line">       如果当id为&#123;<span class="string">"1"</span>,<span class="string">"4"</span>&#125;的时候，表示这种结果是我们所预期所接受的结果，则打印信息<span class="string">"ok"</span>;</span><br><span class="line">       如果程序最终I_Result当中保存的结果是<span class="number">0</span>；则也认为结果是可接受感兴趣的；然后打印信息<span class="string">"danger"</span></span><br><span class="line">       接下来分析下有几种运行结果；</span><br><span class="line">    */</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    public void actor1(I_Result r)&#123;</span><br><span class="line">      <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //线程二 执行的代码；对两个变量进行相应的修改；</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    public void actor2(I_Result r)&#123;</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      画两个箭头代表两个线程；</span><br><span class="line">      (蓝色箭头与紫色箭头)</span><br><span class="line">      而实际上这标有<span class="meta">@Actor</span>注解的两个方法有很多的线程来执行；</span><br><span class="line">      那么为了演示方法，一个线程一个方法也是可以的；</span><br><span class="line">      那么这里存在有几种情况；</span><br><span class="line">      分有线程A与线程B分别执行actor1(I_Result r)与actor2(I_Result r)；</span><br><span class="line">      第一种情况是上面的线程A先走；</span><br><span class="line">      执行actor1(I_Result r)方法；</span><br><span class="line">      则获取得到共享变量 ready取值为<span class="literal">false</span>；</span><br><span class="line">      则此时走<span class="keyword">else</span>块；</span><br><span class="line">      将<span class="number">1</span>赋值给I_Result r当中的成员变量r1，即将r.r1即I_Result成员变量r1属性的取值修改为<span class="number">1</span>；</span><br><span class="line"></span><br><span class="line">      记录一下r.r1(I_Result中r1属性取值的变化)：</span><br><span class="line">      结果<span class="number">1</span>：  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">      接着假设第二种情况下面的线程B先走；</span><br><span class="line">      执行actor2(I_Result r)方法；</span><br><span class="line">      执行代码语句给共享变量num以及ready重新赋值；</span><br><span class="line">      即num该数值变为了<span class="number">2</span>；</span><br><span class="line">      ready该布尔类型取值变为了<span class="literal">true</span>；</span><br><span class="line"></span><br><span class="line">      接着CPU又切换到上面的线程A当中进行执行；</span><br><span class="line">      由于线程B修改num以及ready这两个共享变量成功了；</span><br><span class="line">      即num取值为<span class="number">2</span>；ready取值为<span class="literal">true</span>；</span><br><span class="line">      则此时线程A再一次进行判断ready该变量的取值时此时ready为<span class="literal">true</span>；</span><br><span class="line">      则进入actor1(I_Result r)当中的<span class="keyword">if</span>块中；</span><br><span class="line">      执行赋值语句，此时num取值为<span class="number">2</span>；</span><br><span class="line">      那么此时I_Result r.r1取值又被重新赋值为num+num，即运算结果为<span class="number">4</span>；</span><br><span class="line">      r.r1取值重新赋值为<span class="number">4</span>；</span><br><span class="line"></span><br><span class="line">      记录一下r.r1(I_Result中r1属性取值的变化)：</span><br><span class="line">      结果<span class="number">2</span>：  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">      第三种可能性：</span><br><span class="line">      依然还是假设下面的线程先走即先走线程B；</span><br><span class="line">      执行actor2(I_Result r)方法；</span><br><span class="line">      执行到代码语句 num = <span class="number">2</span>; 时，CPU又切换到线程A中去执行actor1(I_Result r)方法了；</span><br><span class="line">      那么这个时候就是由线程A去执行actor1(I_Result r)方法；</span><br><span class="line">      此时线程A获取得到ready变量的取值：为<span class="literal">false</span>；</span><br><span class="line">      由于是执行线程B执行到num=<span class="number">2</span>;赋值完成之后但是并未执行ready=<span class="literal">true</span>该语句之前CPU进行切换到了线程A的操作上去了；</span><br><span class="line">      所以此时线程A去进行获取ready变量时，ready变量的取值依旧是<span class="literal">false</span>；</span><br><span class="line">      所以此时不会进入<span class="keyword">if</span>块当中而是进入<span class="keyword">else</span>块当中执行操作使得r.r1=<span class="number">1</span>;</span><br><span class="line">      即对I_Result r当中的成员变量r1进行重新赋值为<span class="number">1</span>；</span><br><span class="line"></span><br><span class="line">      记录一下r.r1(I_Result中r1属性取值的变化)：</span><br><span class="line">      结果<span class="number">3</span>：  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">      第四种可能性：</span><br><span class="line">      很难发现；这是由于java在编译时和运行时的优化；</span><br><span class="line">      就可能会对actor2(I_Result r)当中的代码语句</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">      进行重排序；</span><br><span class="line">      比如说有可能会被排成这样：</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">      因为这两句代码并没有什么直接间接的一个因果关系；</span><br><span class="line">      如果说通过编译时和运行时的优化代码变成了</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">      的这种顺序则再来进行分析一下：</span><br><span class="line">      依然还是假设下面的线程B先走，即执行actor2(I_Result r)；</span><br><span class="line">      则执行了第一句ready = <span class="literal">true</span>;</span><br><span class="line">      那么此时假设CPU正好在ready 赋值为 <span class="literal">true</span>之后以及num = <span class="number">2</span>赋值之前又切换到了上面的那个线程，即线程A即执行actor1(I_Result r)方法；</span><br><span class="line">      那么此时线程A在执行actor1(I_Result r)时首先会去获取ready该共享变量的取值，</span><br><span class="line">      则此时的ready变量的取值是在线程B的操作actor2(I_Result r)时进行了修改了的，并且赋值成功了；那么这个时候线程A获取得到ready的取值为<span class="literal">true</span>则进入<span class="keyword">if</span>块当中执行对I_Result r.r1的赋值语句，r.r1=num+num；那么此时的num在线程B的操作actor2(I_Result r)并没有进行执行，即没有赋值成功；所以此时线程A获取得到num的取值依然为<span class="number">0</span>；</span><br><span class="line">      则此时赋值给I_Result r.r1成员变量的取值为num+num=<span class="number">0</span>;即赋值给r1的取值为<span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">      记录一下r.r1(I_Result中r1属性取值的变化)：</span><br><span class="line">      结果<span class="number">4</span>：  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      此时出现结果<span class="number">4</span>: <span class="number">0</span>的原因就是因为actor2(I_Result r)中的两句代码的执行顺序被重排序过了从而导致的；</span><br><span class="line"></span><br><span class="line">      效果：</span><br><span class="line">      通过jcstress来进行检测结果；</span><br><span class="line">      打开idea终端；即Terminal；</span><br><span class="line">      键入命令行：mvn clean install</span><br><span class="line">      完成之后会在target目录当中形成两个jar包（前提是安装了jcstress的依赖；） - jcstress.jar、Synchronized<span class="number">-1.0</span>-SNAPSHOT.jar</span><br><span class="line">      此时运行jcstress.jar该jar包；</span><br><span class="line">      C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; java -jar target/jcstress.jar</span><br><span class="line">      运行之后，进行多轮的压力测试；</span><br><span class="line"></span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>压力测试结果（代码重排序所导致state结果出现了0）:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    [OK] com.xxx.demo02_concurrent_probleam.Test03Ordering</span><br><span class="line">  （JVM args: [-XX:-TieredCompilation]）</span><br><span class="line">Observed state Occurrences         Expectation     Interpretation</span><br><span class="line">             <span class="number">0</span>       <span class="number">5</span>,<span class="number">630</span>  ACCEPTABLE_INTERESTING  danger</span><br><span class="line">             <span class="number">1</span> <span class="number">150</span>,<span class="number">985</span>,<span class="number">557</span>          ACCEPTABLE      ok</span><br><span class="line">             <span class="number">4</span>  <span class="number">41</span>,<span class="number">594</span>,<span class="number">004</span>          ACCEPTABLE      ok</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_probleam.Test03Ordering</span><br><span class="line">  （JVM args: []）</span><br><span class="line">Observed state Occurrences         Expectation     Interpretation</span><br><span class="line">             <span class="number">0</span>       <span class="number">2</span>,<span class="number">787</span>  ACCEPTABLE_INTERESTING  danger</span><br><span class="line">             <span class="number">1</span> <span class="number">113</span>,<span class="number">540</span>,<span class="number">468</span>          ACCEPTABLE      ok</span><br><span class="line">             <span class="number">4</span>  <span class="number">46</span>,<span class="number">388</span>,<span class="number">436</span>          ACCEPTABLE      ok</span><br></pre></td></tr></table></figure>

<p>I_Result.class<br>jcstressjava并发压测工具当中并不只有I_Result这一个类；还存在有多个类似的类来进行保存各种不同的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.openjdk.jcstress.infra.results;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Result</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I_Result</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    成员变量r1 来保存一个int类型的结果</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Contended</span></span><br><span class="line">  <span class="meta">@jdk</span>.internal.vm.annotation.Contended</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> r1;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">I_Result</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">31</span> * result + <span class="keyword">this</span>.r1;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（有序性问题，有可能重排序从而导致在多线程的情况下，数据出现错乱问题。）</p>
<p>I_Result 是一个对象，有一个属性r1 用来保存结果，在多线程情况下可能出现几种结果？</p>
<p>情况1：线程1先执行actor1，这时 ready=false，所以进入else分支结果为1。<br>情况2：线程2执行到actor2，执行了num=2;和ready=true，线程1执行，这回进入if分支，结果为4；<br>情况3：线程2先执行actor2，只执行num=2; 但没来得及执行ready=true; 线程1执行，还是进入else分支，结果为1；<br><strong>还有一种结果为0</strong>；</p>
<p>运行测试：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn clean <span class="keyword">install</span></span><br><span class="line">java -jar <span class="keyword">target</span>/jcstress.jar</span><br></pre></td></tr></table></figure>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>程序代码在执行工程中的 先后顺序，<br>由于java在 编译期以及运行期的优化（为了提高执行效率），<br>导致了 代码的执行顺序 未必就是 开发者编写代码的顺序。（最终程序的执行顺序可能跟编写的顺序不一样）</p>
<p>最后也就能够了解到并发编程当中存在的三个问题；<br>可见性、原子性、有序性；这三个问题有可能会导致共享数据错乱；<br>会出现线程安全问题；</p>
<h2 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h2><p>第二章：Java内存模型（JMM）</p>
<p>在介绍 Java内存模型之前，先来看一下到底什么是计算机内存模型。</p>
<p>当使用多线程并发访问共享资源的时候，会出现可见性、原子性、有序性等线程安全问题；<br>为什么会出现这三种问题以及出现这三种问题如何来进行解决呢？</p>
<p>这也是第二章所需要学习的内容；java内存模型（JMM）；<br>在第二章中分成三部分来进行学习；<br>首先介绍计算机的结构；那么就需要了解知道计算机有哪些重要的组成部分；<br>第二来进行学习java内存模型；需要知道java内存模型的概念和作用；<br>最后来进行学习java内存模型当中的主内存和工作内存之间是如何进行数据交互的；</p>
<h3 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h3><p>学习计算机的主要组成<br>学习缓存的作用</p>
<h3 id="计算机结构简介"><a href="#计算机结构简介" class="headerlink" title="计算机结构简介"></a>计算机结构简介</h3><p>1945年6月，美籍 匈牙利 科学家 <strong>冯 诺依曼</strong> 最先提出把 <strong>计算机</strong>分作 <strong>五部分</strong>：<strong>计算器</strong>、<strong>控制器</strong>、<strong>存储器</strong>、<strong>输入和输出设备</strong>。<br>由于他对 现代计算机技术的特殊贡献，因此 冯 诺依曼 又被称为 “现代计算机之父”。  </p>
<blockquote>
<p>冯诺依曼，提出计算机由五大组成部分，输入设备、输出设备、存储器、控制器、运算器</p>
<ul>
<li>输入设备：键盘、鼠标、扫描仪、etc.</li>
<li>输出设备：显示器、打印机、etc.</li>
<li>存储器：内存条</li>
<li>控制器：控制器+运算器–→CPU</li>
<li>运算器：控制器+运算器–→CPU</li>
</ul>
</blockquote>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">--------------     -----------------        -------------</span><br><span class="line">|<span class="string"> 输入设备</span>|<span class="string"> ------→ </span>|<span class="string">    存储器    </span>|<span class="string"> -------→ </span>|<span class="string"> 输出设备 </span>|</span><br><span class="line">------------       -----------------         ------------</span><br><span class="line">     ↑                |<span class="string">  ↑    </span>|<span class="string">  ↑                 ↑</span></span><br><span class="line"><span class="string">     </span>|<span class="string">                </span>|<span class="string">  </span>|<span class="string">    </span>|<span class="string">  </span>|<span class="string">                 </span>|</span><br><span class="line">     |<span class="string">       ---------</span>|<span class="string">--</span>|<span class="string">----</span>|<span class="string">--</span>|<span class="string">----------       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">        </span>|<span class="string">  </span>|<span class="string">    </span>|<span class="string">  </span>|<span class="string">         </span>|<span class="string">       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">        ↓  </span>|<span class="string">    ↓  </span>|<span class="string">         </span>|<span class="string">       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">   ----------  -----------   </span>|<span class="string">       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">   </span>|<span class="string"> 运算器 </span>|<span class="string">   </span>|<span class="string"> 控制器 </span>|<span class="string">----</span>|<span class="string">-------</span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">   ----------  -----------   </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">                    </span>|<span class="string">        </span>|</span><br><span class="line">     --------|<span class="string">---------------------        </span>|</span><br><span class="line">             |<span class="string">                        CPU  </span>|</span><br><span class="line">             -------------------------------</span><br></pre></td></tr></table></figure>

<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><strong>中央处理器</strong>（<strong>CPU</strong>，<strong>central processing unit</strong>）是<strong>计算机</strong>系统的<strong>运算</strong>和<strong>控制核心</strong>。（相当于人类的大脑）<br>计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。<br>程序最终都会变成 <strong>指令</strong> 让 <strong>CPU</strong> 去执行，处理程序中的数据。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>计算机中所有<strong>程序</strong>的<strong>运行</strong> 都是在 <strong>内存中</strong> 进行的， 内存的作用是 用于暂时存放 CPU的运算数据，以及与 硬盘等 外部存储器 交换的数据。</p>
<p>CPU自产生以来，在逻辑结构、运行效率以及功能外延上取得了巨大发展。<br>但受制于 制造工艺以及成本等的限制，计算机的内存反倒在访问速度上并没有多大的突破，<br>因此CPU的处理速度和内存的访问速度之间的差距越拉越大，通常这种差距可以达到上千倍，极端情况下甚至会在上万倍以上。<br>这就导致CPU每次操作内存都要耗费很多等待时间。<br>内存的读写速度成为了计算机运行的瓶颈。</p>
<p>（程序都是在内存中运行的，内存 会保存 程序运行时的数据，供CPU处理；CPU运行的时候，是需要到内存当中读取数据进行相关处理的；）</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>由于CPU和内存两边速度 严重的不对等，会导致CPU资源受到大量的限制，降低CPU整体的吞吐量，于是就有了在CPU与主内存之间增加缓存的设计，现在缓存的数量都可以增加到3级了，最靠近CPU的缓存称为L1，然后依次是L2，L3和主内存，CPU缓存模型如图 下图所示。  </p>
<p>CPU自从产生以来，在运行速度运行效率上得到了巨大的发展；<br>但是内存由于制造工艺制造成本的控制在访问速度上面并没有多大的提升。<br>因此CPU的运行速度和内存的读写速度其差距就将变得越来越大；<br>这样也就导致了CPU在运算的时候要花上很长的时间去等待内存的读取；<br>那么也就是说内存的读写速度成为了计算机运行的一个瓶颈；<br>那么如何来解决这个两面速度不对等的问题？<br>于是人们就在CPU与主内存之间增加了缓存的设计；</p>
<p>打开任务管理器[CTRL + ALT + DEL]，点开[性 能]菜单栏，可以看到；</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内核：      <span class="number">6</span>             # 我电脑只有<span class="number">4</span></span><br><span class="line">逻辑处理器: <span class="number">12</span>            # 我电脑只有<span class="number">8</span></span><br><span class="line">虚拟化：    已启用</span><br><span class="line">L1缓存：    <span class="number">384</span> KB</span><br><span class="line">L2缓存：    <span class="number">1.5</span> MB</span><br><span class="line">L3缓存：    <span class="number">12.0</span> MB</span><br></pre></td></tr></table></figure>

<p>其中缓存L1缓存最小；L2缓存较之L1缓存较大；L3缓存最大；<br>CPU的缓存是内置在CPU当中的；<br>首先离CPU最近的是L1缓存；其空间比较小但是速度比较快；价格也比较昂贵；<br>L2缓存空间稍大；速度稍慢些；价格的话也会更加便宜些；<br>L3缓存空间更大；速度较之前两者更慢，价格也更便宜些；</p>
<p>看图说话：<br>CPU 在操作内存的时候有59.4 ns(纳秒)的一个延迟(Latency)<br>CPU 在操作L1缓存的时候大约 1.2 ns(纳秒)<br>CPU 在操作L2缓存的时候大约 5.5 ns(纳秒)<br>CPU 在操作L3缓存的时候大约 15.9 ns(纳秒)</p>
<p>从中可以看到的是内存的速度要比缓存的速度慢很多；<br>当CPU有了缓存之后，其数据是如何进行处理的呢？<br>首先CPU运算的时候需要数据，那么CPU直接去一级缓存L1Cache当中找要查找的数据看是否能够查找得到；<br>如果命中了一级缓存则直接从一级缓存当中进行读取数据到CPU，处理完成之后就会将CPU当中处理后的结果又接着放回到缓存L1、L2、L3中以及内存中；<br>那么如果CPU需要数据时，但是此时并没有在一级缓存L1 Cache当中命中缓存；<br>那么这个时候CPU就会去进行读取二级缓存L2 Cache当中所需要查找的数据；<br>如果二级缓存L2 Cache当中也没有找到所需要查找得到的数据，即没有命中缓存；<br>那么这个时候CPU就会去进行读取三级缓存L3 Cache当中所需要查找的数据；<br>如果此时三级缓存L3 Cache当中也没有找到所需要查找得到的数据，即也没有命中缓存；<br>那么这个时候就会去查找内存Memory；从内存当中拿取到相应的所需要查找的数据之后，在CPU中运行计算之后；另外相应的其处理结果也会保存在缓存当中；</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                    单CPU双核的缓存结构</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|<span class="string">--------------------------------------------</span>|</span><br><span class="line">|<span class="string">      -----------          -------------    </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">  Core1  </span>|<span class="string">           </span>|<span class="string">  Core 2  </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">      -----------          -------------    </span>|</span><br><span class="line">|<span class="string">           ↓                     ↓          </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">  L1 Cache </span>|<span class="string">         </span>|<span class="string"> L1 Cache </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">           ↓                    ↓           </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">  L2 Cache </span>|<span class="string">         </span>|<span class="string"> L2 Cache </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">           ↓                    ↓           </span>|</span><br><span class="line">|<span class="string">     ------------------------------------   </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">          L3   Cache             </span>|<span class="string">   </span>|</span><br><span class="line">|<span class="string">     ------------------------------------   </span>|</span><br><span class="line">|<span class="string">                       </span>|<span class="string">                    </span>|</span><br><span class="line">|<span class="string">-----------------------</span>|<span class="string">---------------------</span></span><br><span class="line"><span class="string">                        ↓</span></span><br><span class="line"><span class="string">     ------------------------------------</span></span><br><span class="line"><span class="string">     </span>|<span class="string">              Memory              </span>|</span><br><span class="line">     ------------------------------------</span><br></pre></td></tr></table></figure>

<p><strong>CPU Cache</strong> 分成了三个级别：<strong>L1、L2、L3。</strong><br><strong>级别越小越接近CPU</strong>，<strong>速度也更快</strong>，同时也代表着<strong>容量越小</strong>。</p>
<p><strong>1.</strong> <strong>L1 Cache</strong>是<strong>最接近CPU</strong>的，它<strong>容量最小</strong>，例如32k，<strong>速度最快</strong>，每个核上都有一个L1 Cache。<br><strong>2.</strong> <strong>L2 Cache</strong> <strong>更大</strong>一些，例如256k，<strong>速度要慢</strong>一些，一般情况下每个核上都有一个独立的L2 Cache。<br><strong>3.</strong> <strong>L3 Cache</strong>是三级缓存中<strong>最大</strong>的一级，例如12MB，同时也是缓存中<strong>最慢</strong>的一级，在同一个CPU插槽之间的核共享一个L3 Cache。</p>
<p><strong>Cache的出现</strong>是为了<strong>解决 CPU直接访问内存效率低下问题的</strong>，<br>程序在运行的过程中，CPU接收到指令后，<br>它会最先向CPU中的一级缓存（L1 Cache）去寻找相关的数据，<br>如果命中缓存，CPU进行计算时就可以直接对CPU Cache中的数据进行读取和写入，<br>当运算结束之后，再将CPU Cache中的最新数据刷新到主内存当中，<br><strong>CPU</strong> 通过<strong>直接访问Cache</strong>的方式 <strong>代替</strong> <strong>直接访问主内存</strong>的方式 极大地<strong>提高</strong>了 <strong>CPU的吞吐能力</strong>。  </p>
<p>但是由于 <strong>一级缓存（L1 Cache）</strong> <strong>容量较小</strong>，<br>所以不可能每次都命中，<br>这时 <strong>CPU</strong> 会继续向下一级的<strong>二级缓存（L2 Cache）</strong> 寻找，<br>同样的道理，当所需要的数据在二级缓存中也没有的话，<br>会继续转向<strong>L3 Cache</strong>、<strong>内存（主存）</strong>和<strong>硬盘</strong>。  </p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>计算机的主要组成 <strong>CPU</strong>、<strong>内存</strong>、<strong>输入设备</strong>、<strong>输出设备</strong></p>
<blockquote>
<p><strong>CPU</strong>：计算机的核心；用来控制和处理的<br><strong>内存</strong>：用来保存正在运行的这些程序的数据；<br><strong>输入设备</strong>：<br><strong>输出设备</strong>：<br><strong>缓存</strong>：<br>  CPU的运算速度比内存的访问速度快很多；<br>  那么如果CPU直接从内存当中进行读取数据进行相关处理的话；<br>  则内存读取时间花费开销大就会导致拖累CPU的运算速度；<br>  所以在CPU与内存之间增加了缓存；<br>  缓存的读写速度较之内存的读写速度要快很多；<br>  因此可以让CPU的执行速度高一点；</p>
</blockquote>
<p><strong>1.</strong> 说出计算机的主要组成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU</span><br><span class="line">内存</span><br><span class="line">缓存</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> 为什么会出现缓存？</p>
<p>缓存是为了解决CPU直接访问内存效率低下问题的</p>
<h2 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h2><h3 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h3><p>全称：<strong>Java Memory Model</strong>(翻译成中文名为:<strong>Java内存模型</strong>；一般简称为<strong>JMM</strong>)<br><strong>Java 内存模型</strong> <strong>JMM</strong>千万不要和<strong>Java内存结构</strong>混淆；<br>以前学习Java的时候知道<strong>JVM</strong>会<strong>对内存</strong>进行一个<strong>划分</strong>；会划分成<strong>栈</strong>、<strong>堆</strong>、<strong>方法区</strong>、etc.那么这个是指的是<strong>Java内存结构</strong>；<br>那么<strong>java内存模型</strong> <strong>JMM</strong>则<strong>是一套规范</strong>；关于<strong>Java内存模型</strong>的权威解释可以查看网址；（Oracle提供的纯英文版本，即Java内存模型的详细的说明文档，其实即一套规范，那么这套规范主要描述了两个关键字；一个是synchronized；一个是volatile；）</p>
<p>学习java内存模型的概念和作用<br>java内存模型（即 java Memory Model，简称JMM）。<br>（java内存模型 和 以前学习的栈、堆、方法区、原空间这样的java内存结构是不一样的）<br>很多小伙伴 将 “java内存结构” 与 “java内存模型”混淆。<br>关于 “java内存模型”的权威解释，请参考 <code>https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf</code>。</p>
<p>为什么会出现Java内存模型；<br>Java是一门跨平台的语言；可以在不同的操作系统上运行；<br>那么其底层是依赖JVM虚拟机来进行实现的跨平台这一特性；<br>每一个平台都有其对应的一个虚拟机；<br>那么此时Java程序就可以跑在不同的操作系统上；<br>那么java内存模型是java虚拟机规范当中的一部分；<br>它主要是用来屏蔽java运行在不同操作系统上的一些细节问题；<br>那么java程序仅仅只需要关注java内存模型即可；</p>
<p>Java 内存模型，是 Java虚拟机规范 中 所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。<br>JMM是一套规范， 描述了 Java程序中 各种变量（线程共享变量）的访问规则，以及在 JVM中 将变量 存储到 内存和从内存中读取变量 这样的底层细节，具体如下。</p>
<p>（学习主内存和工作内存，以及它们是如何操作这些共享变量的）<br>Java内存模型主要分作两部分来看；<br>一部分叫做主内存；<br>另一部分叫做工作内存；<br>首先来看主内存，java当中的共享变量；都放在主内存当中；<br>比如说类的成员变量也称之为实例变量；还有静态的成员变量；或者说叫类变量；都是存储在主内存当中的；<br>那么每一个线程都可以来进行访问主内存；<br>接着来看第二部分工作内存；每一个线程都有其自己的工作内存；<br>当线程要执行代码的时候，就必须在工作内存当中来进行处理完成；</p>
<p>假设现在一个线程A要访问主内存当中的一个共享变量X；<br>要对该共享变量X进行操作；<br>那么线程是不能够在主内存当中来进行直接操作共享变量X的；<br>即该线程只能够将该共享变量先进行复制一份放到线程自己的工作内存当中，<br>然后才去进行数据的相关处理；<br>当线程在其工作内存对该复制过来的共享变量相应处理完成之后再将处理完成的结果同步回主内存当中去；</p>
<p>假设线程A想要对共享变量x操作；<br>此时共享变量x的取值在主内存当中为 int x = 10; 这样一个取值；<br>那么首先线程A需要将该共享变量x的取值从主内存当中进行拷贝一份放到自己的工作内存当中去；<br>然后进行相应处理，比方说这里处理为重新赋值为9，<br>即int x = 9;那么假设处理完成之后，<br>那么这个时候该线程A就需要将对该共享变量重新赋值的结果即9需要同步回主内存当中；<br>那么其他的线程也是一样的，<br>也是先要进行将共享变量先要从主内存当中进行拷贝一份放到自己的工作内存当中去；<br>然后再去进行操作for example：int x = 8;<br>最后相应操作（赋值）完成之后再由线程从工作内存同步至主内存当中去；</p>
<ul>
<li><strong>主内存</strong><ul>
<li><strong>主内存</strong>是 所有<strong>线程</strong>都<strong>共享</strong>的，都能访问的。所有的<strong>共享变量</strong>都<strong>存储于主内存</strong>。</li>
<li>共享变量主要包括类当中的成员变量，以及一些静态变量等；线程的局部变量是不会出现在主内存当中的；因为线程的局部变量只能够自己该线程进行使用；</li>
</ul>
</li>
<li><strong>工作内存</strong><ul>
<li>每一个线程有自己的<strong>工作内存</strong>，工作内存只存储 该线程 对<strong>共享变量的副本</strong>。 线程对变量的所有的操作（<strong>读、取</strong>）都必须在<strong>工作内存</strong>中完成，而<strong>不能直接读写主内存中的变量</strong>，不同线程之间也<strong>不能直接访问</strong> <strong>对方工作内存中的 变量</strong>。</li>
<li>线程对共享变量的操作都是对其副本进行操作，操作完成之后再同步回主内存当中去；</li>
</ul>
</li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">                    Java Memory Model(Java 内存模型)</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    --------------------------          ----------------------------</span><br><span class="line">    |<span class="string">        线程1           </span>|<span class="string">           </span>|<span class="string">          线程2           </span>|</span><br><span class="line">    |<span class="string">                        </span>|<span class="string">           </span>|<span class="string">                          </span>|</span><br><span class="line">    |<span class="string">  -------------------   </span>|<span class="string">           </span>|<span class="string">  --------------------    </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string">  线程1工作内存    </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string">  线程2工作内存    </span>|<span class="string">    </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string">                  </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string">                   </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string"> ---------------- </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string"> ----------------  </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string"> </span>|<span class="string"> 共享变量x副本 </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string"> 共享变量x副本 </span>|<span class="string">  </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string"> ---------------- </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string"> ----------------- </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string">                  </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string">                   </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  --------------------  </span>|<span class="string">           </span>|<span class="string">  ---------------------   </span>|</span><br><span class="line">                ↑                                      ↑</span><br><span class="line">                |<span class="string">                                      </span>|</span><br><span class="line">                |<span class="string">←---------------JMM控制--------------→</span>|</span><br><span class="line">                |<span class="string">                                      </span>|</span><br><span class="line">                ↓                                      ↓</span><br><span class="line">   --------------------------------------------------------------------</span><br><span class="line">   |<span class="string">                            主内存                                </span>|</span><br><span class="line">   |<span class="string">  ------------------      ------------------     --------------   </span>|</span><br><span class="line">   |<span class="string">  </span>|<span class="string">   共享变量x    </span>|<span class="string">       </span>|<span class="string">   共享变量 y   </span>|<span class="string">      </span>|<span class="string"> 共享变量z  </span>|<span class="string">  </span>|</span><br><span class="line">   |<span class="string">  ------------------      -------------------    ---------------  </span>|</span><br><span class="line">   |<span class="string">                                                                  </span>|</span><br><span class="line">   --------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h3 id="Java内存模型的作用"><a href="#Java内存模型的作用" class="headerlink" title="Java内存模型的作用"></a>Java内存模型的作用</h3><p>java内存模型是一套规范；<br>主要的目的就是在多线程对共享变量进行读写时，来保证共享变量的可见性、有序性、原子性；<br>java内存模型该规范当中主要阐述了两个关键字；<br>一个是synchronized；一个是volatile；<br>那么在编程当中也是通过这两个关键字来进行保证共享变量的三个特性即可见性、有序性、原子性；</p>
<p>java内存模型 是一套在多线程读写共享数据时，对共享数据的可见性、有序性、原子性的规则和保障。</p>
<p>java内存模型与真实的计算机结构有什么关系？</p>
<h3 id="CPU缓存、内存与Java内存模型的关系"><a href="#CPU缓存、内存与Java内存模型的关系" class="headerlink" title="CPU缓存、内存与Java内存模型的关系"></a>CPU缓存、内存与Java内存模型的关系</h3><p>通过对前面的 <strong>CPU硬件内存架构</strong>、<strong>Java内存模型</strong> 以及 <strong>Java多线程的实现原理</strong> 的了解，应该已经意识到，<strong>多线程的执行</strong> <strong>最终</strong>都会<strong>映射</strong>到 <strong>硬件处理器</strong> 上进行<strong>执行</strong>。</p>
<p>但 <strong>Java内存模型</strong> 和 <strong>硬件内存架构</strong> 并<strong>不完全一致</strong>。<br>对于 <strong>硬件内存</strong> 来说只有 <strong>寄存器</strong>、<strong>缓存内存</strong>、<strong>主内存</strong>的概念，<br>并<strong>没有工作内存和主内存之分</strong>，<br>也就是说 <strong>Java内存模型对内存的划分</strong> 对 <strong>硬件内存</strong> 并<strong>没有任何问题</strong>，<br>因为<strong>JMM</strong>只是一种 <strong>抽象的概念</strong>，是<strong>一组规则</strong>，<br>不管是 <strong>工作内存的数据</strong> 还是 <strong>主内存的数据</strong>，<br>对于 <strong>计算机硬件</strong>来说 都会 <strong>存储在计算机主内存</strong>中，<br>当然也有可能 <strong>存储到CPU缓存</strong>或者<strong>寄存器</strong>中，<br>因此总体上来说，<strong>Java内存模型</strong>和<strong>计算机硬件内存架构</strong> 是一个<strong>相互交叉</strong>的关系，<br>是一种 <strong>抽象概念划分</strong> 与 <strong>真实物理硬件</strong>的<strong>交叉</strong>。</p>
<p>JMM内存模型与CPU硬件内存架构的关系：</p>
<p>图的右边是真实的CPU硬件内存架构；有CPU、CPU当中存在有CPU寄存器、CPU缓存、内存（RAM）；<br>图的左边是Java内存模型：线程、线程当中存在有工作内存、主内存；<br>Java内存模型是一套抽象出来的规范，抽象的概念，是一组规则；<br>java内存模型当中的线程中的工作内存有可能对应着 硬件内存架构当中的CPU寄存器也有可能对应着CPU缓存也有可能对应内存（RAM）；<br>java内存模型当中的主内存也有可能对应着 硬件内存架构当中的CPU寄存器、CPU缓存、内存（RAM）；</p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>java内存模型是一套规范（主要是让java程序来可以实现跨平台这一特性；又不需要去关注平台的底层细节），<br>描述了 java程序中各种变量 （线程共享变量）的访问规则，<br>以及在 JVM中将变量 存储到内存和从内存中读取变量这样的 底层细节，<br>java内存模型是对共享数据的可见性、有序性、原子性的规则和保障。</p>
<h2 id="主内存与工作内存之间的数据交互过程"><a href="#主内存与工作内存之间的数据交互过程" class="headerlink" title="主内存与工作内存之间的数据交互过程"></a>主内存与工作内存之间的数据交互过程</h2><p>java内存模型有主内存、工作内存之分；<br>当线程A需要进行操作一个共享变量X的时候，<br>需要将存在在主内存的共享变量X复制拷贝一份放到线程A自己的工作内存当中；<br>线程A即对自己工作内存当中拷贝过来的共享变量副本进行操作，<br>操作处理完成之后；<br>然后再将结果从工作内存同步回主内存当中去；<br>那么该过程当中其中详细的细节是怎样的？</p>
<h3 id="主内存与工作内存之间的交互"><a href="#主内存与工作内存之间的交互" class="headerlink" title="主内存与工作内存之间的交互"></a>主内存与工作内存之间的交互</h3><h3 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h3><p>了解主内存与工作内存之间的数据交互过程</p>
<p>Java内存模型 中定义了以下 8中操作来完成（为了保证主内存与工作内存之间的数据交互数据是正确的），<br>主内存与工作内存之间 具体的交互协议，<br>即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，<br>虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的；</p>
<p>对应的流程图如下：<br>这8个原子操作先不关心 Lock与Unlock操作；除此之外还余六个操作；<br>假设现在线程1想要来进行访问主内存当中的共享变量x，即当前主内存当中的共享变量x的取值为 boolean x = true;</p>
<p>那么该线程1首先会做一个原子操作叫做Read，那么也就是读取主内存当中的共享变量x的取值即boolean x = true的这样一个取值；<br>那么接下来就是执行一个操作叫做Load，即将该在主内存当中读取到的共享变量加载到了工作内存当中；<br>那么接着会做一个Use操作，也就是说如果该线程1需要对该共享变量x进行操作，即会取到这个从主内存当中加载过来的共享变量x的取值去进行一些操作；<br>那么操作之后会有一个新的结果进行返回；那么假设这个操作的新的结果令这个共享变量的取值变为了false；那么即给这个共享变量x进行赋值操作，即完成操作Assign；那么操作完成之后；就需要同步回主内存；<br>同步回主内存首先会完成一个 Store的这样一个原子操作；表示要来保存这个处理结果；<br>然后接着执行Write操作，即把在工作内存当中处理完成之后最新的取值，即Assign赋值给共享变量的值同步到主内存当中；即主内存中共享变量取值x由true更改为false；<br>另外还有两个操作即Lock与Unlock；这个是与锁相关的操作；<br>比如说加了synchronized，即加了锁；才会产生有lock与unlock操作；<br>如果共享变量的操作没有加这个synchronized即没有加锁；<br>那么也就不会产生有lock与unlock操作；</p>
<p>注意；<br>（对于lock有一些特殊的情况；）</p>
<ol>
<li>如果对一个变量执行 lock操作，将会清空工作内存中 此变量的值。</li>
<li>对一个变量执行unlock操作，必须先把此变量同步到主内存中。</li>
</ol>
<p>即如果线程1中在Read主内存当中的共享变量之前，线程1的工作内存当中已经存在有该共享变量的副本；那么又有lock操作的话则将会将该线程1当中的共享变量的副本进行清空掉，然后再去进行Read读取主内存当中共享变量取值的操作；即读取主内存当中有关该共享变量最新的取值；</p>
<p>unlock操作也需要注意；假设线程1当中的工作内存当中存在有该共享变量的副本；那么在执行unlock之前一定会先将工作内存当中该共享变量副本的取值同步到主内存当中去；然后再进行unlock操作；</p>
<p>synchronized如何保证可见性其实就与lock、unlock这两个原子操作有关；</p>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>主内存 与 工作内存 之间的 数据交互过程(即主内存与工作内存的交互过程中是通过这8个原子操作来进行保证数据的正确性；)</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">lock</span> --<span class="comment">→</span> <span class="comment">read</span> --<span class="comment">→</span> <span class="comment">load</span> --<span class="comment">→</span> <span class="comment">use</span> --<span class="comment">→</span> <span class="comment">assign</span> --<span class="comment">→</span> <span class="comment">store</span> --<span class="comment">→</span> <span class="comment">write</span> --<span class="comment">→</span> <span class="comment">unlock</span></span><br></pre></td></tr></table></figure>

<h2 id="synchronized保证原子性"><a href="#synchronized保证原子性" class="headerlink" title="synchronized保证原子性"></a>synchronized保证原子性</h2><p>（通过synchronized关键字和内存模型来详细的分析原子性问题，以及如何来进行解决原子性问题，如何解决可见性问题以及有序性问题等）</p>
<p>第三章：synchronized保证三大特性（即synchronized是如何进行来保证可见性、原子性、有序性）</p>
<h3 id="回顾synchronized的使用"><a href="#回顾synchronized的使用" class="headerlink" title="回顾synchronized的使用"></a>回顾synchronized的使用</h3><p>synchronized 能够保证在 同一时刻 最多只有一个线程执行该段代码，已达到保证并发安全的效果。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//到时候只有一个线程能够拿到获取锁进入同步代码块当中来；其他的线程拿不到获取不到锁；只能够在同步代码块外进行等待</span></span><br><span class="line"><span class="function"><span class="title">synchronized</span><span class="params">( 锁对象 )</span></span>&#123;</span><br><span class="line">  <span class="comment">// 受保护资源 / 临界区资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 与 原子性</p>
<h3 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h3><p>学习使用 synchronized 保证原子性的原理</p>
<h3 id="使用-synchronized-保证原子性"><a href="#使用-synchronized-保证原子性" class="headerlink" title="使用 synchronized 保证原子性"></a>使用 synchronized 保证原子性</h3><p>案例演示：5个线程各执行1000次 i++；<br>（回顾之前原子性问题的代码，<strong>产生原子性问题的原因</strong>）</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">    1. 定义一个共享变量number</span></span><br><span class="line"><span class="comment">    2. 对number进行1000的++操作</span></span><br><span class="line"><span class="comment">    3. 使用5个线程来进行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02Atomicity</span>&#123;</span></span><br><span class="line">  <span class="comment">// 1. 定义一个共享变量number</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">// 2. 对number进行1000的++操作</span></span><br><span class="line">    <span class="comment">// Runnable当中执行1000次的循环；每次循环使得number++</span></span><br><span class="line">    Runnable increment =  () -&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        number++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Thread&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">    <span class="comment">// 3. 使用5个线程来进行</span></span><br><span class="line">    <span class="comment">// 创建5个线程都去执行Runnable当中的run()</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">      t.start();</span><br><span class="line">      <span class="built_in">list</span>.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t : <span class="built_in">list</span>)&#123;</span><br><span class="line">      t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"number = "</span> + number);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    之前存在线程安全问题；</span></span><br><span class="line"><span class="comment">    即多次运行测试发现数据可能会小于5000；</span></span><br><span class="line"><span class="comment">    number = 5000;</span></span><br><span class="line"><span class="comment">    number = 4935;</span></span><br><span class="line"><span class="comment">    导致这种结果的原因是因为number++是由4条字节码指令进行组成的；</span></span><br><span class="line"><span class="comment">    并没有保证这4条字节码指令的原子性操作；</span></span><br><span class="line"><span class="comment">    接下来使用synchronized；synchronized需要一把锁对象；</span></span><br><span class="line"><span class="comment">    则创建一把锁；Object obj即可；</span></span><br><span class="line"><span class="comment">    那么使用了synchronized之后就可以保证number++是一个原子操作；</span></span><br><span class="line"><span class="comment">    再次多次运行就会发现number的取值不会进行变动了；而是直接就是5000；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<strong>synchronized</strong>来进行保证number++的原子性操作；即进行加锁</p>
</blockquote>
<p>再怎么多次运行得到的number的结果也会是5000；因为synchronized保证了number++的原子性；那么数据就不会错乱；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo02_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：5个线程各执行1000次 i++;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Atomicity</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">      Runnable increment = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Test01Atomicity<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">              number++;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      ArrayList&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList();</span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; <span class="number">50</span> ; i++)&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">        t.start();</span><br><span class="line">        ts.add(t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Thread t : ts)&#123;</span><br><span class="line">        t.join();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"number = "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">    synchronized( Test01Atomicity.<span class="keyword">class</span> )&#123;</span><br><span class="line">      number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示</span></span><br><span class="line"><span class="comment">    1. 定义一个共享变量number</span></span><br><span class="line"><span class="comment">    2. 对number进行1000次的++操作</span></span><br><span class="line"><span class="comment">    3. 使用5个线程来进行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test02Atomicity&#123;</span><br><span class="line">  <span class="comment">// 1. 定义一个共享变量number</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  priavte Object obj = <span class="keyword">new</span> Object();<span class="comment">//对象锁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)<span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="comment">// 2. 对number进行1000次的++操作</span></span><br><span class="line">    Runnable increment = ()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">          number++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">    <span class="comment">// 3. 使用5个线程来进行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">      t.start();</span><br><span class="line">      list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t : list)&#123;</span><br><span class="line">      t.<span class="keyword">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">"number = "</span> + number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  进行分析；为什么加了synchronized之后就可以保证number++是一个原子操作；</span></span><br><span class="line"><span class="comment">  还是通过javap反汇编的方式来进行查看number++这一块的字节码指令的变化；</span></span><br><span class="line"><span class="comment">  通过命令行（Windows PowerShell、CMD等）打开文件；</span></span><br><span class="line"><span class="comment">  目录（工程名/target/classes/com/xxx/demo02_concurrent_probleam/Test02Atomicity.class）</span></span><br><span class="line"><span class="comment">  通过键入命令javap对字节码文件进行反汇编；查看到字节码指令；</span></span><br><span class="line"><span class="comment">  &gt;PS C:\Users\13666\IdeaProjects\XXX\Synchronized\target\classes\com\xxx\demo02_concurrent_probleam&gt; javap -p -v .\Test02Atomicity.class</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  接着依旧是分析下synchronized保证原子性操作的原理；</span></span><br><span class="line"><span class="comment">  在第三步骤时创建了5个线程分别都来进行执行Runnable当中的run()操作；</span></span><br><span class="line"><span class="comment">  即进行循环1000次number++操作；</span></span><br><span class="line"><span class="comment">  分析的时候就以两个线程为例；线程A与线程B；</span></span><br><span class="line"><span class="comment">  假设第一个线程A先进行执行Runnable当中的1000次number++的循环；</span></span><br><span class="line"><span class="comment">  当线程A进入到synchronized的时候，如果发现对象锁obj没有线程在使用的话，</span></span><br><span class="line"><span class="comment">  那么线程A就会拿着对象锁obj进入同步代码块当中；</span></span><br><span class="line"><span class="comment">  那么进来之后就将执行number++操作；</span></span><br><span class="line"><span class="comment">  而number++操作所对应的字节码指令有4条字节码指令；</span></span><br><span class="line"><span class="comment">  那么首先来进行执行读取静态共享变量number的取值指令，</span></span><br><span class="line"><span class="comment">  即15: getstatic     #18   //Field number:I该指令；</span></span><br><span class="line"><span class="comment">  当前读取得到number的取值为0；那么读取之后就继续拿着对象锁obj往下进行执行；</span></span><br><span class="line"><span class="comment">  执行指令准备一个常量1即指令18: iconst_1</span></span><br><span class="line"><span class="comment">  准备一个常量1完成之后又接着往下继续执行；</span></span><br><span class="line"><span class="comment">  接着进行一个相加的操作即指令19: iadd的操作即指令15: getstatic当中获取得到静态共享变量number的取值0与18: iconst_1所准备的常量1进行相加得出运算结果为0+1=1；</span></span><br><span class="line"><span class="comment">  假设执行完该相加操作之后，即19: iadd操作完成之后CPU又切换到了第二个线程，即线程B；</span></span><br><span class="line"><span class="comment">  注意此时线程是在19: iadd执行之后但是在20: putstatic指令执行之前进行了CPU的切换，</span></span><br><span class="line"><span class="comment">  即共享变量并未被重新赋值之前只是得出了运算结果的时候进行了CPU切换到线程B上去了；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  第二个线程即线程B也是要来进行执行同步代码块synchronized()&#123;&#125;当中的代码；</span></span><br><span class="line"><span class="comment">  但是此时的这个对象锁obj已经被线程A锁获取得到了即线程A此时还并没有进行释放锁unlock的操作；所以导致尽管CPU切换到了线程B上但是由于线程A没有释放锁；</span></span><br><span class="line"><span class="comment">  线程B没有办法获取得到锁，</span></span><br><span class="line"><span class="comment">  就只能在synchronized同步代码块的外侧进行等待；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  那么CPU最终还是会切换到第一个线程即线程A上面来继续完成number++所对应的未完成的字节码指令的第四条指令即20: putstatic   #18   //Field number:I</span></span><br><span class="line"><span class="comment">  执行putstatic那么就会将19: iadd所运算得出的取值结果1赋值给静态共享变量number取值；</span></span><br><span class="line"><span class="comment">  最后线程A执行外字节码指令之后就会出同步代码块，</span></span><br><span class="line"><span class="comment">  就会将对象锁obj给还回去；</span></span><br><span class="line"><span class="comment">  那么此时CPU又切换回第二个线程，线程B当中上来了；</span></span><br><span class="line"><span class="comment">  线程B又来执行同步代码块synchronized()&#123;&#125;；</span></span><br><span class="line"><span class="comment">  这次就能够获取得到对像锁了；</span></span><br><span class="line"><span class="comment">  基于线程A完成了其在synchronized同步代码块当中的number++操作之后释放了锁，</span></span><br><span class="line"><span class="comment">  CPU又切换到了线程B上，</span></span><br><span class="line"><span class="comment">  所以此时线程B可以拿到获取得到对象锁obj；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  那么此时线程B也拿着对象锁obj进入同步代码块synchronized当中执行number++操作即所对应的4个字节码指令(getstatic、iconst_1、iadd、putstatic)；</span></span><br><span class="line"><span class="comment">  那么线程B先来进行执行number++操作的第一条字节码指令：15: getstatic    #18     // Field number:I 操作获取得到此时共享变量number的取值，</span></span><br><span class="line"><span class="comment">  那么此时线程B来获取共享变量number的取值时，</span></span><br><span class="line"><span class="comment">  共享变量number变量在之前的线程A当中的操作当中已经由0变为了1，</span></span><br><span class="line"><span class="comment">  所以此时线程B获取得到number共享变量的取值为1；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  接着执行number++操作的第二个字节码指令准备一个常量1即18: iconst_1操作；</span></span><br><span class="line"><span class="comment">  在往下继续执行number操作的第三个字节码指令19: iadd，即获取得到静态共享变量取值number为1 与 所准备的常量1进行相加得到运算结果 1+1=2；</span></span><br><span class="line"><span class="comment">  那么最后走到第四步进行执行20:putstatic   # 18   // Field number:I操作</span></span><br><span class="line"><span class="comment">  那么就会把从第三步字节码指令所运算得出的结果 2 赋值给共享变量number取值；</span></span><br><span class="line"><span class="comment">  那么此时静态共享变量的取值就由1更改为2了；</span></span><br><span class="line"><span class="comment">  这个时候可以看到两个线程进行执行number++操作；</span></span><br><span class="line"><span class="comment">  最终得到的number的结果为2；</span></span><br><span class="line"><span class="comment">  数据没有出现错乱；</span></span><br><span class="line"><span class="comment">  那么这里最根本的原因就是有了同步代码块之后；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  当第一个线程进来执行number++所对应的其四个字节码操作指令；</span></span><br><span class="line"><span class="comment">  执行到一半，就算CPU切换到了第二个线程进行执行相同的操作也会由于没有对象锁而无法进入同步代码块只能够在同步代码块外侧进行等待第一个线程释放锁第二个线程才能够获取锁从而进入同步代码块；</span></span><br><span class="line"><span class="comment">  所以也就能够保证第一个线程在执行number++所对应的四个字节码指令时，</span></span><br><span class="line"><span class="comment">  不会受到其他线程的干扰，</span></span><br><span class="line"><span class="comment">  从而也就保证了操作的原子性。</span></span><br><span class="line"><span class="comment">  所以数据才不会出现错乱。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>字节码指令：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">      frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">27</span></span><br><span class="line">    Exceptions:</span><br><span class="line">      thows java.lang.InterruptedException</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> static <span class="built_in">void</span> lambda$main$<span class="number">0</span>();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">          <span class="number">0</span>: iconst_0</span><br><span class="line">          <span class="number">1</span>: istore_0</span><br><span class="line">          <span class="number">2</span>: iload_0</span><br><span class="line">          <span class="number">3</span>: sipush          <span class="number">1000</span></span><br><span class="line">          <span class="number">6</span>: if_icmpge       <span class="number">39</span></span><br><span class="line">          <span class="number">9</span>: getstatic       #<span class="number">22</span>             <span class="comment">// Field obj:Ljava/lang/Object;</span></span><br><span class="line">         <span class="number">12</span>: dup</span><br><span class="line">         <span class="number">13</span>: astore_1</span><br><span class="line">         <span class="number">14</span>: monitorenter</span><br><span class="line">         <span class="number">15</span>: getstatic       #<span class="number">18</span>             <span class="comment">// Field number:I</span></span><br><span class="line">         <span class="number">18</span>: iconst_1</span><br><span class="line">         <span class="number">20</span>: putstatic       #<span class="number">18</span>             <span class="comment">// Field number:I</span></span><br><span class="line">         <span class="number">23</span>: aload_1</span><br><span class="line">         <span class="number">24</span>: monitorexit</span><br><span class="line">         <span class="number">25</span>: goto            <span class="number">33</span></span><br><span class="line">         <span class="number">28</span>: astore_2</span><br><span class="line">         <span class="number">29</span>: aload_1</span><br><span class="line">         <span class="number">30</span>: monitorexit</span><br><span class="line">         <span class="number">31</span>: aload_2</span><br><span class="line">         <span class="number">32</span>: athrow</span><br><span class="line">         <span class="number">33</span>: iinc            <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">         <span class="number">36</span>: goto</span><br><span class="line">         <span class="number">39</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">          <span class="keyword">from</span>     to     target   type</span><br><span class="line">            <span class="number">15</span>     <span class="number">25</span>         <span class="number">28</span>     any</span><br><span class="line">            <span class="number">28</span>     <span class="number">31</span>         <span class="number">28</span>     any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">19</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">15</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">23</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">33</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>number++操作依旧对应着这四条字节码指令</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>: getstatic         #<span class="number">18</span>       <span class="comment">// Field number:I</span></span><br><span class="line"><span class="number">18</span>: iconst_1</span><br><span class="line"><span class="number">19</span>: iadd</span><br><span class="line"><span class="number">20</span>: putstatic         #<span class="number">18</span>       <span class="comment">// Field number:I</span></span><br></pre></td></tr></table></figure>

<p>而此时包含着这四条字节码指令的还有<code>monitorenter</code>以及<code>monitorexit</code>这两条指令；即；</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>: monitorenter</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>: getstatic        #<span class="number">18</span>        <span class="comment">// Field number:I</span></span><br><span class="line"><span class="number">18</span>: iconst_1</span><br><span class="line"><span class="number">19</span>: iadd</span><br><span class="line"><span class="number">20</span>: putstatic        #<span class="number">18</span>        <span class="comment">// Field number:I</span></span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">23</span>: aload_1</span><br><span class="line"><span class="number">24</span>: monitorexit</span><br></pre></td></tr></table></figure>

<h3 id="synchronized-保证原子性的原理"><a href="#synchronized-保证原子性的原理" class="headerlink" title="synchronized 保证原子性的原理"></a>synchronized 保证原子性的原理</h3><p>对 number++ ，增加同步代码块后，保证同一时间 只有 一个线程操作 number++; 就不会出现安全问题。</p>
<h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>synchronized保证原子性的原理: synchronized保证只有一个线程拿到锁，能够进入同步代码块中，当第一个线程进入了同步代码块当中即使操作到了一半没有操作完由于CPU切换，切换到了其他线程，其他线程也会由于没有对象锁的缘故无法进入同步代码块当中只能进行等待；即其他线程不会来干扰第一个线程的操作；就能够保证同步代码块当中的代码是一个原子性的操作，不会受到其他线程的干扰；</p>
<p>synchronized 保证原子性的原理</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对 <span class="built_in">number</span>++; 增加同步代码块后，保证同一时间只有一个线程操作 <span class="built_in">number</span>++;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized保证可见性"><a href="#synchronized保证可见性" class="headerlink" title="synchronized保证可见性"></a>synchronized保证可见性</h2><h3 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h3><p>学习使用 synchronized 保证可见性的原理</p>
<h3 id="使用synchronized保证可见性"><a href="#使用synchronized保证可见性" class="headerlink" title="使用synchronized保证可见性"></a>使用synchronized保证可见性</h3><p>案例演示： 一个线程根据 boolean类型的标记flag，while循环，另一个线程改变这个flag变量的值，根据boolean 类型的标记flag进行while循环的那个线程 并不会停止循环。</p>
<p>回顾之前的代码（<strong>可见性问题产生的原因</strong>）：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">    1. 创建一个共享变量</span></span><br><span class="line"><span class="comment">    2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">    3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test01Visibility&#123;</span><br><span class="line">  <span class="comment">// 1. 创建一个共享变量；</span></span><br><span class="line">  <span class="comment">// boolea布尔类型flag默认取值为true</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="comment">// 2. 创建一条线程不断读取共享变量；</span></span><br><span class="line">    <span class="comment">// 开启一条线程进行循环；</span></span><br><span class="line">    <span class="comment">// 如果flag变量一直为true则一直循环否则停止循环；</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">while</span>(flag)&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  </span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);<span class="comment">// 主线程沉睡两秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建一条线程修改共享变量flag取值为false</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      flag = <span class="keyword">false</span>;</span><br><span class="line">      System.out.<span class="keyword">println</span>(<span class="string">"线程修改了变量的值为false"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      之前的效果为；两秒之后进行打印了语句“线程修改了变量的值为false”；</span></span><br><span class="line"><span class="comment">      但是另外一个线程并没有获取得到最新值，</span></span><br><span class="line"><span class="comment">      也就是根据flag变量进行while循环的那个线程并没有获取得到最新flag取值从而也就导致这个线程一直在while(flag)/while(true)运行中；</span></span><br><span class="line"><span class="comment">      Run一直为红灯。</span></span><br><span class="line"><span class="comment">      接着来进行分析其原因以及如何来进行解决。</span></span><br><span class="line"><span class="comment">      为什么会出现可见性问题分析：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      首先Test01Visibility当中存在有一个成员变量flag取值为true；</span></span><br><span class="line"><span class="comment">      那么该成员变量是两个线程都会来进行操作的；</span></span><br><span class="line"><span class="comment">      线程A与线程B；</span></span><br><span class="line"><span class="comment">      线程A负责执行根据flag取值变化从而while循环的线程；</span></span><br><span class="line"><span class="comment">      线程B则是负责修改成员变量flag取值的线程；</span></span><br><span class="line"><span class="comment">      那么该成员变量位于主内存当中；即线程A与线程B的共享变量；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      红色的箭头代表主线程，主线程从main()开始执行；</span></span><br><span class="line"><span class="comment">      执行Test01Visibility当中mian()中的代码，创建线程A并启动线程A中的run();</span></span><br><span class="line"><span class="comment">      接着画一个新线程，该新线程用绿色箭头表示，表示的即为线程A，</span></span><br><span class="line"><span class="comment">      那么该A线程就会去进行执行while(flag)&#123;&#125;循环；</span></span><br><span class="line"><span class="comment">      当线程A进行执行的时候就需要用到共享变量flag的取值；</span></span><br><span class="line"><span class="comment">      而该共享变量位于主内存当中；</span></span><br><span class="line"><span class="comment">      那么这个时候线程A就会从主内存当中进行复制一份共享变量flag的取值boolean flag=true的副本放到线程A自己的工作内存当中来；</span></span><br><span class="line"><span class="comment">      那么当前进行循环这个flag为true那么也就会导致一直在进行循环的操作；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      主线程继续往下进行执行，Thread.sleep(2000);主线程沉睡两秒钟；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      那么当主线程沉睡完两秒之后，又会进行启动一个新的线程即线程B，也就是那个修改共享变量flag取值的那个线程；</span></span><br><span class="line"><span class="comment">      再画一个紫色的箭头来代表一个新的线程即线程B；</span></span><br><span class="line"><span class="comment">      那么线程B则对应着图中的右边的那块工作内存；</span></span><br><span class="line"><span class="comment">      那么线程B启动之后也是需要来进行执行线程B当中的run()当中的代码即修改共享变量flag的取值为false并打印输出日志；</span></span><br><span class="line"><span class="comment">      所以此时线程B需要做的是也是从主内存当中去进行读取复制拷贝获取得到一份共享变量flag的副本即boolean flag = true;到线程B自己的工作内存当中来；</span></span><br><span class="line"><span class="comment">      另外在线程B自己的工作内存当中对其共享变量副本进行相关操作即进行重新赋值为false；</span></span><br><span class="line"><span class="comment">      那么当线程B修改工作内存当中共享变量flag副本取值之后会将工作内存当中该共享变量副本的取值同步回主内存当中的共享变量取值；</span></span><br><span class="line"><span class="comment">      也就是主内存当中该共享变量flag取值就由true变为了false；</span></span><br><span class="line"><span class="comment">      那么接着线程B再去打印“线程修改了变量的值为false”信息；</span></span><br><span class="line"><span class="comment">      那么该线程B执行至此就结束了。</span></span><br><span class="line"><span class="comment">      那么可以看到的是线程B所进行修改线程B自己工作内存当中的共享变量副本flag的取值为false并且同步回到了主内存当中去了；</span></span><br><span class="line"><span class="comment">      那么此时的线程A并不知道主内存当中共享变量flag的取值被更改了，线程A依然在进行循环操作；</span></span><br><span class="line"><span class="comment">      即while(true)的循环操作；</span></span><br><span class="line"><span class="comment">      线程A使用到的共享变量依然还是线程A自己工作内存当中之前从主内存中复制拷贝过来的flag共享变量也就是那个flag=true那个时候的取值；</span></span><br><span class="line"><span class="comment">      所以线程A就一直循环一直循环根本停不下来；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      那么造成这种现象的原因就是因为：</span></span><br><span class="line"><span class="comment">      一个线程进行修改了共享变量副本的取值并且同步回了主内存当中；</span></span><br><span class="line"><span class="comment">      第二个线程即根据该共享变量副本的取值做while循环的线程并没有感知到主内存当中共享变量取值发生的变化，</span></span><br><span class="line"><span class="comment">      因为第二个线程当中使用的共享变量副本的取值并没有随着一同主内存当中的共享变量取值改变；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      那么解决方案有两种；先简单介绍下；有一个关键字叫做volatile；</span></span><br><span class="line"><span class="comment">      用该关键字volatile来进行修饰共享变量就可以解决可见性问题；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<strong>volatile</strong>关键字来进行解决可见性问题</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">    1. 创建一个共享变量</span></span><br><span class="line"><span class="comment">    2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">    3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Visibility</span>&#123;</span></span><br><span class="line">  <span class="comment">// 1. 创建一个共享变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">// 2. 创建一条线程不断读取共享变量</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">while</span>(flag)&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);<span class="comment">//主线程沉睡两秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      flag =  <span class="literal">false</span>;</span><br><span class="line">      System.out.<span class="built_in">println</span>(<span class="string">"线程修改了变量的值为false"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    那么此时就需要进行分析 volatile关键字是如何进行解决可见性问题的?</span></span><br><span class="line"><span class="comment">    简单介绍下；</span></span><br><span class="line"><span class="comment">    当共享变量flag添加了 volatile关键字之后，线程B进行修改了共享变量flag副本取值为false之后同步回主内存时；由于volatile关键字的修饰，会有一个缓存一致性协议；会把其他线程当中的工作内存中的该共享变量flag的副本全部进行设置为失效状态；那么这个时候其他线程由于线程自己内部工作内存中需要用到的共享变量flag数据失效的缘故就会重新到主内存当中来进行读取最新的共享变量取值；这是采用volatile的规则；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    那么现在不使用volatile，使用synchronized也可以解决这个可见性问题；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <strong>synchronized</strong> 关键字来进行解决可见性问题</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo02_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    案例演示：</span></span><br><span class="line"><span class="comment">      一个线程根据 boolean 类型的标记flag，while循环，另一个线程改变这个flag变量的值，</span></span><br><span class="line"><span class="comment">      根据boolean 类型的标记flag进行while循环的那个线程 并不会停止循环。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Visibility</span> &#123;</span></span><br><span class="line">    <span class="comment">// 多个线程都会访问的数据，我们称为 线程的共享变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="built_in">run</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException</span>&#123;</span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">run</span>)&#123;</span><br><span class="line">          <span class="comment">//增加对象共享数据的打印，println是同步方法</span></span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="string">"run = "</span> + <span class="built_in">run</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      t1.start();</span><br><span class="line"></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">      Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="built_in">run</span> = <span class="literal">false</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"时间到，线程2设置为 false"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">    1. 创建一个共享变量</span></span><br><span class="line"><span class="comment">    2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">    3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test01Visibility</span>&#123;</span></span><br><span class="line">  <span class="regexp">// 1. 创建一个共享变量</span></span><br><span class="line"><span class="regexp">  private static boolean flag = true;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  private static Object obj =  new Object();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  public static void main(String[] args) throws InterruptedException&#123;</span></span><br><span class="line"><span class="regexp">    //</span> <span class="number">2.</span> 创建一条线程不断读取共享变量</span><br><span class="line">    <span class="keyword">new</span> Tread<span class="function"><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">while</span>(flag)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        synchronized(obj)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">2000</span>)</span>;// 主线程沉睡两秒</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="function">    <span class="title">new</span> <span class="title">Thread</span><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      flag = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">      System.out.println(<span class="string">"线程修改了变量的值为false"</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span>;</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  /**</span></span><br><span class="line"><span class="function">  分析<span class="title">synchronized</span>是如何进行解决的可见性问题？</span></span><br><span class="line"><span class="function">  那么<span class="title">synchronized</span>关键字其实会变成8个原子操作当中的<span class="title">lock</span>与<span class="title">unlock</span>原子操作；</span></span><br><span class="line"><span class="function">  即8个原子操作<span class="params">(主内存与工作内存之间具体的交互协议)</span>为</span></span><br><span class="line"><span class="function">  <span class="title">lock</span> --→<span class="title">read</span> --→ <span class="title">load</span>--→ <span class="title">use</span>--→ <span class="title">assign</span>--→ <span class="title">store</span>--→ <span class="title">write</span>--→ <span class="title">unlock</span>  </span></span><br><span class="line"><span class="function">  那么这个<span class="title">lock</span>原子操作之前就会让线程<span class="title">A</span>当中的工作内存进行去刷新，</span></span><br><span class="line"><span class="function">  也就是如果线程<span class="title">A</span>中存在有该共享变量的副本会被清除，</span></span><br><span class="line"><span class="function">  然后再去获取最新的共享变量<span class="title">flag</span>取值；</span></span><br><span class="line"><span class="function">  也就可以得到最新的<span class="title">false</span>取值；</span></span><br><span class="line"><span class="function">  由线程<span class="title">B</span>进行修改共享变量副本并同步回主内存后的那个最新值；</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  所以这个时候的效果就是线程<span class="title">A</span>当中由于接收到了主内存当中共享变量最新取值的副本<span class="title">flag</span>=<span class="title">false</span>;所以就会不再执行<span class="title">while</span>循环；</span></span><br><span class="line"><span class="function">  另外可以不用进行写 <span class="title">synchronized</span><span class="params">(obj)</span>&#123;&#125; ；</span></span><br><span class="line"><span class="function">  可以直接进行打印也是可以做到解决可见性问题的 <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(flag)</span>;</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  而分析下为什么通过打印语句<span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(flag)</span>;也可以使得<span class="title">while</span>循环停下来呢？</span></span><br><span class="line"><span class="function">  原因在于<span class="title">PrintStream</span>.<span class="title">java</span>中的<span class="title">println</span><span class="params">(boolean x)</span>方法中也使用到了<span class="title">synchronized</span>，</span></span><br><span class="line"><span class="function">  所以也就导致也会去刷新线程<span class="title">A</span>当中工作内存当中的变量从而去获取主内存当中最新的共享变量的取值：</span></span><br><span class="line"><span class="function">  -------------------------------------------------------------------</span></span><br><span class="line"><span class="function">  /**</span></span><br><span class="line"><span class="function">    <span class="title">Prints</span> <span class="title">a</span> <span class="title">boolean</span> <span class="title">and</span> <span class="title">then</span> <span class="title">terminate</span> <span class="title">the</span> <span class="title">line</span>.</span></span><br><span class="line"><span class="function">    <span class="title">This</span> <span class="title">method</span> <span class="title">behaves</span> <span class="title">as</span> <span class="title">though</span> <span class="title">it</span> <span class="title">invokes</span></span></span><br><span class="line"><span class="function">    &lt;<span class="title">code</span>&gt;&#123;@<span class="title">link</span> #<span class="title">print</span><span class="params">(boolean)</span>&#125;&lt;/<span class="title">code</span>&gt; <span class="title">and</span> <span class="title">then</span></span></span><br><span class="line"><span class="function">    &lt;<span class="title">code</span>&gt;&#123;@<span class="title">link</span> #<span class="title">println</span><span class="params">()</span>&#125;&lt;/<span class="title">code</span>&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    @<span class="title">param</span> <span class="title">x</span> <span class="title">The</span> &lt;<span class="title">code</span>&gt;<span class="title">boolean</span>&lt;/<span class="title">code</span>&gt; <span class="title">to</span> <span class="title">be</span> <span class="title">printed</span></span></span><br><span class="line"><span class="function">  */</span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">void</span> <span class="title">println</span><span class="params">(boolean x)</span>&#123;</span></span><br><span class="line"><span class="function">    <span class="title">synchronized</span><span class="params">(<span class="keyword">this</span>)</span>&#123;</span></span><br><span class="line"><span class="function">      <span class="title">print</span><span class="params">(x)</span>;</span></span><br><span class="line"><span class="function">      <span class="title">newLine</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  -------------------------------------------------------------------</span></span><br><span class="line"><span class="function">  */</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="synchronized-保证可见性的原理"><a href="#synchronized-保证可见性的原理" class="headerlink" title="synchronized 保证可见性的原理"></a>synchronized 保证可见性的原理</h3><p>synchronized同步的时候会对应8个原子操作当中的lock与unlock这两个原子操作；<br>那么lock操作执行时回去刷新该线程工作内存当中共享变量的取值；<br>从而该线程就会去主内存中去获取得到最新的值；<br>也就是说synchronized会刷新工作内存中的变量得到主内存中最新共享变量取值的副本；<br>从而保证可见性；</p>
<h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p>synchronized保证可见性的原理</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行<span class="keyword">synchronized</span>时，其对应的lock原子操作会刷新工作内存中共享变量的值</span><br></pre></td></tr></table></figure>

<h2 id="synchronized保证有序性"><a href="#synchronized保证有序性" class="headerlink" title="synchronized保证有序性"></a>synchronized保证有序性</h2><p>synchronized 与 有序性</p>
<h3 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h3><p>学习使用 synchronized 保证有序性的原理</p>
<h3 id="为什么要重排序"><a href="#为什么要重排序" class="headerlink" title="为什么要重排序"></a>为什么要重排序</h3><p>为了提高程序的执行效率，有可能所写的代码对CPU来说其执行效率并不高；<br>它可能经过重排序之后执行的效率更高一点；所以编译器和CPU会对程序中的代码进行重排序；（编译器和CPU不会进行乱排，会满足某种规则；所以就有一个<strong>as-if-serial语义</strong>）</p>
<p>重排序 是指 编译器 和 处理器 为了优化程序性能 而对 指令序列 进行 重新排序 的一种手段。  </p>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>as-if-serial 语义的意思是：</p>
<p>（不管编译器和CPU如何重排序。必须保证在单线程情况下程序的结果是正确的；那么在多线程的情况下就有可能是有问题存在问题的）<br>不管怎么 重排序（编译器和处理器 为了提高 并行度），单线程程序的执行结果不能被改变。<br>编译器、runtime和处理器 都必须遵守 as-if-serial 语义。</p>
<p>以下数据有依赖关系，不能 重排序。</p>
<p>写后读：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int <span class="keyword">a</span> = <span class="number">1</span>; <span class="comment"># 对一个变量进行写操作</span></span><br><span class="line">int b = <span class="keyword">a</span>; <span class="comment"># 在对一个变量写操作完成之后又将该变量的取值读取出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么在这种情况下是不能够进行重排序的；</span></span><br><span class="line"><span class="comment"># 即不能够换成</span></span><br><span class="line"><span class="comment"># int b = a;</span></span><br><span class="line"><span class="comment"># int a = 1;</span></span><br><span class="line"><span class="comment"># 那么在执行 int b = a;的时候，a是没有取值的；</span></span><br></pre></td></tr></table></figure>

<p>写后写：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; # 先给变量a进行赋值操作即写操作；</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>; # 再来给变量a进行赋值操作即写操作；</span><br><span class="line"></span><br><span class="line"><span class="meta"># 那么在这种情况下也是不能够进行重排序的；</span></span><br><span class="line"><span class="meta"># 即不能够换成</span></span><br><span class="line"><span class="meta"># int a = 2;</span></span><br><span class="line"><span class="meta"># int a = 1;</span></span><br><span class="line"><span class="meta"># 的这样一种情况，</span></span><br><span class="line"><span class="meta"># 因为在执行原来没有重排序的代码时最终获取得到a变量的结果为2；</span></span><br><span class="line"><span class="meta"># 而经过重排序之后a变量的取值被重新赋值为了1；</span></span><br><span class="line"><span class="meta"># 导致数据最终结果的不正确性；</span></span><br><span class="line"><span class="meta"># 所以在这种情况下也是不能够进行重排序；</span></span><br></pre></td></tr></table></figure>

<p>读后写：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; # 给变量a进行赋值写操作</span><br><span class="line"><span class="keyword">int</span> b = a; # 将变量a的取值进行读取出来</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>; # 再将变量a的取值进行重新赋值</span><br><span class="line"></span><br><span class="line"><span class="meta"># 这种情况下也是不能够进行重排序的；</span></span><br><span class="line"><span class="meta"># 即不能够换成</span></span><br><span class="line"><span class="meta"># int a = 1;</span></span><br><span class="line"><span class="meta"># int a = 2;</span></span><br><span class="line"><span class="meta"># int b = a;</span></span><br><span class="line"><span class="meta"># 这样一种顺序；</span></span><br><span class="line"><span class="meta"># 如果是这样排序的话；将会导致变量b取值的变化；</span></span><br><span class="line"><span class="meta"># 在原来没有进行重排序的时候变量b原本正确赋有的值应该是1；</span></span><br><span class="line"><span class="meta"># 而当重新排序之后变量b的取值发生了改变，即变成了2；</span></span><br><span class="line"><span class="meta"># 同样是导致了数据的最终不正确性；</span></span><br><span class="line"><span class="meta"># 所以在这种情况下也是不能够进行重排序的；</span></span><br></pre></td></tr></table></figure>

<p>编译器 和 处理器不会对 存在数据依赖关系的 操作 做重排序，<br>因为这种 重排序 会改变执行结果。</p>
<p>但是，如果操作之间 不存在数据依赖关系，这些操作就可能被 编译器和处理器 重排序。</p>
<p>（在有些时候是可以进行重排序的；只要没有影响到单线程执行运行结果的正确性；比如说下面这种情况就是可以进行重排序的；即int a =1;int b=2;这两句代码是可以进行互换位置的；彼此互不影响；即int b = 2; int a=1;但是int c =a +b;一定要处于最下面；否则不能得到变量a与变量b的取值；）</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int a</span> = 1;</span><br><span class="line"><span class="attribute">int b</span> = 2;</span><br><span class="line"><span class="attribute">int c</span> = a + b;</span><br></pre></td></tr></table></figure>

<p>上面3个操作的数据依赖关系如图所示：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line">                                  ---------</span><br><span class="line">-------                            |<span class="string">     </span>|</span><br><span class="line">|<span class="string">  a  </span>|<span class="string">---------------------------→</span>|<span class="string">     </span>|</span><br><span class="line">-------                            |<span class="string">     </span>|</span><br><span class="line">                                   |<span class="string">  c  </span>|</span><br><span class="line">-------                            |<span class="string">     </span>|</span><br><span class="line">|<span class="string">  b  </span>|<span class="string">---------------------------→</span>|<span class="string">     </span>|</span><br><span class="line">-------                            |<span class="string">     </span>|</span><br><span class="line">                                  ---------</span><br><span class="line">-------------------------------------------</span><br><span class="line">/<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">即 变量c 依赖 变量a与变量b 的取值；</span><br><span class="line">但是 变量a 与 变量b 并没有直接的依赖关系；</span><br><span class="line">所以这种情况下是可以进行重排序的；</span><br><span class="line"><span class="symbol">*</span>/</span><br></pre></td></tr></table></figure>

<p>如上图所示 a和c 之间存在数据依赖关系，<br>同时 b和c 之间也存在数据依赖关系。<br>因此在最终执行的指令序列中，<br>c 不能被重排序到 a和b 的前面。<br>但 a和b 之间没有数据依赖关系，<br>编译器和处理器 可以重排序 a和b 之间的执行顺序。<br>下图是该程序的两种执行顺序。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="comment">|</span>  <span class="comment">a</span>  <span class="comment">|</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">→|</span>  <span class="comment">b</span>  <span class="comment">|</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">→|</span>  <span class="comment">c</span>  <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="comment">|</span>  <span class="comment">b</span>  <span class="comment">|</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">→|</span>  <span class="comment">a</span>  <span class="comment">|</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">→|</span>  <span class="comment">c</span>  <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">可以这样：</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">a</span> <span class="comment">=</span> <span class="comment">1;</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">b</span> <span class="comment">=</span> <span class="comment">2;</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">c</span> <span class="comment">=</span> <span class="comment">a</span> <span class="literal">+</span> <span class="comment">b;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">也可可以重排序这样：</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">b</span> <span class="comment">=</span> <span class="comment">2;</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">a</span> <span class="comment">=</span> <span class="comment">1;</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">c</span> <span class="comment">=</span> <span class="comment">a</span> <span class="literal">+</span> <span class="comment">b;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用synchronized保证有序性"><a href="#使用synchronized保证有序性" class="headerlink" title="使用synchronized保证有序性"></a>使用synchronized保证有序性</h3><p>Test03Ordering.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.results.I_Result;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"1"</span>, <span class="string">"4"</span>&#125;, expect = Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>)</span><br><span class="line"><span class="meta">@OUtcome</span>(id = <span class="string">"0"</span>, expect =  Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger"</span>)</span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 线程一 执行的代码</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">      r.r1 = num + num;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程二 执行的代码</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾代码分析有序性问题产生的原因</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome</span>( id = &#123;<span class="string">"1"</span>, <span class="string">"4"</span>&#125;, expect =  Expect.ACCEPTABLE, desc=<span class="string">"ok"</span>)</span><br><span class="line"><span class="meta">@Outcome</span>( id = <span class="string">"0"</span>, expect =  Expect.ACCEPTABLE_INTERESTING, desc=<span class="string">"danger"</span>)</span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程一 执行的代码</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">      r.r1 = num + num;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//线程二 执行的代码</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  以前会观察得到4种可能性；3种结果为0,1,4</span></span><br><span class="line"><span class="comment">  分析回顾下：</span></span><br><span class="line"><span class="comment">  假设有两个线程在执行；分别是线程A与线程B；</span></span><br><span class="line"><span class="comment">  线程A执行actor1(I_Result r)；线程B执行actor2(I_Result r)；</span></span><br><span class="line"><span class="comment">  当初出现0的结果是这样来的：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  是actor2(I_Result r)当中的代码</span></span><br><span class="line"><span class="comment">  num = 2;</span></span><br><span class="line"><span class="comment">  ready = true;</span></span><br><span class="line"><span class="comment">  经过了重排序变成了</span></span><br><span class="line"><span class="comment">  ready = true;</span></span><br><span class="line"><span class="comment">  num = 2;</span></span><br><span class="line"><span class="comment">  的一个顺序；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  假设下面的这个线程，也就是执行actor2(I_Result r)的线程B先走；</span></span><br><span class="line"><span class="comment">  那么走了第一句也就是执行了第一句ready=true该句话；</span></span><br><span class="line"><span class="comment">  但是注意并没有执行num=2;</span></span><br><span class="line"><span class="comment">  所以此时共享变量当中的num仍然为0；而ready为true;</span></span><br><span class="line"><span class="comment">  然后此时CPU切换线程到了第二个线程当中来了；</span></span><br><span class="line"><span class="comment">  那么这个时候线程A进行执行actor1(I_Result r)方法；</span></span><br><span class="line"><span class="comment">  那么这个时候线程A就会进入到判断if(ready)&#123;&#125;代码块中；</span></span><br><span class="line"><span class="comment">  因为此时获取得到的ready变量已经由线程B在actor2(I_Result r)中进行了修改取值；</span></span><br><span class="line"><span class="comment">  所以也就会得到 r.r1 = num + num;</span></span><br><span class="line"><span class="comment">  而此时的num并未被重新赋值也就是说此时的num依旧是取值为0；</span></span><br><span class="line"><span class="comment">  所以得到结果记录 r.r1 为0；</span></span><br><span class="line"><span class="comment">  那么这是之前出现的有序性问题分析；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  那么现在来进行添加synchronized来解决有序性问题；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>synchronized关键字解决有序性问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"1"</span> , <span class="string">"4"</span>&#125;, expect = Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>)</span><br><span class="line"><span class="meta">@Outcome</span>(id = <span class="string">"0"</span>, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger"</span>)</span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 先搞一个对象作为对象锁</span></span><br><span class="line">  <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> ready = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程一 执行的代码</span></span><br><span class="line">  <span class="comment">// 测试方法actor1(I_Result r)进行添加synchronized</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">       <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">         r.r1 = num + num;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         r.r1 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程二 执行的代码</span></span><br><span class="line">  <span class="comment">// 下面的测试方法actor2(I_Result r)同样进行添加synchronized</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">     num = <span class="number">2</span>;</span><br><span class="line">     ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>压力测试指令以及结果查看</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">Terminal执行指令(进行多轮压力测试)：</span><br><span class="line"></span><br><span class="line">C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; mvn clean install</span><br><span class="line">C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; java -jar target/jcstress.jar</span><br><span class="line"></span><br><span class="line">测试结果打印：</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">    [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">(ETA:  <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>) (Rate: <span class="number">4.15E+07</span> samples/sec) (Tests: <span class="number">1</span> of <span class="number">1</span>) (Forks: <span class="number">4</span> of <span class="number">4</span>) (Iterations: <span class="number">15</span> of <span class="number">24</span>; <span class="number">15</span> passed, <span class="number">0</span> failed, <span class="number">0</span> soft errs, <span class="number">0</span> hard....)</span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">(ETA:  <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>) (Rate: <span class="number">3.97E+07</span> samples/sec) (Tests: <span class="number">1</span> of <span class="number">1</span>) (Forks: <span class="number">4</span> of <span class="number">4</span>) (Iterations: <span class="number">15</span> of <span class="number">24</span>; <span class="number">15</span> passed, <span class="number">0</span> failed, <span class="number">0</span> soft errs, <span class="number">0</span> hard....)</span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">(ETA:  <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>) (Rate: <span class="number">3.53E+07</span> samples/sec) (Tests: <span class="number">1</span> of <span class="number">1</span>) (Forks: <span class="number">4</span> of <span class="number">4</span>) (Iterations: <span class="number">15</span> of <span class="number">24</span>; <span class="number">15</span> passed, <span class="number">0</span> failed, <span class="number">0</span> soft errs, <span class="number">0</span> hard....)</span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">(ETA:  <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>) (Rate: <span class="number">3.83E+07</span> samples/sec) (Tests: <span class="number">1</span> of <span class="number">1</span>) (Forks: <span class="number">4</span> of <span class="number">4</span>) (Iterations: <span class="number">15</span> of <span class="number">24</span>; <span class="number">15</span> passed, <span class="number">0</span> failed, <span class="number">0</span> soft errs, <span class="number">0</span> hard....)</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">结果分析：</span><br><span class="line">  发现并没有出现那几种结果出现的次数；</span><br><span class="line">  说明这个代码就没有问题；即没有出现这种<span class="number">0</span>的情况；</span><br><span class="line">  如果真的想看的话；可以这么做；</span><br><span class="line">  假设将取值为<span class="number">4</span>也变为感兴趣的则重新来进行压力测试</span><br><span class="line"></span><br><span class="line">@JCStressTest</span><br><span class="line">@Outcome(id = <span class="string">"1"</span>, expect = Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>)</span><br><span class="line">@Outcome(id = <span class="string">"4"</span>, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger2"</span>)</span><br><span class="line">@Outcome(id = <span class="string">"0"</span>, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger"</span>)</span><br><span class="line">@State</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">Terminal执行指令(进行多轮压力测试)：</span><br><span class="line"></span><br><span class="line">C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; mvn clean install</span><br><span class="line">C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; java -jar target/jcstress.jar</span><br><span class="line"></span><br><span class="line">测试结果打印：</span><br><span class="line">      [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">    (JVM args: [-XX:TieredStopAtLevel=<span class="number">1</span>])</span><br><span class="line">Observed state Occurrences         Expectation     Interpretation</span><br><span class="line">             <span class="number">0</span>       <span class="number">0</span>      ACCEPTABLE_INTERESTING  danger</span><br><span class="line">             <span class="number">1</span>   <span class="number">5</span>,<span class="number">427</span>,<span class="number">079</span>          ACCEPTABLE      ok</span><br><span class="line">             <span class="number">4</span>   <span class="number">5</span>,<span class="number">672</span>,<span class="number">602</span>  ACCEPTABLE_INTERESTING  danger2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_probleam.Test03Ordering</span><br><span class="line">  （JVM args: []）</span><br><span class="line">Observed state Occurrences         Expectation     Interpretation</span><br><span class="line">             <span class="number">0</span>       <span class="number">0</span>      ACCEPTABLE_INTERESTING  danger</span><br><span class="line">             <span class="number">1</span>  <span class="number">42</span>,<span class="number">176</span>,<span class="number">771</span>          ACCEPTABLE      ok</span><br><span class="line">             <span class="number">4</span>  <span class="number">26</span>,<span class="number">991</span>,<span class="number">710</span>  ACCEPTABLE_INTERESTING  danger2</span><br><span class="line">....</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">结果分析：</span><br><span class="line">  此时可以看到的是出现<span class="number">0</span>的此时已经为<span class="number">0</span>了；</span><br><span class="line">  即都不会再出现<span class="number">0</span>了也就表示有序性问题得到了解决；</span><br><span class="line"></span><br><span class="line">分析synchronized是如何进行解决有序性问题的？</span><br><span class="line">当前假设actor2(I_Result r)当中的代码已经出现了重排序，</span><br><span class="line">即</span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line">变为了</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line">这样一个顺序；</span><br><span class="line"></span><br><span class="line">其实会产生很多的线程来执行actor1(I_Result r)与actor2(I_Result r)方法；</span><br><span class="line">那么这个时候举例各有一个线程A、B来分别进行执行actor1(I_Result r)与actor2(I_Result r)；</span><br><span class="line">那么还是一样假设下面的线程先走，即线程B先来执行代码块actor2(I_Result r)当中的同步代码块；</span><br><span class="line">那么线程B就会拿着对象锁Object obj进入actor2(I_Result r)的同步代码块当中执行已经重排序过了的代码即；</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line">那么拿着对象锁obj的线程B就先会去执行ready=<span class="literal">true</span>该句代码；</span><br><span class="line">那么假设此时CPU又切换到另外一个线程上面去了，</span><br><span class="line">注意是在线程B执行ready=<span class="literal">true</span>;之后但是并没有执行num=<span class="number">2</span>该句代码之前进行了CPU切换；</span><br><span class="line">也就是说当前的共享变量当中num取值仍然为<span class="number">0</span>；但是ready的取值已经变为了<span class="literal">true</span>；</span><br><span class="line">即切换到线程A上去执行actor1(I_Result r)方法当中的同步代码块了；</span><br><span class="line">那么到actor1(I_Result r)当中来看，</span><br><span class="line">线程A如果想要进入同步代码块则首先需要去获取拿到对象锁Object obj；</span><br><span class="line">但是该对象锁Object obj现在仍然在线程B当中，</span><br><span class="line">即线程B获取拿到对象锁obj之后还没有释放锁没有执行完成，</span><br><span class="line">CPU就切换到了线程A上了，</span><br><span class="line">导致线程A没有办法拿到获取对象锁Object obj，</span><br><span class="line">从而只能够在同步代码块外侧进行等待；</span><br><span class="line"></span><br><span class="line">等待CPU又切换到线程B上，让线程B执行完流程后释放锁；</span><br><span class="line">这个时候CPU再切换到线程B上时，没有其它线程竞争的话，</span><br><span class="line">那么这个时候线程B就能够获取得到对象锁从而进入同步代码块当中；</span><br><span class="line"></span><br><span class="line">所以来看，即使actor2(I_Result r)当中的代码发生了重排序，也没有问题了；</span><br><span class="line">接着CPU又切换到线程B上来执行actor2(I_Result r)没有执行完成的内容；</span><br><span class="line">即执行num = <span class="number">2</span>; 那么这个时候此时的共享变量 num被更新赋值为<span class="number">2</span>，以及ready取值为<span class="literal">true</span>；</span><br><span class="line">最后线程B出同步代码块，出了同步代码块之后线程B才会将对象锁Object obj还回去。</span><br><span class="line"></span><br><span class="line">假设线程B当前已经执行完成出了同步代码块也已经释放了锁，</span><br><span class="line">此时CPU再次切换到线程A上，</span><br><span class="line">那么这个时候线程A就可以能够获取得到对象锁Object obj了；</span><br><span class="line">那么得到对象锁之后就可以进入到同步代码块中了；</span><br><span class="line">通过判断ready取值进入<span class="keyword">if</span>/<span class="keyword">else</span>块；</span><br><span class="line">由于共享变量ready以及num在线程B的actor2(I_Result r)中被进行了修改；</span><br><span class="line">当前线程A读取到变量ready取值为<span class="literal">true</span>；num取值为<span class="number">2</span>；</span><br><span class="line">所以此时线程A就将会拿着对象锁Object obj 进入到<span class="keyword">if</span>(ready)块当中去；</span><br><span class="line">I_Result r.r1将会被重新赋值为 <span class="number">2</span>+<span class="number">2</span>=<span class="number">4</span>；</span><br><span class="line">所以此时的一个记录结果为<span class="number">4</span>；</span><br><span class="line">现在可以观察到的是：</span><br><span class="line">尽管加了同步代码块synchronized，</span><br><span class="line">但是actor2(I_Result r)当中依然会发生重排序；</span><br><span class="line">但是发生了重排序也没有问题；</span><br><span class="line">因为actor1(I_Result r)与actor2(I_Result r)都添加了同步代码块synchronized，</span><br><span class="line">保证只有一个线程来进行执行；</span><br><span class="line">就算actor2(I_Result r)中线程B执行到ready=<span class="literal">true</span>之后CPU又切换到线程A上面去了；那么线程A将由于无法获取得到对象锁Object obj也无法进入同步代码块当中去；由于线程B没有执行完成，即没有释放锁；所以线程A只能够进行等待；</span><br><span class="line">那么也就相当于是单线程在执行这些代码；</span><br><span class="line">那么重排序是能够保证单线程的执行效果没有问题；</span><br></pre></td></tr></table></figure>

<h3 id="synchronized-保证有序性的原理"><a href="#synchronized-保证有序性的原理" class="headerlink" title="synchronized 保证有序性的原理"></a>synchronized 保证有序性的原理</h3><p>synchronized后，虽然进行了重排序，保证只有一个线程会进入同步代码块，也能保证有序性。</p>
<h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><p>synchronized保证有序性的原理：加synchronized，依然会发生重排序，只不过，存在有同步代码块，可以保证只有一个线程执行同步代码块当中的代码。<br>也就能保证有序性。</p>
<p>有序性除了可以使用synchronized来进行解决，还能够进行给 共享变量num以及ready变量进行添加volatile关键字来进行解决有序性问题。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  添加了volatile关键字之后，</span></span><br><span class="line"><span class="comment">  可以保证共享变量num以及ready变量不会发生重排序；</span></span><br><span class="line"><span class="comment">  也就不会发生有序性问题了；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span> Object obj =  <span class="keyword">new</span> Object();<span class="comment">//对象锁</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> <span class="built_in">ready</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程一 执行的代码</span></span><br><span class="line">  @Actor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ready</span>)&#123;</span><br><span class="line">      r.r1 = num + num;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程二 执行的代码</span></span><br><span class="line">  @Actor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">ready</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized的可重入特性"><a href="#synchronized的可重入特性" class="headerlink" title="synchronized的可重入特性"></a>synchronized的可重入特性</h2><p>第四章：synchronized的特性</p>
<blockquote>
<p>synchronized属于同步锁机制，<br>第四章介绍synchronized作为锁的两个特性：<br>1、 可重入性（当一个线程执行到同步代码块，获取了某一个锁之后，还能够再次进入同步代码块当中，获取同样的一把锁，这个是可以的，可以重新再次进入，将分析其原理以及其可重入性的好处）；<br>2、不可中断性（synchronized是不可中断的：当一个线程进入了同步代码块，那么另外一个线程只能够在外面进行等待，这个处于等待的线程会一直处于等待状态，不会中断，所以也就叫做不可中断；<br>另外还会通过ReentrantLock的代码来进行演示ReentrantLock是可以进行中断的）</p>
</blockquote>
<p>可重入特性</p>
<p>synchronized作为锁，具有两个特性；<br>一个是 可重入性；一个是不可中断性；</p>
<h3 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a>目标</h3><p>了解什么是可重入<br>了解可重入的原理</p>
<h3 id="什么是可重入"><a href="#什么是可重入" class="headerlink" title="什么是可重入"></a>什么是可重入</h3><p>指的是 同一个线程的 可以多次获得 同一把锁。<br>（一个线程可以多次执行synchronized，重复获取同一把锁；）</p>
<p>(当一个线程执行到同步代码块获取到某一个锁之后，还能再次进入同步代码块，获取同样的一把锁，这是可以的，可以重新再进入)</p>
<h3 id="演示可重入特性"><a href="#演示可重入特性" class="headerlink" title="演示可重入特性"></a>演示可重入特性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  可重入特性</span></span><br><span class="line"><span class="comment">    指的是 同一个线程获得锁之后，可以直接再次获取该锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Runnable sellTicket =  <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(Demo01<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是run"</span>);</span><br><span class="line">            test01();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(Demo01<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是test01"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Thread(sellTicket).start();</span><br><span class="line">      <span class="keyword">new</span> Thread(sellTicket).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>演示</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：演示synchronized可重入</span></span><br><span class="line"><span class="comment">    1. 自定义一个线程类</span></span><br><span class="line"><span class="comment">    2. 在线程类的run方法中使用 嵌套的代码同步块</span></span><br><span class="line"><span class="comment">    3. 使用两个线程来执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span></span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">MyThread</span>().start();</span><br><span class="line">      <span class="keyword">new</span> <span class="type">MyThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 自定义一个线程类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  如果一个线程能够获取得到MyThread.class这把锁从而进入同步代码块1并打印；</span></span><br><span class="line"><span class="comment">  还依然能够拿着相同的一把锁再次进入同步代码块2，</span></span><br><span class="line"><span class="comment">  这就说明synchronized是可重入的；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  public void run()&#123;</span><br><span class="line">    synchronized(<span class="type">MyThread</span><span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">      <span class="type">System</span>.out.println(getName() + <span class="string">"进入了同步代码块1"</span>);</span><br><span class="line"></span><br><span class="line">      synchronized(<span class="type">MyThread</span><span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">         <span class="type">System</span>.out.println(getName() + <span class="string">"进入了同步代码块2"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果并分析synchronized可重入性执行流程</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">结果:</span><br><span class="line">Thread-<span class="number">0</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">-------------------------</span><br><span class="line"></span><br><span class="line">先画一个红色的箭头代表主线程；</span><br><span class="line">主线程从main<span class="literal">()</span>方法开始执行；</span><br><span class="line">那么就会启动两个线程即<span class="keyword">new</span> <span class="constructor">MyThread()</span>.start<span class="literal">()</span><span class="operator"> * </span><span class="number">2</span>；</span><br><span class="line">那么画两个箭头，一个绿色的箭头一个紫色的箭头即分别代表A线程与B线程；</span><br><span class="line">那么这两个线程A、B会来进行执行MyThread当中实现的run<span class="literal">()</span>方法；</span><br><span class="line">假设线程A先执行；</span><br><span class="line">那么线程A会获取得到锁<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>从而能够进入代码块当中；</span><br><span class="line">那么这个锁对象<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中存在一个计数器，</span><br><span class="line">该锁对象<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中的计数器会记录自己被获取了几次，</span><br><span class="line">那么当前是线程A第一次获取得到该锁<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>；即计数器取值加<span class="number">1</span>；</span><br><span class="line">那么线程A进入到同步代码块<span class="number">1</span>当中即会进行打印 线程名+<span class="string">"进入了同步代码块1"</span>信息；</span><br><span class="line">接着该线程A继续往下进行执行发现又是一个同步代码块，且还是获取的一个相同的锁；那么这个时候；会将锁对象<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中计数器的取值再次++，设置为<span class="number">2</span>；</span><br><span class="line">假设CPU此时依然在该线程A上，而线程A继续往下进行执行，那么此时就会进行打印 线程名++<span class="string">"进入了同步代码块2"</span>信息；</span><br><span class="line">那么也就可以观察得到同一个线程多次执行synchronized拿到同一把锁；</span><br><span class="line">那么这个锁当中存在有一个计数器，这个计数器当中会进行记录自己被拿到了几次。</span><br><span class="line"></span><br><span class="line">那么假设此时CPU又切换到了另外一个线程；即线程B；</span><br><span class="line">那么此时线程B也会来进行执行MyThread当中实现的run<span class="literal">()</span>方法；</span><br><span class="line">但是会发现<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>该对象锁依然在线程A那里，即线程A还并没有进行释放锁CPU就切换到了线程B上；</span><br><span class="line">所以也就导致了线程B无法获取得到锁从而也就无法进入同步代码块<span class="number">1</span>中，只能够在同步代码块<span class="number">1</span>的外侧进行等待；</span><br><span class="line"></span><br><span class="line">那么这个时候CPU又切换回来到了线程A上；</span><br><span class="line">那么线程A继续接着CPU切换之前的的那个地方往下进行执行；</span><br><span class="line">即当时已经打印完成 线程名称+“进入了同步代码块<span class="number">2</span>”信息了；</span><br><span class="line">即线程A走到了同步代码块<span class="number">2</span>的大括号处说明同步代码块<span class="number">2</span>要结束了；</span><br><span class="line">那么此时同步代码块<span class="number">2</span>结束的时候就会将该同步代码块<span class="number">2</span>的锁给释放掉；</span><br><span class="line">也就意味着对象锁<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中的计数器会进行减<span class="number">1</span>操作；</span><br><span class="line">即此时计数器取值由<span class="number">2</span>变成了<span class="number">1</span>；</span><br><span class="line">那么接着继续往下走；那么线程A就又走到了同步代码块<span class="number">1</span>的结束大括号上，也就意味着此时线程A要出同步代码块<span class="number">1</span>，即又释放一次，即锁对象<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中的计数器又会发生一次减<span class="number">1</span>操作；即此时计数器的取值由<span class="number">1</span>变为<span class="number">0</span>；</span><br><span class="line">计数器取值为<span class="number">0</span>也就意味着当前没有线程来进行获取这把锁了；</span><br><span class="line">也就是相当于线程A将锁还回去了；</span><br><span class="line">那么此时其他线程就可以去进行竞争获取得到该锁进入同步代码块当中来；</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实也可以不用两个synchronized同步代码块嵌套；<br>可以放到两个不同的方法也可以完成；</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">MyThread</span> <span class="symbol">extends</span> <span class="symbol">Thread</span>&#123;</span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> run()&#123;</span><br><span class="line">    synchronized(MyThread.<span class="keyword">class</span>)&#123;</span><br><span class="line">      System.<span class="keyword">out</span>.println(getName() + <span class="string">"进入了同步代码块1"</span>);</span><br><span class="line"></span><br><span class="line">      test01();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> test01()&#123;</span><br><span class="line">    synchronized(MyThread.<span class="keyword">class</span>)&#123;</span><br><span class="line">         System.<span class="keyword">out</span>.println(getName() + <span class="string">"进入了同步代码块2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment">// 再次运行，线程依旧可以重入拿到锁两次；</span></span><br><span class="line">结果:</span><br><span class="line">Thread<span class="number">-0</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread<span class="number">-0</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">Thread<span class="number">-1</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread<span class="number">-1</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">-----------------------------------------</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外不仅是放到同一个类的方法可以实现，放到不同类的方法也可以实现；</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：演示synchronized可重入</span></span><br><span class="line"><span class="comment">    1. 自定义一个线程类</span></span><br><span class="line"><span class="comment">    2. 在线程类的run方法中使用 嵌套的代码同步块</span></span><br><span class="line"><span class="comment">    3. 使用两个线程来执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123;</span><br><span class="line">      new MyThread().start();</span><br><span class="line">      new MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> test01()&#123;</span><br><span class="line">      synchronized(MyThread.<span class="keyword">class</span>)&#123;</span><br><span class="line">          String name = Thread.currentThread.getName();</span><br><span class="line">          System.<span class="keyword">out</span>.println(name + <span class="string">"进入了同步代码块2"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 自定义一个线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">MyThread</span> <span class="symbol">extends</span> <span class="symbol">Thread</span>&#123;</span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> run()&#123;</span><br><span class="line">    synchronized(MyThread.<span class="keyword">class</span>)&#123;</span><br><span class="line">      System.<span class="keyword">out</span>.println(getName() + <span class="string">"进入了同步代码块1"</span>);</span><br><span class="line"></span><br><span class="line">      Demo01.test01();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment">// 再次运行，线程依旧可以重入拿到锁两次；</span></span><br><span class="line">结果:</span><br><span class="line">Thread<span class="number">-0</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread<span class="number">-0</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">Thread<span class="number">-1</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread<span class="number">-1</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">-----------------------------------------</span><br></pre></td></tr></table></figure>

<p>由此说明了synchronized的可重入特性与调用哪一个对象的哪一个方法无关；<br>主要是看线程，看锁；</p>
<h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><p>synchronized的锁对象中有一个计数器（recursions变量）会记录线程获得几次锁；<br>加锁次数 计数器（recursions 变量）</p>
<h3 id="可重入的好处"><a href="#可重入的好处" class="headerlink" title="可重入的好处"></a>可重入的好处</h3><ol>
<li>可以避免死锁</li>
<li>更好的封装代码</li>
</ol>
<p>依然是上述存在有两个同步代码块嵌套的代码；<br>即如果一个线程A进入了一个同步代码块当中去了；<br>那么假设synchronized没有可重入特性；<br>那么就会导致无法再次进入同步代码块当中；<br>那么这个时候就会卡在一个地方；<br>这个地方即为进入到synchronized同步代码块1之后，<br>打印执行完成 线程名+“进入了同步代码块1”之后；<br>没有办法进入下一句代码，即下一个同步代码块2synchronized中；<br>从而无法结束该流程也没有办法释放锁；<br>而其他线程也由于无法获取得到锁从而无法进入同步代码块1只能够在同步代码块1外层进行等待；<br>也就造成了死锁的状态；就相当于是线程A被困在同步代码块1当中了；<br>那么有了synchronized的可重入特性就可以避免死锁；</p>
<p>因为可以在同步代码块1当中调用其他方法，即比如说上述代码中的Demo01.test01();而Demo01.test01()中也存在有同步代码块，那么也就方便了使用方法来进行封装代码；</p>
<h3 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h3><p>synchronized是可重入锁；内部锁对象中会有一个计数器记录线程获取了几次锁了；在执行完同步代码块时，计数器的数量会-1，直到计数器的数量为0，就释放这个锁。</p>
<p>什么是可重入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指的是 同一个线程的 可以 多次 获得 同一把锁</span><br></pre></td></tr></table></figure>

<p>可重入的原理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加锁次数计数器。（recursions变量）</span><br></pre></td></tr></table></figure>

<h2 id="synchronized的不可中断性"><a href="#synchronized的不可中断性" class="headerlink" title="synchronized的不可中断性"></a>synchronized的不可中断性</h2><h3 id="目标-10"><a href="#目标-10" class="headerlink" title="目标"></a>目标</h3><p>了解什么是不可中断<br>学习<strong>synchronized</strong>的<strong>不可中断特性</strong>；<br>学习<strong>Lock</strong>的<strong>可中断特性</strong>；</p>
<h3 id="什么是不可中断"><a href="#什么是不可中断" class="headerlink" title="什么是不可中断"></a>什么是不可中断</h3><p>一旦这个锁 被别人 获得了，如果里另一个锁想获得锁，只能等待或者阻塞，直到别的线程释放这个锁，如果别人永远不释放锁，这个线程只能永远等下去，很执着！<br>（一个线程获得锁后，另一个线程想要锁，必须处于阻塞或等待状态；如果第一个线程不释放锁，第二个线程会一直处于阻塞或等待状态，在阻塞或者等待过程中，不可被中断，将一直等待或阻塞；）</p>
<h3 id="synchronized-不可中断演示"><a href="#synchronized-不可中断演示" class="headerlink" title="synchronized 不可中断演示"></a>synchronized 不可中断演示</h3><p>synchronized 是不可中断，处于阻塞状态的线程会一直等待锁。</p>
<p>(当一个线程进入一个同步代码块，那么另外一个线程只能在外面等待，这个处于等待的线程将会一直等待，不会中断，所以就叫做不可中断)</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Demo02_Uninterruptible&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span> o1 = <span class="keyword">new</span> <span class="keyword">Object</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    Runnable runnable =  () - &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>( <span class="number">01</span> )&#123;</span><br><span class="line">        <span class="keyword">String</span> name = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(name + <span class="string">"start"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(name + <span class="string">"interrupted"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>演示synchronized的不可中断特性</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------</span><br><span class="line">package com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：演示synchronized不可中断</span></span><br><span class="line"><span class="comment">    1. 定义一个Runnable</span></span><br><span class="line"><span class="comment">    2. 在Runnable定义同步代码块</span></span><br><span class="line"><span class="comment">    3. 先开启一个线程来执行同步代码块，保证不退出同步代码块</span></span><br><span class="line"><span class="comment">    4. 后开启一个线程来执行同步代码块（阻塞状态）</span></span><br><span class="line"><span class="comment">    5. 停止第二个线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="keyword">class</span> Demo02_Uninterruptible&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> static Object obj = <span class="keyword">new</span> <span class="constructor">Object()</span>;<span class="comment">//定义锁对象</span></span><br><span class="line"></span><br><span class="line">  public static void main(String<span class="literal">[]</span> args)&#123;</span><br><span class="line">      <span class="comment">// 1. 定义一个Runnable</span></span><br><span class="line">      Runnable run = <span class="literal">()</span>-&gt;&#123;</span><br><span class="line">        <span class="comment">// 2. 在Runnable定义同步代码块；</span></span><br><span class="line">        <span class="comment">// 同步代码块需要一个锁对象；</span></span><br><span class="line">        synchronized(obj)&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 进行打印是哪一个线程进入的同步代码块</span></span><br><span class="line">          String name = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>;</span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(name + <span class="string">"进入同步代码块"</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 需要进行保证不进行退出同步代码块；</span></span><br><span class="line">          <span class="comment">// 所以让此线程进行沉睡sleep</span></span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">888888</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 先开启一个线程来执行同步代码块</span></span><br><span class="line">      Thread t1 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">run</span>)</span>;</span><br><span class="line">      t1.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 沉睡一秒钟；</span></span><br><span class="line">      <span class="comment">// 保证第一个线程先去执行同步代码块之后再来创建第二个线程；</span></span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      4. 后开启一个线程来执行同步代码块（阻塞状态）</span></span><br><span class="line"><span class="comment">      到时候第二个线程去执行同步代码块的时候，</span></span><br><span class="line"><span class="comment">      锁已经被t1线程锁获取得到了；</span></span><br><span class="line"><span class="comment">      所以线程t2是无法获取得到Object obj对象锁的；</span></span><br><span class="line"><span class="comment">      那么也就将会在同步代码块外处于阻塞状态。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      Thread t2 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">run</span>)</span>;</span><br><span class="line">      t2.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 5. 停止第二个线程；</span></span><br><span class="line"><span class="comment">      观察此线程t2能够被中断；</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"停止线程前"</span>);</span><br><span class="line">      t2.interrupt<span class="literal">()</span>;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"停止线程后"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最后得到两个线程的执行状态</span></span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t1.get<span class="constructor">State()</span>);</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t2.get<span class="constructor">State()</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line">运行效果：</span><br><span class="line">(Run显示红灯即没有停止运行依然在继续)</span><br><span class="line">Thread-<span class="number">0</span>进入同步代码块</span><br><span class="line">停止线程前</span><br><span class="line">停止线程后</span><br><span class="line">TIMED_WAITING</span><br><span class="line">BLOCKED</span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">通过interrupt<span class="literal">()</span>方法给t2线程进行强行中断；</span><br><span class="line">最后进行打印t2的状态及State发现状态依然为BLOCKED；</span><br><span class="line">即线程不可中断；</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">synchronized的不可中断性具体分析流程</span><br><span class="line">红色的箭头表示主线程；主线程从main<span class="literal">()</span>方法开始执行；</span><br><span class="line">然后执行到步骤<span class="number">3</span>（<span class="number">3.</span> 先开启一个线程来执行同步代码块）启动第一个线程t1；</span><br><span class="line">那么再画一个箭头代表启动的这第一个线程t1，用线程A表示；</span><br><span class="line">那么线程A启动之后就会去执行Runnable run中的所重写的run方法；</span><br><span class="line">那么线程A第一次执行同步代码块；获取得到对象锁Object obj；</span><br><span class="line">然后进入同步代码块中打印 线程名称+“进入同步代码块”；</span><br><span class="line">继续往下进行执行就会使得线程A进行入沉睡状态；</span><br><span class="line">那么此时CPU再切换到另外一个线程；即主线程继续往下执行；</span><br><span class="line">当主线程沉睡一秒之后，接下来又会启动一个线程即t2，用线程B表示；</span><br><span class="line">线程B启动之后也会来进行执行Runnable当中重写的run<span class="literal">()</span>方法；</span><br><span class="line">但是由于在CPU切换之前线程A并没有释放锁；</span><br><span class="line">即第一个线程，即线程A由于沉睡时间过长；没有办法释放锁；</span><br><span class="line">所以导致线程B无法获取得到锁；</span><br><span class="line">从而只能在同步代码块外侧进行等待锁，处于阻塞状态；</span><br><span class="line">那么此时CPU再次切换到主线程，主线程继续往下进行执行；</span><br><span class="line">进行打印输出“停止线程前”；后继续往下执行；</span><br><span class="line">准备强行将等待锁对象的线程B进行停止掉，即使用了interrupt<span class="literal">()</span>方法（但是停不掉；就是因为synchronized是不可中断的；这个处于阻塞等待的线程是无法被中断的；这个线程会一直处于等待锁状态即不可被中断）；</span><br><span class="line">主线程继续往下执行输出打印“停止线程后”；</span><br><span class="line">最后打印线程A与线程B这两个线程的状态；</span><br><span class="line">线程A由于执行了<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">888888</span>);所以导致线程A的状态处于TIMED_WAITING；</span><br><span class="line">线程B由于synchronized的不可中断性所以一直在同步代码块外侧进行等待获取锁处于等待阻塞状态，所以其状态为BLOCKED；不可被中断；</span><br><span class="line"></span><br><span class="line">至此，可以观察到的是synchronized是不可被中断的；</span><br><span class="line">它会导致没有获取得到锁的线程一直在同步代码块外侧一直处于一个等待阻塞获取锁的一个状态；</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantLock可中断演示"><a href="#ReentrantLock可中断演示" class="headerlink" title="ReentrantLock可中断演示"></a>ReentrantLock可中断演示</h3><p>ReentrantLock可中断</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.<span class="keyword">Lock</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Demo03_INterruptible&#123;</span><br><span class="line">    private static final <span class="keyword">Lock</span> o1 = <span class="built_in">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws InterruptedException&#123;</span><br><span class="line">      Runnable runnable = () -&gt; &#123;</span><br><span class="line">        String <span class="type">name</span> =  Thread.currentThread().getName();</span><br><span class="line">        <span class="type">boolean</span> isLock = <span class="keyword">false</span>;</span><br><span class="line">        try&#123;</span><br><span class="line">            isLock = o1.tryLock( <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">              <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + "lock");</span><br><span class="line">              Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">          <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + "interrupted");</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">              o1.unlock();</span><br><span class="line">              <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + "unlock");</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + "指定时间内没有得到锁，中断，不等了，可以接着做其他事情。");</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>演示 ReentrantLock 的不可中断特性</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：</span></span><br><span class="line"><span class="comment">    演示 Lock不可中断特性</span></span><br><span class="line"><span class="comment">    Lock具有两种特性（一种是可中断；另外一种是不可中断；）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="keyword">class</span> Demo03_Interruptible&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在类的成员变量位置来进行创建一个Lock对象</span></span><br><span class="line">  <span class="keyword">private</span> static Lock lock = <span class="keyword">new</span> <span class="constructor">ReentrantLock()</span>;</span><br><span class="line"></span><br><span class="line">  public static void main(String<span class="literal">[]</span> args)throws InterruptedException&#123;</span><br><span class="line">    test01<span class="literal">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 演示 Lock 不可中断</span></span><br><span class="line">  public static void test01<span class="literal">()</span>&#123;</span><br><span class="line">    Runnable run = <span class="literal">()</span>-&gt;&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        这种方式是属于不可中断的；</span></span><br><span class="line"><span class="comment">        可以看到的是:lock() void</span></span><br><span class="line"><span class="comment">        即该方法是没有返回值的；</span></span><br><span class="line"><span class="comment">        那么这种情况就属于不可中断；</span></span><br><span class="line"><span class="comment">        它也会一直等待锁；</span></span><br><span class="line"><span class="comment">        另外获取锁之后一定要记得unlock()；</span></span><br><span class="line"><span class="comment">        那么将unlock()操作放入到finally块当中进行执行；</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      String name =<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        lock.lock<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">//获取线程的名字</span></span><br><span class="line">        <span class="comment">//打印当前进入run()中的线程名称</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(name + <span class="string">"获得锁，进入锁执行"</span>);</span><br><span class="line">        <span class="comment">//加一个睡眠保证该线程一直在里面进行执行不退出</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">888888</span>);</span><br><span class="line"></span><br><span class="line">      &#125;catch(InterruptedException e)&#123;</span><br><span class="line">          e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">      &#125;finally&#123;</span><br><span class="line">        <span class="comment">//同样unlock也是没有返回值的；void</span></span><br><span class="line">        lock.unlock<span class="literal">()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(name + <span class="string">"释放锁"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">run</span>)</span>;</span><br><span class="line">    t1.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让主线程沉睡一秒；</span></span><br><span class="line">    <span class="comment">//让第一个线程t1启动之后去进行执行Runnable当中的所实现的run()</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续创建第二个线程</span></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">run</span>)</span>;</span><br><span class="line">    t2.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//终止一下t2线程看是否能够进行终止；</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"终止t2线程前"</span>);</span><br><span class="line">    t2.interrupt<span class="literal">()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"终止t2线程后"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//让主线程沉睡一秒</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取两个线程的状态</span></span><br><span class="line">    <span class="comment">//第二个线程t2是后来的即在第一个线程t1创建并启动之后以及主线程沉睡了1秒之后才创建的第二个线程t2；</span></span><br><span class="line">    <span class="comment">//即第一个线程t1已经获取得到锁了；</span></span><br><span class="line">    <span class="comment">//由于第一个线程t1在Runnable所实现的run()方法当中进行了长时间的沉睡又没有办法释放锁；</span></span><br><span class="line">    <span class="comment">//所导致第二个线程，即线程t2只能够在同步代码块外进行阻塞等待获取锁；</span></span><br><span class="line">    <span class="comment">//看第二个线程t2是否能够被中断以及观察这两个线程的状态；</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t1.get<span class="constructor">State()</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t2.get<span class="constructor">State()</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line">运行效果：</span><br><span class="line">(Run显示红灯即没有停止运行依然在继续)</span><br><span class="line">Thread-<span class="number">0</span>进入同步代码块</span><br><span class="line">停止t2线程前</span><br><span class="line">停止t2线程后</span><br><span class="line">TIMED_WAITING</span><br><span class="line">WAITING</span><br><span class="line">--------------------------------------------------</span><br><span class="line">那么通过运行结果可以看出t2.interrupt<span class="literal">()</span>是没有执行成功的；</span><br><span class="line">因为t2进行打印其线程状态发现依旧处于等待状态即WAITING；</span><br><span class="line">也就是说t2线程没有抢到锁所以导致一直处于等待状态；</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">主线程从main<span class="literal">()</span>方法开始进行执行；</span><br><span class="line">即执行test01<span class="literal">()</span>方法；</span><br><span class="line">创建一个Runnable，Runnable当中实现run<span class="literal">()</span>方法；</span><br><span class="line">创建并启动一个线程t1；去进行执行Runnable run当中的run<span class="literal">()</span>方法；</span><br><span class="line">即线程t1执行run<span class="literal">()</span>当中的内容；</span><br><span class="line">此时还没有其他线程获取得到lock.lock<span class="literal">()</span>当中的锁；</span><br><span class="line">所以线程t1此时可以获取得到锁；</span><br><span class="line">即进入同步代码块中进行打印 <span class="string">"Thread-0获得锁，进入锁执行"</span>后进入线程t1长时间睡眠且并未释放锁；</span><br><span class="line">那么此时CPU切换到主线程，主线程继续向下执行；</span><br><span class="line">主线程沉睡一秒之后；又进行创建并启动第二个线程t2；</span><br><span class="line">那么第二个线程t2也会去进行执行Runnable run当中的run<span class="literal">()</span>方法；</span><br><span class="line">但是此时第二个线程t2是无法得到锁的；</span><br><span class="line">由于线程t1并未释放锁而是出于长时间的睡眠状态；</span><br><span class="line">所以导致线程t2无法获取得到锁从而导致在同步代码块外侧进行等待获取锁；</span><br><span class="line">所以线程t2会处于一种叫做WAITING的状态；</span><br><span class="line">那么这个时候CPU又切换到主线程当中来；</span><br><span class="line">则主线程继续往下进行执行准备去强行停止线程t2但是停不掉</span><br><span class="line">（lock.lock<span class="literal">()</span>也是属于不可中断的；）；</span><br><span class="line">打印“停止t2线程前”以及继续往下执行对线程t2进行中断以及打印“停止t2线程后”；</span><br><span class="line"></span><br><span class="line">继续向下执行主线程又一次进行沉睡一秒后；</span><br><span class="line">打印线程t1与线程t2的状态；</span><br><span class="line">那么这个时候就会发现线程t2处于一种WAITING的状态；</span><br><span class="line">即也说明了<span class="module-access"><span class="module"><span class="identifier">ReentrantLock</span>.</span></span>lock<span class="literal">()</span>是不可被中断的；</span><br><span class="line">即lock.lock<span class="literal">()</span>方法则导致在同步代码块外侧的线程状态是不可中断的；</span><br><span class="line">但是ReentrantLock还有一个方法叫做<span class="keyword">try</span><span class="constructor">Lock()</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>演示 ReentrantLock的可中断特性</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：演示Lock的可中断特性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03_Interruptible</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws InterruptedException</span>&#123;</span><br><span class="line">    test02();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 演示 Lock 可中断</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> throws InterruptedException</span>&#123;</span><br><span class="line">    Runnable <span class="built_in">run</span> = ()-&gt;&#123;</span><br><span class="line">      <span class="keyword">String</span> name = Thread.currentThread().getName();</span><br><span class="line">      <span class="keyword">boolean</span> b = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        tryLock(long time, TimeUnit unit) 返回boolean类型</span></span><br><span class="line"><span class="comment">        tryLock会进行尝试获取锁，</span></span><br><span class="line"><span class="comment">        如果能够获得锁则返回true；</span></span><br><span class="line"><span class="comment">        反之不能获得锁则返回false；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        到时候如果是第二个线程要来进行获取锁来进行抢锁；</span></span><br><span class="line"><span class="comment">        那么这个时候如果三秒内没有获取得到锁；</span></span><br><span class="line"><span class="comment">        那么就会进行中断；从而进入else块中做其他操作；</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//尝试3秒，时间单位为秒；</span></span><br><span class="line">        <span class="comment">//由于单位是秒所以直接输入3即可而不是3000</span></span><br><span class="line">        <span class="comment">//b = lock.tryLock(3000, TimeUnit.SECONDS);</span></span><br><span class="line">        b = lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//说明尝试获取得到了锁；则进入if块当中</span></span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">          System.out.<span class="built_in">println</span>(name + <span class="string">"获得锁，进入锁执行"</span>);</span><br><span class="line">          Thread.sleep(<span class="number">888888</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//那么else则说明没有获取得到锁；</span></span><br><span class="line">          <span class="comment">//则可以让其做其他操作从而也就证明了Lock.tryLock()是可中断的；</span></span><br><span class="line">          System.out.<span class="built_in">println</span>(name + <span class="string">"在指定时间内没有获取得到锁则做其他操作"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;finally&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        此时的unlock()需要进行注意；</span></span><br><span class="line"><span class="comment">        如果说CPU当前切换到的当前线程没有获取得到锁则并不需要进行unlock()操作；</span></span><br><span class="line"><span class="comment">        如果CPU当前切换到的当前线程获取得到了锁并执行完成同步代码块当中的内容所以此时finally当中是需要进行执行unlock()操作的；</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(b)&#123;<span class="comment">//得到了锁才进行释放锁操作</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.<span class="built_in">println</span>(name + <span class="string">"释放锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在后续的代码中让两个线程进行启动起来即可其余代码可以不要；</span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="built_in">run</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="built_in">run</span>);</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    System.out.println("停止t2线程前");</span></span><br><span class="line"><span class="comment">    t2.interrupt();</span></span><br><span class="line"><span class="comment">    System.out.println("停止t2线程后");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">    System.out.println(t1.getState());</span></span><br><span class="line"><span class="comment">    System.out.println(t2.getState());</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">代码执行效果：</span><br><span class="line">Thread<span class="number">-0</span>获得锁，进入锁执行</span><br><span class="line">Thread<span class="number">-1</span>在指定时间没有得到锁做其他操作</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">详细分析一下ReentrantLock可中断性流程：</span><br><span class="line">先画一个红色的箭头来表示主线程；然后来分析整个流程；</span><br><span class="line">程序由main()方法开始进行执行；然后执行test02()方法；</span><br><span class="line">创建一个Runnable并实现其<span class="built_in">run</span>()方法；</span><br><span class="line">创建Runnable完成之后；创建第一个线程t1并启动去执行Runnable当中的<span class="built_in">run</span>()方法即执行<span class="built_in">run</span>()方法内部的内容；</span><br><span class="line">而第一个线程t1是可以进行获取得到锁的；即lock.tryLock(<span class="number">3</span>,TimeUnit.SECONDS)时；则进入代码块<span class="keyword">if</span>(b)当中并打印第一句话“Thread<span class="number">-0</span>获得锁，进入锁执行”；那么接着线程t1就一直睡眠了Thread.sleep(<span class="number">888888</span>);</span><br><span class="line">那么此时CPU又切换会主线程；接着往下走沉睡一秒之后进行创建t2线程并启动t2线程；</span><br><span class="line">那么线程t2此时也会来进行执行Runnable当中的<span class="built_in">run</span>()方法；</span><br><span class="line">那么第二个线程t2进来时执行lock.tryLock时会发现锁已经被t1线程获取得到了；且t1线程并没有释放锁而且处于长时间的睡眠状态；</span><br><span class="line">那么这个时候t2线程会进行尝试获取锁<span class="number">3</span>秒；</span><br><span class="line"><span class="number">3</span>秒过后如果依旧无法获取得到锁（即线程t1三秒后依旧没有进行释放锁）那么线程t2则将中断且不会继续等待获取锁，</span><br><span class="line">即tryLock则返回<span class="literal">false</span>；</span><br><span class="line">返回<span class="literal">false</span>则将会执行<span class="keyword">else</span>块当中的代码即打印输出“Thread<span class="number">-1</span>在指定时间没有得到锁做其他操作”做其他操作去了；</span><br><span class="line">那么此时可以看到的是 tryLock的话则会等待指定的时间，</span><br><span class="line">在指定的时间内去尝试获取锁；</span><br><span class="line">也就是说在指定的时间内等待上一个获取锁的线程进行释放锁；</span><br><span class="line">如果说在指定的时间内上一个获取得到锁的线程执行完成并释放了锁那么则当前该线程就在指定的时间结束后会返回<span class="literal">true</span>表示获取得到锁；</span><br><span class="line">如果上一个获取得到锁的线程在指定的时间内并没有释放锁那么则当前等待的线程在指定等待的时间结束后；则进行中断不会再去等待获取锁；</span><br><span class="line">直接返回<span class="literal">false</span>表示没有获取得到锁，该为去做其他的操作；</span><br></pre></td></tr></table></figure>

<h3 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h3><p>不可中断是指：当一个线程获得锁之后，另一个线程一致处于阻塞或等待状态，前一个线程不释放锁，后一个线程会一直阻塞或者等待，并且在阻塞或等待的过程中它是不可被中断的，它会一直等待或者被阻塞；  </p>
<p><strong>synchronized</strong>是属于<strong>不可被中断</strong>的；<br><strong>Lock（ReentrantLock）</strong>的<strong>lock</strong>方法是<strong>不可被中断</strong>的；<br><strong>Lock（ReentrantLock）</strong>的<strong>tryLock</strong>方法是<strong>可中断</strong>的；</p>
<h2 id="javap反汇编学习synchronized的原理"><a href="#javap反汇编学习synchronized的原理" class="headerlink" title="javap反汇编学习synchronized的原理"></a>javap反汇编学习synchronized的原理</h2><p>第五章：synchronized原理</p>
<p>（较难的一块，由浅入深，涉及<strong>synchronized的原理</strong>讲解；）</p>
<blockquote>
<ul>
<li>首先会通过<strong>javap反汇编</strong>的方式，</li>
<li><em>synchronized*</em>其实被转换成了<strong>两条字节码指令</strong>，<br>分别是<strong>monitorenter</strong>以及<strong>monitorexit</strong>；<br>然后会通过Oracle的官方文档即<strong>JVM规范</strong>来对<strong>字节码指令</strong> <strong>monitorenter</strong>以及<strong>monitorexit</strong>的一个简单的介绍，<br>介绍这<strong>两个指令</strong>时如何来进行<strong>加锁和解锁</strong>的，<br>通过<strong>字节码指令</strong>来介绍<strong>synchronized</strong>属于比较深入，<br>但是有并不是特别的深入，<br>那么为了更加深层次的理解<strong>synchronized的底层机制</strong>，<br>将会深入<strong>JVM的源码</strong>来进行源码分析。</li>
<li><strong>JVM底层</strong>是使用<strong>c、c++</strong>所编写的；</li>
<li><em>synchronized*</em>是一个<strong>关键字</strong>，</li>
<li><em>底层*</em>由<strong>c、c++</strong>来编写。<br>会进行分析这一块的代码；<br>到时候就可以清晰的知道<strong>synchronized</strong>的一个清晰的<strong>底层结构</strong>以及如何<strong>获得锁</strong>、<strong>等待锁</strong>以及如何<strong>释放锁</strong>的；</li>
<li>另外还会去介绍<strong>synchronized</strong>为什么是一个<strong>重量级的锁</strong>，<br>以及<strong>synchronized</strong>为什么会<strong>开销比较大</strong>；<br>因为<strong>synchronized</strong>是一个<strong>重量级的锁</strong>，<br>所以其<strong>效率不高</strong>，<br>那么在第六章就会来进行介绍<strong>JDK6</strong>当中对<strong>synchronized</strong>的一个<strong>优化措施</strong>，<strong>synchronized</strong>的涉及到一个叫做<strong>CAS操作</strong>，<br>那么就会先去进行介绍<strong>CAS</strong>的一个<strong>原理</strong>，<br>那么其实<strong>CAS</strong>也属于一个<strong>原子操作</strong>，<br>可以将<strong>CAS操作</strong>看做是一个<strong>轻量级的synchronized</strong>，<br>它能够<strong>保证变量修改</strong>的这样一个<strong>原子操作</strong>；<br>介绍了<strong>CAS</strong>之后就将会介绍<strong>锁升级</strong>的一个<strong>过程</strong>，</li>
<li><em>锁升级*</em>是由 <strong>无锁-→偏向锁-→轻量级锁-→重量级锁</strong> ；</li>
<li>由浅入深的来进行学习，那么存在这么多锁就会存在一个问题；<br>如何来得知是<strong>属于哪一种锁</strong>，<br>那么这个时候会先进行了解<strong>JAVA对象的布局</strong>；<br>以前对java对象的理解是这样的-→java对象是存在在堆中，然后有一块空间可以来进行存放其对象当中的成员变量；<br>那么介绍的<strong>java对象布局</strong>，其当中不仅会有<strong>java对象的实例数据</strong>还会有<strong>对象头</strong>以及一些<strong>对齐数据</strong>；<br>那么<strong>锁升级过程</strong>中的这些<strong>锁</strong>是<strong>存在于对象头当中的Mark Word</strong>当中的，<br>到时候通过c++的源码来进行详细分析；</li>
<li>另外<strong>JDK6</strong>还对<strong>synchronized</strong>做了一些<strong>锁消除和锁粗化的优化</strong>操作，<br>经过对<strong>synchronized的原理</strong>的学习之后就可以总结出写代码应该如何对<strong>synchronized优化</strong>，写出更<strong>高效</strong>更<strong>好</strong>的代码；<br>那么会从以下几个方面进行来介绍；<br>第一个：<strong>减少synchronized的范围</strong>；<br>第二个：<strong>降低synchronized锁的粒度</strong><br>（这当中有一个经典的例子就是<strong>HashTable</strong>，<strong>HashTable</strong>会<strong>锁</strong>住所有的<strong>数据</strong>；而后又推出了一个叫做<strong>ConcurrentHashMap</strong>，那么<strong>ConcurrentHashMap</strong> <strong>只</strong>会<strong>锁</strong>住<strong>一个桶</strong>当中的<strong>数据</strong>）；<br>第三个：通过<strong>读写分离</strong>的方式来进行<strong>提高效率</strong>；<br>以上就是<strong>synchronized</strong>课程的主要内容；</li>
</ul>
</blockquote>
<p>javap 反汇编</p>
<p>synchronized原理的学习；<br>首先通过javap反汇编的方式来进行学习synchronized原理；<br>接着再通过JVM源码再来深入的学习synchronized原理；</p>
<h3 id="目标-11"><a href="#目标-11" class="headerlink" title="目标"></a>目标</h3><p>通过 <strong>javap 反汇编</strong> 学习 synchronized的原理</p>
<p>编写一个简单的synchronized代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo04_synchronized_monitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span></span>&#123;</span><br><span class="line">  <span class="comment">//依赖的锁对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//synchronized同步代码块；且在代码块当中做了简单的打印操作；</span></span><br><span class="line">      <span class="comment">//重点是看synchronized在反汇编之后形成的字节码指令</span></span><br><span class="line">      <span class="keyword">synchronized</span>( obj )&#123;</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//编写了一个synchronized修饰的方法</span></span><br><span class="line">  <span class="comment">//synchronized修饰代码块与synchronized修饰方法反汇编之后的结果是不太一样的；</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"a"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="comment">//代码写好之后让idea进行一个编译得到字节码文件；</span></span><br><span class="line">  <span class="comment">//编译好的字节码文件目录：工程名/target/classes/xxx/demo04_synchronized_monitor/Demo01.class</span></span><br></pre></td></tr></table></figure>

<p>要看 synchronized的原理，但是 synchronized是一个关键字，看不到源码。<br>可以将class文件进行反汇编。<br>JDK自带的一个工具: javap，对字节码进行反汇编，查看字节码指令。<br>在DOS命令行或者是Windows PowerShell等其他命令行输入(对字节码文件进行反汇编)：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3666<span class="symbol">\I</span>deaProjects<span class="symbol">\X</span>xx<span class="symbol">\S</span>ynchronized<span class="symbol">\t</span>arget<span class="symbol">\c</span>lasses<span class="symbol">\c</span>om<span class="symbol">\x</span>xx<span class="symbol">\d</span>emo04_synchronized_monitor<span class="symbol">\j</span>avap -p -v Demo01.class</span><br><span class="line"># -p 是显示包括所有的私有的</span><br><span class="line"># -v 就是详细的来进行显示</span><br></pre></td></tr></table></figure>

<blockquote>
<p>反汇编之后得到的字节码指令如下所示：</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">      <span class="attr">LineNumberTable:</span></span><br><span class="line">          <span class="attr">line 3:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">LocalVariableTable:</span></span><br><span class="line">          <span class="string">Start</span>     <span class="string">Length</span>      <span class="string">Slot</span>     <span class="string">Name</span>     <span class="string">Signature</span></span><br><span class="line">              <span class="number">0</span>          <span class="number">5</span>         <span class="number">0</span>     <span class="string">this</span>      <span class="string">Lcom/xxx/demo04_synchronized_monitor/Demo01;</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">public</span> <span class="string">static</span> <span class="string">void</span> <span class="string">main(java.lang.String[]);</span></span><br><span class="line">    <span class="attr">descriptor:</span> <span class="string">([Ljava/lang/String;)V</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">ACC_PUBLIC,</span> <span class="string">ACC_STATIC</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="string">stack=2,</span>  <span class="string">locals=3;</span>   <span class="string">args_size=1</span></span><br><span class="line">          <span class="attr">0:</span> <span class="string">getstatic</span>           <span class="comment">#2        // Field obj:Ljava/lang/Object;</span></span><br><span class="line">          <span class="attr">3:</span> <span class="string">dup</span></span><br><span class="line">          <span class="attr">4:</span> <span class="string">astore_1</span></span><br><span class="line">          <span class="attr">5:</span> <span class="string">monitorenter</span></span><br><span class="line">          <span class="attr">6:</span> <span class="string">getstatic</span>           <span class="comment">#3        // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">          <span class="attr">9:</span> <span class="string">1dc</span>                 <span class="comment">#4        // String 1</span></span><br><span class="line">         <span class="attr">11:</span> <span class="string">invokevirtual</span>       <span class="comment">#5        // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="attr">14:</span> <span class="string">aload_1</span></span><br><span class="line">         <span class="attr">15:</span> <span class="string">monitorexit</span></span><br><span class="line">         <span class="attr">16:</span> <span class="string">goto</span>                <span class="number">24</span></span><br><span class="line">         <span class="attr">19:</span> <span class="string">astore_2</span></span><br><span class="line">         <span class="attr">20:</span> <span class="string">aload_1</span></span><br><span class="line">         <span class="attr">21:</span> <span class="string">monitorexit</span></span><br><span class="line">         <span class="attr">22:</span> <span class="string">aload_2</span></span><br><span class="line">         <span class="attr">23:</span> <span class="string">athrow</span></span><br><span class="line">         <span class="attr">24:</span> <span class="string">return</span></span><br><span class="line">      <span class="attr">Exception table:</span></span><br><span class="line">          <span class="string">from</span>     <span class="string">to</span>    <span class="string">target</span>   <span class="string">type</span></span><br><span class="line">             <span class="number">6</span>      <span class="number">16</span>       <span class="number">19</span>    <span class="string">any</span></span><br><span class="line">            <span class="number">19</span>      <span class="number">22</span>       <span class="number">19</span>    <span class="string">any</span></span><br><span class="line">      <span class="attr">LineNumberTable:</span></span><br><span class="line">        <span class="attr">line 7:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">line 8:</span> <span class="number">6</span></span><br><span class="line">        <span class="attr">line 9:</span> <span class="number">14</span></span><br><span class="line">        <span class="attr">line 10:</span> <span class="number">24</span></span><br><span class="line">      <span class="attr">LocalVariableTable:</span></span><br><span class="line">        <span class="string">Start</span>      <span class="string">Length</span>     <span class="string">Slot</span>   <span class="string">Name</span>    <span class="string">Signature</span></span><br><span class="line">            <span class="number">0</span>          <span class="number">25</span>        <span class="number">0</span>   <span class="string">args</span>    <span class="string">[Ljava/lang/String;</span></span><br><span class="line">      <span class="attr">StackMapTable:</span> <span class="string">number_of_entries</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line">        <span class="string">frame_type</span> <span class="string">=</span> <span class="number">255</span> <span class="string">/*</span> <span class="string">full_frame</span> <span class="string">*/</span></span><br><span class="line">          <span class="string">offset_delta</span> <span class="string">=</span> <span class="number">19</span></span><br><span class="line">          <span class="string">locals</span> <span class="string">=</span> <span class="string">[</span> <span class="string">class</span> <span class="string">"[Ljava/lang/String;"</span><span class="string">,</span> <span class="string">class</span> <span class="string">java/lang/Object</span> <span class="string">]</span></span><br><span class="line">          <span class="string">stack</span> <span class="string">=</span> <span class="string">[</span> <span class="string">class</span> <span class="string">java/lang/Throwable</span> <span class="string">]</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<p>反汇编后的效果如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">class</span> <span class="string">com.xxx.demo04_synchronized_monitor.Increment</span> <span class="string">implements</span> <span class="string">java.lang.Runnable&#123;</span></span><br><span class="line">  <span class="string">public</span> <span class="string">static</span> <span class="string">int</span> <span class="string">number;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">private</span> <span class="string">static</span> <span class="string">java.lang.Object</span> <span class="string">obj;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">com.xxx.demo04_synchronized_monitor.Increment();</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="attr">0 :</span> <span class="string">aload_0</span></span><br><span class="line">      <span class="attr">1 :</span> <span class="string">invokespecial</span>   <span class="comment">#1       // Method java/lang/Object."&lt;init&gt;":()v</span></span><br><span class="line">      <span class="attr">4 :</span> <span class="string">return</span></span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">void</span> <span class="string">run();</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="attr">0 :</span> <span class="string">iconst_0</span></span><br><span class="line">      <span class="attr">1 :</span> <span class="string">istore_1</span></span><br><span class="line">      <span class="attr">2 :</span> <span class="string">iload_1</span></span><br><span class="line">      <span class="attr">3 :</span> <span class="string">sipush</span>    <span class="number">1000</span></span><br><span class="line">      <span class="attr">6 :</span> <span class="string">if_icmpge</span> <span class="number">39</span></span><br><span class="line">      <span class="attr">9 :</span> <span class="string">getstatic</span> <span class="comment">#2           // Field obj:Ljava/lang/Object</span></span><br><span class="line">      <span class="attr">12:</span> <span class="string">dup</span></span><br><span class="line">      <span class="attr">13:</span> <span class="string">astore_2</span></span><br><span class="line">      <span class="attr">14:</span> <span class="string">monitorenter</span></span><br><span class="line">      <span class="attr">15:</span> <span class="string">getstatic</span> <span class="comment">#3           // Field number:I</span></span><br><span class="line">      <span class="attr">18:</span> <span class="string">iconst_1</span></span><br><span class="line">      <span class="attr">19:</span> <span class="string">iadd</span></span><br><span class="line">      <span class="attr">20:</span> <span class="string">putstatic</span> <span class="comment">#3           // Field number:I</span></span><br><span class="line">      <span class="attr">23:</span> <span class="string">aload_2</span></span><br><span class="line">      <span class="attr">24:</span> <span class="string">monitorexit</span></span><br><span class="line">      <span class="attr">25:</span> <span class="string">goto</span>      <span class="number">33</span></span><br><span class="line">      <span class="attr">28:</span> <span class="string">astore_3</span></span><br><span class="line">      <span class="attr">29:</span> <span class="string">aload_2</span></span><br><span class="line">      <span class="attr">30:</span> <span class="string">monitorexit</span></span><br><span class="line">      <span class="attr">31:</span> <span class="string">aload_3</span></span><br><span class="line">      <span class="attr">32:</span> <span class="string">athrow</span></span><br><span class="line">      <span class="attr">33:</span> <span class="string">iinc</span>      <span class="number">1</span><span class="string">,</span>  <span class="number">1</span></span><br><span class="line">      <span class="attr">36:</span> <span class="string">goto</span>      <span class="number">2</span></span><br><span class="line">      <span class="attr">39:</span> <span class="string">return</span></span><br><span class="line">   <span class="attr">Exception table:</span></span><br><span class="line">        <span class="string">from</span>   <span class="string">to</span>  <span class="string">target</span> <span class="string">type</span></span><br><span class="line">          <span class="number">15</span>   <span class="number">25</span>    <span class="number">29</span>    <span class="string">any</span></span><br><span class="line">          <span class="number">28</span>   <span class="number">31</span>    <span class="number">28</span>    <span class="string">any</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">synchronized</span> <span class="string">void</span> <span class="string">test();</span></span><br><span class="line">    <span class="attr">descriptor:</span> <span class="string">()V</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">ACC_PUBLIC,</span> <span class="string">ACC_SYNCHRONIZED</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">        <span class="string">stack=2,</span>  <span class="string">locals=1,</span>  <span class="string">args_size=1</span></span><br><span class="line">            <span class="attr">0:</span> <span class="string">getstatic</span>     <span class="comment">#4              // Field</span></span><br><span class="line"><span class="attr">java/lang/System.out:Ljava/io/PrintStream:</span></span><br><span class="line">            <span class="attr">3:</span> <span class="string">ldc</span>           <span class="comment">#5              // String a</span></span><br><span class="line">            <span class="attr">5:</span> <span class="string">invokevirtual</span> <span class="comment">#6              // Method java/io/PrintStream.println:(Ljava/lang.String;)V</span></span><br><span class="line">            <span class="attr">8:</span> <span class="string">return</span></span><br><span class="line">        <span class="attr">LineNumberTable:</span></span><br><span class="line">          <span class="attr">line 16:</span> <span class="number">0</span></span><br><span class="line">          <span class="attr">line 17:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">LocalVariableTable:</span></span><br><span class="line">          <span class="string">Start</span>     <span class="string">Length</span>    <span class="string">Slot</span>  <span class="string">Name</span>  <span class="string">Signature</span></span><br><span class="line">            <span class="number">0</span>          <span class="number">9</span>       <span class="number">0</span>     <span class="string">this</span>   <span class="string">Lcom/xxx/demo04_synchronized_monitor/Increment;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">static</span> <span class="string">&#123;&#125;;</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">       <span class="attr">0:</span> <span class="string">iconst_0</span></span><br><span class="line">       <span class="attr">1:</span> <span class="string">putstatic</span>       <span class="comment">#3       // Field number:I</span></span><br><span class="line">       <span class="attr">4:</span> <span class="string">new</span>             <span class="comment">#4       // class java/lang/Object</span></span><br><span class="line">       <span class="attr">7:</span> <span class="string">dup</span></span><br><span class="line">       <span class="attr">8:</span> <span class="string">invokespecial</span>   <span class="comment">#1       // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">      <span class="attr">11:</span> <span class="string">putstatic</span>       <span class="comment">#2       // Field obj:Ljava/lang/Object</span></span><br><span class="line">      <span class="attr">14:</span> <span class="string">return</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>主要是看观看这一块的字节码指令与Demo01.java当中的代码做对比分析:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------</span><br><span class="line">  <span class="keyword">public</span> static <span class="built_in">void</span> main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>,  locals=<span class="number">3</span>;   args_size=<span class="number">1</span></span><br><span class="line">          <span class="number">0</span>: getstatic           #<span class="number">2</span>        <span class="comment">// Field obj:Ljava/lang/Object;</span></span><br><span class="line">          <span class="number">3</span>: dup</span><br><span class="line">          <span class="number">4</span>: astore_1</span><br><span class="line">          <span class="number">5</span>: monitorenter</span><br><span class="line">          <span class="number">6</span>: getstatic           #<span class="number">3</span>        <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">          <span class="number">9</span>: <span class="number">1</span>dc                 #<span class="number">4</span>        <span class="comment">// String 1</span></span><br><span class="line">         <span class="number">11</span>: invokevirtual       #<span class="number">5</span>        <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">14</span>: aload_1</span><br><span class="line">         <span class="number">15</span>: monitorexit</span><br><span class="line">         <span class="number">16</span>: goto                <span class="number">24</span></span><br><span class="line">         <span class="number">19</span>: astore_2</span><br><span class="line">         <span class="number">20</span>: aload_1</span><br><span class="line">         <span class="number">21</span>: monitorexit</span><br><span class="line">         <span class="number">22</span>: aload_2</span><br><span class="line">         <span class="number">23</span>: athrow</span><br><span class="line">         <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">          <span class="keyword">from</span>     to    target   type</span><br><span class="line">             <span class="number">6</span>      <span class="number">16</span>       <span class="number">19</span>    any</span><br><span class="line">            <span class="number">19</span>      <span class="number">22</span>       <span class="number">19</span>    any</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">首先<span class="number">0</span>: getstatic 代表的是获取得到静态的成员变量Object obj的值；</span><br><span class="line">即<span class="keyword">private</span> static Object obj = new Object();</span><br><span class="line"></span><br><span class="line">同步代码块开始的地方即synchronized(obj)&#123; 对应于字节码指令当中的<span class="number">5</span>: monitorenter指令；</span><br><span class="line">那么接着往下字节码指令当中的<span class="number">6</span>: getstatic 其实对应着java代码层中的System.<span class="keyword">out</span>.println(<span class="string">"1"</span>);该句中的<span class="keyword">out</span>变量；到时候进行执行其实是进行执行的println()方法；</span><br><span class="line">那么结束的时候就需要注意了，同步代码块synchronized结束的地方也就是synchronized(obj)&#123; 的返回花括号&#125;处，即对应着字节码指令当中的<span class="number">15</span>: monitorexit</span><br><span class="line">那么字节码指令monitorenter与monitorexit这两个字节码指令分别有什么含义呢？</span><br></pre></td></tr></table></figure>

<h3 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h3><p>首先来看一下JVM规范中对于 monitorenter 和 monitorexit 的描述：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>docs.oracle.com<span class="regexp">/javase/</span>specs<span class="regexp">/jvms/</span>se8<span class="regexp">/html/</span>jvms-<span class="number">6</span>.html<span class="comment">#jvms-6.5.monitorenter</span></span><br><span class="line"></span><br><span class="line">https:<span class="regexp">//</span>docs.oracle.com<span class="regexp">/javase/</span>specs<span class="regexp">/jvms/</span>se8<span class="regexp">/html/i</span>ndex.html</span><br></pre></td></tr></table></figure>

<p>（Oracle官方 java虚拟机规范文档；Java虚拟机有好多种Oracle公司有，IBM公司也有，淘宝也有；java虚拟机是一套规范；该文档指的就是java虚拟机的规范）  </p>
<blockquote>
<p>Each object is associlated with a monitor.<br>A monitor is locked if and only if it has an owner.<br>The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p>
</blockquote>
<ul>
<li>If the entry count of the monitor associated with objectref is zero,<br>the thread enters the monitor and sets its entry count to one.<br>The thread is then the owner of the monitor.</li>
<li>If the thread already owns the monitor associated with objectref,<br>it reenters the monitor, incrementing its entry count.</li>
<li>If another thread already owns the monitor associated with objectref,<br>the thread blocks until the monitor’s entry count is zero,<br>then tries again to gain ownership.</li>
</ul>
<p>翻译过来：<br>  每一个对象 都会和 一个监视器monitor关联。<br>  监视器被占用时会被锁住，其他线程无法来获取该monitor。<br>  （其实可以理解为这个monitor才是真正的锁）<br>  当JVM执行某个线程的某个方法内部的monitorenter时，它会尝试去获取当前对象对应的monitor的所有权。<br>  （即尝试去获取这把锁；有可能获取得到有可能获取不到）<br>  其过程如下：</p>
<ol>
<li>若monitor的进入数为0，线程可以进入 monitor，并将 monitor的进入数 置为1。 当前线程成为 monitor的 owner（所有者）。</li>
<li>若线程已拥有 monitor的所有权，允许它 重入 monitor，则进入monitor的进入数加1。</li>
<li>若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，直到monitor的进入数变为0，才能重新尝试获取monitor的所有权。</li>
</ol>
<p>monitorenter线程获取锁，宁进入同步代码块。<br>同时只能有一个线程获取锁。<br>monitorenter 插入在同步代码块的开始位置，当底代码执行到该指令时，将会尝试获取该对象monitor的所有权，即尝试获得该对象的锁。</p>
<blockquote>
<p>monitorenter流程分析</p>
</blockquote>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">分析<span class="keyword">monitor</span>流程画图说明：</span><br><span class="line">通过刚才的描述可以知道synchronized是需要传一个对象进来也就是对象锁；</span><br><span class="line">即synchronized(obj)&#123;；</span><br><span class="line">而真正的锁并非是这个传入进来的该对象obj；</span><br><span class="line">而是该对象obj会去关联一个叫做<span class="keyword">monitor</span>的东西，而这个叫做<span class="keyword">monitor</span>的东西才是真正的锁；</span><br><span class="line">而这个对象<span class="keyword">monitor</span>并非是手动式使用代码进行创建的；</span><br><span class="line">当拿到一个对象放到同步代码块的参数当中来；</span><br><span class="line">即synchronized(obj)&#123;中来的时候，JVM会去进行检查该对象obj是否有进行关联<span class="keyword">monitor</span>对象；</span><br><span class="line">如果JVM进行检测得到该对象obj没有进行关联<span class="keyword">monitor</span>对象的话那么就会去创建一个与之关联的<span class="keyword">monitor</span>对象；</span><br><span class="line">而且该<span class="keyword">monitor</span>对象还需要进行注意的是<span class="keyword">monitor</span>并不是一个java对象；</span><br><span class="line"><span class="keyword">monitor</span>而是一个C++对象；</span><br><span class="line">在<span class="keyword">monitor</span>对象当中又这么几个内容是需要注意的；</span><br><span class="line"><span class="keyword">monitor</span>当中有两个比较重要的成员变量；</span><br><span class="line">一个是owner：指的是用有锁的线程；</span><br><span class="line">另一个是recursions:指的是记录获取锁的次数；</span><br><span class="line">当JVM执行到monitorenter的时候；那么会找到该对象Object obj上的<span class="keyword">monitor</span>对象看这个Object obj所关联的<span class="keyword">monitor</span>锁对象是否被别的线程所拿走了；如果别的线程没有拿走即没有竞争走；那么当前该线程就来获取该<span class="keyword">monitor</span>锁对象；</span><br><span class="line">首先先会将<span class="keyword">monitor</span>锁对象中的成员变量owner变成当前线程；</span><br><span class="line">现在假设t1线程来执行到同步代码块synchronized(obj)&#123;；</span><br><span class="line">那么当t1线程来执行同步代码块的时候就会找到该Object obj对象所关联的<span class="keyword">monitor</span>对象；看这个所关联的<span class="keyword">monitor</span>有没有被其他的锁给获取得到；</span><br><span class="line">如何查看该<span class="keyword">monitor</span>是否有被其他线程获取得到？</span><br><span class="line">如果别的线程没有竞争得到该<span class="keyword">monitor</span>锁对象，那么该锁对象<span class="keyword">monitor</span>的owner成员变量属性就会变成当前线程t1；</span><br><span class="line">那么这也是t1线程第一次进入同步代码块当中来；</span><br><span class="line">所以<span class="keyword">monitor</span>其成员变量recursions（记录获取锁的次数，计数器）也会进行改变取值进行++操作；即当前由<span class="number">0</span>变为<span class="number">1</span>；</span><br><span class="line">接着t1线程就拥有了这把锁，即Object obj所关联的锁对象<span class="keyword">monitor</span>从而进入了同步代码块synchronized(obj)&#123;&#125;当中；</span><br><span class="line">在t1进入到同步代码块中时如果同步代码块当中依然存在有同步代码块，即嵌套的同步代码块时并且锁对象依然还是Object obj的话则；synchronized具有可重入特性；那么这个时候t1线程就会重入到嵌套同步代码块中去；重入的话就会将Object obj所关联的<span class="keyword">monitor</span>锁对象的成员变量属性取值recursions计数器的取值进行++操作；即由次数<span class="number">1</span>变为次数<span class="number">2</span>；那么也就是说出一次同步代码块计数器recursions进行--操作即次数减一操作，由<span class="number">2</span>变为<span class="number">1</span>；这种类似；</span><br><span class="line">另外当t1线程进入同步代码块时，并执行到输出打印语句“<span class="number">1</span>”时；</span><br><span class="line">此时<span class="meta">CPU</span>切换到了t2线程上；那么t2线程同时会来进行执行Runnable当中所实现的run()方法内容；</span><br><span class="line">那么t2线程也会来进行竞争获取得到这把锁；即Object obj所关联的锁对象<span class="keyword">monitor</span>；</span><br><span class="line">那么此时由于线程t1并没有进行释放锁操作，<span class="meta">CPU</span>就开始进行切换到了线程t2上来了；</span><br><span class="line">那么这个时候t2线程就会发现Object obj所关联的<span class="keyword">monitor</span>锁对象当中的成员变量属性取值为并不是当前线程t2而是线程t1；</span><br><span class="line">那么通过这个观察也就知道当前获取锁的线程是哪一个线程了；</span><br><span class="line">那么此时t2线程就会进入阻塞状态；</span><br><span class="line">那么这个就是monitorenter的原理；</span><br></pre></td></tr></table></figure>

<h4 id="monitorenter小结"><a href="#monitorenter小结" class="headerlink" title="monitorenter小结"></a>monitorenter小结</h4><p>synchronized的锁对象会关联一个monitor，<br>这个monitor不是主动进行创建的，<br>而是JVM的线程执行到这个同步代码块时，<br>会检查发现到对象没有monitor，那么此时就会创建monitor；<br>monitor内部有两个重要的成员变量；<br>owner: 拥有这把锁的线程；<br>recursions: 会记录线程拥有锁的次数；<br>当一个线程拥有monitor之后其他的线程只能够进行等待；</p>
<h3 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h3><p>首先来看一下 JVM规范 中对于 monitorenter和monitorexit的描述：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>docs.oracle.com<span class="regexp">/javase/</span>specs<span class="regexp">/jvms/</span>se8<span class="regexp">/html/</span>jvms-<span class="number">6</span>.html<span class="comment">#jvms-6.5.monitorexit</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced ny objectref.<br>  The thread decrements the entry count of the monitor associated with objectref.<br>  iIf as a result the value of the entry count is zero , the thread exits the monitor and is no longer its owner.<br>  Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>翻译过来：</p>
<ol>
<li>能执行 monitorexit 指令的线程 一定是 拥有当前对象的 monitor的所有权的线程。</li>
<li>执行 monitorexit时 会将 monitor的进入数减1。 当monitor的进入数减为0时，当前线程退出monitor，不再拥有monitor的所有权，此时其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。</li>
</ol>
<p>monitorexit：释放锁；<br>monitorexit插入在方法结束处和异常处；<br>JVM保证每个 monitorenter必须有对应的monitorexit；</p>
<blockquote>
<p>monitorexit流程分析</p>
</blockquote>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">假设线程t1获取拿到Object obj所关联的对象锁monitor之后从而进入到同步代码块当中走到要结束同步代码块的位置，即synchronized(obj)&#123;所对应返回&#125;花括号的位置处，即将要释放锁的位置；</span><br><span class="line">t1线程执行完同步代码块之后就会执行字节码指令15: monitorexit 指令；</span><br><span class="line">遇到这个指令之后，就会去找到这个锁对象Object obj真正的锁对象monitor；</span><br><span class="line">找到之后会进行对monitor的成员变量的属性取值owner以及recursions进行更改赋值；</span><br><span class="line">那么此时线程t1仍然在拥有着这把锁；所以此时monitor的owner依然是当前线程t1，不需要改变；</span><br><span class="line">而线程t2即将要出同步代码块，则recursions计数器就需要进行减一操作；即赋值为0，由1变为0；</span><br><span class="line">当monitor锁对象的成员变量recursions计数器取值变为0时也就代表着当前线程t1释放了当前其所拥有的这一把锁；</span><br><span class="line">那么同时monitor锁对象的成员变量owner属性取值即锁的拥有者也不存在了；</span><br><span class="line"></span><br><span class="line">另外还需要注意一个问题；</span><br><span class="line">进入同步代码块时：synchronized(obj)&#123; ------→ 字节码指令5: monitorenter</span><br><span class="line">出同步代码块时：&#125;  ------→ 字节码指令15: monitorexit</span><br><span class="line">除了这两处地方存在有monitor相关的指令之外其余的地方也存在有monitor相关字节码指令操作；</span><br><span class="line">即 21: monitorexit（为什么此处也存在有monitor相关字节码指令操作呢？）</span><br><span class="line"></span><br><span class="line">字节码指令最下面的Exception table称作为异常表；即：</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="code">      Exception table:</span></span><br><span class="line"><span class="code">          from     to    target   type</span></span><br><span class="line"><span class="code">             6      16       19    any</span></span><br><span class="line"><span class="code">            19      22       19    any</span></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">from ... to : 指的是从哪一行到哪一行；即指的是6~16行或者19~22行之间的字节码指令；</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="code">          6: getstatic           #3        // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="code">          9: 1dc                 #4        // String 1</span></span><br><span class="line"><span class="code">         11: invokevirtual       #5        // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line"><span class="code">         14: aload_1</span></span><br><span class="line"><span class="code">         15: monitorexit</span></span><br><span class="line"><span class="code">         16: goto                24</span></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">也就是所对应在java代码当中的：</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">synchronized(obj)&#123;</span><br><span class="line"><span class="code">  System.out.println("1");</span></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">也就意味着如果同步代码块当中的代码当中出现了异常；</span><br><span class="line">那么也就是指的字节码指令6~16行出现了异常则target为19；</span><br><span class="line">那么也就会走字节码指令编号为19的字节码指令代码：即19: astore<span class="emphasis">_2</span></span><br><span class="line"><span class="emphasis">那么执行完字节码指令19之后继续向下执行字节码指令20: aload_</span>1、21: monitorexit；</span><br><span class="line">也就说明了其最终也会去进行释放锁；</span><br><span class="line">这也就是在告知：如果在同步代码块当中出现了异常；monitor会自动帮助释放锁即monitorexit字节码指令；</span><br></pre></td></tr></table></figure>

<p><strong>面试题</strong>：synchronized出现异常会释放锁吗？</p>
<p>答：会释放锁；</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>docs.oracle.com<span class="regexp">/javase/</span>specs<span class="regexp">/jvms/</span>se8<span class="regexp">/html/</span>jvms-<span class="number">2</span>.html<span class="comment">#jvms-2.11.10</span></span><br></pre></td></tr></table></figure>

<p>可以看到 同步方法 在反汇编之后，<br>会增加<code>ACC_SYNCHRONIZED</code>修饰。<br>会隐式地调用 monitorenter和monitorexit。<br>在执行 同步方法 之前会调用monitorenter，在执行完同步方法后会调用monitorexit；</p>
<blockquote>
<p>查看反汇编之后的字节码指令-同步方法</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> synchronized <span class="built_in">void</span> test();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>,    locals=<span class="number">1</span>,     args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: getstatic         #<span class="number">3</span>        <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">3</span>: <span class="number">1</span>dc               #<span class="number">6</span>        <span class="comment">// String a</span></span><br><span class="line">        <span class="number">5</span>: invokevirtual     #<span class="number">5</span>        <span class="comment">// Method java/io/PrintStream.println(Ljava/lang/String;)V</span></span><br><span class="line">    LineNUmberTable:</span><br><span class="line">      line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTalbe:</span><br><span class="line">      Start       Length       Slot     Name     Signature</span><br><span class="line">          <span class="number">0</span>            <span class="number">9</span>          <span class="number">0</span>     <span class="keyword">this</span>     Lcom/xxx/demo04_synchronized_monitor/Demo01;</span><br><span class="line">......</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">对应的代码：</span><br><span class="line"><span class="keyword">public</span> synchronized <span class="built_in">void</span> test()&#123;</span><br><span class="line">  System.<span class="keyword">out</span>.println(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">同步方法test()内部并没有形成monitorenter以及monitorexit；</span><br><span class="line">只是对该方法做了一个标识；即观察flags:标识；</span><br><span class="line">ACC_SYNCHRONIZED：那么该标识的作用即在于（在JVM规范当中也有相关说明）同步方法会被JVM隐式地调用monitorenter和monitorexit；</span><br><span class="line">也就是说java虚拟机的线程执行到同步方法的时候它会自动的去调用字节码指令monitorenter；</span><br><span class="line">当执行完同步方法之后也会自动的去调用字节码指令monitorexit；</span><br><span class="line">即所谓隐式调用；</span><br></pre></td></tr></table></figure>

<h3 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h3><p>通过 javap反汇编，看到synchronized使用变成了monitorenter和monitorexit两个字节码指令；真正的锁是monitor；每个锁对象都会关联一个monitor(监视器,monitor才是真正的锁对象)，monitor内部有两个重要的成员变量owner（owner：会保存获得锁的线程）和recursions（会保存线程获得锁的次数）；<br>执行monitorenter那么线程就会来进行竞争monitor这把锁；<br>抢到monitor这把锁之后；<br>就会将monitor当中的成员变量owner的取值改为当前抢到锁的该线程；<br>以及拥有锁的次数recursions变为1；<br>如果再次进入同步代码块即嵌套同步代码块也是同样的这一把锁；<br>那么（可重入特性）重入即monitor的成员变量recursions的取值就会进行加一操作；<br>当执行到monitorexit时，那么monitor的成员变量recursions计数器就会进行减一操作；<br>当monitor的计数器recursions减到0时，那么当前拥有该锁monitor的现场称就会去进行释放锁；</p>
<h2 id="面试题：synchronized与Lock的区别"><a href="#面试题：synchronized与Lock的区别" class="headerlink" title="面试题：synchronized与Lock的区别"></a>面试题：synchronized与Lock的区别</h2><p><strong>1、</strong> synchronized是关键字，而Lock是一个接口（ReentrantLock为其实现类）。  </p>
<p>synchronized是JDK提供的一个关键字；无法查看得到其源码；<br>synchronized由JVM直接来支持的；<br>而前面所使用到的Lock实际上是一个接口；</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  <span class="doctag">@since</span> 1.5            //从jdk1.5之后有的</span></span><br><span class="line"><span class="comment">  <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span></span>&#123;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*并且该接口Lock存在相应的实现类；</span></span><br><span class="line"><span class="comment">  ReadLockView in StampedLock (java.util.concurrent.....)</span></span><br><span class="line"><span class="comment">  WriteLock in ReetrantReadWriteLock (java.....)</span></span><br><span class="line"><span class="comment">  ReentrantLock (java.util.concurrent.locks)</span></span><br><span class="line"><span class="comment">  WriteLockView in StampedLock (java.util.concurrent....)</span></span><br><span class="line"><span class="comment">  ReadLock in ReentrantReadWriteLock (java....)</span></span><br><span class="line"><span class="comment">  这些实现类当中大部分都在(WriteLock in )ReetrantReadWriteLock类当中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><strong>2、</strong> synchronized会自动释放锁，而Lock必须手动释放锁。  </p>
<p>通过javap 反汇编的形式就可以进行查看得到；<br>synchronized并没有手动的去获取锁以及释放锁；<br>它在反汇编之后会形成相应的字节码指令；<br>当执行到synchronized(obj){ 的时候会执行到5: monitorenter字节码指令；<br>当执行到synchronized(obj){所对应的回括号}（同步代码块执行完时）时会执行到15: monitorexit字节码指令；<br>并且就算同步代码块当中出现了异常；synchronized也会将锁给释放掉；<br>即Exception table中from…to的6~16行字节码指令如果出现异常则target跳转至字节码指令19行执行 19: astore_2以及接着19行字节码指令继续往下进行执行；20: aload_1、21: monitorexit即释放锁；  </p>
<p>而Lock就需要手动的来进行释放锁；<br>当去尝试获取锁之后获取返回得到boolean类型变量；<br>根据该布尔类型变量判断是否获取得到了锁；<br>并且在finally块当中需要进行保证锁的释放<br>（前提是如果tryLock返回为true则需要进行执行unlock()操作；如果tryLock返回为true但是没有执行unlock操作那么就将会导致锁一直不释放；）</p>
<p><strong>3、</strong> synchronized是不可中断的，而Lock可以是不可中断的也可以是可中断的。  </p>
<p>synchronized：当有一个线程执行到synchronized同步代码块当中执行代码的时候；另外一个线程由于没有锁只能够在同步代码块外侧进行等待操作；<br>这个等待的线程是不能够被中断的，它会一直等待获取锁；  </p>
<p>而Lock有两种处理方式：可以中断也可以不中断；<br>一种是可中断式的采用tryLock()的方式；<br>（尝试去获取锁，并且可以定义等待获取锁的时间以及时间单位；指定等待获取锁的时间到了如果仍然没有获取得到锁的话那么这个时候是可以中断的，即一直处于等待状态的线程不必再进行等待获取锁而是可以去执行其他的任务）<br>另外一种是lock()方式的而这种方式是不可中断的；</p>
<p><strong>4、</strong> 通过Lock可以知道线程有没有拿到锁（tryLock()），而synchronized不能。  </p>
<p>比如说Lock定义使用了其tryLock(3, TimeUnit.SECONDS);方法；<br>则将返回有布尔类型的取值；<br>如果其返回值为true则说明当前该等待的线程拿到了锁；<br>如果其返回值为false则说明当前等待的该线程并没有拿到锁；则进行中断完成其他的操作；<br>而synchronized是不能够去进行判断有没有拿到锁的；synchronized就是一个代码块；<br>比如说这段代码当中拿到锁则自动进入同步代码块当中执行相应的打印操作；没有拿到锁则只能够在同步代码块外侧进行等待拿到锁的线程进行释放锁；如果没有释放则将一直等待；</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">  System.<span class="keyword">out</span>.println(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5、</strong> synchronized能锁住方法和代码块，而Lock只能锁住代码块。  </p>
<p>通过语法层面可以看到synchronized可以用来锁住方法以及代码块；<br>而Lock只能够锁住代码块而不能锁住方法；<br>也就是该Lock只能够在方法内部进行调用；<br>而不能将Lock放到方法上进行修饰方法；</p>
<p><strong>6、</strong> Lock可以使用读锁提高多线程效率。  </p>
<p>Lock当中有一个实现类叫做ReentrantReadWriteLock；<br>这种锁可以进行提高读的效率的；</p>
<p>ReentrantReadWriteLock.java<br>这个锁的机制是这样的；<br>如果在读的时候它允许多个线程来进行读操作；<br>那么如果写的时候那就只能一个线程来进行写也不能进行读取操作；<br>所以它是可以提高多个线程来进行读的效率。</p>
<p><strong>7、</strong> synchronized是非公平锁，ReentrantLock可以控制是否是公平锁。  </p>
<p>synchronized是非公平锁；<br>即其进行唤醒的时候并不是公平的先来后到的方式来进行唤醒；<br>举个例子：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pubilc <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">  synchronized(obj)&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"1"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设一个线程A先进行获取得到锁从而进入同步代码块当中进行执行相关内容如打印“1”；<br>那么后面还有其他的线程B、C、D、E、F……进来；那么后面的线程B、C、D、E、F……在抢不到锁，即第一个线程A没有释放锁的情况下，只能在同步块外侧进行等待；<br>那么此时假设线程A执行完同步代码块之后；那么肯定就需要去唤醒等待在同步代码块外侧的线程B、C、D、E、F……中的某一个来获取锁进入同步代码块中；<br>那么唤醒的时候则不是按照先来后到的方式进行唤醒；<br>而是属于随机的唤醒一个线程；<br>所以；synchronized是非公平的；<br>而ReentrantLock是可以去进行控制它是否为公平锁的；</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 此时使用的是ReentrantLock当中的无参构造器；</span><br><span class="line">//而无参构造器默认是非公平的；</span><br><span class="line">private<span class="keyword"> static</span> Lock lock =<span class="built_in"> new </span>ReentrantLock();</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line">ReentrantLock.java</span><br><span class="line">/**</span><br><span class="line">  Creates an<span class="built_in"> instance </span>of &#123;@code ReentantLock&#125;</span><br><span class="line">  This is equivalent to using &#123;@Code ReentrantLock(false)&#125;</span><br><span class="line">  无参构造器</span><br><span class="line">*/</span><br><span class="line">public ReentrantLock()&#123;</span><br><span class="line">  sync =<span class="built_in"> new </span>NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  Creates an<span class="built_in"> instance </span>of &#123;@code ReentrantLock&#125; with the</span><br><span class="line">  given fairness policy.</span><br><span class="line">  有参构造器；boolean类型操作来指定ReentrantLock是否公平；</span><br><span class="line">  也就是唤醒等待线程的时候是否采用先来后到的方式进行唤醒；</span><br><span class="line">  如果是先来后到的方式那么就是采用的是公平锁；</span><br><span class="line">  如果不是先来后到的方式那么就是非公平锁；</span><br><span class="line"></span><br><span class="line">  @param fair&#123;@code true&#125;<span class="built_in"> if </span>this lock should use a fair ordering policy.</span><br><span class="line">*/</span><br><span class="line">public ReentrantLock(boolean fair)&#123;</span><br><span class="line">  sync = fair ?<span class="built_in"> new </span>FairSync()<span class="keyword"> :</span><span class="built_in"> new </span>NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深入JVM源码-monitor监视器锁"><a href="#深入JVM源码-monitor监视器锁" class="headerlink" title="深入JVM源码-monitor监视器锁"></a>深入JVM源码-monitor监视器锁</h2><p>synchronized是java当中的一个关键字；<br>通过java是看不到synchronized关键字源码的；<br>synchronized是由JVM直接来进行支持的；<br>现在通过JVM源码的方式来进行分析synchronized原理；<br>JVM的源代码是使用C++编写的；那么介绍IDE工具来方便查看JVM的源代码；<br>synchronized本质是通过monitor然后来进行同步操作的；<br>那么会详细介绍monitor的结构；<br>另外当存在有多个线程来执行synchronized的时候，只存在有一个线程竞争得到锁，那么这个时候就会来进行介绍monitor的竞争；<br>以及线程没有竞争得到锁是如何处理的也就是monitor等待；<br>以及synchronized执行完成之后线程要释放锁；那么线程是如何来进行释放的呢？<br>这里就牵扯到了monitor释放；<br>最后还会介绍到monitor是一个重量级锁，monitor其性能开销比较大；</p>
<p>学习部分分为：</p>
<ul>
<li>深入JVM源码<ul>
<li>目标</li>
<li>JVM源码下载</li>
<li>IDE(Clion)下载</li>
<li>monitor监视器锁</li>
<li>monitor竞争</li>
<li>monitor等待</li>
<li>monitor释放</li>
<li>monitor是重量级锁</li>
</ul>
</li>
</ul>
<h3 id="目标-12"><a href="#目标-12" class="headerlink" title="目标"></a>目标</h3><p>通过JVM源码 分析 synchronized的原理</p>
<h3 id="JVM源码下载"><a href="#JVM源码下载" class="headerlink" title="JVM源码下载"></a>JVM源码下载</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//openjdk.java.net/</span></span><br><span class="line">选中左边菜单栏中[Source Code]下的子菜单栏[Mercurial]</span><br><span class="line">点击完之后得到的就是jdk所有源代码的一个托管结构；</span><br><span class="line">那么在这当中找到jdk8；</span><br><span class="line">找到的页面：http:<span class="comment">//hg.openjdk.java.net/jdk8</span></span><br><span class="line">页面中就是jdk8的源码；</span><br><span class="line">选择hotspot进行下载，Hotspot是jdk自带的虚拟机；</span><br><span class="line">进行跳转页面：http:<span class="comment">//hg.openjdk.java.net/jdk8/hotspot</span></span><br><span class="line">看到左侧菜单栏选择zip格式进行下载源代码；</span><br><span class="line">S<span class="function"><span class="title">ource</span> Code ---&gt;</span> M<span class="function"><span class="title">ercurial</span> ---&gt;</span> <span class="function"><span class="title">jdk8</span> ---&gt;</span> <span class="function"><span class="title">hotspot</span> ---&gt;</span> zip</span><br></pre></td></tr></table></figure>

<p>java 是开源的；<br>那么java开源部分的代码就属于在openjdk这个项目当中；<br>那么在该网站当中就能够下载得到其源代码；</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">jvm所有的源码都在其src目录下；</span><br><span class="line"><span class="title">.ideea</span></span><br><span class="line"><span class="title">.jcheck</span></span><br><span class="line">agent</span><br><span class="line">cmake-build-debug</span><br><span class="line">make</span><br><span class="line">src</span><br><span class="line"><span class="title">.hg_archival.txt</span></span><br><span class="line"><span class="title">.hgignore</span></span><br><span class="line"><span class="title">.hgtags</span></span><br><span class="line">ASSEMBLY<span class="emphasis">_EXCEPTION</span></span><br><span class="line"><span class="emphasis">CMakeLists.txt</span></span><br><span class="line"><span class="emphasis">LICENSE</span></span><br><span class="line"><span class="emphasis">README</span></span><br><span class="line"><span class="emphasis">THIRD_</span>PARTY<span class="emphasis">_README</span></span><br><span class="line"><span class="emphasis">--------------------------------------</span></span><br><span class="line"><span class="emphasis">src下的目录又分成几个部分：</span></span><br><span class="line"><span class="emphasis">cpu</span></span><br><span class="line"><span class="emphasis">os</span></span><br><span class="line"><span class="emphasis">os_</span>cpu</span><br><span class="line">share</span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">第一部分cpu；cpu跟虚拟机相关的一些代码；</span><br><span class="line">其下目录有</span><br><span class="line">sparc</span><br><span class="line">x86</span><br><span class="line">zero</span><br><span class="line">----------------------------------------</span><br><span class="line">第二部分os: 操作系统（也就是虚拟机在不同的操作系统当中存在有一些特别的代码）</span><br><span class="line">其下目录有</span><br><span class="line">bsd</span><br><span class="line">linux</span><br><span class="line">posix</span><br><span class="line">solaris</span><br><span class="line">windows</span><br><span class="line">-------------------------------------------</span><br><span class="line">第三部分os<span class="emphasis">_cpu: 与cpu相关也与操作系统相关的一些特殊代码</span></span><br><span class="line"><span class="emphasis">其下目录有</span></span><br><span class="line"><span class="emphasis">bsd_</span>x86</span><br><span class="line">bxd<span class="emphasis">_zero</span></span><br><span class="line"><span class="emphasis">linux_</span>sparc</span><br><span class="line">linux<span class="emphasis">_x86</span></span><br><span class="line"><span class="emphasis">linux_</span>zero</span><br><span class="line">solaris<span class="emphasis">_sparc</span></span><br><span class="line"><span class="emphasis">solaris_</span>x86</span><br><span class="line">windows<span class="emphasis">_x86</span></span><br><span class="line"><span class="emphasis">-------------------------------------------------------</span></span><br><span class="line"><span class="emphasis">第四部分share: 即公共的JVM源码</span></span><br><span class="line"><span class="emphasis">其下目录有</span></span><br><span class="line"><span class="emphasis">tools //工具类</span></span><br><span class="line"><span class="emphasis">vm    //所有JVM公共的源码都在vm当中</span></span><br><span class="line"><span class="emphasis">-------------------------------------------------------</span></span><br><span class="line"><span class="emphasis">-------------------------------------------------------</span></span><br><span class="line"><span class="emphasis">vm目录下又分有一些子目录：</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">adlc</span></span><br><span class="line"><span class="emphasis">asm</span></span><br><span class="line"><span class="emphasis">c1</span></span><br><span class="line"><span class="emphasis">ci</span></span><br><span class="line"><span class="emphasis">classfile</span></span><br><span class="line"><span class="emphasis">code</span></span><br><span class="line"><span class="emphasis">compiler</span></span><br><span class="line"><span class="emphasis">gc_</span>implementation</span><br><span class="line">gc<span class="emphasis">_interface</span></span><br><span class="line"><span class="emphasis">interpreter</span></span><br><span class="line"><span class="emphasis">libadt</span></span><br><span class="line"><span class="emphasis">memory</span></span><br><span class="line"><span class="emphasis">oops</span></span><br><span class="line"><span class="emphasis">opto</span></span><br><span class="line"><span class="emphasis">precompiled</span></span><br><span class="line"><span class="emphasis">prims</span></span><br><span class="line"><span class="emphasis">runtime</span></span><br><span class="line"><span class="emphasis">Xusage.txt</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">-----------------------------------------------------</span></span><br><span class="line"><span class="emphasis">-----------------------------------------------------</span></span><br><span class="line"><span class="emphasis">主要关注vm文件夹下的</span></span><br><span class="line"><span class="emphasis">oops：即面向对象即一些类的描述类的结构都存储放在该文件夹下；</span></span><br><span class="line"><span class="emphasis">runtime文件夹：主要是一些线程还有一些monitor锁都在该文件夹下。</span></span><br><span class="line"><span class="emphasis">---------------------------------------------------------</span></span><br></pre></td></tr></table></figure>

<h3 id="IDE-Clion-下载"><a href="#IDE-Clion-下载" class="headerlink" title="IDE(Clion)下载"></a>IDE(Clion)下载</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------</span><br><span class="line">下载c++的ide:</span><br><span class="line">https://www.jetbrains.com/</span><br><span class="line"><span class="code">          |</span></span><br><span class="line"><span class="code">          ↓</span></span><br><span class="line">https://jetbrains.com/clion/</span><br><span class="line">-----------------------------------</span><br><span class="line"></span><br><span class="line">导入java虚拟机的源码：</span><br><span class="line">File--&gt;new Project；</span><br><span class="line">导入文件夹当中的源码；</span><br><span class="line">该文件夹即为当前该目录的文件夹；</span><br><span class="line"><span class="title">.ideea</span></span><br><span class="line"><span class="title">.jcheck</span></span><br><span class="line">agent</span><br><span class="line">cmake-build-debug</span><br><span class="line">make</span><br><span class="line">src</span><br><span class="line"><span class="title">.hg_archival.txt</span></span><br><span class="line"><span class="title">.hgignore</span></span><br><span class="line"><span class="title">.hgtags</span></span><br><span class="line">ASSEMBLY<span class="emphasis">_EXCEPTION</span></span><br><span class="line"><span class="emphasis">CMakeLists.txt</span></span><br><span class="line"><span class="emphasis">LICENSE</span></span><br><span class="line"><span class="emphasis">README</span></span><br><span class="line"><span class="emphasis">THIRD_</span>PARTY<span class="emphasis">_README</span></span><br></pre></td></tr></table></figure>

<h3 id="monitor监视器锁"><a href="#monitor监视器锁" class="headerlink" title="monitor监视器锁"></a>monitor监视器锁</h3><p>(JVM底层由C++实现)</p>
<p>可以看出 无论是 synchronized代码块 还是 synchronized方法，<br>（最终需要一个java对象；而java对象又会关联到一个monitor监视器锁的东西；真正的同步是靠monitor监视器锁来实现的；那么monitor监视器锁的结果是什么样的？）<br>其线程安全的语义实现 最终依赖一个叫 monitor的东西，那么这个神秘的东西是什么呢？<br>下面来详细介绍一下。</p>
<p>在HotSpot虚拟机中，monitor是由ObjectMonitor实现的。<br>其源码是用c、c++来实现的，位于HotSpot虚拟机源码 ObjectMonitor.hpp文件中（src/share/vm/runtime/objectMonitor.hpp）。<br>ObjectMonitor主要数据结构如下：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 构造器，给很多的成员变量赋值（让其与java源代码组合起来进行分析比较方便）</span></span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">  _header              = NULL;</span><br><span class="line">  _<span class="built_in">count</span>               = <span class="number">0</span>;</span><br><span class="line">  _waiters             = <span class="number">0</span>;</span><br><span class="line">  _recursions          = <span class="number">0</span><span class="comment">; // 线程的重入次数</span></span><br><span class="line">  _object              = NULL<span class="comment">; //存储该monitor的对象</span></span><br><span class="line">  _owner               = NULL<span class="comment">; //标识拥有该monitor的线程</span></span><br><span class="line">  _WaitSet             = NULL<span class="comment">; //处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">  _WaitSetLock         = <span class="number">0</span>;</span><br><span class="line">  _Responsible         = NULL;</span><br><span class="line">  _succ                = NULL;</span><br><span class="line">  _cxq                 = NULL<span class="comment">; // 多线程竞争锁时的单项列表</span></span><br><span class="line">  FreeNext             = NULL;</span><br><span class="line">  _EntryList           = NUll<span class="comment">; //处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">  _SpinFreq            = <span class="number">0</span>;</span><br><span class="line">  _SpinClock           = <span class="number">0</span>;</span><br><span class="line">  OwnerIsThread        = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">  <span class="keyword">synchronized(obj)&#123;</span></span><br><span class="line"><span class="keyword"> </span>   System.out.println(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">    obj.<span class="keyword">wait();</span></span><br><span class="line"><span class="keyword"> </span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">分析：</span><br><span class="line"><span class="keyword">Java代码：synchronized(obj)&#123; </span>同步代码块需要一个<span class="keyword">java对象，类对象都可以；</span></span><br><span class="line"><span class="keyword">那么这个java对象new出来是肯定存放在java内存结构当中的堆中的；</span></span><br><span class="line"><span class="keyword">那么对象当中存在一些什么呢？</span></span><br><span class="line"><span class="keyword">以前知道对象当中存在有成员变量；</span></span><br><span class="line"><span class="keyword">堆中会存放对象中的成员变量；也叫示例数据；</span></span><br><span class="line"><span class="keyword">那么其实；除了示例数据以外还会有一个叫做对象头的内容；</span></span><br><span class="line"><span class="keyword">那么这个对象头的作用就在于保存对应的monitor对象；</span></span><br><span class="line"><span class="keyword">这个对象会关联一个monitor对象；那么这个monitor对象如何来的呢？</span></span><br><span class="line"><span class="keyword">monitor时候由C++的类ObjectMonitor.hpp所造的这样一个对象；</span></span><br><span class="line"><span class="keyword">首先在ObjectMonitor.hpp当中进行查看一些比较重要的成员变量；</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">_recursions；_recursions记录线程拿了几次锁了；即线程锁重入的次数；</span></span><br><span class="line"><span class="keyword">举个例子:</span></span><br><span class="line"><span class="keyword">假设线程第一次进入同步代码块中；获取得到锁对象；即synchronized(obj)&#123;；</span></span><br><span class="line"><span class="keyword">那么此时锁对象所关联的monitor对象当中的成员属性中的_recursions就会记录拿了一次；</span></span><br><span class="line"><span class="keyword">那么假设该同步代码块当中还存在了一个同步代码块即嵌套同步代码块以及同样的一把锁；</span></span><br><span class="line"><span class="keyword">那么这个_recursions计数器就会执行加1操作；</span></span><br><span class="line"><span class="keyword">假设该嵌套同步代码块当中还存在有一个同步代码块且依旧是同样的一把锁，</span></span><br><span class="line"><span class="keyword">那么这个_recursions计数器就又会执行加1操作；</span></span><br><span class="line"><span class="keyword">接着如果当前线程出一个同步代码块那么计数器_recursions就会减1；</span></span><br><span class="line"><span class="keyword">再出一个同步代码块_recursions减1；</span></span><br><span class="line"><span class="keyword">直到_recursions减到0为止就说明该线程就把该锁给释放掉了；</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">_object: </span>存储该monitor的对象；</span><br><span class="line">即该_object会进行存储<span class="keyword">java对象即 </span><span class="keyword">synchronized(obj)&#123;&#125;中的obj对象；</span></span><br><span class="line"><span class="keyword">也就是说是相互引用的；</span></span><br><span class="line"><span class="keyword">即java对象当中的obj会引用monitor对象；而monitor对象中的成员变量属性_object取值也会引用着java对象；</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">_owner: </span>指的是标识拥有该monitor的线程（即指的就是线程的拥有者）</span><br><span class="line">假设线程A抢到锁进入到了同步代码块当中来了；</span><br><span class="line">那么到时候ObjectMonitor当中的_owner所指的就是当前该线程A；</span><br><span class="line"></span><br><span class="line"><span class="symbol">_WaitSet:</span> 处于<span class="keyword">wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line"><span class="keyword">Wait是等待的意思；Set代表集合；</span></span><br><span class="line"><span class="keyword">WaitSet是用来存放处于wait状态的线程的集合</span></span><br><span class="line"><span class="keyword">比如说，当前线程A获取得到锁之后从而进入同步代码块执行同步代码块中的代码；</span></span><br><span class="line"><span class="keyword">执行obj.wait()方法；那么当前该锁住就将进入无限的等待中；</span></span><br><span class="line"><span class="keyword">那么无限等待的线程就会被放置在_WaitSet集合当中去；</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">_cxq: </span>多个线程在竞争锁时的单向列表；</span><br><span class="line">假设当前有一个<span class="built_in">t1</span>线程进入到同步代码块当中；</span><br><span class="line">由于<span class="built_in">t1</span>线程是第一次先进入同步代码块当中来的；</span><br><span class="line">所以抢得到锁从而进入同步代码块；</span><br><span class="line">假设又来了另外一个线程即<span class="built_in">t2</span>线程；</span><br><span class="line">那么<span class="built_in">t2</span>线程是没有抢到锁的；</span><br><span class="line">那么没有抢到锁的线程依旧要等待；</span><br><span class="line">那么这些没有抢到锁的线程去哪里进行等待；</span><br><span class="line">或者说用什么来进行保存这些正在等待的线程呢？</span><br><span class="line">准备要等待的线程会进入到_cxq该变量当中去，_cxq是一个单向列表；</span><br><span class="line">那么此时假如还有一个线程进来叫做<span class="built_in">t3</span>线程；</span><br><span class="line">那么这个<span class="built_in">t3</span>线程执行同步代码块也抢不到锁，也会先进行进入这个_cxq单向列表当中；</span><br><span class="line">假设线程<span class="built_in">t1</span>往下继续进行执行；执行完同步代码块那么就会将锁进行给释放掉了；</span><br><span class="line">那么此时就有可能是由线程<span class="built_in">t1</span>、<span class="built_in">t2</span>、<span class="built_in">t3</span>都有可能获取抢到锁；</span><br><span class="line">那么还是假设线程<span class="built_in">t1</span>进行抢到了锁；</span><br><span class="line">那么这就是线程<span class="built_in">t1</span>第二次抢到了锁；也就是<span class="built_in">t1</span>线程第二次进入同步代码块了；那么这个时候<span class="built_in">t1</span>线程拿着锁进入同步代码块当中；</span><br><span class="line">那么上一次放在在等待中的_cxq单向列表中的等待中的线程<span class="built_in">t2</span>、<span class="built_in">t3</span>此时就会进入到_EntryList变量当中去；</span><br><span class="line"></span><br><span class="line"><span class="symbol">_EntryList:</span> 处于等待锁<span class="keyword">block状态的线程，会被加入到该列表</span></span><br><span class="line"><span class="keyword">即就处于BLOCK状态的线程就会被添加入到_EntryList变量当中来；</span></span><br><span class="line"><span class="keyword">假设t1在执行的时候，这个时候又来了一个线程叫做t4;</span></span><br><span class="line"><span class="keyword">那么t4线程进入同步代码块由于没有抢到锁会先进入_cxq单向列表当中去；</span></span><br><span class="line"><span class="keyword">假设再来了一个线程叫做t5；那么t5也要执行同步代码块也没有获取得到锁从而也会被放置到_cxq单向列表中去；</span></span><br><span class="line"><span class="keyword">假设t1线程执行完成出了同步代码块了；假设t1又再次争抢获取得到锁进入了同步代码块当中；那么上一次在_cxq单向列表中进行等待的两个线程t4、t5就会进入到_EntryList当中去；即变为BLOCK状态；</span></span><br><span class="line"><span class="keyword">-----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">分析Monitor结构图</span></span><br><span class="line"><span class="keyword">Monitor主要由三个组件进行构成: </span>_owner、_EntryList、_WaitSet</span><br><span class="line">等待一轮之后依旧没有抢到锁的线程被放置到_EntryList当中来了；</span><br><span class="line">那么还有就是执行obj.<span class="keyword">wait()方法的被放置放到_WaitSet单项列表中去；</span></span><br><span class="line"><span class="keyword">当线程拥有者在执行那么执行完就会出同步代码块；</span></span><br><span class="line"><span class="keyword">那么当线程拥有者在执行完成出同步代码块的时候</span></span><br><span class="line"><span class="keyword">有可能会是_EntryList当中正在阻塞的线程竞争获取拿到锁变成monitor当中的_owner；</span></span><br><span class="line"><span class="keyword">也有可能会是_WaitSet当中处于Wait的线程被别的操作所唤醒了；</span></span><br><span class="line"><span class="keyword">那么它也有可能会获得锁变成线程的user即monitor结构中的_owner；</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">竞争到锁的线程、处于阻塞状态的线程、处于等待状态的线程；</span></span><br></pre></td></tr></table></figure>

<ol>
<li>_owner: 初始化为NUll，当有线程占有该monitor时，owner标记为该线程的唯一表示。当线程释放monitor时，owner又恢复到NULL。owner是一个临界资源，JVM是通过CAS操作来保证其线程安全的。</li>
<li>_cxq: 竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。_cxq是一个临界资源，JVM通过CAS原子指令来修改_cxq队列。 修改前 _cxq的旧值 填入了 node的next字段， _cxq指向新值（新线程）。因此 _cxq是一个后进先出的stack(栈)。</li>
<li>_EntryList: _cxq队列中 有资格成为 候选资源的 线程 会被移动到该队列中。</li>
<li>_WaitSet: 因为调用wait方法而被阻塞的 线程会被放在该队列中。</li>
</ol>
<p>每一个java对象都可以与一个监视器 monitor关联，<br>可以把它理解成为一把锁，<br>当一个线程想要执行一段被synchronized圈起来的同步方法或者代码块时，<br>该线程得 先获取到 synchronized修饰的对象 对应的monitor。</p>
<p>java代码里不会 显式地去创造这么一个 monitor对象，<br>也无需创建，<br>事实上可以这么理解：<br>monitor并不是随着对象创建而创建的。<br>是通过 synchronized 修饰符 告诉 JVM 需要为 某个对象创建关联的 monitor对象。<br>每个线程都存在两个ObjectMonitor对象列表，分别为 free和 used列表。<br>同时JVM中也维护着 global locklist。<br>当线程需要 ObjectMonitor对象时，首先从线程自身的free表中申请，若存在则使用，若不存在则从 globallist 中申请。</p>
<p>ObjectMonitor 的数据结构包含三种队列： _cxq、_WaitSet和 _EntryList，他们之间的关系转换可以用下图表示：</p>
<h2 id="深入JVM源码-monitor竞争"><a href="#深入JVM源码-monitor竞争" class="headerlink" title="深入JVM源码-monitor竞争"></a>深入JVM源码-monitor竞争</h2><p>monitor竞争<br>monitor对象监视器锁竞争的过程；</p>
<p>synchronized为什么是重量级锁，为什么开销比较大？<br>synchronized是重量级的锁，效率不高。<br>synchronized的优化涉及到一个叫做CAS的操作。<br>CAS也属于一个原子操作，可以将其看做是一个轻量级的synchronized。</p>
<h3 id="目标-13"><a href="#目标-13" class="headerlink" title="目标"></a>目标</h3><p>分两步<br>第一步；了解何时会出现monitor竞争？<br>第二步：monitor是如何竞争的？</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java代码举例：</span><br><span class="line">----------------------------------------</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"><span class="code">  synchronized(obj)&#123;</span></span><br><span class="line"><span class="code">    System.out.println("1");</span></span><br><span class="line"><span class="code">  &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------</span><br><span class="line">假设有一个t1线程；再来一个t2线程；</span><br><span class="line">可能这两个线程t1、t2都会来进行执行同步代码块synchronized(obj)&#123;；</span><br><span class="line">那么这个时候就会处于monitor竞争状态；</span><br><span class="line">线程执行同步代码块就会出现竞争的现象；</span><br><span class="line">之前反汇编javap看到synchronized会变成两条字节码指令monitorenter以及monitorexit；</span><br><span class="line">当线程进入同步代码块synchronized时会执行monitorenter字节码指令；</span><br><span class="line">当线程执行完同步代码块中的内容即退出同步代码块时会执行monitorexit字节码指令；</span><br><span class="line">这个monitorenter字节码指令最终会调用到InterpreterRuntime.cpp代码中的一个方法；</span><br></pre></td></tr></table></figure>

<ol>
<li>执行 monitorenter时，会调用 InterpreterRuntime.cpp<br>（位于：src/share/vm/interpreterRuntime.cpp）的InterpreterRuntime::monitorenter 函数。</li>
</ol>
<p>具体代码可参见 HotSpot源码。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 截取的部分代码</span><br><span class="line"><span class="constructor">IRT_ENTRY_NO_ASYNC(<span class="params">void</span>, InterpreterRuntime:<span class="params">monitorenter</span>(JavaThread<span class="operator">*</span>  <span class="params">thread</span>, BasicObjectLock<span class="operator">*</span> <span class="params">elem</span>)</span>)</span><br><span class="line">#ifdef ASSERT</span><br><span class="line">  thread-&gt;last<span class="constructor">_frame()</span>.interpreter<span class="constructor">_frame_verify_monitor(<span class="params">elem</span>)</span>;</span><br><span class="line">#endif</span><br><span class="line">  <span class="keyword">if</span>(PrintBiasedLockingStatistics)&#123;</span><br><span class="line">    Atomic::inc(BiasedLocking::slow<span class="constructor">_path_entry_count_addr()</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Handle h<span class="constructor">_obj(<span class="params">thread</span>, <span class="params">elem</span>-&gt;<span class="params">obj</span>()</span>);</span><br><span class="line">  <span class="keyword">assert</span>(Universe::heap<span class="literal">()</span>-&gt;is<span class="constructor">_in_reserved_or_null(<span class="params">h_obj</span>()</span>),</span><br><span class="line">          <span class="string">"must be NULL or an object"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  重点代码if()&#123;&#125;else&#123;&#125;块</span></span><br><span class="line"><span class="comment">  UseBiasedLocking是不是使用了偏向锁；</span></span><br><span class="line"><span class="comment">  这个UseBiasedLocking条件其实是JVM可以进行设置的一个启动参数；</span></span><br><span class="line"><span class="comment">  如果进行设置了启用偏向锁那么就会走if()&#123;&#125;块当中的代码；</span></span><br><span class="line"><span class="comment">  如果没有设置启用偏向锁那么则会走else&#123;&#125;块中的代码；</span></span><br><span class="line"><span class="comment">  也就是所要分析的monitor重量级锁的过程叫做slow_enter慢进入；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span>(UseBiasedLocking)&#123;</span><br><span class="line">    <span class="comment">//Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast<span class="constructor">_entry(<span class="params">h_obj</span>, <span class="params">elem</span>-&gt;<span class="params">lock</span>()</span>, <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ObjectSynchronizer::slow<span class="constructor">_enter(<span class="params">h_obj</span>, <span class="params">elem</span>-&gt;<span class="params">lock</span>()</span>, CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">assert</span>(Universe::heap<span class="literal">()</span>-&gt;is<span class="constructor">_in_reserved_or_null(<span class="params">elem</span>-&gt;<span class="params">obj</span>)</span>),</span><br><span class="line">          <span class="string">"must be NULL or an object"</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对于重量级锁，monitorenter的函数中(slow_enter最终)会调用ObjectSynchronizer::slow_enter</li>
<li>最终调用 ObjectMonitor::enter（对象监视器锁monitor的enter方法，说明还是要回到ObjectMonitor.cpp）<br>(位于：src/share/vm/runtime/objectMonitor.cpp)，源码如下：</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">void ATTR ObjectMonitor::enter(TRAPS)&#123;</span><br><span class="line">  <span class="comment">// The following code is ordered to check the most common cases first</span></span><br><span class="line">  <span class="comment">// and to reduce RTS-&gt;RTO cache line upgrades on SPARC and IA32 processors.</span></span><br><span class="line">  Thread * <span class="keyword">const</span> <span class="keyword">Self</span> = THREAD;</span><br><span class="line">  void * cur ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  通过 CAS 操作尝试把 monitor 的 _owner 字段设置为当前线程</span></span><br><span class="line"><span class="comment">  在ObjectMonitor::enter进入的时候会调用Actomic当中的cmpxchg_ptr；</span></span><br><span class="line"><span class="comment">  Atomic::cmpxchg_ptr(Self, &amp;_owner, NULL)</span></span><br><span class="line"><span class="comment">  该函数属于linux系统内存当中的一个函数最终会依赖CPU去做原子赋值操作；</span></span><br><span class="line"><span class="comment">  CAS是一个原子的赋值操作；</span></span><br><span class="line"><span class="comment">  作用就是将monitor对象当中的_owner设置成这个当前线程Self；</span></span><br><span class="line"><span class="comment">  看其是否能够设置成功</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  cur = Atomic::cmpxchg_ptr(<span class="keyword">Self</span>, &amp;_owner, <span class="keyword">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(cur == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">// Either ASSERT _recursions == 0 or explicitly Set _recursions = 0.</span></span><br><span class="line">    assert (_recursions == <span class="number">0</span> ,   <span class="string">"invariant"</span>) ;</span><br><span class="line">    assert (_owner      == <span class="keyword">Self</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">    <span class="comment">// CONSIDER: set or assert OwnerIsThread == 1</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//线程重入；recursions++</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    如果上一步骤当中设置monitor对象中的_owner设置成当前这个线程Self成功；</span></span><br><span class="line"><span class="comment">    并且当前线程Self的线程名字，即之前的_owner保存的线程就是当前线程Self的线程的名字，即名称一致的话；</span></span><br><span class="line"><span class="comment">    那么这样就意味着锁重入；即重新又进入了一个代码块有获取得到了同一把锁；</span></span><br><span class="line"><span class="comment">    那么这个时候进行monitor对象当中的_recursions变量进行++操作，即该线程的重入次数；并且return;</span></span><br><span class="line"><span class="comment">    说明当前线程竞争到该锁；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span>(cur == <span class="keyword">Self</span>)&#123;</span><br><span class="line">    <span class="comment">// TODO-<span class="doctag">FIXME:</span> : check for integer overflow! BUGID 6557169</span></span><br><span class="line">    _recursions ++;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如果当前线程第一次来抢monitor该锁；</span></span><br><span class="line"><span class="comment">如果当前线程是第一次进入该monitor，如果抢到锁了；</span></span><br><span class="line"><span class="comment">设置_recursions为1，并且将_owner设置为当前线程；</span></span><br><span class="line"><span class="comment">最后返回即表示当前线程竞争到该锁；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">Self</span> -&gt; is_lock_owned((address)cur))&#123;</span><br><span class="line">  assert (_recursions == <span class="number">0</span>, <span class="string">"internal state error"</span>);</span><br><span class="line">  _recursions = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// Commute error from a thread-specific on-stack BasicLockObject address to</span></span><br><span class="line">  <span class="comment">// a full-fledged "Thread *".</span></span><br><span class="line">  _owner = <span class="keyword">Self</span>;</span><br><span class="line">  OwnerIsThread = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略一些代码</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  那么如果经过以上操作当前线程都没有抢到锁的话；</span></span><br><span class="line"><span class="comment">  则就将进入到该for循环当中；</span></span><br><span class="line"><span class="comment">  假设第一个线程t1抢到锁进入到了同步代码块当中；</span></span><br><span class="line"><span class="comment">  那么第二个线程t2就由于t1线程已经抢到锁且当前时间内没有进行释放锁的缘故第二个线程没有抢到锁；</span></span><br><span class="line"><span class="comment">  那么抢不到锁的第二个线程t2就会执行方法EnterI(THREAD)；</span></span><br><span class="line"><span class="comment">  最终进入到monitor对象的成员变量_cxq单向列表当中进行等待获取锁；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">    jt-&gt;set_suspend_equivalent();</span><br><span class="line">    <span class="comment">// cleared by handle_special_suspend_equivalent_condition()</span></span><br><span class="line">    <span class="comment">// or java_suspend_self()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果获取锁失败，则等待锁的释放</span></span><br><span class="line">    EnterI(THREAD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!ExitSuspendEquivalent(jt)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// we have acquired the contended monitor, but while we were</span></span><br><span class="line">    <span class="comment">// waiting another thread suspended us. We don't want to enter</span></span><br><span class="line">    <span class="comment">// the monitor while suspend because that would surprise the</span></span><br><span class="line">    <span class="comment">// thread that suspended us.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">      _recursions = <span class="number">0</span>;</span><br><span class="line">    _succ = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="keyword">false</span>, <span class="keyword">Self</span>);</span><br><span class="line"></span><br><span class="line">    jt-&gt;java_suspend_self();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">Self</span>-&gt;set_current_pending_monitor(<span class="keyword">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处省略<strong>锁的自旋优化</strong>等操作，统一放在后面<strong>synchronized优化</strong>中说。<br>以上代码的具体流程概括如下：</p>
<p><strong>1、</strong> 通过 CAS 尝试把monitor的 _owner字段设置为当前线程（即把monitor的_owner成员变量的属性取值设置为竞争的该线程；如果设置成功则说明该线程竞争到了锁）<br><strong>2、</strong> 如果设置之前的_owner指向当前线程，说明当前线程再次进入monitor，即重入锁，执行recursions++，记录重入的次数；（如果在这之前的上一次竞争当前线程获取得到了该锁，那么现在当次竞争当前线程又竞争到了该锁；两把锁一样；那么说明是锁重入；）<br><strong>3、</strong> 如果当前线程是第一次进入该monitor，设置recursions为1，_owner为当前线程，该线程成功获得锁并返回。<br><strong>4、</strong> 如果获取锁失败，则等待锁的释放(进入阻塞等待状态，即进入到monitor对象的成员变量_cxq单向列表队列)；</p>
<h2 id="深入JVM源码-monitor等待"><a href="#深入JVM源码-monitor等待" class="headerlink" title="深入JVM源码-monitor等待"></a>深入JVM源码-monitor等待</h2><h3 id="回顾并引入"><a href="#回顾并引入" class="headerlink" title="回顾并引入"></a>回顾并引入</h3><p>当前在竞争monitor对象锁的时候会发现；<br>有一个线程会竞争到monitor并且让线程接着往下执行；<br>但是有一些线程竞争不到monitor那么这个时候它会执行EnterI(THREAD)这个函数；<br>也就是说没有抢到锁的线程会进入等待处于阻塞状态；<br>那么接下来也就是学习monitor等待过程；也就是EnterI(THREAD)方法；</p>
<p>monitor等待</p>
<p>竞争失败等待调用的是 ObjectMonitor对象的EnterI(THREAD)方法<br>（位于：/src/share/vm/runtime/ObjectMonitor.cpp），<br>源码如下所示：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 截取部分代码分析</span></span><br><span class="line">void ATTR ObjectMonitor::EnterI(THREAD)&#123;</span><br><span class="line">  Thread * <span class="keyword">Self</span> = THREAD;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try the lock - TATAS</span></span><br><span class="line">  <span class="keyword">if</span>(TryLock (<span class="keyword">Self</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    assert (_succ        != <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">    assert (_owner       == <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">    assert (_Responsible != <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(TrySpin (<span class="keyword">Self</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    assert (_succ        == <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">    assert (_owner       != <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">    assert (_Responsible != <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ</span></span><br><span class="line">  ObjectWaiter node(<span class="keyword">Self</span>);</span><br><span class="line">  <span class="keyword">Self</span>-&gt;ParkEvent-&gt;reset();</span><br><span class="line">  node._prev  = (ObjectWaiter *) <span class="number">0xBAD</span>;</span><br><span class="line">  node.TState = ObjectWaiter::TS_CXQ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过CAS把node节点push到_cxq列表中</span></span><br><span class="line">  ObjectWaiter * nxt;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    node._next = next = _cxq;</span><br><span class="line">    <span class="keyword">if</span>(Atomic::cmpxchg_ptr(&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interference - the CAS failed because _cxq changed. Just retry.</span></span><br><span class="line">    <span class="comment">// As an optional optimization we retry the lock.</span></span><br><span class="line">    <span class="keyword">if</span>(TryLock(<span class="keyword">Self</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(TryLock (<span class="keyword">Self</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          assert (_succ        != <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">          assert (_owner       == <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">          assert (_Responsible != <span class="keyword">Self</span>              , <span class="string">"invariant"</span>);</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">      <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="comment">// 线程在挂起前做一下挣扎，看能不能获取到锁</span></span><br><span class="line">        <span class="keyword">if</span>(TryLock (<span class="keyword">Self</span>) &gt; <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        assert (_owner != <span class="keyword">Self</span>, <span class="string">"inveriant"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((SyncFlags &amp; <span class="number">2</span>) &amp;&amp; _Reponsible == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">          Atomic::cmpxchg_ptr (<span class="keyword">Self</span>, &amp;_Reponsible, <span class="keyword">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// park self</span></span><br><span class="line">        <span class="keyword">if</span>(_Responsible == <span class="keyword">Self</span> || (SynchFlags &amp; <span class="number">1</span>))&#123;</span><br><span class="line">          TEVENT (Inflated enter - park TIMED);</span><br><span class="line">          <span class="keyword">Self</span>-&gt;_ParkEvent-&gt;park((jlong)RecheckInterval);</span><br><span class="line">          <span class="comment">// Increase the RecheckInterval, but clamp the value.</span></span><br><span class="line">          RecheckInterval *= <span class="number">8</span>；</span><br><span class="line">          <span class="keyword">if</span>(RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          TEVENT (Inflated enter - park UNTIMED);</span><br><span class="line">          <span class="comment">// 通过park将当前线程挂起，等待被唤醒</span></span><br><span class="line">          <span class="keyword">Self</span>-&gt;_ParkEvent-&gt;park();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(TryLock(<span class="keyword">Self</span>) &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">java代码：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(String[] args)&#123;</span><br><span class="line">  synchronized(obj)&#123;</span><br><span class="line">    System.out.println(<span class="string">"1"</span>);</span><br><span class="line">    obj.wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">看图说话：</span><br><span class="line"></span><br><span class="line">假设t1线程没有竞争得到锁；则t1线程就将要去处于等待状态；</span><br><span class="line">那么这个处于等待这个动作是如何做的呢？</span><br><span class="line"></span><br><span class="line">首先这个t1线程会进入EnterI(THREAD)方法当中；</span><br><span class="line">进入EnterI(THREAD)方法之后；</span><br><span class="line">那么会先去进行执行TryLock(<span class="keyword">Self</span>)尝试获取锁操作；</span><br><span class="line">即t1线程虽然没有抢到锁但是它还会继续TryLock(THREAD)进行尝试一下，最后做一下挣扎；</span><br><span class="line">如果在这个挣扎过程中抢到了锁则后面接着执行；</span><br><span class="line">如果在这个挣扎过程中没有抢到锁那么就会继续往下走会执行函数TrySpin(<span class="keyword">Self</span>)函数；</span><br><span class="line">那么函数TrySpin(<span class="keyword">Self</span>)函数的作用就在于自旋；</span><br><span class="line">自旋即意味着进入一个循环当中多次进行抢一抢锁看能不能够抢到该锁；</span><br><span class="line">即再次挣扎一下看能不能再次抢救一下；</span><br><span class="line">如果经过TryLock尝试获取锁以及TrySpin自旋之后还是没有办法获取得到锁；</span><br><span class="line">那么这个时候就会走到下面来；</span><br><span class="line">就会将当前这个没有抢到锁且经过TryLock以及TrySpin后依然没有抢到锁的t1线程放到ObjectWaiter中来并进行封装起来；</span><br><span class="line">ObjectWaiter即一个等待的线程；</span><br><span class="line">并且会将当前这个没有抢到锁的线程状态设置为ObjectWaiter当中的TS_CXQ状态取值；</span><br><span class="line">接着通过CAS把即将要等待的线程t1线程push到_cxq单向列表当中去；</span><br><span class="line">但是可能有一个线程抢到也有其他很多线程没有抢到锁；</span><br><span class="line">那么这些很多没有抢到锁的线程都要被push到这个_cxq节点上面来；</span><br><span class="line">那么因此这个没有抢到锁的线程要被push到_cxq结点上去的这一操作也可能会成功也有可能会失败；</span><br><span class="line">所以这一操作即没有抢到锁的线程都要被push到_cxq结点上去也是使用到了一个<span class="keyword">for</span>循环加上Atomic::cmpxchg_ptr该内核函数；即CAS一次不行就再重试再重试；直到几个没有成功获取得到锁的线程都被挂在结点_cxq单向列表上；</span><br><span class="line">另外在每次重试的时候，都会再去进行重试挣扎一下即TryLock看能不能抢到锁；</span><br><span class="line">那么经过<span class="keyword">for</span>(;;)循环之后这几个没有获取得到锁的线程都会被挂在_cxq结点单向列表上；</span><br><span class="line">当没有获取得到锁的线程放到结点_cxq单向列表当中之后；那么还要将该线程进行挂起操作；即下面的代码；</span><br><span class="line">在挂起的时候首先它也还是会去进行TryLock尝试挣扎抢救一下去获取锁，看能不能获取得到锁；得不到锁则继续往下走；继续往下走存在<span class="keyword">if</span>()&#123;&#125;<span class="keyword">else</span>&#123;&#125;块但是无论走哪一块最终都会导致当前线程执行park()，park就是把当前线程进行挂起；</span><br><span class="line">那么在当前该线程被挂起之后那么该线程就不会再进行执行了，那么这个时候就只有等待别的线程来进行唤醒的时候才会进行继续执行；</span><br><span class="line">那么不管是从<span class="keyword">if</span>()&#123;&#125;或者是<span class="keyword">else</span>&#123;&#125;块当中的点开始进行被唤醒，当该线程被唤醒之后都会去进行尝试抢锁即TryLock(<span class="keyword">Self</span>)；看是否能够获取得到锁；</span><br></pre></td></tr></table></figure>

<p>当该线程被唤醒时，会从挂起的点继续执行，通过<code>ObjectMonitor::TryLock</code>尝试获取锁,TryLock方法实现如下：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 截取部分代码</span></span><br><span class="line"><span class="keyword">int</span> ObjectMonitor::TryLock(Thread * <span class="keyword">Self</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    void * own = _owner;</span><br><span class="line">    <span class="keyword">if</span>(own != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Atomic::cmpxchg_ptr (<span class="keyword">Self</span>, &amp;_owner, <span class="keyword">NULL</span>) == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">      <span class="comment">// Either guarantee _recursions == 0 or set _recursions = 0.</span></span><br><span class="line">      assert (_recursions == <span class="number">0</span>,    <span class="string">"invariant"</span>);</span><br><span class="line">      assert (_owner      == <span class="keyword">Self</span>, <span class="string">"invariant"</span>);</span><br><span class="line">      <span class="comment">// CONSIDER: set or assert that OwnerIsThread == 1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The lock had been freen momentarily, but we lost the race to the lock.</span></span><br><span class="line">    <span class="comment">// Interference -- the CAS faild.</span></span><br><span class="line">    <span class="comment">// we can either return -1 or retry.</span></span><br><span class="line">    <span class="comment">// Retry doesn't make as much sense because the lock was just acquired.</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">true</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">尝试锁也是使用的CAS操作去进行做一个判断；</span><br><span class="line">如果尝试获取得到锁那么就会返回<span class="number">1</span>；</span><br><span class="line">如果尝试没有获取得到锁那么就会返回<span class="number">-1</span>；</span><br></pre></td></tr></table></figure>

<h3 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h3><p>首先第一个；当线程没有抢到锁那么就将会被放到_cxq单向列表当中去；<br>那么该流程的第一步骤：<br>以上代码的具体流程如下：</p>
<p><strong>1、</strong> 当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ。<br><strong>2、</strong> 在for循环中（用CAS尝试把当前该线程放到_cxq的一个节点上去；因为同时有多个线程往单向列表_cxq当中放，所以使用了for循环，CAS多次尝试），通过CAS把node节点push到_cxq列表中，同一时刻可能有多个线程把自己的node节点push到_cxq列表中。<br><strong>3、</strong> （没有抢到锁的线程在放到_cxq节点上之前）node结点push到_cxq列表之后，通过自旋尝试获取锁，如果还是没有获取得到锁，则通过park将当前线程挂起（park内核函数，让当前线程进行挂起那么其实也就相当于阻塞状态需要别的线程进行唤醒才能够继续往下执行），等待被唤醒。<br><strong>4、</strong> 当该线程被唤醒时，会从挂起的点继续执行，通过<code>ObjectWaiter::TryLock</code>尝试获取锁。</p>
<h2 id="深入JVM源码-monitor释放"><a href="#深入JVM源码-monitor释放" class="headerlink" title="深入JVM源码-monitor释放"></a>深入JVM源码-monitor释放</h2><h3 id="目标-14"><a href="#目标-14" class="headerlink" title="目标"></a>目标</h3><p>分成两个部分来进行学习；<br>首先进行介绍什么时候monitor会进行释放；<br>接着进行介绍monitor的释放过程是什么样的；</p>
<h3 id="monitor释放分析"><a href="#monitor释放分析" class="headerlink" title="monitor释放分析"></a>monitor释放分析</h3><p>当某个持有锁的线程执行完同步代码块时，会进行锁的释放，给其他线程机会执行同步代码块。<br>在HotSpot中，通过推出monitor的方式实现锁的释放，并通知被阻塞的线程，具体实现位于ObjectMonitor的exit方法中。<br>（位于：/src/share/vm/runtime/ObjectMonitor.cpp），源码如下所示:</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 截取部分代码</span></span><br><span class="line">void ATTR ObjectMonitor::exit(<span class="keyword">bool</span> not_suspended, TRAPS)&#123;</span><br><span class="line">  Thread * <span class="keyword">Self</span> = THREAD;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  <span class="keyword">if</span>(_recursions != <span class="number">0</span>)&#123;</span><br><span class="line">    _recursions--;    <span class="comment">// this is simple recursive enter</span></span><br><span class="line">    TEVENT (Inflated <span class="keyword">exit</span> - recursive);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">  ObjectWaiter * w = <span class="keyword">NULL</span>;</span><br><span class="line">  <span class="keyword">int</span> QMode = Knob_QMode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// qmode = 2：直接绕过EntryList队列，从_cxq队列中获取线程用于竞争锁</span></span><br><span class="line">  <span class="keyword">if</span>(QMode == <span class="number">2</span> &amp;&amp; _cxq != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">    w = _cxq;</span><br><span class="line">  assert ( w != <span class="keyword">NULL</span>, <span class="string">"invariant"</span>);</span><br><span class="line">  assert ( w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"invariant"</span>);</span><br><span class="line">  ExitEpilog(<span class="keyword">Self</span>, w);</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// qmode=3：cxq队列插入EntryList尾部；</span></span><br><span class="line">  <span class="keyword">if</span>(QMode == <span class="number">3</span> &amp;&amp; _cxq != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">    w = _cxq;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      assert (w != <span class="keyword">NULL</span>, <span class="string">"Invariant"</span>);</span><br><span class="line">      ObjectWaiter * u = (ObjectWaiter *)Atomic::cmpxchg_ptr (<span class="keyword">NULL</span>, &amp;_cxq, w);</span><br><span class="line">      <span class="keyword">if</span>( u == w ) <span class="keyword">break</span>;</span><br><span class="line">      w = u;</span><br><span class="line">    &#125;</span><br><span class="line">    assert( w != <span class="keyword">NULL</span> , <span class="string">"invariant"</span>);</span><br><span class="line"></span><br><span class="line">    ObjectWaiter * q = <span class="keyword">NULL</span>;</span><br><span class="line">    ObjectWaiter * p;</span><br><span class="line">    <span class="keyword">for</span>( p = w ;  p != <span class="keyword">NULL</span> ; p = p-&gt;_next)&#123;</span><br><span class="line">      guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"Invariant"</span>);</span><br><span class="line">      p-&gt;TState = ObjectWaiter::TS_ENTER;</span><br><span class="line">      p-&gt;prev = q;</span><br><span class="line">      q = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectWaiter * Tail;</span><br><span class="line">    <span class="keyword">for</span> ( Tail = _EntryList; Tail != <span class="keyword">NULL</span> &amp;&amp; Tail-&gt;_next != <span class="keyword">NULL</span>; Tail = Tail-&gt;_next);</span><br><span class="line">    <span class="keyword">if</span>(Tail == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">      _EntryList = w;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      Tail-&gt;_next = w;</span><br><span class="line">      w-&gt;_prev = Tail;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// qmode=4: cxq队列插入到_EntryList头部</span></span><br><span class="line">  <span class="keyword">if</span>(QMode == <span class="number">4</span> &amp;&amp; _cxq != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">    w = _cxq;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      assert (w != <span class="keyword">NULL</span>, <span class="string">"Invariant"</span>);</span><br><span class="line">      ObjectWaiter * u = (ObjectWaiter *)Atomic::cmpxchg_ptr(<span class="keyword">NULL</span>, &amp;_cxq, w);</span><br><span class="line">      <span class="keyword">if</span>(u == w) <span class="keyword">break</span>;</span><br><span class="line">      w = u;</span><br><span class="line">    &#125;</span><br><span class="line">    assert (w != <span class="keyword">NULL</span> , <span class="string">"invariant"</span>);</span><br><span class="line"></span><br><span class="line">    ObjectWaiter * q = <span class="keyword">NULL</span>;</span><br><span class="line">    ObjectWaiter * p;</span><br><span class="line">    <span class="keyword">for</span>( p = w; p != <span class="keyword">NULL</span> ; p -&gt;_next)&#123;</span><br><span class="line">      guarantee(p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"Invariant"</span>);</span><br><span class="line">      p-&gt;TState = ObjectWaiter::TS_ENTER;</span><br><span class="line">      p-&gt;_prev = q;</span><br><span class="line">      q = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_EntryList != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">      q-&gt;_next = _EntryList;</span><br><span class="line">      _EntryList-&gt;_prev = q;</span><br><span class="line">    &#125;</span><br><span class="line">    _EntryList = w;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  w = _EntryList;</span><br><span class="line">  <span class="keyword">if</span>(w != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">    assert (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">"invariant"</span>);</span><br><span class="line">    ExitEpilog(<span class="keyword">Self</span>, w);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  w = _cxq;</span><br><span class="line">  <span class="keyword">if</span>(w == <span class="keyword">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    assert (w != <span class="keyword">NULL</span>, <span class="string">"Invariant"</span>);</span><br><span class="line">    ObjectWaiter * u = (ObjectWaiter *)Atomic::cmpxchg_ptr(<span class="keyword">NULL</span>, &amp;_cxq, w);</span><br><span class="line">    <span class="keyword">if</span>(u == w) <span class="keyword">break</span>;</span><br><span class="line">    w = u;</span><br><span class="line">  &#125;</span><br><span class="line">  TEVENT(Inflated <span class="keyword">exit</span> - drain cxq into EntryList);</span><br><span class="line"></span><br><span class="line">  assert( w          != <span class="keyword">NULL</span> , <span class="string">"invariant"</span>);</span><br><span class="line">  assert( _EntryList != <span class="keyword">NULL</span> , <span class="string">"invariant"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(QMode == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// QMode == 1: drain cxq to EntryList,reversing order</span></span><br><span class="line">    <span class="comment">// we also reverse the order of the list</span></span><br><span class="line">    ObjectWaiter * s = <span class="keyword">NULL</span>;</span><br><span class="line">    ObjectWaiter * t = w;</span><br><span class="line">    ObjectWaiter * u = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(t != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">      guarantee(t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"invariant"</span>);</span><br><span class="line">      t-&gt;TState = ObjectWaiter::TS_ENTER;</span><br><span class="line">      u = t-&gt;_next;</span><br><span class="line">      t-&gt;_prev = u;</span><br><span class="line">      t-&gt;_next = s;</span><br><span class="line">      s = t;</span><br><span class="line">      t = u;</span><br><span class="line">    &#125;</span><br><span class="line">    _EntryList = s;</span><br><span class="line">    assert(s != <span class="keyword">NULL</span>, <span class="string">"invariant"</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// QMode ==0 or QMode == 2</span></span><br><span class="line">    _EntryList = w;</span><br><span class="line">    ObjectWaiter * q = <span class="keyword">NULL</span>;</span><br><span class="line">    ObjectWaiter * p;</span><br><span class="line">    <span class="keyword">for</span>(p = w; p != <span class="keyword">NULL</span>; p = p-&gt;_next)&#123;</span><br><span class="line">      guarantee(p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"Invariant"</span>);</span><br><span class="line">      p-&gt;TState = ObjectWaiter::TS_ENTER;</span><br><span class="line">      p-&gt;_prev = q;</span><br><span class="line">      q = p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_succ != <span class="keyword">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  w = _EntryList;</span><br><span class="line">  <span class="keyword">if</span>(w != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">    guarantee(w -&gt; TState == ObjectWater::TS_ENTER, <span class="string">"invariant"</span>);</span><br><span class="line">    ExitEpilog(<span class="keyword">Self</span>, w);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">java代码：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(String[] args)&#123;</span><br><span class="line">  synchronized(obj)&#123;</span><br><span class="line">    System.out.println(<span class="string">"1"</span>);</span><br><span class="line">    obj.wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">第一部分：什么时候释放monitor分析：</span><br><span class="line">获得锁的线程t1执行完同步代码块当中的代码之后，</span><br><span class="line">那么就需要出同步代码块；</span><br><span class="line">在出同步代码块的时候就会进行monitor的释放操作；</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">第二部分：monitor释放的过程是怎么样的分析：</span><br><span class="line">在<span class="keyword">exit</span>的释放过程当中；</span><br><span class="line">如果_recursions计数器不等于<span class="number">0</span>；</span><br><span class="line">那么_recursions就会去做一个--即减一操作；再去<span class="keyword">return</span>；</span><br><span class="line">那么这个其实对应着的是重入锁；</span><br><span class="line">_recursions当不为<span class="number">0</span>的情况下会进行--即减一操作；</span><br><span class="line">如果_recursions等于<span class="number">0</span>的情况下那么就表示线程完全出了同步代码块，</span><br><span class="line">且把锁释放返回了；</span><br><span class="line">那么这个时候除了释放锁之外还需要做一个操作；</span><br><span class="line">即去唤醒之前正在等待阻塞中的线程；那么需要唤醒哪一个线程呢？</span><br><span class="line">这个时候就需要注意了；有两个链表当中都存放有需要被唤醒的线程；</span><br><span class="line">即一个是_cxq；另外一个是EntryList；</span><br><span class="line">那么是随机唤醒某一个线程即有可能合适唤醒_cxq列表当中的线程也有可能是唤醒_EntryList当中的线程；</span><br><span class="line"></span><br><span class="line">所以继续往下看；</span><br><span class="line">ObjectWaiter是之前被阻塞进行等待的一个线程的一个封装；</span><br><span class="line">需要记住的是w，找到了w即找到了需要被唤醒的线程；</span><br><span class="line"></span><br><span class="line">在<span class="keyword">exit</span>当中提供很多种模式；</span><br><span class="line">模式一：</span><br><span class="line">如果QMode等于<span class="number">2</span>；那么这个时候会让w等于_cxq的首节点即链表头；</span><br><span class="line">那么也就取到了这个要被唤醒的线程；</span><br><span class="line">那么这一种方法绕过了_EntryList当中被阻塞的线程直接取_cxq列表当中的线程作为要被唤醒的线程对象；</span><br><span class="line">另外方法ExitEpilog(<span class="keyword">Self</span>,w)方法就是去作为唤醒线程的方法；</span><br><span class="line">模式二：</span><br><span class="line">如果QMode等于<span class="number">3</span>；首先要被唤醒的线程w也是等于_cxq的首节点；</span><br><span class="line">并且会将_cxq的这些节点放到_EntryList的尾部去；</span><br><span class="line">模式三：</span><br><span class="line">如果QMode等于<span class="number">4</span>；则那么首先这个要被唤醒的线程也是等于_cxq的首节点；</span><br><span class="line">并且会将_cxq列表当中的元素插入到_EntryList列表的头部；</span><br><span class="line">etc...</span><br><span class="line"></span><br><span class="line">那么最后就找到了w，即需要被唤醒的线程；</span><br><span class="line">那么也会去调用到方法ExitEpilog(<span class="keyword">Self</span>, w);</span><br><span class="line">即唤醒w线程；</span><br><span class="line">ExitEpilog即为具体唤醒的过程；</span><br></pre></td></tr></table></figure>

<p><strong>1、</strong> 退出同步代码块时 会让_recursions减1，当_recursions的值减为0时，说明（线程完全退出了同步代码块中）线程释放了锁；<br><strong>2、</strong> （释放完锁之后需要唤醒线程）根据不停的策略（策略不同唤醒不同的线程）（由QMode指定），从_cxq或_EntryList中获取头节点，通过<code>ObjectMonitor::ExitEpilog</code>方法唤醒该节点封装的线程，唤醒操作最终由unpack完成（将之前park的线程进行唤醒），实现如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment"># 截取部分代码</span></span><br><span class="line">void ObjectMonitor::ExitEpilog(Thread * <span class="keyword">Self</span>, ObjectWaiter * wakee)&#123;</span><br><span class="line">  assert( _owner == <span class="keyword">Self</span>, <span class="string">"invariant"</span>);</span><br><span class="line"></span><br><span class="line">  _succ = Knob_SuccEnabled ? wakee-&gt;_thread : <span class="keyword">NULL</span>;</span><br><span class="line">  ParkEvent * Trigger = wakee-&gt;_event;</span><br><span class="line"></span><br><span class="line">  wakee = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop the lock</span></span><br><span class="line">  OrderAccess::release_store_ptr(&amp;_owner, <span class="keyword">NULL</span>);</span><br><span class="line">  OrderAccess::fence();           <span class="comment">// ST _owner vs LD in unpark()</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(SafepointSynchronize::do_call_back())&#123;</span><br><span class="line">    TEVENT(unpack before SAFEPOINT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DTRACE_MONITOR_PROBE(contended__exit, this, object(), <span class="keyword">Self</span>);</span><br><span class="line">  Trigger-&gt;unpark();  <span class="comment">// 唤醒之前被park()挂起的线程</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Maintain stats and report events to JVMTI</span></span><br><span class="line">  <span class="keyword">if</span> (ObjectMonitor::_synch_Parks != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">    ObjectMonitor::_sync_Parks-&gt;inc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">分析：</span><br><span class="line">最重要的代码在于Trigger-unpark();</span><br><span class="line">unpark的含义即代表：</span><br><span class="line">假设找到线程t1要被唤醒；</span><br><span class="line">那么找到这个线程t1之后；调用unpark()方法就会将线程t1进行唤醒；</span><br><span class="line">那么也就是说这个t1线程就又能够有有机会去获取竞争得到锁从而进入到同步代码块当中去；</span><br><span class="line">执行完unpark之后就会将需要唤醒的线程进行唤醒；</span><br><span class="line">唤醒完成之后就会进入到之前park()让该线程挂起的代码行中；</span><br><span class="line">那么后面当unpark()将该需要唤醒的线程唤醒之后，就又会去进行执行TryLock尝试获取锁的代码；抢到锁则进入到同步代码块当中去；</span><br></pre></td></tr></table></figure>

<p>被唤醒的线程，会回到void ATTR ObjectMonitor::EnterI(TRAPS)的第600行，继续执行monitor的竞争。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 截取部分代码</span></span><br><span class="line"><span class="comment">// park self</span></span><br><span class="line"><span class="keyword">if</span>(_REsponsible == <span class="keyword">Self</span> || (SynchFlags &amp; <span class="number">1</span>))&#123;</span><br><span class="line">  TEVENT (Inflated enter - park TIMED);</span><br><span class="line">  <span class="keyword">Self</span>-&gt;_ParkEvent-&gt;park((jlong) RecheckInterval);</span><br><span class="line">  <span class="comment">// Increase the RecheckInterval , but clamp the value.</span></span><br><span class="line">  RecheckInterval *= <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">if</span>(RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  TEVENT (Infalted enter - park UNTIMED);</span><br><span class="line">  <span class="keyword">Self</span>-&gt;_ParkEvent-&gt;park();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(TryLock(<span class="keyword">Self</span>) &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h2 id="深入JVM源码-monitor是重量级锁"><a href="#深入JVM源码-monitor是重量级锁" class="headerlink" title="深入JVM源码-monitor是重量级锁"></a>深入JVM源码-monitor是重量级锁</h2><p>synchronized代码块在代码执行的时候效率比较低；<br>因为synchronized所关联的锁对象monitor是一个重量级锁；</p>
<h3 id="目标-15"><a href="#目标-15" class="headerlink" title="目标"></a>目标</h3><p>monitor为什么属于一个重量级锁？<br>monitor为什么效率比较低？</p>
<p>可以看到 ObjectMonitor 的函数调用中 会涉及到 Atomic::cmpxchg_ptr，Atomic::inc_ptr等内核函数，执行同步代码块，没有竞争到锁的对象会执行调用park()被挂起，竞争到锁的线程执行完成退出同步代码块时（即当其他线程退出同步代码块时）会调用unpark()唤醒上次那些没有竞争到锁从而被park()挂起的线程；<br>（这个park和unpark也属于内核函数；即也就是说synchronized在执行的时候会涉及到大量的内核函数的执行，而内核函数的执行就会涉及到操作系统中用户态和内核态的一个切换；）<br>这个时候就会存在操作系统 用户态和内核态的转换，这种转换会消耗大量的系统资源。<br>所以synchronized是java语言中的一个重量级（Heavyweight）的操作。<br>用户态和内核态是什么东西呢？<br>要想了解用户态和内核态还需要先了解一下Linux系统的体系架构：</p>
<p>linux系统的体系架构由<br>内核（操作系统的内核，而内核本质上也是一种应用程序；作用是来控制计算机的硬件资源的，比如说控制硬盘、那么还有可能控制内存等控制网络等相关的一些硬件设备比如说网卡、声卡、键盘、鼠标等）；<br>系统调用、shell、公用函数库；<br>应用程序（用户空间）<br>（自己写的程序被称为普通的应用程序；用户空间其实指的是自己所编写的应用程序所运行的那一块内存空间就成为用户空间；而应用程序在用户空间进行运行的时候就有可能会涉及到一些硬件资源的调用；那么这个时候就需要靠内核来进行去操作硬件资源；那么用户空间去调用内核的时候，就需要通过系统调用才能够进行；那么系统调用的作用即在于让在用户空间的应用程序能够去调用内核的一些内核函数；那么系统调用可以看做是提供内核的接口供外层的应用程序来进行调用；）<br>这几个部分来进行组成；</p>
<p>从上图可以看出，linux操作系统的体系架构分为：用户空间（应用程序的活动空间）和内核。<br>内核：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境。<br>用户空间：上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。<br>系统调用：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用；<br>所有进程初始都运行于用户空间，此时即为用户运行状态（简称：用户态）；<br>（当应用程序需要用到键盘、需要去读取文件、需要通过网络去发送一些资源的时候那么说白了也就是需要用到计算机的一些硬件资源的时候；那么这个时候就需要通过系统调用到内核来帮助执行；普通的应用程序在用户空间当中运行那么就称之为用户态；当应用程序如果需要调用内核的一些功能，即通过系统调用来进行调用内核当中的一些功能；那么这个时候应用程序就会进入内核态；那么用户态与内核态的切换是需要系统调用来进行的；）<br>但是当它调用系统调用执行某些操作时，例如I/O调用，此时需要陷入内核中运行，就称之为 进程处于内核运行态（或简称为 内核态）。</p>
<p>系统调用的过程可以简单理解为：</p>
<p><strong>1、</strong> 用户态程序将一些数据值放在寄存器中，或者使用参数创建一个堆栈，以此表明需要操作系统提供的服务。<br><strong>2、</strong> 用户态程序执行系统调用。<br><strong>3、</strong> CPU切换到内核态，并跳到 位于内存指定位置 的指令。<br><strong>4、</strong> 系统调用处理器（system call handler）会读取程序放入内存的数据参数，并执行程序请求的服务。<br><strong>5、</strong> 系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果。</p>
<p>首先应用程序属于用户态；即将调用内核函数的时候，那么应用程序会把现在程序的一个运行状态主要是程序运行的一些运行数值进行保存可能会保存在寄存器当中也有可能使用参数创建一个堆栈来保存现在应用程序的一些运行信息运行参数；<br>那么接着用户态的应用程序就会来进行执行系统调用；<br>那么经过系统调用之后，CPU就会切换到内核态；然后到内存当中指定的位置去执行相关指令；<br>接下来系统调用处理器它会进行用户态当中应用程序保存在堆栈或者是保存在寄存器当中的一些运行信息运行数据，然后并且会执行相应的内核函数以及请求一些内核的服务；<br>那么这个时候系统就由用户态切换到了内核态；<br>那么接着内核函数的调用在系统调用中调用完毕之后；<br>操作系统会进行重置CPU又切换为用户态；并且将内核态当中调用的结果进行返回；那么应用程序就又回到了用户空间；得到了内核函数系统调用返回的结果数据；</p>
<p>由此可见，用户态切换至内核态 需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器值、变量等，以备内核态切换回用户态。<br>这种切换就带来了大量的系统资源消耗，这就是synchronized未优化之前，效率低的原因（属于重量级锁）。</p>
<h3 id="monitor是重量级锁"><a href="#monitor是重量级锁" class="headerlink" title="monitor是重量级锁"></a>monitor是重量级锁</h3><p>在虚拟机规范对 monitorenter 和 monitorexit 的行为描述中，<br>有两点是需要特别注意的。  </p>
<p>首先，synchronized同步块 对 同一条线程来说是可重入的，不会出现自己把自己锁死的问题。</p>
<p>其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。  </p>
<p>第12章讲过，java的线程 是 映射到 操作系统的 原生线程 之上的，<br>如果要 阻塞或唤醒 一个线程，都需要操作系统来帮忙完成， 这就需要从用户态转换到核心态中，因此 状态转换需要耗费很多的处理器时间。</p>
<p>对于代码简单的同步块（如被synchronized修饰的 getter()或setter()方法），<br>状态转换消耗的时间 有可能比 用户代码执行的时间还要长。</p>
<p>所以 synchronized 是java语言中一个重量级（Heavyweight）的操作，有经验的程序员都会在确实必要的情况下才使用这种操作。  </p>
<p>而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态之中。  </p>
<p>可以看到ObjectMonitor的函数调用中会涉及到 Atomic::cmpxchg_ptr，Atomic::inc_prt等内核函数，这个时候就会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。</p>
<p>用户态和内核态是什么东西呢？<br>要想了解用户态和内核态还需要先了解一下Linux系统的体系架构：</p>
<h2 id="synchronized优化-CAS-AtomicInteger使用"><a href="#synchronized优化-CAS-AtomicInteger使用" class="headerlink" title="synchronized优化_CAS_AtomicInteger使用"></a>synchronized优化_CAS_AtomicInteger使用</h2><blockquote>
<p>第六章：JDK6 synchronized优化</p>
</blockquote>
<ul>
<li>CAS<ul>
<li>JDK6当中对synchronized所做的优化处理；</li>
<li>在JDK6当中对synchronized做了大量的优化处理；</li>
<li>以及这些优化处理很多都涉及到了CAS操作；</li>
</ul>
</li>
<li>锁升级过程<ul>
<li>锁升级依赖java对象头；</li>
</ul>
</li>
<li>Java对象的布局</li>
<li>偏向锁</li>
<li>轻量级锁</li>
<li>重量级锁</li>
<li>锁消除</li>
<li>锁优化</li>
<li>平时写代码如何对synchronized优化</li>
</ul>
<h3 id="目标-16"><a href="#目标-16" class="headerlink" title="目标"></a>目标</h3><p>学习CAS的作用<br>学习CAS的原理</p>
<h3 id="CAS概述和作用"><a href="#CAS概述和作用" class="headerlink" title="CAS概述和作用"></a>CAS概述和作用</h3><p>CAS的全称是 Compare And Swap（比较再交换）。<br>（确切一点称之为：比较并且相同再做交换）<br>是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。</p>
<p>CAS的作用是：CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理器CPU保证。<br>CAS可以保证共享变量赋值时的原子操作；<br>CAS在操作时依赖三个值；内存中的值V、旧的预估值X、要修改的新值B，<br>如果旧的预估值X等于内存中的值V，就将新的值B保存到内存中；替换这个内存中的值V；</p>
<p>(可以看做是一个轻量级的synchronized，它能保证变量修改的原子操作)</p>
<h4 id="CAS和volatile实现无锁并发"><a href="#CAS和volatile实现无锁并发" class="headerlink" title="CAS和volatile实现无锁并发"></a>CAS和volatile实现无锁并发</h4><p>java当中已经提供好了一个类叫做AtomicInteger；<br>这个类其底层即使用的就是CAS；</p>
<blockquote>
<p>回顾代码</p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo05_cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)<span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    Runnable mr = ()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(mr);</span><br><span class="line">      t.start();</span><br><span class="line">      ts.<span class="built_in">add</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t:ts)&#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"number = "</span> + atomicInteger.<span class="built_in">get</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：演示原子性问题</span></span><br><span class="line"><span class="comment">    1. 定义一个共享变量</span></span><br><span class="line"><span class="comment">    2. 对number进行1000次的++操作</span></span><br><span class="line"><span class="comment">    3. 使用5个线程来进行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span>&#123;</span></span><br><span class="line">  <span class="comment">// 1. 定义一个共享变量</span></span><br><span class="line">  <span class="comment">//private static int number = 0;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">// 2. 对number进行1000的++操作</span></span><br><span class="line">    Runnable increment = ()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//number++;</span></span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Thread&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">    <span class="comment">// 3. 使用5个线程来进行</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">      t.start();</span><br><span class="line">      <span class="built_in">list</span>.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t: <span class="built_in">list</span>)&#123;</span><br><span class="line">      t.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//System.out.println("number = " + number);</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"atomicInteger = "</span> + atomicInteger.<span class="built_in">get</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">由于number++并不是原子操作；</span></span><br><span class="line"><span class="comment">所以就会导致原子性问题的产生；</span></span><br><span class="line"><span class="comment">即最后会导致number输出时number的值是小于5000的；</span></span><br><span class="line"><span class="comment">  private static int number = 0;</span></span><br><span class="line"><span class="comment">那么此时就不使用int类型的共享变量number了；</span></span><br><span class="line"><span class="comment">而是给共享变量number换一种类型叫做AtomicInteger类型；</span></span><br><span class="line"><span class="comment">  private static AtomicInteger atomicInteger = new AtomicInteger();</span></span><br><span class="line"><span class="comment">变量名number换为atomicInteger；</span></span><br><span class="line"><span class="comment">并且number++操作也要换成atomicInteger.incrementAndGet();</span></span><br><span class="line"><span class="comment">那么atomicInteger.incrementAndGet()也会去做一个自增操作；</span></span><br><span class="line"><span class="comment">其该自增操作是一个原子性的操作；</span></span><br><span class="line"><span class="comment">最后打印atomicInteger的最新值；通过atomicInteger.get()来进行获取atomicInteger的最新值；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">最后再怎么运行发现运行结果都是5000；</span></span><br><span class="line"><span class="comment">也就意味着 AtomicInteger的incrementAndGet()方法可以进行保证共享变量赋值的原子性；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">多次运行后的运行打印：</span><br><span class="line">atomicInteger = <span class="number">5000</span></span><br><span class="line">atomicInteger = <span class="number">5000</span></span><br><span class="line">atomicInteger = <span class="number">5000</span></span><br><span class="line">.....</span><br><span class="line">-------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h2 id="synchronized优化-CAS原理"><a href="#synchronized优化-CAS原理" class="headerlink" title="synchronized优化_CAS原理"></a>synchronized优化_CAS原理</h2><p>CAS 原理</p>
<p>通过刚才 AtomicInteger 的源码可以看到， Unsafe类提供了原子操作。<br>AtomicInteger类当中其内部会包含一个叫做UnSafe的类；<br>UnSafe该类可以进行保证变量在赋值时的原子操作；<br>也就是UnSafe类当中提供了CAS操作；</p>
<h3 id="Unsafe类介绍"><a href="#Unsafe类介绍" class="headerlink" title="Unsafe类介绍"></a>Unsafe类介绍</h3><p>java是无法去操作内存地址的（即也就是没有指针）；</p>
<p>Unsafe类使java拥有了像C语言的指针一样操作内存空间的能力（操作对象的内存空间即能够操作对象里面的内容；但是这个UnSafe类不太安全；如果使用不当会出现一些比较危险的事情；所以java官方并不推荐使用；并且在jdk当中也无法找到此类；只能够通过反射的方式才能够找到该类），同时也带来了指针的问题。<br>过渡的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。<br>Unsafe对象不能直接调用，只能通过反射获得。  </p>
<h3 id="Unsafe实现CAS"><a href="#Unsafe实现CAS" class="headerlink" title="Unsafe实现CAS"></a>Unsafe实现CAS</h3><blockquote>
<p>AtomicInteger.java源码</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">publlic <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="title">extends</span> <span class="title">Number</span> <span class="title">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">  <span class="keyword">private</span> static <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">  <span class="keyword">private</span> static <span class="keyword">final</span> long valueOffset;</span><br><span class="line">  static &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      valueOffset = unsafe.objectFieldOffset(</span><br><span class="line">        AtomicInteger<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclareField</span></span>(<span class="string">"value"</span>)</span><br><span class="line">      );</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception ex)&#123; <span class="keyword">throw</span> new Error(ex);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> int value;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">AtomicInteger内部具有一个成员变量unsafe，通过Unsafe.getUnsafe()得到；</span><br><span class="line">另外需要注意的还是AtomicInteger是用来进行保存数字的；</span><br><span class="line">该AtomicInteger数值保存在AtomicInteger类成员变量value当中；</span><br><span class="line">而且该value成员变量使用了<span class="keyword">volatile</span>关键字进行修饰；</span><br><span class="line"><span class="keyword">volatile</span>即保证了多线程操作时的可见性；</span><br><span class="line">另外AtomicInteger类中还有一个成员变量valueOffset；</span><br><span class="line">那么valueOffset的作用即用来找到<span class="keyword">volatile</span>关键字修饰的value变量的内存地址；</span><br><span class="line">到时候根据AtomicInteger类所生成的对象atomicInteger的内存地址再加上偏移量valueOffset就可以找到value所在的内存地址了；</span><br><span class="line">也就可以找到value的取值；也就可以对value进行修改等操作；</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"># java测试用例代码</span><br><span class="line">Demo01.java</span><br><span class="line">    <span class="keyword">private</span> static AtomicInteger atomicInteger =  new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    Runnable increment = ()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>( int i = <span class="number">0</span> ; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        atomicInteger.incrementAndGet();  <span class="comment">// 变量赋值的原子性</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"># AtomicInteger.incrementAndGet()方法中具体执行流程；分析源码；</span><br><span class="line">-------------------</span><br><span class="line">AtomicInteger.java</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> int incrementAndGet()&#123;</span><br><span class="line">      <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">------------------</span><br><span class="line">        ↓</span><br><span class="line">------------------</span><br><span class="line">Unsafe<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> int getAndAddInt(Object var1, long var2, int var4)&#123;</span><br><span class="line">      int var5;</span><br><span class="line">      <span class="keyword">do</span>&#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1 , var2);</span><br><span class="line">      &#125;<span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5+var4));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//compareAndSwapInt CAS操作</span></span><br><span class="line">------------------</span><br><span class="line">分析执行流程：</span><br><span class="line">当刚进行创建AtomicInteger对象（AtomicInteger atomicInteger=new AtomicInteger();）时其AtomicInteger.java当中通过<span class="keyword">volatile</span>修饰的value变量取值为<span class="number">0</span>；</span><br><span class="line">假设AtomicInteger当中的成员变量value取值为<span class="number">0</span>之后；</span><br><span class="line">那么当前来进行<span class="keyword">for</span>循环atomicInteger进行执行incrementAndGet()方法；</span><br><span class="line">即也就意味着会执行到AtomicInteger.java类当中的incrementAndGet()方法；</span><br><span class="line">那么AtomicInteger.java类当中的incrementAndGet方法中又会去通过unsafe成员变量去执行方法getAndAddInt(<span class="keyword">this</span> , valueOffset, <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">即就相当于调用到了Unsafe<span class="class">.<span class="keyword">class</span>当中的<span class="title">getAndAddInt</span></span>(Object var1, long var2, int var4)方法；</span><br><span class="line">最后Unsafe<span class="class">.<span class="keyword">class</span>就在<span class="title">getAndAddInt</span></span>(Object var1, long var2, int var4)当中进行CAS的操作即<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5+var4);</span><br><span class="line"></span><br><span class="line">当前假设有两个线程，分别是线程t1和线程t2；</span><br><span class="line">那么此时这两个线程同时来进行执行Runnable当中所实现的run()方法即去执行循环，循环中执行atomicInteger.incrementAndGet()方法；</span><br><span class="line">假设t2线程先走，那么t2线程就会走过</span><br><span class="line">Demo01.java当中的atomicInteger.incrementAndGet()</span><br><span class="line">                   ↓</span><br><span class="line">AtomicInteger.java当中的incrementAndget方法中的unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>)+<span class="number">1</span></span><br><span class="line">                   ↓</span><br><span class="line">UnSafe<span class="class">.<span class="keyword">class</span>当中的<span class="title">getAndAddInt</span></span>(Object var1, long var2, int var4)当中的代码</span><br><span class="line">---------------------</span><br><span class="line">在Unsafe<span class="class">.<span class="keyword">class</span>当中的<span class="title">getAndAddInt</span></span>(Object var1, long var2, int var4)当中的var5的含义代表的是：（可以理解为是）旧的预估值；</span><br><span class="line">此时t2线程即准备进入到代码层中的<span class="keyword">do</span>-<span class="keyword">while</span>循环；</span><br><span class="line">那么先执行<span class="keyword">do</span>&#123;&#125;块当中的内容进行获取var5的取值，即获取旧的预估值取值；</span><br><span class="line">获取var5取值是通过 <span class="keyword">this</span>.getIntVolatile(var1, var2)方法进行获取得到的；</span><br><span class="line">通过两个参数var1以及var2就能够获取得到一个int类型的取值即var5；</span><br><span class="line">这两个参数当中的var1即Object var1，</span><br><span class="line">该var1即AtomicInteger.java的incrementAndGet()方法当中的<span class="keyword">this</span>，</span><br><span class="line">也就是在Demo01.java当中new好的atomicInteger对象（AtomicInteger atomicInteger = new AtomicInteger();）；</span><br><span class="line">那么var2即为AtomicInteger.java的incrementAndGet()方法当中的valueOffset，是一个内存偏移值；</span><br><span class="line">那么也就是说 var1+var2 → <span class="keyword">this</span>+valueOffset 其目的也就是找到<span class="keyword">private</span> <span class="keyword">volatile</span> value的取值；找到AtomicInteger.java当中的成员变量value的取值；</span><br><span class="line">（即当前AtomicInteger要执行类似number++的操作；而AtomicInteger所存的自增数值被存放在其AtomicInteger成员变量value当中；在进行自增操作时首先就需要去获取原先该AtomicInteger当中value的取值为多少或者是找到value的内存地址等信息然后对该value进行一个重新赋值的一个操作，修改操作；）</span><br><span class="line">找到AtomicInteger当中value的取值来作为一个旧的预估值；</span><br><span class="line">那么当前在创建AtomicInteger atomicInteger对象的时候，AtomicInteger当中的成员变量属性value取值为<span class="number">0</span>；</span><br><span class="line">即现在通过var1+var2 → <span class="keyword">this</span>+valueOffset参数调用<span class="keyword">this</span>.getIntVolatile方法获取得到的取值为<span class="number">0</span>即赋值给var5；</span><br><span class="line">假设一种极端的情况；即t2线程找到旧的预估值之后即var5变量被赋值；</span><br><span class="line">此时CPU切换到了另外一个线程上面去了；</span><br><span class="line">切换到t1线程上来了；</span><br><span class="line">那么t1线程也会来进行执行AtomicInteger类当中的incrementAndGet方法；</span><br><span class="line">即t1线程也会进入到Unsafe<span class="class">.<span class="keyword">class</span>当中的<span class="title">getAndAddInt</span>方法中来；</span></span><br><span class="line">那么此时t1也会来进行寻找一个旧的预估值即也会进入<span class="keyword">do</span>&#123;&#125;块当中进行调用<span class="keyword">this</span>.getIntVolatile来进行给var5进行赋值；也是通过<span class="keyword">this</span>和valueOffset来进行找到value的取值；</span><br><span class="line">那么此时就会存在有两个线程t1、t2来竞争准备给var5进行赋值操作；(极端情况)</span><br><span class="line">那么此时假设仍然还是t1线程先进行执行；</span><br><span class="line">那么这个时候t1线程就会进入<span class="keyword">while</span>当中执行<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5+var4)方法（即比较如果相同的话则并且交换一个int类型的取值）；</span><br><span class="line">分析compareAndSwapInt当中的参数var1、var2、var5、var4；</span><br><span class="line">var1: 其实还是这个<span class="keyword">this</span>，即AtomicInteger atomicInteger对象；</span><br><span class="line">var2: 即其实还是valueOffset，即内存偏移量；var1与var2的目的还是用于来进行找到内存中value的最新取值；此时找到的是value值取值为<span class="number">0</span>；由于AtomicInteger对象创建value变量便会赋值为<span class="number">0</span>；</span><br><span class="line">var5: 即旧的预估值；</span><br><span class="line">      即value旧的预估值取值，即也是<span class="number">0</span>；即var1+var2所在内存中查找到的value最新值与当前var5旧的预估值是相等的此时；</span><br><span class="line">      如果var1+var2在内存当中查找得到的value最新值 与 当前var5旧的预估值的取值一致，即相等；</span><br><span class="line">      那么var5+var4所加获得的值就会被赋值到内存当中的value取值上来，成为内存当中value的最新值；</span><br><span class="line">      即这个内存当中value的最新值就会变成var5+var4的和值；</span><br><span class="line">      当前var5旧的预估值为<span class="number">0</span>；</span><br><span class="line">      var4即为AtomicInteger.java类当中的方法incrementAndGet方法中所传入的值<span class="number">1</span>；</span><br><span class="line">      所以即也就是自增一的操作；</span><br><span class="line">      当var5与var4一加法运算完成之后那么得到新值<span class="number">1</span>；</span><br><span class="line">      那么也就是该新的值<span class="number">1</span>也就会赋值给内存当中value变量的取值；</span><br><span class="line">      因为当前是比较compare成功即var1+var2所查询获取得到的内存最新值<span class="number">0</span>与旧的预估值var5 <span class="number">0</span>处于两者相等的情况所以匹配成功了（比较成功之后进行了替换内存中value取值的一个操作，替换的值为var5+var4；即CAS需要的三个取值：内存中的值V、旧的预估值X、要修改的新值B；这个时候就属于旧的预估值+var4=要修改的新值B并替换掉了内存中的值V）；</span><br><span class="line">      那么这个时候<span class="keyword">this</span>.compareAndSwapInt（var1, var2, var5, var5+var4）就会返回<span class="literal">true</span>；</span><br><span class="line">      由于返回的是<span class="literal">true</span>，而<span class="keyword">while</span>(! <span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5+var4))当中的<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5+var4)加了! 表示否定；</span><br><span class="line">      即<span class="keyword">while</span>(<span class="literal">false</span>)则表示<span class="keyword">do</span>&#123;&#125;whille()结束循环；</span><br><span class="line">      即t1线程一次性设置自增<span class="number">1</span>成功；</span><br><span class="line">      那么此时t1线程就完成了自增<span class="number">1</span>的操作，结束任务；</span><br><span class="line">var4: 常量<span class="number">1</span>；在AtomicInteger.java的incrementAndGet方法当中所赋值<span class="number">1</span>；</span><br><span class="line"></span><br><span class="line">假设现在切换到t2线程当中来了；</span><br><span class="line">而之前是当t2线程拿到旧的预估值，</span><br><span class="line">也就是<span class="keyword">this</span>.getIntVolatile(var1, var2)拿到取值之后并且赋值给了t2线程当中的工作内存中的var5旧的预估值变量之后才进行CPU的切换的，</span><br><span class="line">即CPU当时切换到了t1线程；</span><br><span class="line">需要注意的是在CPU切换到t1线程之前t2线程中获取得到var5旧的预估值为<span class="number">0</span>；</span><br><span class="line">且当CPU切换到t1线程之后完成了自增<span class="number">1</span>的操作即比较内存value取值与t1线程中的工作内存中的var5旧的预估值取值相同的时候完成了交换SwapInt的操作即var5+var4替换掉或者说重新赋值给了内存当中value的取值了，即<span class="number">1</span>；</span><br><span class="line">那么也就是说此时CPU切换回来线程t2，</span><br><span class="line">而t2线程的工作内存中var5的取值为<span class="number">0</span>；</span><br><span class="line">而此时内存当中的value取值为<span class="number">1</span>；</span><br><span class="line">也就是两者取值不相同；</span><br><span class="line">就无法进行compareAndSwapInt交换的操作即无法完成value自增的操作；</span><br><span class="line"></span><br><span class="line">t2线程之前的var5取值为<span class="number">0</span>；那么t2线程也会来进行执行<span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2. var5, var5+var4));当中的compareAndSwapInt(var1, var2. var5, var5+var4)方法；</span><br><span class="line">此时分析在t2线程中执行的时候compareAndSwapInt(var1, var2. var5, var5+var4)方法当中的四个参数；</span><br><span class="line">var1 与 var2: 即<span class="keyword">this</span>+valueOffset即找到内存当中最新的预估值value，即此时内存当中value取值为<span class="number">1</span>；</span><br><span class="line">而旧的预估值即var5；t2线程获取得到的其取值为<span class="number">0</span>；</span><br><span class="line">那么此时就发现 内存value的最新值<span class="number">1</span>与旧的预估值var5的取值不一样；</span><br><span class="line">不一样则此时就不会进行对内存当中的value进行更新取值；并且返回一个<span class="literal">false</span>；</span><br><span class="line">即对于compareAndSwapInt(var1, var2. var5, var5+var4)操作返回的<span class="literal">false</span>；</span><br><span class="line">而<span class="keyword">while</span>(!compareAndSwapInt(var1, var2. var5, var5+var4))中该方法前是!，即表示<span class="keyword">while</span>(!<span class="literal">false</span>) ---&gt; <span class="keyword">while</span>(<span class="literal">true</span>) 即继续执行<span class="keyword">do</span>-<span class="keyword">while</span>循环；</span><br><span class="line">这次虽然内存当中value的最新值与t2线程中var5旧的预估值的取值不一样；</span><br><span class="line">但是<span class="literal">false</span>前面加了一个非即!；那么就会变成<span class="literal">true</span>；也就是说<span class="keyword">while</span>(<span class="literal">true</span>)则将继续进行<span class="keyword">do</span>-<span class="keyword">while</span>循环；</span><br><span class="line">则此时t2循环会接着这个<span class="keyword">do</span>-<span class="keyword">while</span>循环又进入到<span class="keyword">do</span>&#123;&#125;块当中；进行执行通过var1与var2即<span class="keyword">this</span>+valueOffset调用方法<span class="keyword">this</span>.getIntVolatile()方法获取找到得到内存当中value的最新值<span class="number">1</span>并赋值给t2线程的工作内存中var5变量；即此时t2线程var5变量为<span class="number">1</span>；继续执行代码<span class="keyword">while</span>(!compareAndSwapInt(var1, var2. var5, var5+var4))中的compareAndSwapInt(var1, var2. var5, var5+var4)；</span><br><span class="line">那么这次需要注意的是此时内存当中value的最新值为<span class="number">1</span>；</span><br><span class="line">而t2线程刚刚所找的旧的预估值var5也是<span class="number">1</span>；</span><br><span class="line">那么这一次的时候t2线程当中的旧的预估值var5与内存当中value的最新值相同都为<span class="number">1</span>；</span><br><span class="line">即内存最新值与旧的预估值相同那么就需要完成交换操作，</span><br><span class="line">即对内存中的value取值进行重新赋值为var5+var4，</span><br><span class="line">对内存当中value取值赋值一个最新值，</span><br><span class="line">那么这个最新值就是var5+var4（var5即旧的预估值<span class="number">1</span>；var4为常量<span class="number">1</span>）；</span><br><span class="line">得到运算结果为<span class="number">2</span>并赋值给当前内存当中的value取值</span><br><span class="line">（也就是说需要进行修改的最新值为<span class="number">2</span>）；</span><br><span class="line">那么由于内存最新值与旧的预估值一样那么就会将var5+var4，即<span class="number">2</span> 最新取值赋值给当前内存value变量取值；</span><br><span class="line">即当前内存当中value的取值为<span class="number">2</span>；完成一次自增效果；</span><br><span class="line">当赋值成功之后；</span><br><span class="line">并且compareAndSwapInt(var1, var2. var5, var5+var4)方法会返回<span class="literal">true</span>；</span><br><span class="line">那么一旦compareAndSwapInt(var1, var2. var5, var5+var4)返回<span class="literal">true</span>，而<span class="keyword">while</span>(!compareAndSwapInt(var1, var2. var5, var5+var4))中存在有一个非!的操作；那么也就是<span class="keyword">while</span>(<span class="literal">false</span>)至此相对于t2线程来说整个<span class="keyword">do</span>-<span class="keyword">while</span>循环就结束了，完成一次自增操作；</span><br><span class="line">那么此时就明白了CAS的原理；</span><br><span class="line">CAS主要是靠三个变量的取值；</span><br><span class="line">一个是内存当中的最新值；一个是旧的预估值；还有一个即新的要修改的值；</span><br><span class="line">如果当前内存当中的最新值与旧的预估值取值一样那么就把新的要修改的值赋值给内存当中的该最新值；并且返回tue；以至于<span class="keyword">while</span>(!<span class="literal">true</span>)，即<span class="keyword">while</span>(<span class="literal">false</span>)导致该<span class="keyword">do</span>-<span class="keyword">while</span>循环不再继续；</span><br><span class="line">如果当前内存当中的值与旧的预估值不一样；那么就会返回<span class="literal">false</span>，以至于<span class="keyword">while</span>(!<span class="literal">false</span>)，即<span class="keyword">while</span>(<span class="literal">true</span>)继续执行<span class="keyword">do</span>-<span class="keyword">while</span>循环；重新再一次拿到旧的预估值var5；并且再一次进行compareAndSwapInt操作，拿到最新的内存取值去进行比较以及是否交换内存取值，如果成功就不再进行循环如果不成功就继续进行<span class="keyword">do</span>-<span class="keyword">while</span>循环再次拿到内存最新值与旧的预估值进行比较...............；</span><br><span class="line">那么以上即为CAS的原理；</span><br></pre></td></tr></table></figure>

<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>从思想角度进行区分；</p>
<p><strong>悲观锁</strong> 从悲观的角度出发：</p>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，（这样的话就只有一个线程进来别的线程没有锁无法进入，即别的线程会阻塞，那么也就保证数据操作没有问题）这样别人想拿这个数据就会阻塞。<br>因此synchronized也将其称之为<strong>悲观锁</strong>。<br>JDK中的ReentrantLock也是一种<strong>悲观锁</strong>。<br>性能较差！<br>（总有刁民想害朕）</p>
<p><strong>乐观锁</strong> 从乐观的角度出发：<br>总是假设最好的情况，每次去拿数据的会后都认为别人不会修改，就算改了也没关系，再重试即可。<br>所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如果没有人修改则更新，如果有人修改则重试。</p>
<p>（乐观锁在对数据进行操作的时候总是很乐观的认为：当前线程进行操作的时候没有其他的线程来进行修改即干扰到当前线程的操作；因此乐观锁的操作是不上锁；但是也不能什么也不管，以防万一；那么乐观锁虽然在设置取值的时候不加锁但是会进行一个判断，即旧值与新值的判断； 即在设置前稍微做一个判断即旧的预估值与内存当中的最新取值是否一致；如果一致则直接设置如果不一致则说明有别的线程已经修改过，那么没有关系，当前线程进行重新循环，重新去获取内存中的最新值；重新来进行设置一次或者多次即可，即也就是重新尝试重新尝试重新尝试….）</p>
<p><strong>CAS</strong>这种机制也可以将其称之为<strong>乐观锁</strong>，综合<strong>性能较好</strong>！<br>（在修改的时候不上锁；只是做一个判断，不行则再次判断一次即可）</p>
<p>CAS可以保证变量在设置取值的时候可以保证其操作的一个原子性；<br>为了使得在线程间变量取值状态变化可见，<br>那么需要给该变量添加volatile关键字进行修饰；<br>volatile可以结合CAS机制实现无锁并发；<br>保证变量在修改时的原子性；<br>需要注意的是CAS只适合在竞争并不太激烈、多核CPU的情况场景下进行使用；<br>CAS之所以效率高是因为在其内部没有使用synchronized关键字；<br>那么也就是说CAS不会让线程进入阻塞状态；<br>那么也就避免了synchronized当中用户态和内核态的切换所带来的的性能消耗问题也避免了线程挂起等资源的消耗问题；<br>如果竞争非常激烈，那么CAS就会出现线程大量重试，因为多线程来进行竞争，那么也就导致有可能很多的线程设置取值失败，那么又要进行while循环重试；即大量的线程进行重试操作；成功存的线程反而不多；那么这样的话反而会会浪费性能，即性能变低；<br>所以如果竞争太激烈还使用的是CAS机制那么就会导致其性能比synchronized还会低；</p>
<blockquote>
<p>CAS获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰，结合CAS和volatile可以实现无锁并发，适用于竞争不激烈，多核CPU的场景下。</p>
<ol>
<li>因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</li>
</ol>
</blockquote>
<h3 id="小结-13"><a href="#小结-13" class="headerlink" title="小结"></a>小结</h3><p>CAS指的是Compare And Swap；会拿旧的预估值与内存当中的最新值进行比较；如果相同就进行交换并且把最新的值赋值到内存当中的这个变量；<br>CAS的作用？Compare And Swap，CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理器保证（由CPU支持）。<br>CAS的原理？CAS需要三个值：内存地址V、旧的预期值A、要修改的新值B，如果内存地址V和旧的预期值A相等就修改内存地址的值为B（即新的值B赋值到内存当中去）；</p>
<p>CAS的作用是什么？</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAS</span>可以将比较和交换转换为原子操作，这个原子操作直接由处理器保证。</span><br></pre></td></tr></table></figure>

<p>CAS的原理是什么？</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CAS需要<span class="number">3</span>个值：内存地址V，旧的预期值<span class="keyword">A</span>，要修改的新值B</span><br><span class="line">如果内存地址V和旧的预期值<span class="keyword">A</span>相等就修改内存地址值为B</span><br></pre></td></tr></table></figure>

<h2 id="synchronized优化锁升级过程"><a href="#synchronized优化锁升级过程" class="headerlink" title="synchronized优化锁升级过程"></a>synchronized优化锁升级过程</h2><p>在JDK1.5之前synchronized只包含有一种锁即monitor重量级锁；<br>所以在JDK1.5之前其效率是比较低的；<br>另外在JDK的源码当中大量的使用到了synchronized；<br>包括java开发的时候也会经常使用到synchronized；<br>虚拟机开发团队就意识到了这个问题；<br>因此在JDK1.6这个版本当中对synchronized做了重要改进；<br>在JDK1.6当中synchronized就不仅仅只有monitor这一种重量级的锁了；<br>包括偏向锁、轻量级锁、适应性自旋、锁消除、锁优化等机制；<br>另外到转变成重量级锁之前会有一个适应性自旋的过程进行抢救一下；<br>这些机制的目的就是为了能够让synchronized的效率得到提升；</p>
<p>高效并发是从JDK1.5到JDK1.6的一个重要改进。<br>HotSpot虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，<br>包括如偏向锁（Biased Locking）、轻量级锁（Lightweight Locking）和适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock、Coarsening）等，<br>这些技术都是为了在线程之间更高效地共享数据，<br>以及解决竞争问题，从而提高程序的执行效率。</p>
<p>无锁 —→ 偏向锁 —→ 轻量级锁 —→ 重量级锁<br>在JDK1.6之后不是说直接就会变成重量级锁了；<br>而是会有一个过程；<br>首先对象是无锁状态；然后如果需要进行加锁那么就会进行添加一个偏向锁；<br>如果偏向锁无法满足不行的话就会换成轻量级锁；<br>如果轻量级锁不行的话就有可能会进入适应性自旋的过程；<br>如果通过适应性自旋依然没有抢到锁则换成重量级锁；<br>即会有这样一个锁升级的过程；<br>还需要注意的是JDK1.6当中既然存在有这些不同的锁；<br>那么必然是这些锁有其存在的不同场景下才适用；<br>并不是说这个锁是万能的；</p>
<h2 id="synchronized优化-对象的布局"><a href="#synchronized优化-对象的布局" class="headerlink" title="synchronized优化-对象的布局"></a>synchronized优化-对象的布局</h2><h3 id="回顾并引入-1"><a href="#回顾并引入-1" class="headerlink" title="回顾并引入"></a>回顾并引入</h3><p>JDK1.6时对synchronized做了很多的优化；<br>锁升级过程为 无锁 —→ 偏向锁 —→ 轻量级锁 —→ 重量级锁<br>那么这个锁升级的过程当中就会遇到锁存在有很多的状态；<br>那么这些锁的状态存在在哪里呢？<br>那么这些锁的状态也就存在在java对象的布局当中；<br>以前认为java当中存在成员变量，也称之为实例数据；<br>那么其实在JVM当中对象不仅仅会存放实例数据；<br>对象总共由三部分组成：对象头、实例数据（成员变量等）和对齐数据；</p>
<p>Java对象的布局</p>
<h3 id="目标-17"><a href="#目标-17" class="headerlink" title="目标"></a>目标</h3><p>学习java对象的布局</p>
<p>术语参考：<code>http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</code></p>
<p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头由两部分组成；<br>synchronized锁可能有很多的状态，那么这些状态都是靠对象头来进行存储的；</p>
<p>当一个线程尝试访问 synchronized修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？是存在在锁对象的对象头中的。</p>
<p>在Hotspot虚拟机当中对象头又分为两种；<br>一种是普通对象的对象头即instanceOopDesc；<br>另外一种是描述数组的对象头即arrayOopDesc；<br>那么当前仅关心普通对象的对象头即instanceOopDesc；</p>
<p>Hotspot采用 instanceOopDesc和arrayOopDesc来描述对象头；<br>arrayOopDesc对象用来描述数组类型。<br>instanceOopDesc的定义的在Hotspot源码的 instanceOop.hpp 文件中，<br>另外， arrayOopDesc的定义对应 arrayOop.hpp。</p>
<p>instanceOop.hpp记录了对象头的信息；<br>instanceOopDesc当中没有很多代码；<br>但是可以发现instanceOop继承了父类oopDesc；<br>那么这个时候可以去看下其父类oopDesc中的代码；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 截取部分代码</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">instanceOopDesc</span> :</span> <span class="keyword">public</span> oopDesc&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// aligned header size.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">header_size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">sizeof</span>(instanceOopDesc)/HeapWordSize; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If compressed. the offset of the fields of the instance may not be aligned.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">base_offset_in_bytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">/* offset computation code breaks if useCompressedClassPointers</span></span><br><span class="line"><span class="comment">         only is true</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> (UseCompressedOops &amp;&amp; UseCompressedClassPointers) ? klass_gap_offset_in_bytes() : <span class="keyword">sizeof</span>(instanceOopDesc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">contains_field_offset</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">int</span> nonstatic_field_size)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> base_in_bytes = base_offset_in_bytes();</span><br><span class="line">      <span class="keyword">return</span> (offset &gt;= base_in_bytes &amp;&amp; (offset-base_in_bytes) &lt; nonstatic_field_size = heapOopSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从instanceOopDesc代码中可以看到 instanceOopDesc继承自oopDesc，<br>oopDesc的定义在Hotspot源码中的 oop.hpp文件中；</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span>&#123;</span></span><br><span class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span><br><span class="line">  <span class="keyword">private</span> :</span><br><span class="line">    volatile markOop _mark;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">_metadata</span>&#123;</span></span><br><span class="line">      Klass*       _klass; <span class="comment"># 没有开启指针压缩时的类型指针</span></span><br><span class="line">      narrowKlass  _compressed_klass; <span class="comment"># 开启了指针压缩</span></span><br><span class="line">    &#125; _metadata;</span><br><span class="line"></span><br><span class="line">    /<span class="regexp">/ Fast access to barrier set. Must be initialized.</span></span><br><span class="line"><span class="regexp">    static BarrierSet* _bs;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 省略其他代码</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>在openjdk当中Klass*与narrowKlass有相关的介绍；</p>
<blockquote>
<p><strong>klass pointer</strong><br>The second word of every object header.<br>Points to another object(a metaobject) which<br>describes the layout and behavior of the original object.<br>For java objects, the “Klass” contains a C++ style “vtable”.</p>
</blockquote>
<blockquote>
<p><strong>mark word</strong><br>The first word of every object header.<br>Ususlly a set of bitfields including synchronization state<br>and identity hash code.<br>May also be a poiter(with characteristic low bit encoding)<br>to synchronization related infomation.<br>During GC,may contain GC state bits.</p>
</blockquote>
<blockquote>
<p><strong>object header</strong><br>Common structure at the beginning of every GC-managed heap object.<br>(Every oop points to an object header.)<br>Includes fundamental information about the heap object’s layout, type , GC state, synchronization state, and identity hash code.<br>Consists of two words.<br>In arrays it is immediately followed by a length field.<br>Note that both java objects and VM-internal objects have a common object header format.</p>
</blockquote>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------</span><br><span class="line">|<span class="string">                          Xxx 对象                               </span>|</span><br><span class="line">|<span class="string">                          -------------------                    </span>|</span><br><span class="line">|<span class="string">                       ---</span>|<span class="string">  Mark     Word  </span>|<span class="string">  markOop   _mark   </span>|</span><br><span class="line">|<span class="string">-------------------   </span>|<span class="string">   -------------------                    </span>|</span><br><span class="line">||<span class="string"> instanceOopDesc </span>|<span class="string">-------</span>|<span class="string">  Klass pointer  </span>|<span class="string">  Klass*    _klass  </span>|</span><br><span class="line">||<span class="string"> 对象头          </span>|<span class="string">       --------------------                   </span>|</span><br><span class="line">|<span class="string">-------------------       </span>|<span class="string">  实例      数据  </span>|<span class="string">                   </span>|</span><br><span class="line">|<span class="string">                          --------------------                   </span>|</span><br><span class="line">|<span class="string">                          </span>|<span class="string">  对齐      数据  </span>|<span class="string">                   </span>|</span><br><span class="line">|<span class="string">                          --------------------                   </span>|</span><br><span class="line">-----------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>在 普通示例对象 中，oopDesc的定义包含两个成员，分别是<code>_mark</code>和<code>_metadata</code>。</p>
<p>_mark表示对象标记、属于markOop类型，也就是接下来要讲解的Mark Word，它记录了对象和锁有关的信息；<br>_metadata表示类元信息，类元信息存储的是对象指向它的类元数据（Klass）的首地址，其中Klass表示普通指针；<br>_compressed_klass表示压缩类指针。</p>
<p>对象头由两部分组成；<br>一部分用于存储自身的运行时数据，称之为Mark Word；<br>另一部分是类型指针，即对象指向它的类元数据的指针。</p>
<h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。</p>
<p>Mark Word对应的类型是markOop。<br>源码位于 <code>markOop.hpp</code>中。</p>
<blockquote>
<p>在32位状态下以及64位状态下每一位分别代表什么；</p>
</blockquote>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------</span><br><span class="line">// Bit-format of an object header (most significant first , big endian layout below):</span><br><span class="line">//</span><br><span class="line">// 32 bits:</span><br><span class="line">// ---------</span><br><span class="line">//           hash:25 --------------&gt;|<span class="string"> age:4   biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="string">//           JavaThread*:23 epoch:2   age:4   biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="string">//           size；32 -------------------------------------------&gt;</span>|<span class="string"> (CMS free block)</span></span><br><span class="line"><span class="string">//           PromotedObject*:29 ------------&gt; promo_bits:3 ------&gt;</span>|<span class="string"> (CMS promoted object)</span></span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">// 64 bits:</span></span><br><span class="line"><span class="string">// ----------</span></span><br><span class="line"><span class="string">// unused:25 hash:31 --&gt;</span>|<span class="string"> unused:1    age:4   biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="string">// JavaThread*:54 epoch:2 unused:1    age:4   biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="string">// PromotedObject*:61 ---------------------&gt;</span>|<span class="string"> promo_bits:3-----&gt;</span>|<span class="string"> (CMS promoted object)</span></span><br><span class="line"><span class="string">// size:64 ----------------------------------------------------&gt;</span>|<span class="string"> (CMS free block)</span></span><br><span class="line"></span><br><span class="line"><span class="string"># 偏向锁的时候其第三位是1；（0、1、2、3的顺序）</span></span><br><span class="line"><span class="string">//   [JavaThread* </span>|<span class="string"> epoch </span>|<span class="string"> age </span>|<span class="string"> 1 </span>|<span class="string"> 01]   lock is biased toward given thread</span></span><br><span class="line"><span class="string">//   [0           </span>|<span class="string"> epoch </span>|<span class="string"> age </span>|<span class="string"> 1 </span>|<span class="string"> 01]   lock is anonymously biased</span></span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">// - the two lock bits are used to describe three states: locked/unlocked and monitor.</span></span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string"># 当第三位为0的时候则表示不是偏向锁；那么就看其后两位；00表示轻量级锁；01表示无锁；10即monitor表示重量级锁；</span></span><br><span class="line"><span class="string">//   [ptr             </span>|<span class="string"> 00]  locked         ptr points to real header on stack           # 轻量级锁</span></span><br><span class="line"><span class="string">//   [header      </span>|<span class="string"> 0 </span>|<span class="string"> 01]  unlocked       regular object header                        # 无锁</span></span><br><span class="line"><span class="string">//   [ptr             </span>|<span class="string"> 10]  monitor        inflated lock (header is wapped out)         # 重量级锁</span></span><br><span class="line"><span class="string">//   [ptr             </span>|<span class="string"> 11]  marked         used by markSweep to mark an object</span></span><br><span class="line"><span class="string">//                                          not valid at any other time</span></span><br><span class="line"><span class="string">--------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">|<span class="string">---------------------------------------------------------------------------------</span>|<span class="string">--------------------</span>|</span><br><span class="line">|<span class="string">                              Mark Word(64 bits)                                 </span>|<span class="string">        State       </span>|</span><br><span class="line">|<span class="string">---------------------------------------------------------------------------------</span>|<span class="string">--------------------</span>|</span><br><span class="line">|<span class="string"> unused:25 </span>|<span class="string"> identity_hashcoder:31 </span>|<span class="string"> unused:1 </span>|<span class="string"> age:4 </span>|<span class="string"> biased_lock:1 </span>|<span class="string"> lock:2   </span>|<span class="string">        Normal      </span>|</span><br><span class="line">|<span class="string">---------------------------------------------------------------------------------</span>|<span class="string">--------------------</span>|</span><br><span class="line">|<span class="string"> thread:54 </span>|<span class="string">        epoch:2        </span>|<span class="string"> unused:1 </span>|<span class="string"> age:4 </span>|<span class="string"> biased_lock:1 </span>|<span class="string"> lock:2   </span>|<span class="string">        Biased      </span>|</span><br><span class="line">|<span class="string">---------------------------------------------------------------------------------</span>|<span class="string">--------------------</span>|</span><br><span class="line">|<span class="string">                   ptr_to_lock__record:62                             </span>|<span class="string"> lock:2   </span>|<span class="string"> Lightweight Locked </span>|</span><br><span class="line">|<span class="string">---------------------------------------------------------------------------------</span>|<span class="string">--------------------</span>|</span><br><span class="line">|<span class="string">               ptr_to_heavyweight_monitor:62                          </span>|<span class="string"> lock:2   </span>|<span class="string"> Heavyweight Locked </span>|</span><br><span class="line">|<span class="string">---------------------------------------------------------------------------------</span>|<span class="string">--------------------</span>|</span><br><span class="line">|<span class="string">                                                                      </span>|<span class="string"> lock:2   </span>|<span class="string"> Marked  for  GC    </span>|</span><br><span class="line">|<span class="string">---------------------------------------------------------------------------------</span>|<span class="string">--------------------</span>|</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<strong>64位虚拟机</strong>下，<strong>Mark Word</strong>是<strong>64bit</strong>大小的，其存储结构如下：</p>
</blockquote>
<p>（在不同的锁情况下每一位的作用不一样）  </p>
<table>
  <tr>
    <td rowspan="2">锁状态</td>
    <td>25bit</td>
    <td>31bit</td>
    <td>1bit</td>
    <td>4bit</td>
    <td>1bit</td>
    <td>2bit</td>
  </tr>
  <tr>
    <td> </td>
    <td> </td>
    <td>cms_free</td>
    <td>分代年龄</td>
    <td>偏向锁</td>
    <td>锁标志位</td>
  </tr>
  <tr>
    <td>无锁</td>
    <td>unused（没有使用）</td>
    <td>hashCode</td>
    <td></td>
    <td></td>
    <td>0（是否是偏向锁；0表示非偏向锁；1表示是偏向锁）</td>
    <td>01（锁的标志位；01代表无锁；00代表轻量级锁；10代表重量级锁）</td>
  </tr>
    <tr>
    <td>偏向锁</td>
    <td colspan="2">ThreadId(54bit)Epoch(2bit)</td>
    <td></td>
    <td></td>
    <td>1</td>
    <td>01</td>
  </tr>
  <tr>
    <td>轻量级锁</td>
    <td colspan="5">指向栈中锁记录的指针</td>
    <td>00</td>
  </tr>
  <tr>
    <td>重量级锁</td>
    <td colspan="5">指向互斥量（重量级锁）的指针</td>
    <td>10</td>
  </tr>
</table>

<blockquote>
<p>在32位虚拟机下，Mark Word是32bit大小的，其存储结构如下：</p>
</blockquote>
<table>
  <tr>
    <td rowspan="2">锁状态</td>
    <td colspan="2">25bit</td>
    <td rowspan="2">4bit</td>
    <td>1bit</td>
    <td>2bit</td>
  </tr>
  <tr>
    <td>23bit</td>
    <td>2bit</td>
    <td>是否是偏向锁</td>
    <td>锁标志位</td>
  </tr>
    <td>轻量级锁</td>
    <td colspan="4">指向栈中锁记录的指针</td>
    <td>00</td>
  
  <tr>
    <td>重量级锁</td>
    <td colspan="4">指向互斥量（重量级锁）的指针</td>
    <td>10</td>
  </tr>
</table>

<p>一般网络上是32位居多；<br>现在的虚拟机绝大多数使用的是64位虚拟机；<br>所以现下关注的是64位虚拟机MarkWord的存储结构；<br>关于上述32or64位虚拟机的mark word是多少bit的存储结构等信息在markOop.hpp当中有详细介绍；</p>
<p>Klass pointer 类型指针；</p>
<h3 id="Klass-pointer"><a href="#Klass-pointer" class="headerlink" title="Klass pointer"></a>Klass pointer</h3><p>java当中的对象肯定是由某个类所产生的；<br>那么Klass pointer就是用来表示该对象是哪一个类所产生的；<br>Klass pointer会保存这个类的元信息；<br>Klass pointer根据虚拟机大小其自身大小也不一样；<br>如果是32位虚拟机则其Klass pointer的大小为32位；<br>如果是64位虚拟机则其Klass pointer的大小为64位；<br>一般来说虚拟机都会开启指针压缩；<br>即也就是说在64位虚拟机情况下其Klass pointer也会被压缩成32位；</p>
<p>这一部分用于 存储对象的类型指针，<br>该指针 指向它的类元数据，<br>JVM通过这个指针确定对象是哪个类的实例。<br>该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位；</p>
<p>如果应用的对象过多，使用64位的指针将大量浪费内存，<br>统计而言，64位的JVM将会比32位的JVM多耗费50%的内存。<br>为了节约内存可以使用选项<code>-XX:+UseCompressedOops</code>开启指针压缩；<br>其中，oop即ordinary object pointer普通对象指针。<br>开启该选项后，下列指针将压缩至32位：</p>
<ol>
<li>每个Class的属性指针（即静态变量）</li>
<li>每个对象的属性指针（即对象变量）</li>
<li>普通对象数组的每个元素指针</li>
</ol>
<p>当然，也不是所有的指针都会压缩；<br>一些特殊类型的指针JVM不会优化，<br>比如执行PermGen的Class对象指针（JDK8中指向元空间的Class对象指针）、本地变量、堆栈元素、入参、返回值和NULL指针等。</p>
<p>对象头 = Mark Word + 类型指针（未开启指针压缩的情况下）<br>在32位系统中，Mark Word = 4 bytes， 类型指针 = 4bytes， 对象头 = 8bytes = 64 bits；<br>在64位系统中，Mark Word = 8 bytes， 类型指针 = 8bytes， 对象头 = 16bytes = 128 bits；</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>就是类中定义的成员变量。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>（可能有可能没有；如果java对象整体大小为8字节的整数倍那么这个时候就不需要对齐填充；如果java对象整体大小不为8字节的整数倍那么这个时候就需要对齐填充的一些填充数据使之对齐从而变成8字节的整数倍；那么这样是方便操作系统来进行寻址的）；<br>对齐填充并不是必然存在的，也没有什么特别的意义，它仅仅起着占位符的作用。<br>由于HotSpot VM的自动内存管理系统 要求 对象起始地址必须是8字节的整数倍。<br>换句话说，就是对象的大小必须是8字节的整数倍。<br>而对象头正好是8字节的整数倍，<br>因此，当对象实例数据没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="查看java对象布局"><a href="#查看java对象布局" class="headerlink" title="查看java对象布局"></a>查看java对象布局</h3><p>之前是通过观察JVM源码的方式来进行查看的接着来进行验证一下；<br>工具类；openjdk提供叫做jol；<br>java对象布局的工具；可以来查看java对象布局；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aratifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">aratifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------</span><br><span class="line">package com.xxx.demo06_object_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">LockObj</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> x;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line">package com.xxx.demo06_object_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo01</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123;</span><br><span class="line">    LockObj obj = new LockObj();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//parseInstance 解析实例对象；</span></span><br><span class="line">    <span class="comment">//toPrintable进行打印其解析的实例对象信息</span></span><br><span class="line">    ClassLayout.parseInstance(obj).toPrintable().;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------</span><br><span class="line">打印对象布局：</span><br><span class="line">com.xxx.demo06_object_layout.LockObj object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134168253</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line"> Instance size: <span class="number">16</span> bytes</span><br><span class="line"> Space losses: <span class="number">0</span> bytes <span class="built_in">int</span>ernal + <span class="number">0</span> bytes <span class="keyword">external</span> = <span class="number">0</span> bytes total</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">分析：</span><br><span class="line">从整个对象开始；</span><br><span class="line">OFFSET偏移<span class="number">0</span>；SIZE为<span class="number">4</span>表示用了<span class="number">4</span>个字节去进行描述DESCRIPTION对象头object header信息；</span><br><span class="line">OFFSET偏移<span class="number">4</span>；SIZE为<span class="number">4</span>表示用了<span class="number">4</span>个字节也是去进行描述DESCRIPTION与对象头object header相关的内容；</span><br><span class="line">OFFSET偏移<span class="number">8</span>；SIZE为<span class="number">4</span>表示用了<span class="number">4</span>个字节也是去进行描述DESCRIPTION与对象头object header相关的内容；</span><br><span class="line">那么此时来看对象头object header所占了<span class="number">3</span> * <span class="number">4</span> = <span class="number">12</span>个字节来进行描述与对象头object header相关信息；</span><br><span class="line">与之前所说：在<span class="number">64</span>位系统中，Mark Word = <span class="number">8</span> bytes，类型指针 = <span class="number">8</span>bytes，对象头 = <span class="number">16</span> bytes = <span class="number">128</span> bits；此处存在偏差；</span><br><span class="line">由于也是<span class="number">64</span>位操作系统但是打印得到其对象布局信息得到的对象头所占字节信息不一致；</span><br><span class="line">实际上打印出来对象头object header所占字节数并不是<span class="number">16</span>个字节而是<span class="number">12</span>个字节；</span><br><span class="line">那么为什么打印出来的对象布局信息中的object header对象头信息所占字节不是<span class="number">16</span>个字节而是<span class="number">12</span>个字节呢?</span><br><span class="line">那么这是因为JVM默认自动开启了指针压缩的选项参数；</span><br><span class="line">从而也就导致了JVM在默认情况下去进行打印对象布局当中的对象头信息所占字节为<span class="number">12</span>个字节而不是<span class="number">16</span>个字节；</span><br><span class="line">所以此时可以尝试进行关闭指针压缩进行尝试；</span><br><span class="line">选项-XX:+UseCompressedOops是用来进行开启指针压缩；</span><br><span class="line">所以此时可以用-XX:+UseCompressedOops拿过来来作为JVM的一个参数；</span><br><span class="line">即打开idea的Run/Debug Configurations中填入到VM options当中即可；</span><br><span class="line">那么此时要注意的是-XX:+UseCompressedOops是用来开启指针压缩的；</span><br><span class="line">而JVM默认就是开启指针压缩的；而此时要做的是让JVM关闭指针压缩；</span><br><span class="line">所以此时VM options当中填入的即为：-XX:-UseCompressedOops；</span><br><span class="line">-XX:-UseCompressedOops即 - 为关闭指针压缩了；</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">再次打印对象布局:</span><br><span class="line">com.xxx.demo06_object_layout.LockObj object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     d8 <span class="number">34</span> <span class="number">5</span>a <span class="number">25</span> (<span class="number">11011000</span> <span class="number">00110100</span> <span class="number">01011010</span> <span class="number">00100101</span>) (<span class="number">626668760</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>        （object header）     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">     <span class="number">16</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line">     <span class="number">20</span>      <span class="number">4</span>        （loss due to the next object alignment）</span><br><span class="line"> Instance size: <span class="number">24</span> bytes</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"> 此时就可以分析看到对象布局当中object header对象头所占字节为<span class="number">16</span>个字节；</span><br><span class="line"> 其中；后面<span class="number">8</span>个字节即第三排和第四排的object header是用来表示Klass pointer，也就是这个对象所对应的这个类的元信息；</span><br><span class="line"> LockObj.x在偏移OFFSET为<span class="number">16</span>的时候所占字节为<span class="number">4</span>个字节；</span><br><span class="line"> 那么此时所累加字节数为 <span class="number">16</span>个对象头信息所占字节数 + LockObject.x <span class="built_in">int</span>类型变量所占字节数为<span class="number">4</span>个字节 = 累计当前字节数为 <span class="number">20</span> 个字节；</span><br><span class="line"> （那么当前此时是不满足对象头信息总占字节数需要为<span class="number">8</span>个字节的整数倍这一限制条件的；）</span><br><span class="line">而<span class="number">20</span>个字节并不是<span class="number">8</span>字节的整数倍；</span><br><span class="line">所以此时就有了填充数据；即最后一排的<span class="number">4</span>个字节，加了<span class="number">4</span>个字节的填充数据；即:</span><br><span class="line"> <span class="number">20</span>      <span class="number">4</span>        （loss due to the next object alignment）</span><br><span class="line">那么将关闭指针压缩参数进行去掉再次分析原来的打印结果：</span><br><span class="line">VM options: -XX:+UseCompressedOops</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">再次打印对象布局：</span><br><span class="line">com.xxx.demo06_object_layout.LockObj object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134168253</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line"> Instance size: <span class="number">16</span> bytes</span><br><span class="line"> Space losses: <span class="number">0</span> bytes <span class="built_in">int</span>ernal + <span class="number">0</span> bytes <span class="keyword">external</span> = <span class="number">0</span> bytes total</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">从上面的分析可得此时Klass pointer的指针只占了<span class="number">4</span>个字节；即：</span><br><span class="line"><span class="number">8</span>      <span class="number">4</span>        （object header）     <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134168253</span>)</span><br><span class="line">整个对象布局当中对象头信息所占字节数为<span class="number">12</span>个字节；</span><br><span class="line">再加上LockObj当中的<span class="built_in">int</span>类型变量占有<span class="number">4</span>个字节；</span><br><span class="line">所以此时累计总共占有字节数为<span class="number">16</span>个字节；为<span class="number">8</span>字节的整数倍；</span><br><span class="line">所以此时并没有填充数据；</span><br><span class="line">那么再做测试在LockObj类当中再写一个变量<span class="keyword">private</span> <span class="built_in">bool</span>ean b；</span><br><span class="line">那么布尔类型的变量在java当中所占字节是为<span class="number">1</span>个字节；</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">package com.xxx.demo06_object_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">LockObj</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">bool</span>ean b;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">再次打印对象布局：</span><br><span class="line">com.xxx.demo06_object_layout.LockObj object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134168253</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line">     <span class="number">16</span>      <span class="number">1</span>  <span class="built_in">bool</span>ean LockObj.b           <span class="literal">false</span></span><br><span class="line">     <span class="number">17</span>      <span class="number">7</span>    <span class="built_in">int</span> （loss due to the next object alignment）</span><br><span class="line"> Instance size: <span class="number">24</span> bytes</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">此时分析到：<span class="built_in">bool</span>ean布尔类型在其中占用到了<span class="number">1</span>个字节数；</span><br><span class="line">那么此时累加到字节数即为：<span class="number">12</span>个对象头信息所占字节数 + LockObj当中<span class="built_in">int</span>类型变量所占字节数<span class="number">4</span>个字节 + LockObj当中<span class="built_in">bool</span>ean类型所占字节数为<span class="number">1</span>个字节 = 总计字节数为<span class="number">17</span>个字节；</span><br><span class="line">而<span class="number">17</span>个字节数显然是不满足<span class="number">8</span>字节的整数倍这一说法；</span><br><span class="line">所以就存在有最后一排的对齐填充数据占有<span class="number">7</span>个字节进行平衡；即：</span><br><span class="line"><span class="number">17</span>      <span class="number">7</span>    <span class="built_in">int</span> （loss due to the next object alignment）</span><br><span class="line">填充了<span class="number">7</span>个字节之后导致数据实例大小为<span class="number">24</span>个字节满足<span class="number">8</span>字节的整数倍这一说法；</span><br><span class="line">另外还有一个问题，在<span class="number">64</span>位虚拟机下，Mark Word是<span class="number">64</span>bit大小的；</span><br><span class="line">其中是存在有<span class="number">31</span>位导致hashCode的；但是根据上述的打印结果来看好像是并没有看到什么有关hashCode相关的内容；</span><br><span class="line"><span class="number">8</span>      <span class="number">4</span>        （object header）     <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134168253</span>)</span><br><span class="line">除了地址之外没有看到有关hashCode相关的内容；</span><br><span class="line"></span><br><span class="line">hashCode的取值不是一来就有的；</span><br><span class="line">而是先需要在代码层当中使用到了这个hashCode那么它才会去进行保存这个hashCode取值；</span><br><span class="line">也就是说生成LockObj obj对象之后，需要去代码层当中调用该obj对象的.hashCode()方法；那么在打印结果当中才能够看到有关hashCode的信息；</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">package com.xxx.demo06_object_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo01</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123;</span><br><span class="line">    LockObj obj = new LockObj();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用obj对象的hashCode()方法</span></span><br><span class="line">    obj.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//parseInstance 解析实例对象；</span></span><br><span class="line">    <span class="comment">//toPrintable进行打印其解析的实例对象信息</span></span><br><span class="line">    ClassLayout.parseInstance(obj).toPrintable().;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">再次打印对象布局：</span><br><span class="line">com.xxx.demo06_object_layout.LockObj object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">01</span> <span class="number">28</span> <span class="number">6</span>e <span class="number">6f</span> (<span class="number">00000001</span> <span class="number">00101000</span> <span class="number">01101110</span> <span class="number">01101111</span>) (<span class="number">1869490177</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">6</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01101101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">109</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134168253</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line">     <span class="number">16</span>      <span class="number">1</span>  <span class="built_in">bool</span>ean LockObj.b           <span class="literal">false</span></span><br><span class="line">     <span class="number">17</span>      <span class="number">7</span>    <span class="built_in">int</span> （loss due to the next object alignment）</span><br><span class="line"> Instance size: <span class="number">24</span> bytes</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">再次分析对象布局的打印信息当中此时存在VALUE当中的一些数据；</span><br><span class="line">那么这些数据就代表着hashCode；</span><br><span class="line">即：</span><br><span class="line"><span class="number">01</span> <span class="number">28</span> <span class="number">6</span>e <span class="number">6f</span> (<span class="number">00000001</span> <span class="number">00101000</span> <span class="number">01101110</span> <span class="number">01101111</span>) (<span class="number">1869490177</span>)</span><br><span class="line"><span class="number">6</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01101101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">109</span>)</span><br><span class="line">那么如何判断上述是否真的为hashCode呢？那么来进行一下验证；</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">package com.xxx.demo06_object_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo01</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123;</span><br><span class="line">    LockObj obj = new LockObj();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用obj对象的hashCode()方法</span></span><br><span class="line">    obj.hashCode();</span><br><span class="line">    <span class="comment">//该打印的为十进制的hashCode</span></span><br><span class="line">    System.<span class="keyword">out</span>.println(obj.hashCode());</span><br><span class="line">    <span class="comment">//换一种打印方式；使用Integer.toHexString()将十进制hashCode转换成十六进制的hashCode</span></span><br><span class="line">    System.<span class="keyword">out</span>.println(Integer.toHexString(obj.hashCode()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//parseInstance 解析实例对象；</span></span><br><span class="line">    <span class="comment">//toPrintable进行打印其解析的实例对象信息</span></span><br><span class="line">    ClassLayout.parseInstance(obj).toPrintable().;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">再次输出结果并打印对象布局：</span><br><span class="line"><span class="number">1836019240</span>    # <span class="number">10</span>进制hashCode</span><br><span class="line"><span class="number">6</span>d6f6e28      # <span class="number">16</span>进制hashCode</span><br><span class="line">com.xxx.demo06_object_layout.LockObj object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">01</span> <span class="number">28</span> <span class="number">6</span>e <span class="number">6f</span> (<span class="number">00000001</span> <span class="number">00101000</span> <span class="number">01101110</span> <span class="number">01101111</span>) (<span class="number">1869490177</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">6</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01101101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">109</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     <span class="number">43</span> c1 <span class="number">00</span> f8 (<span class="number">01000011</span> <span class="number">11000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134168253</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line">     <span class="number">16</span>      <span class="number">1</span>  <span class="built_in">bool</span>ean LockObj.b           <span class="literal">false</span></span><br><span class="line">     <span class="number">17</span>      <span class="number">7</span>    <span class="built_in">int</span> （loss due to the next object alignment）</span><br><span class="line"> Instance size: <span class="number">24</span> bytes</span><br><span class="line"> -----------------------------------------------------------</span><br><span class="line"> 分析此时发现十六进制位的hashCode：<span class="number">6</span>d6f6e28与</span><br><span class="line"> <span class="number">01</span> <span class="number">28</span> <span class="number">6</span>e <span class="number">6f</span> (<span class="number">00000001</span> <span class="number">00101000</span> <span class="number">01101110</span> <span class="number">01101111</span>) (<span class="number">1869490177</span>)</span><br><span class="line"> <span class="number">6</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01101101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">109</span>)</span><br><span class="line"> 对比起来有些茫然；顺序不一致（尽管对象布局的对象头信息打印中出现了这些字符串）；</span><br><span class="line">这里需要稍微注意一下；有一个大端和小端的问题；</span><br><span class="line">比如说当前存在有<span class="number">64</span>位；</span><br><span class="line"><span class="number">64</span>位有大端和小端的区别；</span><br><span class="line">第一种情况</span><br><span class="line">    <span class="number">1</span>       <span class="number">2</span>        <span class="number">3</span>        <span class="number">4</span>        <span class="number">5</span>         <span class="number">6</span>        <span class="number">7</span>       <span class="number">8</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">第二种情况</span><br><span class="line">    <span class="number">8</span>       <span class="number">7</span>        <span class="number">6</span>        <span class="number">5</span>        <span class="number">4</span>         <span class="number">3</span>        <span class="number">2</span>       <span class="number">1</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">那么刚才在<span class="number">64</span>位JVM当中看到的是属于哪一种呢？</span><br><span class="line">即为下面第二种情况当中的；也就是说<span class="number">64</span>位的Mark Word</span><br><span class="line">    <span class="number">8</span>       <span class="number">7</span>        <span class="number">6</span>        <span class="number">5</span>        <span class="number">4</span>         <span class="number">3</span>        <span class="number">2</span>       <span class="number">1</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">前面<span class="number">25</span>位是没有进行使用的；中间的话存在<span class="number">31</span>位是被用来表示hashCode的；</span><br><span class="line">后面倒数第三位表示偏向锁；最后两位表示其他锁的标志位；</span><br><span class="line">但是java当中通过jol工具进行打印出来的对象布局当中的hashCode信息是反过来的；</span><br><span class="line">即所以需要反过来进行查看；即</span><br><span class="line"> <span class="number">01</span> <span class="number">28</span> <span class="number">6</span>e <span class="number">6f</span> (<span class="number">00000001</span> <span class="number">00101000</span> <span class="number">01101110</span> <span class="number">01101111</span>) (<span class="number">1869490177</span>)</span><br><span class="line"> <span class="number">6</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01101101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">109</span>)</span><br><span class="line"> 需要反过来看即</span><br><span class="line"> （忽略前面的<span class="number">00</span> <span class="number">00</span> <span class="number">00</span>前面的这<span class="number">25</span>位；中间的<span class="number">6</span>d <span class="number">6f</span> <span class="number">6</span>e <span class="number">28</span>这<span class="number">31</span>位才是用来表示hashCode的；）：</span><br><span class="line"> <span class="number">01</span> <span class="number">28</span> <span class="number">6</span>e <span class="number">6f</span> (<span class="number">00000001</span> <span class="number">00101000</span> <span class="number">01101110</span> <span class="number">01101111</span>) (<span class="number">1869490177</span>)</span><br><span class="line"> <span class="number">6</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">01101101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">109</span>)</span><br><span class="line">即hashCode为<span class="number">6</span>d <span class="number">6f</span> <span class="number">6</span>e <span class="number">28</span>(<span class="number">01101101</span> <span class="number">01101111</span> <span class="number">01101110</span> <span class="number">00101000</span>)</span><br><span class="line">至此也是使用了java工具来进行验证了对象的布局；</span><br></pre></td></tr></table></figure>

<table>
  <tr>
    <td rowspan="2">锁状态</td>
    <td>25bit</td>
    <td>31bit</td>
    <td>1bit</td>
    <td>4bit</td>
    <td>1bit</td>
    <td>2bit</td>
  </tr>
  <tr>
    <td> </td>
    <td> </td>
    <td>cms_free</td>
    <td>分代年龄</td>
    <td>偏向锁</td>
    <td>锁标志位</td>
  </tr>
  <tr>
    <td>无锁</td>
    <td>unused（没有使用）</td>
    <td>hashCode</td>
    <td></td>
    <td></td>
    <td>0（是否是偏向锁；0表示非偏向锁；1表示是偏向锁）</td>
    <td>01（锁的标志位；01代表无锁；00代表轻量级锁；10代表重量级锁）</td>
  </tr>
    <tr>
    <td>偏向锁</td>
    <td colspan="2">ThreadId(54bit)Epoch(2bit)</td>
    <td></td>
    <td></td>
    <td>1</td>
    <td>01</td>
  </tr>
  <tr>
    <td>轻量级锁</td>
    <td colspan="5">指向栈中锁记录的指针</td>
    <td>00</td>
  </tr>
  <tr>
    <td>重量级锁</td>
    <td colspan="5">指向互斥量（重量级锁）的指针</td>
    <td>10</td>
  </tr>
</table>

<h3 id="小结-14"><a href="#小结-14" class="headerlink" title="小结"></a>小结</h3><p>java对象由三部分组成：对象头、实例数据、对齐数据；<br>对象头分为两部分：Mark Word + Klass pointer；</p>
<h2 id="synchronized优化-偏向锁"><a href="#synchronized优化-偏向锁" class="headerlink" title="synchronized优化-偏向锁"></a>synchronized优化-偏向锁</h2><h3 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h3><p>高效并发是从JDK1.5到JDK1.6的一个重要改进。<br>HotSpot虚拟机开发团队在这个版本上花费了大量的精力趋实现各种锁优化技术，<br>如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，<br>这些技术都是为了 在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<p>无锁–→偏向锁–→轻量级锁–→重量级锁</p>
<p>无锁并不会直接进入到重量级锁当中去；而是先进入偏向锁；</p>
<p>偏向锁</p>
<h3 id="目标-18"><a href="#目标-18" class="headerlink" title="目标"></a>目标</h3><p>学习偏向锁的原理和好处</p>
<h3 id="什么是偏向锁"><a href="#什么是偏向锁" class="headerlink" title="什么是偏向锁"></a>什么是偏向锁</h3><p>偏向锁是JDK6中的重要引进，因为HotSpot作者经过研究实践发现，<br>（代码）在大多数情况下，锁不仅不存在多线程竞争而且总是由同一线程多次获得（即由同一个线程反复的得到锁释放锁得到锁释放锁；如果一上来就是重量级锁的话那么得到锁就需要花费性能释放锁也需要花费性能），为了让线程获得锁的代价更低，引进了偏向锁。<br>减少不必要的CAS操作。</p>
<p>偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及ThreadID即可。</p>
<p>不过一旦出现多个线程竞争时，必须撤销偏向锁，<br>所以撤销偏向锁消耗的性能必须小于之前节省下来的CAS原子操作的性能消耗，<br>不然就得不偿失了。</p>
<p>如果是偏向锁则倒数第三个字节会变成1；另外由前面56个字节当中的前54个字节会来保存偏向锁的id；另外56个字节当中其余两个字节用来保证Epoch即时间；</p>
<table>
  <tr>
    <td rowspan="2">锁状态</td>
    <td>25bit</td>
    <td>31bit</td>
    <td>1bit</td>
    <td>4bit</td>
    <td>1bit</td>
    <td>2bit</td>
  </tr>
  <tr>
    <td> </td>
    <td> </td>
    <td>cms_free</td>
    <td>分代年龄</td>
    <td>偏向锁</td>
    <td>锁标志位</td>
  </tr>
  <tr>
    <td>无锁</td>
    <td>unused（没有使用）</td>
    <td>hashCode</td>
    <td></td>
    <td></td>
    <td>0（是否是偏向锁；0表示非偏向锁；1表示是偏向锁）</td>
    <td>01（锁的标志位；01代表无锁；00代表轻量级锁；10代表重量级锁）</td>
  </tr>
    <tr>
    <td>偏向锁</td>
    <td colspan="2">ThreadId(54bit)Epoch(2bit)</td>
    <td></td>
    <td></td>
    <td>1</td>
    <td>01</td>
  </tr>
  <tr>
    <td>轻量级锁</td>
    <td colspan="5">指向栈中锁记录的指针</td>
    <td>00</td>
  </tr>
  <tr>
    <td>重量级锁</td>
    <td colspan="5">指向互斥量（重量级锁）的指针</td>
    <td>10</td>
  </tr>
</table>

<p>但是需要注意的是这个偏向锁仅限用于没有竞争的状态；<br>也就是说反复是同一个线程获得锁释放锁；</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo07_biased_lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环5次并且进出同步代码块就只有一个线程；</span></span><br><span class="line"><span class="comment">// 那么这种情况就适合使用偏向锁；</span></span><br><span class="line"><span class="comment">// 即反复是同一个线程进入同步代码块的情况；</span></span><br><span class="line"><span class="comment">// 但是如果遇到有线程来进行竞争那么即立即要撤销掉偏向锁从而升级到轻量级锁；</span></span><br></pre></td></tr></table></figure>

<h3 id="偏向锁原理"><a href="#偏向锁原理" class="headerlink" title="偏向锁原理"></a>偏向锁原理</h3><p>当线程第一次访问同步代码块并获取锁时，偏向锁处理流程如下：</p>
<blockquote>
<ol>
<li>检测Mark Word是否为 可偏向状态，即是否为偏向锁1，锁标识为为01。</li>
<li>若为 可偏向状态，则测试线程ID是否为当前线程ID，如果是，执行同步代码块，否则执行步骤（3）</li>
<li>如果测试线程ID不为当前线程ID，则通过CAS操作将Mark Word的线程ID替换为当前线程，执行同步代码块</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>虚拟机将会把对象头中的标志位设为“01”，即偏向模式</li>
<li>同时使用 CAS操作 把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步代码块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</li>
</ol>
</blockquote>
<p>首先虚拟机会进行检查这个偏向锁的状态即倒数第三位取值是否为0；<br>是0的话那么也就代表着可以进行偏向，将倒数第三位修改成1表示偏向锁；那么虚拟机也就会将其倒数两位数改成01；即变成偏向锁；<br>那么还会通过CAS操作将对象的Mark Word当中的前54位修改为当前获取得到偏向锁的线程的Thread ID；那么到此时这个偏向锁就设置成功了；<br>那么以后的话线程退出同步代码块的时候并不需要做任何操作而下一次循环当中重新进入同步代码块时，只需要进行判定一下THREAD ID即Mark Word当中的前54位当中的取值即THREAD ID与当前该要获取锁的线程的THREAD ID是否相同；<br>如果是一样的话那么则进入同步代码块当中；无需其他操作；<br>所以偏向锁它在一个线程的情况下其效率还是很高的；</p>
<table>
  <tr>
    <td rowspan="2">锁状态</td>
    <td>25bit</td>
    <td>31bit</td>
    <td>1bit</td>
    <td>4bit</td>
    <td>1bit</td>
    <td>2bit</td>
  </tr>
  <tr>
    <td> </td>
    <td> </td>
    <td>cms_free</td>
    <td>分代年龄</td>
    <td>偏向锁</td>
    <td>锁标志位</td>
  </tr>
  <tr>
    <td>无锁</td>
    <td>unused（没有使用）</td>
    <td>hashCode</td>
    <td></td>
    <td></td>
    <td>0（是否是偏向锁；0表示非偏向锁；1表示是偏向锁）</td>
    <td>01（锁的标志位；01代表无锁；00代表轻量级锁；10代表重量级锁）</td>
  </tr>
    <tr>
    <td>偏向锁</td>
    <td colspan="2">ThreadId(54bit)Epoch(2bit)</td>
    <td></td>
    <td></td>
    <td>1</td>
    <td>01</td>
  </tr>
  <tr>
    <td>轻量级锁</td>
    <td colspan="5">指向栈中锁记录的指针</td>
    <td>00</td>
  </tr>
  <tr>
    <td>重量级锁</td>
    <td colspan="5">指向互斥量（重量级锁）的指针</td>
    <td>10</td>
  </tr>
</table>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo07_biased_lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo01</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123;</span><br><span class="line">    MyThread mt = new MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">MyThread</span> <span class="symbol">extends</span> <span class="symbol">Thread</span>&#123;</span><br><span class="line">  static Object obj = new Object();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> run()&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      synchronized(obj)&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">线程进过5次循环每一次循环都进入到同步代码块当中；</span></span><br><span class="line"><span class="comment">对象锁为obj；此时只有一个线程按道理应该是使用的偏向锁；</span></span><br><span class="line"><span class="comment">另外在同步代码块当中进行打印的对象的对象布局信息；以此用来检查是否存在偏向锁的标记；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">打印结果：</span><br><span class="line">com.lang.Object object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     d8 ed <span class="number">44</span> <span class="number">29</span> (<span class="number">11011000</span> <span class="number">11101101</span> <span class="number">01000100</span> <span class="number">00101001</span>) (<span class="number">692383192</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134217243</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line"> Instance size: <span class="number">16</span> bytes</span><br><span class="line"> Space losses: <span class="number">0</span> bytes <span class="built_in">int</span>ernal + <span class="number">4</span> bytes <span class="keyword">external</span> = <span class="number">4</span> bytes total</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">分析：</span><br><span class="line"><span class="number">0</span>      <span class="number">4</span>        （object header）     d8 ed <span class="number">44</span> <span class="number">29</span> (<span class="number">11011000</span> <span class="number">11101101</span> <span class="number">01000100</span> <span class="number">00101001</span>) (<span class="number">692383192</span>)</span><br><span class="line">当中的</span><br><span class="line">d8 ed <span class="number">44</span> <span class="number">29</span> (<span class="number">11011000</span> <span class="number">11101101</span> <span class="number">01000100</span> <span class="number">00101001</span>) (<span class="number">692383192</span>)</span><br><span class="line">当中的</span><br><span class="line">d8 <span class="number">11011000</span> 即最终的第<span class="number">8</span>个字节即</span><br><span class="line">    <span class="number">8</span>       <span class="number">7</span>        <span class="number">6</span>        <span class="number">5</span>        <span class="number">4</span>         <span class="number">3</span>        <span class="number">2</span>       <span class="number">1</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">其实就是</span><br><span class="line">    <span class="number">1</span></span><br><span class="line"><span class="number">00000000</span></span><br><span class="line">显示到前面去了即</span><br><span class="line">    <span class="number">1</span>       <span class="number">2</span>        <span class="number">3</span>        <span class="number">4</span>        <span class="number">5</span>         <span class="number">6</span>        <span class="number">7</span>       <span class="number">8</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">这个样子；</span><br><span class="line">即d8 <span class="number">11011000</span>代表的就是是否是偏向锁，即锁的标志位；</span><br><span class="line">那么d8其<span class="number">8</span>位当中的最后三位即<span class="number">000</span>；那么<span class="number">000</span>是属于偏向锁吗；不是；</span><br><span class="line">那么为什么不是偏向锁呢？原因在于：偏向锁虽然在jdk1<span class="number">.6</span>的时候偏向锁是开启的；</span><br><span class="line">但是这个默认开启的偏向锁并不是立马可以进行使用的；</span><br><span class="line">所以这个时候又需要添加一个JVM参数即在VM options处填入参数：-XX:BiasedLockingStartupDelay=<span class="number">0</span>；</span><br><span class="line">让其原始值为<span class="number">0</span>即程序一启动那么偏向锁就生效；</span><br><span class="line">那么再次运行尝试：</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">再次运行打印结果：</span><br><span class="line">com.lang.Object object <span class="built_in">int</span>ernals:</span><br><span class="line"> OFFSET   SIZE   TYPE  DESCRIPTION         VALUE</span><br><span class="line">      <span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">05</span> <span class="number">90</span> <span class="number">61</span> <span class="number">27</span> (<span class="number">00000101</span> <span class="number">10010000</span> <span class="number">01100001</span> <span class="number">00100111</span>) (<span class="number">660705285</span>)</span><br><span class="line">      <span class="number">4</span>      <span class="number">4</span>        （object header）     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>      <span class="number">4</span>        （object header）     e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (<span class="number">-134217243</span>)</span><br><span class="line">     <span class="number">12</span>      <span class="number">4</span>    <span class="built_in">int</span>   LockObj.x           <span class="number">0</span></span><br><span class="line"> Instance size: <span class="number">16</span> bytes</span><br><span class="line"> Space losses: <span class="number">0</span> bytes <span class="built_in">int</span>ernal + <span class="number">4</span> bytes <span class="keyword">external</span> = <span class="number">4</span> bytes total</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">分析：</span><br><span class="line">程序首先由主线程从main方法开始进行执行并在main方法当中创建一个新线程叫做mt并启动它；用t1表示新线程mt；</span><br><span class="line">那么新线程t1就会执行到run方法当中去进行<span class="number">5</span>次循环并在每次循环当中进入同步代码块且打印其对象布局中对象头等对象布局信息；</span><br><span class="line">此时只有一个线程没有其他线程来进行竞争操作；</span><br><span class="line">那么此时t1第一次来进行执行同步代码块synchronized的时候就会去看这个对象头obj当中它的锁标记是什么；</span><br><span class="line">那么一开始的时候该对象头是属于无锁状态即倒数第二位为<span class="number">0</span>（表示不为偏向锁状态；即无锁状态）；</span><br><span class="line">那么这个时候由于要将无锁状态改为偏向锁状态那么此时就会将倒数第三位改成<span class="number">1</span>（即偏向锁状态；表示转成偏向锁状态）；</span><br><span class="line">另外前<span class="number">56</span>位当中的前<span class="number">54</span>位会被用来保存这个偏向锁的id；以及前<span class="number">56</span>位当中的后两位用来进行保存Epoch即相关时间；</span><br><span class="line">那么这个时候就让t1线程进入了同步代码块当中（其实也就表示设置好了偏向锁，要进入同步代码块当中进行执行；然后进行打印对象布局信息中即<span class="number">101</span>；</span><br><span class="line">也就是<span class="number">0</span>      <span class="number">4</span>        （object header）     <span class="number">05</span> <span class="number">90</span> <span class="number">61</span> <span class="number">27</span> (<span class="number">00000101</span> <span class="number">10010000</span> <span class="number">01100001</span> <span class="number">00100111</span>) (<span class="number">660705285</span>)中的<span class="number">05</span> <span class="number">00000101</span>其<span class="number">8</span>位的倒数三位<span class="number">101</span>；也就表示转变成了偏向锁状态）；</span><br><span class="line">当执行完成打印对象布局信息即也就是完成同步代码块中的任务要出同步代码块时，退出同步代码块时这个偏向锁就并不用做什么事情；</span><br><span class="line">那么当下一次循环时（总共有<span class="number">5</span>次循环），该线程t1又要从同步代码块当中来进行获取锁；</span><br><span class="line">它就会发现对象锁obj当中即为一个偏向锁的状态；</span><br><span class="line">并且只要去进行对比一下这个线程Id即前<span class="number">56</span>位当中的<span class="number">54</span>位的值是否取值相等即THREAD id是否与当前这个要获取锁的线程的THREAD id相同；</span><br><span class="line">如果是，那么就直接进入到同步代码块当中；</span><br><span class="line">即有了偏向锁之后，那么后面的循环中当前该线程再次去获取锁就变得很简单了只需要（对比一下THREAD ID是否一致即可）两个动作</span><br><span class="line">（<span class="number">1</span>: 检查倒数第三位是否是偏向锁标志，如果是则执行第二个动作；如果不是则将倒数第三位的数值改为<span class="number">1</span>即表示偏向锁；<span class="number">2</span>: 首先检查前<span class="number">56</span>位当中的前<span class="number">54</span>位的THREAD ID是否有取值；如果没有取值则设置为当前的该线程ID；如果存在取值THREAD ID则将当前要获取锁的线程进行与前<span class="number">54</span>位中的THREAD ID进行比较，如果相同则直接可以进入到同步代码块当中）；</span><br><span class="line">退出循环之后每次再次进行循环需要进入同步代码块时之前对比一下THREAD ID是否一致即可；</span><br><span class="line">所以偏向锁可以看到在一个线程执行同步代码块的情况下其效率是非常高的（较之重量级锁要高很多）；</span><br></pre></td></tr></table></figure>

<h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><h4 id="什么时候撤销偏向锁"><a href="#什么时候撤销偏向锁" class="headerlink" title="什么时候撤销偏向锁"></a>什么时候撤销偏向锁</h4><p>一旦存在有两个线程来进行锁的时候那么就会撤销偏向锁；</p>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo07_biased_lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line"></span><br><span class="line">    MyThread mt2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">假设在这当中存在有两个线程；</span></span><br><span class="line"><span class="comment">也就意味着有两个线程会去进行run()当中的synchronized；</span></span><br><span class="line"><span class="comment">那么两个线程来进行执行的时候就需要将该偏向锁给进行撤销；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="偏向锁撤销过程"><a href="#偏向锁撤销过程" class="headerlink" title="偏向锁撤销过程"></a>偏向锁撤销过程</h3><ol>
<li>偏向锁的撤销动作必须等待<strong>全局安全点</strong></li>
<li>暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态</li>
<li>撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态；</li>
</ol>
<blockquote>
<p>TIPS: 全局安全点<br>假设当前需要进行统计超市在9点的时候超市当中有多少人；<br>那么应该如何统计？<br>即在9点的时候，让在超市当中的所有人都停下来；不要有人进入超市也不要有人出超市；那么这个时候才来进行统计；<br>那么这个线程安全点指的就是在这个点的时候所有的线程都会进行停下来；那么也就叫做全局安全点；那么只有到了全局安全点的时候才能来进行撤销偏向锁；</p>
</blockquote>
<p>偏向锁 在 java1.6 之后是默认启用的；<br>但是在应用程序启动几秒钟才激活，可以使用<code>-XX:BiasedLockingStartupDelay=0</code>参数关闭延迟，<br>如果确定应用程序所有锁通常情况下处于竞争状态，<br>可以通过<code>-XX:-UseBiasedLocking=false</code>参数关闭偏向锁</p>
<h3 id="偏向锁好处"><a href="#偏向锁好处" class="headerlink" title="偏向锁好处"></a>偏向锁好处</h3><p>偏向锁适合使用在只有一个线程来获取锁的时候进行使用；<br>即没有竞争情况；那么在这种情况下一个线程反复进入同步代码块退出同步代码块的效率是很高的；只要进行判断对象头当中的线程id即THREAD ID跟现在要获取锁的线程的THREAD ID是否相同即可；如果相同则进入同步代码块；退出同步代码块时也不需要做什么事情；所以性能高；<br>但是这个偏向锁不一定总是好的；<br>如果存在有很多的线程来竞争锁；那么这个时候偏向锁就起不到什么作用了反而会影响效率；因为每次撤销一次偏向锁都必须要等待全局安全点所有线程都会停下来才能够进行撤销偏向锁，所以反而还会影响性能；<br>比如说使用线程池来执行代码的时候，那么这个时候知道线程池当中肯定有多个线程反复去执行同样的任务，同样的代码即反复的去竞争同一把锁；那么在这个时候偏向锁就是多余的了；<br>注意在JDK1.5的时候偏向锁是默认关闭的；而在JDK1.6的时候偏向锁是默认开启的；如果不需要偏向锁可以通过启动参数<code>-XX:-UseBiasedLocking=false</code>来进行关闭偏向锁；让其直接进入重量级锁；</p>
<p>偏向锁是在 只有一个线程执行同步块时 进一步提高性能，适用于一个线程反复获得同一把锁的情况。<br>偏向锁可以提高带有同步但无竞争的程序性能。</p>
<p>它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利。<br>如果程序中大多数的锁总是被多个不同的线程访问比如线程池，那偏向模式就是多余的。  </p>
<p>在JDK1.5中偏向锁默认是关闭的，而到了JDK6中偏向锁已经默认开启。<br>但在应用程序启动几秒钟之后才激活，可以使用<code>-XX:BiasedLockingStartupDelay=0</code>参数关闭延迟，<br>如果确定应用中所有锁通常情况下处于竞争状态，可以通过<code>-XX:-UseBiasedLocking=false</code>参数关闭偏向锁；</p>
<h3 id="小结-15"><a href="#小结-15" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>偏向锁的原理是什么？</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当锁对象第一次被线程获取的时候，</span><br><span class="line">虚拟机将会把对象头中的锁标志位设置为“<span class="number">01</span>”，即偏向模式。</span><br><span class="line">同时使用<span class="built_in">CAS</span>操作把获取得到的这个锁的线程的ID记录在对象的Mark Word之中，</span><br><span class="line">如果<span class="built_in">CAS</span>操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</span><br></pre></td></tr></table></figure>

<table>
  <tr>
    <td rowspan="2">锁状态</td>
    <td>25bit</td>
    <td>31bit</td>
    <td>1bit</td>
    <td>4bit</td>
    <td>1bit</td>
    <td>2bit</td>
  </tr>
  <tr>
    <td> </td>
    <td> </td>
    <td>cms_free</td>
    <td>分代年龄</td>
    <td>偏向锁</td>
    <td>锁标志位</td>
  </tr>
  <tr>
    <td>无锁</td>
    <td>unused（没有使用）</td>
    <td>hashCode</td>
    <td></td>
    <td></td>
    <td>0（是否是偏向锁；0表示非偏向锁；1表示是偏向锁）</td>
    <td>01（锁的标志位；01代表无锁；00代表轻量级锁；10代表重量级锁）</td>
  </tr>
    <tr>
    <td>偏向锁</td>
    <td colspan="2">ThreadId(54bit)Epoch(2bit)</td>
    <td></td>
    <td></td>
    <td>1</td>
    <td>01</td>
  </tr>
  <tr>
    <td>轻量级锁</td>
    <td colspan="5">指向栈中锁记录的指针</td>
    <td>00</td>
  </tr>
  <tr>
    <td>重量级锁</td>
    <td colspan="5">指向互斥量（重量级锁）的指针</td>
    <td>10</td>
  </tr>
</table>

<p>当线程第一次来获取锁的时候，<br>那么虚拟机就会把对象头设置为01，且偏向锁设置为1；<br>那么这个时候就记录了偏向模式；同时通过CAS操作将前面的54位设置为获取了偏向锁的线程的THREAD ID；那么如果设置成功则说明该线程获取得到了该偏向锁；<br>那么后续的进入同步代码块时效率就会变高了；</p>
<blockquote>
<p>偏向锁的好处是什么？</p>
</blockquote>
<p>偏向锁适用于一个线程反复进入同步代码块的情况；<br>即没有锁竞争的情况下；那么这个时候是可以提高一个线程进入同步代码块时的效率的；但是如果存在竞争那就不行了；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">偏向锁是在 只有一个线程 执行同步代码块时 进一步提高性能，</span><br><span class="line">适用于 一个线程反复获得同一个锁的情况。</span><br><span class="line">偏向锁可以提高带有同步但是无竞争的程序性能。</span><br></pre></td></tr></table></figure>

<h2 id="synchronized优化-轻量级锁"><a href="#synchronized优化-轻量级锁" class="headerlink" title="synchronized优化-轻量级锁"></a>synchronized优化-轻量级锁</h2><h3 id="目标-19"><a href="#目标-19" class="headerlink" title="目标"></a>目标</h3><p>学习轻量级锁的原理和好处</p>
<h3 id="什么是轻量级锁"><a href="#什么是轻量级锁" class="headerlink" title="什么是轻量级锁"></a>什么是轻量级锁</h3><p>当偏向锁出现竞争的时候，会撤下偏向锁从而升级到轻量级锁；<br>轻量级锁是JDK1.6当中为了优化synchronized而引入的一种新型锁机制；<br>需要注意的是轻量级锁不是任何情况下其开销比较的小而是在特定的情况下才开销比较小；所以轻量级锁并不能够用来代替重量级锁；轻量级锁只是在一定的情况下来进行减少消耗；</p>
<p>轻量级锁是 JDK1.6之中加入的 新型锁机制，<br>它名字中的“轻量级”是相对于使用monitor的传统锁而言的，<br>因此传统的锁机制就称为“重量级”锁。<br>首先需要强调的一点是，轻量级锁并不是用来代替重量级锁的；</p>
<p>引入轻量级锁的目的： 在多线程交替执行同步块的情况下，（引入轻量级锁）尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要代替重量级锁。</p>
<p>（也就是说在多线程交替执行同步块的时候轻量级的性能才是比较好的）<br>假设在餐厅当中，有多个桌椅以便于用来用户用餐；<br>假设现在有第一个人来进行到一号座当中用餐，用餐完毕之后离开一号座；<br>那么当一号座的用户离开之后现在又来了第二个用户又坐到了一号座当中进行用餐，同样用餐完毕之后离开一号座；紧接着第二个用户离开之后第三个用户又来了且也是坐在一号座的位置上进行用餐；可以看到的是这三个用户是分别不同时刻来进行用餐的；即也就是交替进行的没有竞争的状况；那么如果说一号座的风景比较好又处于下班用餐的高峰期，同一时刻三个用户同时来进行竞争一号座的用餐；那么这个时候就出现了竞争；也就不适合使用轻量级锁了；</p>
<h3 id="轻量级锁原理"><a href="#轻量级锁原理" class="headerlink" title="轻量级锁原理"></a>轻量级锁原理</h3><p>当关闭偏向锁功能 或者 多个线程竞争偏向锁导致偏向锁升级为轻量级锁，<br>则会尝试获取轻量级锁，其获取锁步骤如下：</p>
<ol>
<li><p>判断当前对象 是否处于无锁状态（hashcode、0、01）；<br>如果是，则JVM首先将在当前线程的栈帧中建立一个所记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word），将对象的Mark Word赋值到栈帧中的Lock Record中，将Lock Record的owner指向当前对象。</p>
</li>
<li><p>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针；如果成功表示竞争到锁，则将锁标志位变成00，执行同步操作。</p>
</li>
<li><p>如果失败则判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象</p>
</li>
</ol>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p>写一个方法时那么到时候这个方法运行时就将会进入到栈当中来进行执行；<br>那么该方法进入到栈中的该方法就称作是栈帧；<br>栈帧：一个进入栈中的方法就是一个栈帧；<br>那么这个栈帧是用来执行方法的所以这个栈帧也具有空间，也能够存储一些变量；</p>
<table>
  <tr>
    <td rowspan="2">锁状态</td>
    <td>25bit</td>
    <td>31bit</td>
    <td>1bit</td>
    <td>4bit</td>
    <td>1bit</td>
    <td>2bit</td>
  </tr>
  <tr>
    <td> </td>
    <td> </td>
    <td>cms_free</td>
    <td>分代年龄</td>
    <td>偏向锁</td>
    <td>锁标志位</td>
  </tr>
  <tr>
    <td>无锁</td>
    <td>unused（没有使用）</td>
    <td>hashCode</td>
    <td></td>
    <td></td>
    <td>0（是否是偏向锁；0表示非偏向锁；1表示是偏向锁）</td>
    <td>01（锁的标志位；01代表无锁；00代表轻量级锁；10代表重量级锁）</td>
  </tr>
    <tr>
    <td>偏向锁</td>
    <td colspan="2">ThreadId(54bit)Epoch(2bit)</td>
    <td></td>
    <td></td>
    <td>1</td>
    <td>01</td>
  </tr>
  <tr>
    <td>轻量级锁</td>
    <td colspan="5">指向栈中锁记录的指针</td>
    <td>00</td>
  </tr>
  <tr>
    <td>重量级锁</td>
    <td colspan="5">指向互斥量（重量级锁）的指针</td>
    <td>10</td>
  </tr>
</table>

<p>轻量级锁分析</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">java代码：</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">MyThread</span> <span class="symbol">extends</span> <span class="symbol">Thread</span>&#123;</span><br><span class="line">  static Object obj = new Object();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> run()&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      synchronized(obj)&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">分析：</span><br><span class="line">synchronized当中的obj即为锁对象（对象锁）</span><br><span class="line">当前具有两个线程，分别是A线程以及B线程</span><br><span class="line">（创建这两个线程并启动他们，那么他们都会将去执行run()方法当中的代码）；</span><br><span class="line">可以看到的是进入synchronized同步代码块之前需要一个obj对象锁；</span><br><span class="line">假设线程A来先进行执行run()方法；</span><br><span class="line">即，即将执行的run()方法运行就会进入到栈中去，那么进入到栈中执行的方法即一个栈帧，即此时运行的run()方法即为一个栈帧；</span><br><span class="line">假设此时线程A要进入到同步代码块之中；那么这个时候就要升级为轻量级锁；因为存在有多个锁竞争；所以未使用偏向锁；</span><br><span class="line">那么此时如何进行升级为轻量级锁?</span><br><span class="line">首先在栈中运行执行run()方法的该栈帧当中会创建一个叫做Lock Record的锁记录空间（这块空间内存放displaced hdr以及owner）；</span><br><span class="line">那么接着就会将锁对象即obj升级为轻量级锁；</span><br><span class="line">那么其当前obj锁对象的状态为无锁状态；</span><br><span class="line">即会将对象当中的无锁状态当中的hashCode、分代年龄以及锁标记赋值到栈帧当中Lock record中创建的displaced hdr当中；</span><br><span class="line">另外还会将栈帧当中的Lock record当中还会进行创建的owner指向obj，即也就是synchronized的锁对象（对象锁）；</span><br><span class="line">另外还需要做的事情有升级为轻量级锁的时候会将锁标志位的数值修改成“<span class="number">00</span>”；</span><br><span class="line">并且存在前<span class="number">25</span>bit+<span class="number">31</span>bit+<span class="number">1</span>bit+<span class="number">4</span>bit+<span class="number">1</span>bit来进行保存栈帧中Lock Record的地址；</span><br><span class="line">那么这些操作都是通过CAS来进行操作的；</span><br><span class="line">这就是轻量级锁的原理；</span><br><span class="line">笔记小结-轻量级锁的原理：</span><br><span class="line">当关闭了偏向锁或者说偏向锁出现了竞争的情况那么都会导致偏向锁升级为轻量级锁；</span><br><span class="line">轻量级锁步骤如下：</span><br><span class="line">首先判断对象头当中的倒数两位即标志位是否为<span class="number">01</span>,<span class="number">01</span>即代表无锁状态；</span><br><span class="line">如果确实无锁；那么JVM就会在当前的栈帧当中建立一个Lock Record这样一个空间；</span><br><span class="line">这块空间用来存储对象头；即用来存储displaced hdr(displaced hdr即Displaced Mark Word)以及owner；</span><br><span class="line">displaced hdr也就是指的Displaced Mark Word（会将分代年龄、锁标志、锁标志等放到displaced hdr当中去）；</span><br><span class="line">并且owner会执行当前的对象即synchronized当中的obj；</span><br><span class="line">接着还会使用CAS操作把对象头当中的Mark Word进行保存栈帧中创建的Lock record的地址；</span><br><span class="line">最后会将对象头当中的标志位改成<span class="number">00</span>即代表的是轻量级锁；</span><br><span class="line">如果在这个当中升级轻量级锁失败那么就会膨胀为重量级锁；</span><br></pre></td></tr></table></figure>

<h3 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h3><p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p>
<ol>
<li>取出在获取轻量级锁 保存在Displaced Mark Word中的数据；</li>
<li>用CAS操作 将取出的数据 替换当前对象的Mark Word中，如果成功，则说明释放锁成功；</li>
<li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级锁。</li>
</ol>
<p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，<br>如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</p>
<p>轻量级锁的释放即将栈帧当中的Lock Record当中的displaced hdr当中的hashCode重新放回到对象头原有的位置上即无锁状态上31bit处；以及displaced hdr当中的分代年龄以及锁标志位等都放回原位；<br>撤销轻量级锁也是一个CAS操作；即如果将hashCode、分代年龄以及锁标志位都还原归位了那么也就说明轻量级锁已经被撤销了；</p>
<p>需要注意的是，对于轻量级锁而言：轻量级锁的性能之所以高，是因为在绝大部分情况下，这个同步代码块不存在有竞争的状况；线程之间交替执行；<br>如果是多线程同时来进行竞争这个锁的话，那么这个轻量级锁的开销也就会更大；</p>
<h3 id="轻量级锁好处"><a href="#轻量级锁好处" class="headerlink" title="轻量级锁好处"></a>轻量级锁好处</h3><p>在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</p>
<h3 id="小结-16"><a href="#小结-16" class="headerlink" title="小结"></a>小结</h3><p>轻量级锁的原理是什么？</p>
<p>轻量级锁即会在栈帧中创建一个叫做Lock record锁记录的空间；<br>那么在Lock Record锁记录空间内的displaced hdr会去进行保存对象头当中的hashCode、分代年龄以及锁标志等；另外Lock record锁记录空间当中的owner即指向的是这个锁对象；并且在对象头当中会来进行保存Lock Record锁记录的空间地址；然后将对象头当中的锁标志改成00以表示轻量级锁；</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将对象的Mark <span class="keyword">Word</span>赋值到栈帧中的Lock <span class="keyword">Record</span>中，Mark <span class="keyword">Word</span>更新为指向Lock <span class="keyword">Record</span>的指针。</span><br></pre></td></tr></table></figure>

<p>轻量级锁的好处是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</span><br></pre></td></tr></table></figure>

<h2 id="synchronized优化-自旋锁"><a href="#synchronized优化-自旋锁" class="headerlink" title="synchronized优化-自旋锁"></a>synchronized优化-自旋锁</h2><h3 id="回顾并引入-2"><a href="#回顾并引入-2" class="headerlink" title="回顾并引入"></a>回顾并引入</h3><p>当轻量级锁发生竞争的时候会膨胀升级为重量级锁；<br>但是重量级锁相对于性能开销的消耗是比较大的；<br>因此应该尽量避免升级为重量级锁；<br>所以JVM在轻量级锁在升级为重量级锁的时候的这个过程当中还会再挣扎一下；<br>尽量避免升级为重量级锁；<br>这个挣扎的过程就是自旋锁；</p>
<p>重量级锁回顾：重量级锁是由monitor来进行实现的；当一个线程来进行竞争monitor锁如果没有竞争到那么线程就会进入阻塞状态；当其他线程将锁释放的时候会来进行唤醒那些处于阻塞状态的线程有机会去竞争锁；</p>
<p>举个例子：假设第一个线程，线程A来进行执行同步代码块；<br>那么线程A竞争得到锁从而进入同步代码块当中进行执行；<br>与此同时又来了第二个线程，即线程B；第二个线程，线程B也来进行执行同步代码块；但是线程A由于没有释放锁；从而线程B就没有办法获取得到锁从而无法进入同步代码块从而进入阻塞状态；只有第一个线程即线程A退出同步代码块并且将锁释放之后才会去唤醒阻塞状态的线程B；从而第二个线程线程B才能够有机会再次获取锁从而进入同步代码块中；<br>线程的阻塞和唤醒是需要CPU从用户态切换至内核态的；<br>频繁的状态切换对于CPU的开销来说也是比较大的；<br>并且虚拟机开发团队也发现其实大部分情况下线程对共享资源的操作所持续的时间是比较短的；即也就是说进入同步代码块到退出同步代码块释放锁的时间也是比较短的；<br>那么之前都是执行执行同步代码块而让其他没有获取得到锁的线程进行等待阻塞状态；那么这样其实是不划算的；</p>
<p>具体来说是这样的：<br>假设第一个线程A获取得到锁并进入同步代码块当中去执行，很快就可以执行完成；<br>但是与此同时来了第二个线程线程B；而此时线程A并没有释放锁；所以线程B没有获得锁从而进入阻塞状态；可能在线程B还没有进入到阻塞状态时这个线程A就已经执行完并且将锁进行释放了；<br>那么对于外面陷入等待阻塞的线程B来说就开销较大并且比较耗费资源；<br>其实这个时候只要让外面这个线程B在同步代码块外面多循环几次多尝试一下就有可能获取得到锁；就不必要让外面这个线程B进入阻塞状态；以及后面还要去唤醒它，浪费资源；</p>
<p>举个例子：<br>在火车上的一间卫生间当中；<br>假设有两个人分别是叫做A用户和B用户；<br>那么此时A用户先进入到火车的这一间卫生间当中；并且将卫生间的门给锁上了；<br>后面来了的第二个人即用户B，从他的位置上走过来到卫生间，表示也想要上厕所；<br>但是用户B发现此时卫生间的门已经被锁上了；所以用户B又从卫生间回到了他自己的位置上去了；<br>那么此时就有这样一种情况发生：<br>当用户A进行上卫生间只需要花费10秒钟的时间；<br>而用户B从位置上到达卫生间可能需要花费30秒的时间；<br>当用户A进入到卫生间并将卫生间的门锁上的时候；10秒钟还没有执行完；<br>与此同时用户B从位置上走到卫生间花费了30秒的时间，发现卫生间的门被锁上了；所以又从卫生间返回到其位置上去花费了30秒钟的时间；<br>其实用户A也许10秒钟之后就可以从卫生间中出来了；那么即用户B就浪费了一部分的时间资源；<br>这个例子其实就相当于是重量级锁；<br>那么其实也还可以这么做，当用户A进入卫生间并将门锁上的时候；用户B从位置上走到卫生间来看到卫生间的门被锁住，第一时间并不是又返回到位置上面去这样花费的时间太长了；而是在卫生间的门口进行等待；而且可以每隔一秒敲一下门看门内的用户A是否用完了卫生间可以出来；即如果用户A没有出门则可以再隔一秒钟再次敲一下门，如果用户A仍然还没有出来那么这个时候用户B又过一秒再次敲一下门，如果用户A出来了那么这个时候卫生间外的用户B就可以进去了；<br>那么可以看到卫生间外的用户B只要在门口等多尝试几次就可以获取得到锁；<br>就避免了从卫生间又走到位置上花了30秒的时间；</p>
<p>要让外面的线程不进行阻塞；而是循环几次来进行抢锁；<br>那么就需要保证本机是一个多核CPU，能够让两个或以上的线程来进行并行执行；<br>这样就可以线程A在同步代码块内进行执行代码；而另外其他的线程B则在同步代码块外进行尝试的来进行获取锁；<br>即同步代码块外面的线程B就不会进入到阻塞状态中去；<br>这样的话可能性能开销就小一点；<br>那么让同步代码块外面的线程B进行多次尝试抢锁的这个过程就叫做自旋；<br>那么支持这种自旋的锁就称之为自旋锁；<br>另外还需要注意的是循环是很快的所以就需要让这个循环尽量慢一点；即让这个循环锁花费的时间尽量长一点；<br>那么也就知道了自旋锁在一定情况下是可以减小性能开销的；</p>
<h3 id="目标-20"><a href="#目标-20" class="headerlink" title="目标"></a>目标</h3><p>学习自旋锁的原理</p>
<h3 id="自旋锁原理"><a href="#自旋锁原理" class="headerlink" title="自旋锁原理"></a>自旋锁原理</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(<span class="module-access"><span class="module"><span class="identifier">Demo01</span>.</span></span><span class="keyword">class</span>)&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面讨论 monitor实现锁 的时候，知道 monitor会阻塞和唤醒线程，<br>线程的阻塞和唤醒 需要CPU从用户态转化为核心态，<br>频繁的阻塞和唤醒对CPU来说 是一件负担很重的工作。<br>这些操作给系统的并发性能 带来了很大的压力。<br>同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间阻塞和唤醒线程并不值得。<br>如果物理机器有一个以上的处理器，能让两个或两个以上的线程同时并发执行，<br>就可以让后面请求锁的那个线程 “稍等一下”，<br>但不放弃处理器的执行时间，看看持有锁的线程 是否很快就会释放锁。<br>为了让线程等待，只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p>
<p><strong>自旋锁</strong>在<strong>JDK 1.4.2</strong>中就已经引入，只不过<strong>默认是关闭</strong>的，<br>可以使用<code>-XX:+UseSpinning</code>参数来开启，<br>在<strong>JDK 6</strong>中就已经改为<strong>默认开启</strong>了。<br>自旋等待不能代替阻塞，且先不说处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的；<br>因此，如果锁被占用的时间很短，自旋等待的效果就会非常好；<br>反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费；<br>因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。<br>自旋次数的默认值是10次，用户可以使用参数-XX:PreBlockSpin来更改；</p>
<p>通过前面的学习中可以知道自旋锁不一定是最好的，而是在（某些情况下比较好）特定一定的条件下；<br>即同步代码块执行的时间较短，从而能够很快的抢到锁；<br>另外还有就是硬件要能够支持两个或两个以上的线程进行并行执行；<br>即一个线程在同步代码块内进行执行，而另一个线程则在同步代码块外进行自旋即尝试获取锁；<br>但是自旋也是会消耗CPU的性能的；<br>因为要在同步代码块外层不断的进行循环重试获取锁；<br>因此这个自旋锁需要去控制这个自旋的时间或者是说自旋尝试获取锁的次数；<br>如果自旋的次数太多了那么对于CPU的开销也是很大的；<br>如果自旋的次数太少了又有可能抢不到锁导致白白自旋了；<br>自旋锁默认的自旋次数是<strong>10次</strong>，可以通过手动的修改JVM的启动参数来修改默认自旋的次数（改变自旋锁的自旋次数）；</p>
<p>但是又有一个问题：这个自旋锁的自旋次数改成多少合适呢？那么这就很难判定了；<br>改多了浪费资源；改少了又没有抢到锁也是浪费资源；所以这个自旋的次数就很难来判断了；因此在JDK6中引入了自适应自旋锁；</p>
<h3 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h3><p>在JDK 6中引入了 自适应的自旋锁。<br>自适应 意味着 自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。<br>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机 就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100次循环。<br>另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。<br>有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序搜的状况预测就会越来越准确，虚拟机就会变得越来越“聪明”了。</p>
<p>（自适应自旋锁中自旋的次数或者是自旋的时间就不再固定了，而是由前一次自旋的效果来进行决定）</p>
<p>举个例子：<br>假设一个线程A在同步代码块上，自旋了10次并且获得了锁；那么就会认为这个同步代码块通过自旋是比较容易获得锁的；所以在后续的执行过程中也会进行自旋；并且还允许自旋的时间稍微长一点；因为之前得到过所以感觉现在也能得到；所以自旋的时间还允许更长一点；<br>再举一个例子：<br>假设有一个同步代码块，但是自旋从来就没有在这个同步代码块上成功获取过锁过；所以jvm就会认为这个同步代码块很难通过自旋来获取得到锁；干脆就不再进行自旋了；那么这样就可以避免性能的浪费；即所以自旋锁也是越来越”聪明”了；<br>monitor在进入竞争的时候会进入ObjectMonitor::enter(TRAPS)来进行竞争；<br>该方法中前一部分是抢到锁的情况；后一部分是没有抢到锁的情况；<br>当没有抢到锁的时候会进入到EnterI(THREAD)方法来进行线程的阻塞以及挂起等操作；<br>在EnterI(THREAD)当中就准备让线程进行阻塞，但是在阻塞之前首先还是会去进行尝试获取锁；如果还是获取不到锁则进入TrySpin(Self)，即就是去进行自旋；<br>那么接着看TrySpin(Self)进行了什么操作；</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#define TrySpin TrySpin_VaryDuration</span><br><span class="line"><span class="comment">// 恒定义对于另外一个函数即TrySpin_VaryDuration；</span></span><br><span class="line">------------------------------------------------</span><br><span class="line"><span class="comment">//TrySpin_VaryDuration时间不固定的尝试自旋锁</span></span><br><span class="line"><span class="built_in">int</span> ObjectMonitor::TrySpin_VaryDuration(Thread * Self)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dumb , brutal spin, Good for comparative measurements against adaptive spinning.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  Knob_FixedSpin自旋固定的次数</span></span><br><span class="line"><span class="comment">  如自旋固定的次数不等于0那么就会进入循环来进行自旋；</span></span><br><span class="line"><span class="comment">  然后每次循环一次就让数量减去一；</span></span><br><span class="line"><span class="comment">  每次自旋一下就要去TryLock一下尝试一下去获取锁；</span></span><br><span class="line"><span class="comment">  尝试获取不到锁则自旋的时候稍微花点时间等待一下即调用SpinPause()方法；</span></span><br><span class="line"><span class="comment">  再接着下一次自旋；</span></span><br><span class="line"><span class="comment">  那么这个就属于之前所说的固定的自旋次数以及固定的自旋时间；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">int</span> ctr = Knob_FixedSpin ;</span><br><span class="line">  <span class="keyword">if</span>( ctr != <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">while</span>( --ctr &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(TryLock(Self) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">      SpinPause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  以下的这个循环就是所推出的适应性自旋锁；</span></span><br><span class="line"><span class="comment">  首先来进行看到适应性自旋锁的自旋次数是多少；</span></span><br><span class="line"><span class="comment">  在objectMonitor.cpp当中给Knob_PreSpin设置了默认值为10次：</span></span><br><span class="line"><span class="comment">  static int Knob_PreSpin = 10; // 20 - 100 likely better</span></span><br><span class="line"><span class="comment">  并且注释推荐20到100次的自旋次数是比较合适的；</span></span><br><span class="line"><span class="comment">  自旋次数是10次，每次自旋一次就会去进行尝试一次看能不能抢得到锁；</span></span><br><span class="line"><span class="comment">  如果抢到了锁那么就回去修改自旋的时间，它就会去允许自旋的时间比以前自旋的时间稍微长一点；</span></span><br><span class="line"><span class="comment">  因为这次通过自旋抢到了那么下一次也有可能抢到；</span></span><br><span class="line"><span class="comment">  所以它允许自旋所花的时间加长一点；</span></span><br><span class="line"><span class="comment">  那么如果没有在一次自旋当中即循环的一次尝试当中没有获取得到锁；</span></span><br><span class="line"><span class="comment">  那么这个时候就会去调用SpinPause()即进入自旋的一个等待；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span>( ctr = Knob_PreSpin + <span class="number">1</span>; --ctr &gt;= <span class="number">0</span> ; )&#123;</span><br><span class="line">    <span class="keyword">if</span>( TryLock(Self) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// Increase _SpinDuration ...</span></span><br><span class="line">      <span class="comment">// Note that we don't clamp SpinDuration precisely at SpinLimit.</span></span><br><span class="line">      <span class="comment">// Raising _SpurDuration to the poverty line is key.</span></span><br><span class="line">      <span class="built_in">int</span> x = _SpinDuration ;</span><br><span class="line">      <span class="keyword">if</span>(x &lt; Knob_SpinLimit)&#123;</span><br><span class="line">        <span class="keyword">if</span>( x &lt; Knob_Poverty) x = Knob_Poverty ;</span><br><span class="line">        _SpinDuration = x + Knob_BonusB ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    SpinPause();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized优化-锁消除"><a href="#synchronized优化-锁消除" class="headerlink" title="synchronized优化-锁消除"></a>synchronized优化-锁消除</h2><h3 id="回顾并引入-3"><a href="#回顾并引入-3" class="headerlink" title="回顾并引入"></a>回顾并引入</h3><p>在JDK6中，对synchronized做了一个优化，即会有一个锁升级（无锁-偏向锁-轻量级锁-重量级锁）的过程；<br>那么在JDK6当中除了这个锁升级的优化之后还会有一个锁消除的优化；</p>
<h3 id="目标-21"><a href="#目标-21" class="headerlink" title="目标"></a>目标</h3><p>学习锁消除的原理</p>
<p>锁消除 是指 虚拟机 即时编译器（JIT）在 运行时，<br>对一些代码上要求同步，但是被检测到 不可能存在共享数据竞争的锁 进行消除。</p>
<p>锁消除 的主要判定依据 来源于 逃逸分析的数据支持，<br>如果判断在一段代码中，堆上的所有数据 都不会逃逸出去 从而被其他线程 访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，<br>同步加锁 自然就无需进行。</p>
<p>变量是否逃逸，对于虚拟机来说 需要使用 数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在 明知道不存在数据争用的情况下 要求同步呢？</p>
<p>实际上有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的想象。<br>下面这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    concatString(<span class="string">"aa"</span> , <span class="string">"bb"</span> , <span class="string">"cc"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> concatString(<span class="keyword">String</span> s1, <span class="keyword">String</span> s2, <span class="keyword">String</span> s3)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer().<span class="built_in">append</span>(s1).<span class="built_in">append</span>(s2).<span class="built_in">append</span>(s3).toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">代码分析concatString()该方法：</span><br><span class="line">StringBuffer.<span class="built_in">append</span>()方法是同步的；</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">StringBuffer.java</span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="built_in">append</span>(<span class="keyword">String</span> <span class="built_in">str</span>)&#123;</span><br><span class="line">  toStringCache = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">super</span>.<span class="built_in">append</span>(<span class="built_in">str</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">那么此时可以看到StringBuffer的<span class="built_in">append</span>()方法使用了<span class="keyword">synchronized</span>进行了同步处理；</span><br><span class="line">而concatString当中进行调用了三次<span class="built_in">append</span>()方法，也就是表明会进行执行三次的这个同步方法；</span><br><span class="line">实际上再来仔细观察一下concatString()方法；</span><br><span class="line">三个<span class="built_in">append</span>()方法调用者是谁？</span><br><span class="line">即<span class="keyword">new</span> StringBuffer 该对象进行调用的<span class="built_in">append</span>()方法；</span><br><span class="line">也就是StringBuffer的<span class="built_in">append</span>()方法即普通的同步方法它所使用的对象锁即为<span class="keyword">this</span>；</span><br><span class="line">而这个<span class="keyword">this</span>对象其实也就是这个<span class="built_in">append</span>()方法的调用者，也就是<span class="keyword">new</span> StringBuffer()，即对象锁就是这个<span class="keyword">new</span> StringBuffer()；</span><br><span class="line">而接着分析concatString()方法当中的<span class="keyword">new</span> StringBuffer()是concatString()方法当中所<span class="keyword">new</span>出来的局部变量；</span><br><span class="line">并没有逃逸出concatString()这个方法；</span><br><span class="line">那么就算现在有多线程来进行执行；即当前了存在两个线程，线程A和线程B；</span><br><span class="line">假设线程A先来进行执行concatString()方法；</span><br><span class="line">那么这个时候线程A就会进入到concatString()方法当中<span class="keyword">new</span> StringBuffer()对象作为锁来进行来锁住StringBuffer类当中的<span class="built_in">append</span>()方法；</span><br><span class="line">那么假设CPU切换到线程B上来，那么此时线程B也会进入到concatString()方法当中来也进行<span class="keyword">new</span> StringBuffer()对象作为锁来进行锁住StringBuffer类的<span class="built_in">append</span>()方法；</span><br><span class="line">锁就是另外一个对象了；</span><br><span class="line">也就是说concatString()方法内部的<span class="keyword">new</span> StringBuffer()对象没有逃逸出concatString()这个方法；</span><br><span class="line">就算有不同的线程来进行执行，那么每个线程也都是获取拿到的不同的锁；</span><br><span class="line">即每个线程拿到的都是不同的<span class="keyword">new</span> StringBuffer()对象即不同的锁；</span><br><span class="line">所以根本不存在有竞争；</span><br><span class="line">那么既然不存在有竞争那么这个StringBuffer类当中的<span class="built_in">append</span>()方法的同步代码块<span class="keyword">synchronized</span>就没有必要了；</span><br><span class="line">所以会自动进行消除掉这个同步代码块<span class="keyword">synchronized</span>；知道此处没有竞争；即转变成</span><br><span class="line"></span><br><span class="line">---------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> StringBuffer <span class="built_in">append</span>(<span class="keyword">String</span> <span class="built_in">str</span>)&#123;</span><br><span class="line">  toStringCache = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">super</span>.<span class="built_in">append</span>(<span class="built_in">str</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line">即线程A与线程B两者之间锁住StringBuffer类当中的<span class="built_in">append</span>()方法使用的不同的锁；</span><br><span class="line">很明显线程A所<span class="keyword">new</span> StringBuffer()对象与线程B所<span class="keyword">new</span> StringBuffer()对象显然不是同一个对象，</span><br><span class="line">而这个<span class="keyword">new</span> StringBuffer()对象也就是调用StringBuffer类当中的<span class="built_in">append</span>()方法的<span class="keyword">this</span>，</span><br><span class="line">也就是这个同步<span class="keyword">synchronized</span>方法<span class="built_in">append</span>()的对象锁；</span><br><span class="line">即线程A与线程B所获取的锁不是同一把锁；</span><br><span class="line"></span><br><span class="line">那么这就是锁消除；</span><br></pre></td></tr></table></figure>

<p>那么这个锁消除是谁来进行完成这一职责的呢？<br>锁消除是虚拟机 即时编译器JIT在对代码执行之前也会对代码进行一个编译操作；<br>最终即时编译器会根据对象的逃逸分析来判断，如果对象逃逸不出这个方法，那么这个锁是不存在竞争的，即那么就会取消这个同步代码块；</p>
<p>StringBuffer的append()是一个同步方法，<br>锁就是this也就是(new StringBuffer())。<br>虚拟机发现它的 动态作用于被限制在 concatString()方法内部。<br>也就是说，new StringBuffer()对象的引用永远不会“逃逸”到concatString()方法之外，其他线程无法访问到它，<br>因此，虽然这里有锁，但是可以被安全地消除掉；<br>在即时编译之后，这段代码就会忽略掉所有的同步而执行了；</p>
<h2 id="synchronized优化-锁粗化"><a href="#synchronized优化-锁粗化" class="headerlink" title="synchronized优化-锁粗化"></a>synchronized优化-锁粗化</h2><h3 id="回顾并引入-4"><a href="#回顾并引入-4" class="headerlink" title="回顾并引入"></a>回顾并引入</h3><p>锁粗化</p>
<p>JDK1.6在对synchronized进行优化的时候除了锁升级、锁消除；<br>还会做一个锁粗化的操作；</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="keyword">package</span> com.xxx.demo10_lock_coarsing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    建议同步代码块当中的代码尽量的少；</span></span><br><span class="line"><span class="comment">    执行的时间尽量的短；</span></span><br><span class="line"><span class="comment">    如果同步代码块当中的代码少且时间短那么偏向锁就有可能满足要求；</span></span><br><span class="line"><span class="comment">    或者说轻量级锁就能够满足要求；</span></span><br><span class="line"><span class="comment">    或者说在自旋的时候就能够满足要求；</span></span><br><span class="line"><span class="comment">    就不会进入到重量级锁的状态；</span></span><br><span class="line"><span class="comment">    但是往往可能情况又比较特殊；</span></span><br><span class="line"><span class="comment">    比如说下面的情况；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//synchronized(Demo01.class)&#123;</span></span><br><span class="line">    <span class="comment">//  System.out.println("aaa");</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     在循环外层new StringBuffer()；</span></span><br><span class="line"><span class="comment">     在循环内存调用append()即执行了100次的append()</span></span><br><span class="line"><span class="comment">     而StringBuffer.append()是一个同步方法；</span></span><br><span class="line"><span class="comment">     那么这也就意味着在调用100次StringBuffer.append()方法时，</span></span><br><span class="line"><span class="comment">     那么就会进入同步代码块append()100次；</span></span><br><span class="line"><span class="comment">     出来同步代码块append()100次；</span></span><br><span class="line"><span class="comment">     那么这个性能消耗也是比较大的；</span></span><br><span class="line"><span class="comment">     它可能会做这样一个处理；</span></span><br><span class="line"><span class="comment">     将StringBuffer.append()方法当中的synchronized进行消除掉；</span></span><br><span class="line"><span class="comment">     然后再将synchronized加入到100次for循环的外面；</span></span><br><span class="line"><span class="comment">     即：</span></span><br><span class="line"><span class="comment">     ------------------------------------</span></span><br><span class="line"><span class="comment">     StringBuffer.java</span></span><br><span class="line"><span class="comment">     public StringBuffer append(String str)&#123;</span></span><br><span class="line"><span class="comment">      toStringCache = null;</span></span><br><span class="line"><span class="comment">      super.append(str);</span></span><br><span class="line"><span class="comment">      return this;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     ------------------------------------</span></span><br><span class="line"><span class="comment">     Demo01.java</span></span><br><span class="line"><span class="comment">      public static void main(String[] args)&#123;</span></span><br><span class="line"><span class="comment">        StringBuffer sb = new StringBuffer();</span></span><br><span class="line"><span class="comment">        synchronized&#123;</span></span><br><span class="line"><span class="comment">          for(int i = 0; i&lt; 100 ; ++)&#123;</span></span><br><span class="line"><span class="comment">            sb.append("aa");</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(sb.toString());</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">     ------------------------------------</span></span><br><span class="line"><span class="comment">     那么此时再来看就只需要进入一次同步代码块然后再for循环100次即可；</span></span><br><span class="line"><span class="comment">     那么这就是锁粗化；</span></span><br><span class="line"><span class="comment">     由之前for循环零散的调用很多次的同步代码块到现在将其放到同步代码块里面来做一次进入同步代码块即可，把很多小锁去掉了变成一个大锁；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">      sb.<span class="built_in">append</span>(<span class="string">"aa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(sb.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">StringBuffer.java</span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="built_in">append</span>(<span class="keyword">String</span> <span class="built_in">str</span>)&#123;</span><br><span class="line">  toStringCache = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">super</span>.<span class="built_in">append</span>(<span class="built_in">str</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="目标-22"><a href="#目标-22" class="headerlink" title="目标"></a>目标</h3><p>学习锁粗化的原理</p>
<p>原则上，在编写代码的时候，总是推荐将 同步亏啊的作用范围 限制得尽量小，<br>只在共享数据的实际作用域中 才进行同步，<br>这样是为了使得需要同步的操作数量 尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>大部分情况下，上面的原则都是正确地，但是如果一些列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能消耗。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">new</span> StringBuffer()</span><br><span class="line">          .<span class="built_in">append</span>(<span class="string">"aa"</span>).<span class="built_in">append</span>(<span class="string">"bb"</span>).<span class="built_in">append</span>(<span class="string">"cc"</span>).toString();</span><br><span class="line">    </span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"aa"</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"bb"</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"cc"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果虚拟机检测到有这样一串 零碎小的操作 都是用一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，这样只需要加锁一次就可以了。</p>
<h3 id="小结-17"><a href="#小结-17" class="headerlink" title="小结"></a>小结</h3><p>什么是锁粗化？<br>JVM会探测到一连串细小的操作都是用同一个对象加锁，<br>将同步代码块的范围放大；<br>放到这串操作的外面；<br>那么这样只需要加一次锁即可；</p>
<h2 id="平时写代码如何对synchronized优化"><a href="#平时写代码如何对synchronized优化" class="headerlink" title="平时写代码如何对synchronized优化"></a>平时写代码如何对synchronized优化</h2><ul>
<li>synchronized的原理；</li>
<li>JDK1.6对synchronized所做的优化；</li>
<li>偏向锁、轻量级锁、自旋锁、锁消除、锁粗化等；</li>
</ul>
<h3 id="减少synchronized的范围"><a href="#减少synchronized的范围" class="headerlink" title="减少synchronized的范围"></a>减少synchronized的范围</h3><p>同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争。</p>
<p>尽量让synchronized同步代码块当中的代码少一点这样执行的时间也就会少一点；<br>那么在单位时间内所执行的线程也就多一点；等待的线程也就少一点；<br>另外由于执行比较短，由轻量级锁就有可能搞得定；或者通过自旋锁就可以搞得定；<br>避免升级到重量级锁；</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(<span class="module-access"><span class="module"><span class="identifier">Demo01</span>.</span></span><span class="keyword">class</span>)&#123;</span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="降低synchronized锁的粒度"><a href="#降低synchronized锁的粒度" class="headerlink" title="降低synchronized锁的粒度"></a>降低synchronized锁的粒度</h3><p>将一个锁拆分为多个锁提高并发度</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------</span><br><span class="line"><span class="keyword">package</span> com.xxx.demo11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    Hashtable hs = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    hs.put(<span class="string">"aa"</span>,<span class="string">"bb"</span>);</span><br><span class="line">    hs.put(<span class="string">"xx"</span>,<span class="string">"yy"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------</span><br><span class="line"># 截取部分代码 Hashtable.java</span><br><span class="line"><span class="keyword">public</span> class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    The hash table data/</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    The total number of entries in the hash table.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="built_in">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//省略一些代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//对put整个方法进行加锁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> V put(K <span class="built_in">key</span>, V value)&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NUllPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is  not already in the hashtable</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="built_in">int</span> hash = <span class="built_in">key</span>.hashCode();</span><br><span class="line">    <span class="built_in">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    /unchecked/</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next)&#123;</span><br><span class="line">      <span class="keyword">if</span>((entry.hash==hash) &amp;&amp; entry.<span class="built_in">key</span>.equlas(<span class="built_in">key</span>))&#123;</span><br><span class="line">        <span class="comment">//省略一些代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//对get整个方法进行加锁</span></span><br><span class="line">  /unchecked/</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="built_in">int</span> hash = <span class="built_in">key</span>.hashCode();</span><br><span class="line">    <span class="built_in">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e=e.next)&#123;</span><br><span class="line">      <span class="keyword">if</span>((e.hash == hash) &amp;&amp; e.<span class="built_in">key</span>.equals(<span class="built_in">key</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> (V)e.value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对remove整个方法进行加锁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> V remove(<span class="keyword">Object</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="built_in">int</span> hash = <span class="built_in">key</span>.hashCode();</span><br><span class="line">    <span class="built_in">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    /unchecked/</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev=<span class="keyword">null</span> ; e != <span class="keyword">null</span>; prev = e, e=e.next)&#123;</span><br><span class="line">      <span class="keyword">if</span>((e.hash==hash) &amp;&amp; e.<span class="built_in">key</span>.equals(<span class="built_in">key</span>))&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="keyword">null</span>)&#123;</span><br><span class="line">          prev.next = e.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          tab[index] = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略一些代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line">由此可以看到Hashtable对增删改查的方法全部添加了<span class="keyword">synchronized</span>，</span><br><span class="line">使之成为同步方法；</span><br><span class="line">那么同步方法的锁对象是什么？是<span class="keyword">this</span>；</span><br><span class="line">也就意味着Hashtable其增删改查这几个方法使用的都是同一把锁；</span><br><span class="line">那么这样会造成什么问题？</span><br><span class="line">因为Hashtable的方法全部加了<span class="keyword">synchronized</span>从而变成了同步方法；</span><br><span class="line">那么意味着对于Hashtable这个对象；</span><br><span class="line">如果有一个线程在往这个Hashtable对象当中的一个桶当中进行添加；</span><br><span class="line">那么就没有办法存在另外一个线程往同样的这个Hashtable这个对象当中的另外一个桶中进行添加了；</span><br><span class="line">肯定是不行的；因为put()方法加锁<span class="keyword">synchronized</span>了；</span><br><span class="line">且锁对象为<span class="keyword">this</span>即所操作的Hashtable对象；</span><br><span class="line">由于put()方法加锁了；</span><br><span class="line">所以只允许一个线程A进行往Hashtable对象的一个桶中添加；</span><br><span class="line">而另外的其他线程B则必须等待线程A添加完成，才能往相同的该Hashtable对象当中的其他桶中添加；</span><br><span class="line">而事实上并没有必要这样操作；</span><br><span class="line">即A线程操作Hashtable对象的第一个桶进行添加操作；</span><br><span class="line">线程B操作与线程A操作的同一个Hashtable对象，其当中的另外一个桶进行添加操作；实则并不影响；</span><br><span class="line">另外Hashtable还存在一个问题；</span><br><span class="line">即当有一个线程A在对Hashtable对象的第一个桶进行添加的时候；</span><br><span class="line">此时存在有另外一个线程B对同样的Hashtable对象的其他桶进行读取<span class="built_in">get</span>()或者是remove()方法的时候是不可以的；只能等待线程A操作完对第一个桶进行添加的这个操作；</span><br><span class="line">因为其方法都是<span class="keyword">synchronized</span>同步方法；且加的锁都是同一把锁即<span class="keyword">this</span>；</span><br><span class="line">那么这样就导致了效率的低下；</span><br><span class="line">因此jdk又推出了一个新的类叫做ConcurrentHashMap；</span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="keyword">package</span> com.xxx.demo11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    Hashtable hs = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    hs.put(<span class="string">"aa"</span>,<span class="string">"bb"</span>);</span><br><span class="line">    hs.put(<span class="string">"xx"</span>,<span class="string">"yy"</span>);</span><br><span class="line">    hs.<span class="built_in">get</span>(<span class="string">"a"</span>);</span><br><span class="line">    hs.remove(<span class="string">"b"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line"># 截取部分代码 ConcurrentHashMap.java</span><br><span class="line"><span class="keyword">public</span> class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">724906924676318397</span>L;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//ConcurrentHashMap对于get没有加锁</span></span><br><span class="line">  <span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">    Node&lt;K,V&gt;p[] tab; Node&lt;K,V&gt; e, p; <span class="built_in">int</span> n , eh; K ek;</span><br><span class="line">    <span class="built_in">int</span> h = spread(<span class="built_in">key</span>.hashCode());</span><br><span class="line">    <span class="keyword">if</span>((tab==table) != <span class="keyword">null</span> &amp;&amp; (n=tab.length) &gt; <span class="number">0</span> &amp;&amp; (e=tabAt(tab, (n<span class="number">-1</span>)&amp; h)) != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>((eh=e.hash) == h)&#123;</span><br><span class="line">        <span class="keyword">if</span>((ek=e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))&#123;</span><br><span class="line">          <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ek &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> (p = e.find(h, <span class="built_in">key</span>)) != <span class="keyword">null</span> ? p.val:<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((e=e.next) != <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(e.hash == h &amp;&amp; ((ek=e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equlas(ek))))</span><br><span class="line">          <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V put(@NotNUll K <span class="built_in">key</span>, @NotNull V value)&#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(<span class="built_in">key</span> , value , <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Implementation for put and putIfAbsent */</span></span><br><span class="line">    <span class="keyword">final</span> V putVal(K <span class="built_in">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">key</span> == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="built_in">int</span> hash = spread(<span class="built_in">key</span>.hashCode());</span><br><span class="line">        <span class="built_in">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node&lt;K,V&gt;[] tab = table;;)&#123;</span><br><span class="line">          Node&lt;K,V&gt; f;<span class="built_in">int</span> n,i,fh;</span><br><span class="line">          <span class="keyword">if</span>(tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>((f = tabAt(tab, i = (n<span class="number">-1</span>) &amp; hash)) == <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//casTabAt 此处即为CAS操作去进行添加一个结点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash,<span class="built_in">key</span>,value,<span class="keyword">null</span>)))</span><br><span class="line">              <span class="keyword">break</span>;  <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            另外下面还有synchronized来进行添加一个结点</span></span><br><span class="line"><span class="comment">            而且该synchronized所用的锁并不是一把锁；</span></span><br><span class="line"><span class="comment">            synchronized所用的锁是桶中的第一个元素；</span></span><br><span class="line"><span class="comment">            也就意味着是这样：</span></span><br><span class="line"><span class="comment">            ConcurrentHashMap在进行添加元素的时候;</span></span><br><span class="line"><span class="comment">            如果该桶当中一个元素也没有,那么就是用CAS操作来进行添加第一个元素；</span></span><br><span class="line"><span class="comment">            如果该桶当中有存在元素往后面加元素呢?</span></span><br><span class="line"><span class="comment">            那么这个时候在锁的时候会使用该桶当中的第一个元素第一个节点作为锁对象，那么也就意味着只会锁住这一个桶；</span></span><br><span class="line"><span class="comment">            即这一个线程往这一个桶当中进行添加，只会对这一个桶进行锁；</span></span><br><span class="line"><span class="comment">            另外再来一个线程往同一个ConcurrentHashMap对象中的其他桶当中进行添加那么这个时候就是可以进行的；</span></span><br><span class="line"><span class="comment">            因为另外一个线程所要进行添加的是该同一个ConcurrentHashMap对象当中的其他桶，那么锁的对象即为其他桶当中的第一个结点对象；</span></span><br><span class="line"><span class="comment">            即这两个线程之间所操作的同一个ConcurrentHashMap对象的桶不一样其锁也不一样；</span></span><br><span class="line"><span class="comment">            由于锁不一样所以线程往其他桶当中进行添加是没有问题的；</span></span><br><span class="line"><span class="comment">            也就是说ConcurrentHashMap只要是不同的桶那么是可以进行同时添加的；</span></span><br><span class="line"><span class="comment">            除此之外还看到ConcurrentHashMap的get()方法是没有加synchronized变成同步方法的；</span></span><br><span class="line"><span class="comment">            这也就意味着当一个线程A在对该ConcurrentHashMap当中的一个桶进行添加的时候，另外一个线程还可以对该同一个ConcurrentHashMap对象当中的同一个桶进行读取操作；那么这样的话也不会受到锁的影响；</span></span><br><span class="line"><span class="comment">            其性能也就更高一点；</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span>(f)&#123;</span><br><span class="line">              <span class="keyword">if</span>(tabAt(tab, i) == f)&#123;</span><br><span class="line">                <span class="keyword">if</span>(fh &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                  binCount = <span class="number">1</span>;</span><br><span class="line">                  <span class="keyword">for</span>(Node&lt;K,V&gt; e = f;; ++binCount)&#123;</span><br><span class="line">                    K ek;</span><br><span class="line">                    <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek!=<span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek))))&#123;</span><br><span class="line">                      oldVal = e.val;</span><br><span class="line">                      <span class="keyword">if</span>(!onlyIfAbsent)&#123;</span><br><span class="line">                        e.val=value;</span><br><span class="line">                        <span class="comment">//省略部分代码</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="keyword">package</span> com.xxx.demo11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    Hashtable hs = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    hs.put(<span class="string">"aa"</span>,<span class="string">"bb"</span>);</span><br><span class="line">    hs.put(<span class="string">"xx"</span>,<span class="string">"yy"</span>);</span><br><span class="line">    hs.<span class="built_in">get</span>(<span class="string">"a"</span>);</span><br><span class="line">    hs.remove(<span class="string">"b"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> test01()&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Demo01.class)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> test02()&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Demo01.class)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  写代码的时候千万注意不要这么去做：</span></span><br><span class="line"><span class="comment">  这两个方法test01()以及test02()没有任何业务关联；</span></span><br><span class="line"><span class="comment">  且很多时候一般使用 类名.class来作为锁；</span></span><br><span class="line"><span class="comment">  觉得这样很简单有可以锁住；</span></span><br><span class="line"><span class="comment">  如果使用类名.class作为锁的话；</span></span><br><span class="line"><span class="comment">  如果一个线程A在进行执行test01()当中的同步代码块时；</span></span><br><span class="line"><span class="comment">  而对于另外一个线程B执行毫无业务关联的test02()方法时，</span></span><br><span class="line"><span class="comment">  也就意味着线程A抢了线程B的锁并且线程A还没有释放锁；</span></span><br><span class="line"><span class="comment">  所以线程B无法进入test02()方法中的同步代码块从而阻塞只能等待线程A释放锁；</span></span><br><span class="line"><span class="comment">  那么这样的话并发效率就很低了；</span></span><br><span class="line"><span class="comment">  所以尽量不要使用类名.class这样的锁；</span></span><br><span class="line"><span class="comment">  建议是降低锁的粒度；这样使得其并发效率可以更高一点；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br></pre></td></tr></table></figure>

<p><strong>HashTable：锁定整个哈希表，一个操作正在进行时，其他操作也同时锁定，效率低下</strong>：</p>
<p><strong>ConcurrentHashMap：局部锁定，只锁定桶，当对当前元素锁定时，其他元素不锁定</strong>。</p>
<p>HashTable与ConcurrentHashMap这两个容器都实现了Map接口，并且都能够保证线程安全；</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------</span><br><span class="line">|<span class="string"> 元素1 </span>|<span class="string"> 元素2 </span>|<span class="string"> 元素3 </span>|<span class="string"> 元素4 </span>|<span class="string"> 元素5 </span>|</span><br><span class="line">----↑------------------------------↑-----</span><br><span class="line">    |<span class="string">            objA              </span>|</span><br><span class="line">take添加元素使用一把锁objA          put添加元素使用一把锁objA</span><br><span class="line"></span><br><span class="line">/<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">往其头部进行获取元素；往尾部进行添加元素；</span><br><span class="line">为了保证队列的线程安全，就有可能加一把锁；</span><br><span class="line">届时获取和添加都是用这同一把锁；</span><br><span class="line">这样也就导致了在获取的时候没有办法进行添加；</span><br><span class="line">所以效率就会更低；</span><br><span class="line">因此就有了LinkedBlockingQueue的存在；</span><br><span class="line"><span class="symbol">*</span>/</span><br></pre></td></tr></table></figure>

<p>LinkedBlockingQueue入队和出队使用不同的锁，相对于读写只有一个锁效率要高。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------</span><br><span class="line">|<span class="string"> 元素1 </span>|<span class="string"> 元素2 </span>|<span class="string"> 元素3 </span>|<span class="string"> 元素4 </span>|<span class="string"> 元素5 </span>|</span><br><span class="line">----↑------------------------------↑-----</span><br><span class="line">    |<span class="string">                              </span>|</span><br><span class="line">take添加元素使用一把锁objB          put添加元素使用一把锁objA</span><br><span class="line"></span><br><span class="line">/<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">添加元素的时候使用objA锁</span><br><span class="line">获取元素的时候使用objB锁</span><br><span class="line">即两把锁；</span><br><span class="line">当在获取的时候；那么添加元素则不受影响；</span><br><span class="line">另外在添加的时候，也可以使用另外一把锁来进行获取元素；</span><br><span class="line">这就可以保证同时又可以添加又可以获取；</span><br><span class="line"><span class="symbol">*</span>/</span><br></pre></td></tr></table></figure>

<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>ConcurrentHashMap<br>（在写的时候为了保证线程安全上锁，但是在读的时候不会修改数据所以没有加锁，这样即保证多个线程来进行读取；写的时候加锁保证在写的过程中的线程安全；读的时候不会改变数据可以让多个线程来进行读取）， CopyOnWriteArrayList和ConyOnWriteSet<br>（都是读的时候不加锁，写的时候才加锁；）</p>
<p>读取时不加锁，写入和删除时加锁</p>

      
    </div>
    
    
    



<div>
    
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>Java面试热点问题，synchronized原理剖析与优化📝</a></p>
  <p><span>文章作者:</span>Fsn✨🧙‍♀️✨</a></p>
  <p><span>发布时间:</span>2020年06月09日 - 04:20:50🌞</p>
  <p><span>最后更新:</span>2020年06月09日 - 04:12:36🌜</p>
  <p><span>原始链接:</span><a href="/2020/06/09/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/" title="Java面试热点问题，synchronized原理剖析与优化">https://fengshana.github.io/2020/06/09/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://fengshana.github.io/2020/06/09/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。🎄	</p>  
</div>
<style>
</style>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        //swal({   
          //title: "",   
         // text: '<div style="width:300px;height:100px;font-size:14px;">道友，复制成功了哟(＾Ｕ＾)ノ~</div>',   
          //html: true,
          //timer: 500,   
        //showConfirmButton: false
        //});
      });
      new ClipboardJS('.fa-clipboard', {
          target: function(trigger) {
              $('<div>').appendTo('body').addClass('alert alert-success').html('🤠道友ᕦ(･ㅂ･)ᕤ，🥭复制成功了哟(^_−)☆').show().delay(1500).fadeOut();
              return trigger.nextElementSibling;
            }
      });
    }));  
</script>


    
</div>



    








<div>
  
    <div>
    
        <br/>
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------🍓🍇本文结束🤞感谢道友的阅读🍍🍒-------------</div>
    
</div>
  
</div>












    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>🥕🍆坚持原创技术分享🐳，🌽🥬您的支持将鼓励我继续创作！🐬</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatreward.png" alt="Fsn✨🧙‍♀️✨ 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipayreward.png" alt="Fsn✨🧙‍♀️✨ 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    










    <footer class="post-footer">
      
        <div class="post-tags" style="text-align:center">
          
            <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">🌟面试</i></a>
          
            <a href="/tags/%E9%94%81/" rel="tag">🌟锁</i></a>
          
            <a href="/tags/synchronized/" rel="tag">🌟synchronized</i></a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/09/%E3%80%90Modern%20Java%20IN%20ACTION%E3%80%91/Modern%20Java%20IN%20ACTION01/" rel="next" title="Modern Java IN ACTION01">
                👈 Modern Java IN ACTION01
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/11/%E3%80%90MongoDB%E3%80%91/java%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-MongoDB%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/" rel="prev" title="java必备基础教程-MongoDB基础入门到高级进阶">
                java必备基础教程-MongoDB基础入门到高级进阶 👉
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80ODk3My8yNTQ2Nw=="></div>
    </div>

  
  
  

  
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/fsn.jpg"
                alt="Fsn✨🧙‍♀️✨" />
            
              <p class="site-author-name" itemprop="name">Fsn✨🧙‍♀️✨</p>
              <p class="site-description motion-element" itemprop="description">🌈勿忘初心💫 🌞，🌜方得始终⭐</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!--<a href="/archives/%7C%7Carchive">-->
                <a href="/archives/">
              
                  <span class="site-state-item-count">155</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">84</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/fengshana" target="_blank" title="GitHub">
                      
                        <i 

                          
                          class="fa fa-fw fa-github">
                          
                         
                        
                        </i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://space.bilibili.com/475144966" target="_blank" title="Bilibili">
                      
                        <i 

                          
                            class="">🏃‍♂️
                          
                         
                        
                        </i>Bilibili</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#课程介绍"><span class="nav-number">2.</span> <span class="nav-text">课程介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#深入学习并发编程中的synchronized"><span class="nav-number">2.1.</span> <span class="nav-text">深入学习并发编程中的synchronized</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可见性问题"><span class="nav-number">3.</span> <span class="nav-text">可见性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标"><span class="nav-number">3.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可见性概念"><span class="nav-number">3.2.</span> <span class="nav-text">可见性概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可见性演示"><span class="nav-number">3.3.</span> <span class="nav-text">可见性演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">3.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子性问题"><span class="nav-number">4.</span> <span class="nav-text">原子性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-1"><span class="nav-number">4.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性概念"><span class="nav-number">4.2.</span> <span class="nav-text">原子性概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性演示"><span class="nav-number">4.3.</span> <span class="nav-text">原子性演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-1"><span class="nav-number">4.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序性问题"><span class="nav-number">5.</span> <span class="nav-text">有序性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-2"><span class="nav-number">5.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序性概念"><span class="nav-number">5.2.</span> <span class="nav-text">有序性概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序性演示"><span class="nav-number">5.3.</span> <span class="nav-text">有序性演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-2"><span class="nav-number">5.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机结构"><span class="nav-number">6.</span> <span class="nav-text">计算机结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-3"><span class="nav-number">6.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机结构简介"><span class="nav-number">6.2.</span> <span class="nav-text">计算机结构简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU"><span class="nav-number">6.3.</span> <span class="nav-text">CPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存"><span class="nav-number">6.4.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存"><span class="nav-number">6.5.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-3"><span class="nav-number">6.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java内存模型"><span class="nav-number">7.</span> <span class="nav-text">java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-4"><span class="nav-number">7.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java内存模型的作用"><span class="nav-number">7.2.</span> <span class="nav-text">Java内存模型的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU缓存、内存与Java内存模型的关系"><span class="nav-number">7.3.</span> <span class="nav-text">CPU缓存、内存与Java内存模型的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-4"><span class="nav-number">7.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主内存与工作内存之间的数据交互过程"><span class="nav-number">8.</span> <span class="nav-text">主内存与工作内存之间的数据交互过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主内存与工作内存之间的交互"><span class="nav-number">8.1.</span> <span class="nav-text">主内存与工作内存之间的交互</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-5"><span class="nav-number">8.2.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-5"><span class="nav-number">8.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized保证原子性"><span class="nav-number">9.</span> <span class="nav-text">synchronized保证原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回顾synchronized的使用"><span class="nav-number">9.1.</span> <span class="nav-text">回顾synchronized的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-6"><span class="nav-number">9.2.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-synchronized-保证原子性"><span class="nav-number">9.3.</span> <span class="nav-text">使用 synchronized 保证原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-保证原子性的原理"><span class="nav-number">9.4.</span> <span class="nav-text">synchronized 保证原子性的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-6"><span class="nav-number">9.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized保证可见性"><span class="nav-number">10.</span> <span class="nav-text">synchronized保证可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-7"><span class="nav-number">10.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用synchronized保证可见性"><span class="nav-number">10.2.</span> <span class="nav-text">使用synchronized保证可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-保证可见性的原理"><span class="nav-number">10.3.</span> <span class="nav-text">synchronized 保证可见性的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-7"><span class="nav-number">10.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized保证有序性"><span class="nav-number">11.</span> <span class="nav-text">synchronized保证有序性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-8"><span class="nav-number">11.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要重排序"><span class="nav-number">11.2.</span> <span class="nav-text">为什么要重排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#as-if-serial语义"><span class="nav-number">11.3.</span> <span class="nav-text">as-if-serial语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用synchronized保证有序性"><span class="nav-number">11.4.</span> <span class="nav-text">使用synchronized保证有序性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-保证有序性的原理"><span class="nav-number">11.5.</span> <span class="nav-text">synchronized 保证有序性的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-8"><span class="nav-number">11.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized的可重入特性"><span class="nav-number">12.</span> <span class="nav-text">synchronized的可重入特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-9"><span class="nav-number">12.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是可重入"><span class="nav-number">12.2.</span> <span class="nav-text">什么是可重入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#演示可重入特性"><span class="nav-number">12.3.</span> <span class="nav-text">演示可重入特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重入原理"><span class="nav-number">12.4.</span> <span class="nav-text">可重入原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重入的好处"><span class="nav-number">12.5.</span> <span class="nav-text">可重入的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-9"><span class="nav-number">12.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized的不可中断性"><span class="nav-number">13.</span> <span class="nav-text">synchronized的不可中断性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-10"><span class="nav-number">13.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是不可中断"><span class="nav-number">13.2.</span> <span class="nav-text">什么是不可中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-不可中断演示"><span class="nav-number">13.3.</span> <span class="nav-text">synchronized 不可中断演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock可中断演示"><span class="nav-number">13.4.</span> <span class="nav-text">ReentrantLock可中断演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-10"><span class="nav-number">13.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javap反汇编学习synchronized的原理"><span class="nav-number">14.</span> <span class="nav-text">javap反汇编学习synchronized的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-11"><span class="nav-number">14.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitorenter"><span class="nav-number">14.2.</span> <span class="nav-text">monitorenter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#monitorenter小结"><span class="nav-number">14.2.1.</span> <span class="nav-text">monitorenter小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitorexit"><span class="nav-number">14.3.</span> <span class="nav-text">monitorexit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步方法"><span class="nav-number">14.4.</span> <span class="nav-text">同步方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-11"><span class="nav-number">14.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题：synchronized与Lock的区别"><span class="nav-number">15.</span> <span class="nav-text">面试题：synchronized与Lock的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入JVM源码-monitor监视器锁"><span class="nav-number">16.</span> <span class="nav-text">深入JVM源码-monitor监视器锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-12"><span class="nav-number">16.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM源码下载"><span class="nav-number">16.2.</span> <span class="nav-text">JVM源码下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDE-Clion-下载"><span class="nav-number">16.3.</span> <span class="nav-text">IDE(Clion)下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitor监视器锁"><span class="nav-number">16.4.</span> <span class="nav-text">monitor监视器锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入JVM源码-monitor竞争"><span class="nav-number">17.</span> <span class="nav-text">深入JVM源码-monitor竞争</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-13"><span class="nav-number">17.1.</span> <span class="nav-text">目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入JVM源码-monitor等待"><span class="nav-number">18.</span> <span class="nav-text">深入JVM源码-monitor等待</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回顾并引入"><span class="nav-number">18.1.</span> <span class="nav-text">回顾并引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-12"><span class="nav-number">18.2.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入JVM源码-monitor释放"><span class="nav-number">19.</span> <span class="nav-text">深入JVM源码-monitor释放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-14"><span class="nav-number">19.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitor释放分析"><span class="nav-number">19.2.</span> <span class="nav-text">monitor释放分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入JVM源码-monitor是重量级锁"><span class="nav-number">20.</span> <span class="nav-text">深入JVM源码-monitor是重量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-15"><span class="nav-number">20.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitor是重量级锁"><span class="nav-number">20.2.</span> <span class="nav-text">monitor是重量级锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-CAS-AtomicInteger使用"><span class="nav-number">21.</span> <span class="nav-text">synchronized优化_CAS_AtomicInteger使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-16"><span class="nav-number">21.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS概述和作用"><span class="nav-number">21.2.</span> <span class="nav-text">CAS概述和作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS和volatile实现无锁并发"><span class="nav-number">21.2.1.</span> <span class="nav-text">CAS和volatile实现无锁并发</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-CAS原理"><span class="nav-number">22.</span> <span class="nav-text">synchronized优化_CAS原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsafe类介绍"><span class="nav-number">22.1.</span> <span class="nav-text">Unsafe类介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsafe实现CAS"><span class="nav-number">22.2.</span> <span class="nav-text">Unsafe实现CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乐观锁和悲观锁"><span class="nav-number">22.3.</span> <span class="nav-text">乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-13"><span class="nav-number">22.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化锁升级过程"><span class="nav-number">23.</span> <span class="nav-text">synchronized优化锁升级过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-对象的布局"><span class="nav-number">24.</span> <span class="nav-text">synchronized优化-对象的布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回顾并引入-1"><span class="nav-number">24.1.</span> <span class="nav-text">回顾并引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-17"><span class="nav-number">24.2.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象头"><span class="nav-number">24.3.</span> <span class="nav-text">对象头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mark-Word"><span class="nav-number">24.4.</span> <span class="nav-text">Mark Word</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Klass-pointer"><span class="nav-number">24.5.</span> <span class="nav-text">Klass pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例数据"><span class="nav-number">24.6.</span> <span class="nav-text">实例数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对齐填充"><span class="nav-number">24.7.</span> <span class="nav-text">对齐填充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看java对象布局"><span class="nav-number">24.8.</span> <span class="nav-text">查看java对象布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-14"><span class="nav-number">24.9.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-偏向锁"><span class="nav-number">25.</span> <span class="nav-text">synchronized优化-偏向锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#锁升级过程"><span class="nav-number">25.1.</span> <span class="nav-text">锁升级过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-18"><span class="nav-number">25.2.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是偏向锁"><span class="nav-number">25.3.</span> <span class="nav-text">什么是偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁原理"><span class="nav-number">25.4.</span> <span class="nav-text">偏向锁原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁的撤销"><span class="nav-number">25.5.</span> <span class="nav-text">偏向锁的撤销</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么时候撤销偏向锁"><span class="nav-number">25.5.1.</span> <span class="nav-text">什么时候撤销偏向锁</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#示例"><span class="nav-number">25.5.1.0.1.</span> <span class="nav-text">示例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁撤销过程"><span class="nav-number">25.6.</span> <span class="nav-text">偏向锁撤销过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁好处"><span class="nav-number">25.7.</span> <span class="nav-text">偏向锁好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-15"><span class="nav-number">25.8.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-轻量级锁"><span class="nav-number">26.</span> <span class="nav-text">synchronized优化-轻量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-19"><span class="nav-number">26.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是轻量级锁"><span class="nav-number">26.2.</span> <span class="nav-text">什么是轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轻量级锁原理"><span class="nav-number">26.3.</span> <span class="nav-text">轻量级锁原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#栈帧"><span class="nav-number">26.3.1.</span> <span class="nav-text">栈帧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轻量级锁的释放"><span class="nav-number">26.4.</span> <span class="nav-text">轻量级锁的释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轻量级锁好处"><span class="nav-number">26.5.</span> <span class="nav-text">轻量级锁好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-16"><span class="nav-number">26.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-自旋锁"><span class="nav-number">27.</span> <span class="nav-text">synchronized优化-自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回顾并引入-2"><span class="nav-number">27.1.</span> <span class="nav-text">回顾并引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-20"><span class="nav-number">27.2.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋锁原理"><span class="nav-number">27.3.</span> <span class="nav-text">自旋锁原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适应性自旋锁"><span class="nav-number">27.4.</span> <span class="nav-text">适应性自旋锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-锁消除"><span class="nav-number">28.</span> <span class="nav-text">synchronized优化-锁消除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回顾并引入-3"><span class="nav-number">28.1.</span> <span class="nav-text">回顾并引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-21"><span class="nav-number">28.2.</span> <span class="nav-text">目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-锁粗化"><span class="nav-number">29.</span> <span class="nav-text">synchronized优化-锁粗化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回顾并引入-4"><span class="nav-number">29.1.</span> <span class="nav-text">回顾并引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-22"><span class="nav-number">29.2.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-17"><span class="nav-number">29.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平时写代码如何对synchronized优化"><span class="nav-number">30.</span> <span class="nav-text">平时写代码如何对synchronized优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#减少synchronized的范围"><span class="nav-number">30.1.</span> <span class="nav-text">减少synchronized的范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#降低synchronized锁的粒度"><span class="nav-number">30.2.</span> <span class="nav-text">降低synchronized锁的粒度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写分离"><span class="nav-number">30.3.</span> <span class="nav-text">读写分离</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      


      
<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
<div class="widget-wrap">
    <div id="myCanvasContainer" class="widget tagcloud">
        <canvas width="300" height="300" id="resCanvas" style="width=100%; background-color:transparent;">
            <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ArrayList/" rel="tag">ArrayList</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B-%E6%A0%91/" rel="tag">B+树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B%E6%A0%91/" rel="tag">B树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CORS/" rel="tag">CORS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git%E5%B7%A5%E4%BD%9C%E6%B5%81/" rel="tag">Git工作流</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/" rel="tag">Gradle</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HASH%E8%A1%A8/" rel="tag">HASH表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">JVM虚拟机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MICROSERVICES/" rel="tag">MICROSERVICES</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/" rel="tag">MongoDB</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql%E7%B4%A2%E5%BC%95/" rel="tag">MySql索引</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/" rel="tag">Oracle</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PayPal/" rel="tag">PayPal</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/" rel="tag">RabbitMQ实战指南</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" rel="tag">Redis设计与实现</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SendGrid/" rel="tag">SendGrid</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SprigBoot/" rel="tag">SprigBoot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/" rel="tag">Spring技术内幕</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sql/" rel="tag">Sql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vuejs/" rel="tag">Vuejs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaScript/" rel="tag">javaScript</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdk8/" rel="tag">jdk8</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/motto/" rel="tag">motto</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oss/" rel="tag">oss</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/synchronized/" rel="tag">synchronized</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/" rel="tag">tomcat</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/volatile/" rel="tag">volatile</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%B2/" rel="tag">串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BF%A1666/" rel="tag">信666</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BF%A1666%E5%B7%A5%E4%BD%9C%E4%BA%A4%E6%8E%A5/" rel="tag">信666工作交接</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E9%A1%B5/" rel="tag">分页</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">前端面试题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E8%89%B2%E7%90%83/" rel="tag">双色球</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%A3%E8%AF%AD/" rel="tag">口语</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE/" rel="tag">图</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" rel="tag">存储过程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/" rel="tag">微信公众号</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E6%80%81/" rel="tag">心态</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E6%80%81%E8%AF%BE%E7%A8%8B/" rel="tag">心态课程</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E6%83%85/" rel="tag">心情</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%AF%E4%BB%98/" rel="tag">支付</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" rel="tag">数据库优化</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9F%A5%E6%89%BE/" rel="tag">查找</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" rel="tag">栈与队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/" rel="tag">流程图</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90/" rel="tag">理解分析</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%90%86%E8%B4%A2/" rel="tag">理财</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%90%86%E8%B4%A2%E5%AD%A6%E4%B9%A0/" rel="tag">理财学习</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%B4%E6%92%AD/" rel="tag">直播</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%8E%A5%E7%8F%AD%E4%BA%BA/" rel="tag">社会主义接班人</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" rel="tag">红黑树</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="tag">线性表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8B%B1%E8%AF%AD/" rel="tag">英语</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%8D%E6%B1%87/" rel="tag">词汇</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1/" rel="tag">邮件服务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%86%E8%B5%AB/" rel="tag">领赫</a><span class="tag-list-count">11</span></li></ul>
        </canvas>
    </div>
</div>



    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">🌱2019 🍄 🌳

<span itemprop="copyrightYear">2020</span>
  <span class="with-love">
  <!--user-->
    🍉
  </span>
 
 <span class="author" itemprop="copyrightHolder">Fsn✨🧙‍♀️✨</span>

  





  <script async src="http://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
 
     🏃‍♂️ 
    <span class="post-meta-item-icon">
      📈
    </span>
    
      <span class="post-meta-item-text">小屋💒总字数：</span>
    
	<span title="Site words total count">
     605.7k🌟 </span>
    <!--<span title="symbols_count_time.count_total">1.2m</span>-->
  
</div>



  <!-- <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>-->






<!--



 -->
 






        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-beta.2/lazyload.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  













  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  
  <script type="text/javascript" src="/js/src/exturl.js?v=5.1.4"></script>


  
  
  
  <!-- 
  
  -->
  <link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>

  <!-- 代码块复制功能    <script src="dist/clipboard.min.js"></script>-->
  <script type="text/javascript" src="/js/src/clipboard.min.js"></script>
  <script type="text/javascript" src="/js/src/clipboard-use.js"></script>
  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":250,"vOffset":-10},"mobile":{"show":false},"log":false,"tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>

<!--崩溃欺骗 <script type="text/javascript" src="/js/src/crash_cheat.js"></script> -->




