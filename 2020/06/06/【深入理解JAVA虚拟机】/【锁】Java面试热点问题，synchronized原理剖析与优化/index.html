<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script>
	(function(){
		if(''){
			if (prompt('请输入文章密码','') !== ''){
				alert('密码错误！');
				history.back();
			}
		}
	})();
</script>









<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #A0A0A0; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #A0A0A0, 0 0 5px     #A0A0A0; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #A0A0A0;    /*上边框颜色*/
        border-left-color: #A0A0A0;    /*左边框颜色*/
    }
</style>

<meta name="theme-color" content="#222">










<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
    
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/fsn-16x16.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/fsn-32x32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/fsn-16x16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/fsn-16x16.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="面试,锁,synchronized," />





  <link rel="alternate" href="/atom.xml" title="✨Fsn✨" type="application/atom+xml" />






<meta name="description" content="前言观看笔记：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1aJ411V763?from&#x3D;search&amp;seid&#x3D;6293835933701781647 观看了这个视频之后，我建议啊😉，可以去看下那个《深入java虚拟机》这本书，因为这个课讲的内容跟这本书当中的第13章 线程安全与锁优化，内容十分相似；所以我认为可以当做是课后复习书的那种；我也是经过了对比两者的内容">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试热点问题，synchronized原理剖析与优化">
<meta property="og:url" content="https://fengshana.github.io/2020/06/06/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="✨Fsn✨">
<meta property="og:description" content="前言观看笔记：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1aJ411V763?from&#x3D;search&amp;seid&#x3D;6293835933701781647 观看了这个视频之后，我建议啊😉，可以去看下那个《深入java虚拟机》这本书，因为这个课讲的内容跟这本书当中的第13章 线程安全与锁优化，内容十分相似；所以我认为可以当做是课后复习书的那种；我也是经过了对比两者的内容">
<meta property="og:image" content="http://r.photo.store.qq.com/psc?/V13IdniL3IuSOB/TCfiP1YaPeRT4Jil9RANX4vLl8AstIRGl9P8oTiaYxMydq3nKZRukFcfX8VESLmsBdLaQnizkJqmwuNgIhy5oXCRrbdw7oeBbu09AWBNcVI!/r">
<meta property="article:published_time" content="2020-06-06T12:20:50.000Z">
<meta property="article:modified_time" content="2020-06-06T12:37:47.351Z">
<meta property="article:author" content="Fsn✨🧙‍♀️✨">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="锁">
<meta property="article:tag" content="synchronized">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://r.photo.store.qq.com/psc?/V13IdniL3IuSOB/TCfiP1YaPeRT4Jil9RANX4vLl8AstIRGl9P8oTiaYxMydq3nKZRukFcfX8VESLmsBdLaQnizkJqmwuNgIhy5oXCRrbdw7oeBbu09AWBNcVI!/r">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fengshana.github.io/2020/06/06/【深入理解JAVA虚拟机】/【锁】Java面试热点问题，synchronized原理剖析与优化/"/>









  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "07d52b28"
    });
  daovoice('update');
  </script>

  <title>Java面试热点问题，synchronized原理剖析与优化 | ✨Fsn✨</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2a839053bb6194637483460a0f428730";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.js"></script>
<script src="https://unpkg.com/minigrid@3.1.1/dist/minigrid.min.js"></script>
<link rel="stylesheet" href="/photos/photos.css">
<script type="text/javascript" src="/photos/photo.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/mermaid/0.2.4/mermaid.full.min.js"></script>


<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">✨Fsn✨</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-camera">
          <a href="/photos/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-camera"></i> <br />
            
            相册
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sentence">
          <a href="/shuoshuo" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-commenting"></i> <br />
            
            小心情
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>







 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>[🌿诗酒年华🌻]</h1>
    <p id="poem">挑选中🌺...🍃🍂</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '🍃《' + result.data.origin.title + '》🍂'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>

        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fengshana.github.io/2020/06/06/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fsn✨🧙‍♀️✨">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/fsn.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="✨Fsn✨">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java面试热点问题，synchronized原理剖析与优化</h1>
        

        <div class="post-meta">
		

          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-06T20:20:50+08:00">
                2020-06-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-06-06T20:37:47+08:00">
                2020-06-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  33.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  130
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="http://r.photo.store.qq.com/psc?/V13IdniL3IuSOB/TCfiP1YaPeRT4Jil9RANX4vLl8AstIRGl9P8oTiaYxMydq3nKZRukFcfX8VESLmsBdLaQnizkJqmwuNgIhy5oXCRrbdw7oeBbu09AWBNcVI!/r " rel="gallery_ckb3mtpp200g768um232l9qts"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="http://r.photo.store.qq.com/psc?/V13IdniL3IuSOB/TCfiP1YaPeRT4Jil9RANX4vLl8AstIRGl9P8oTiaYxMydq3nKZRukFcfX8VESLmsBdLaQnizkJqmwuNgIhy5oXCRrbdw7oeBbu09AWBNcVI!/r " itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>观看笔记：<code>https://www.bilibili.com/video/BV1aJ411V763?from=search&amp;seid=6293835933701781647</code></p>
<p>观看了这个视频之后，我建议啊😉，可以去看下那个《<strong>深入java虚拟机</strong>》这本书，因为这个课讲的内容跟这本书当中的<strong>第13章 线程安全与锁优化</strong>，内容十分相似；所以我认为可以当做是课后复习书的那种；<br>我也是经过了对比两者的内容才这么觉得；因为真的很相似；<br>包括后面举的string的那个例子；<br>为了我更深刻的记忆；我决定我还是仔细看一遍这一部分内容；<br>（现在看来其实就是<strong>第五部分 高效并发</strong> 跟该课程视频讲的 非常非常相同了；）</p>
<h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typora-root-ur<span class="variable">l:</span> img</span><br><span class="line">typora-<span class="keyword">copy</span>-images-<span class="keyword">to</span>: img</span><br></pre></td></tr></table></figure>

<h3 id="深入学习并发编程中的synchronized"><a href="#深入学习并发编程中的synchronized" class="headerlink" title="深入学习并发编程中的synchronized"></a>深入学习并发编程中的synchronized</h3><blockquote>
<p>课程背景  </p>
</blockquote>
<p><strong>第一</strong>： <strong>并发编程</strong>是java知识体系当中比较重要而且比较是比较难的一块内容。  </p>
<p>因为<strong>并发编程</strong>涉及的知识面比较广，然后比较抽象不好理解，<br>因此如果我们想很好的掌握并发编程这块内容，其实是有一定难度的。<br><strong>synchronized的原理</strong>以及其<strong>优化</strong>了解少。  </p>
<p><strong>第二</strong>： <strong>并发编程</strong>在实际企业开发当中也是会遇到的，一个比较重要的比较棘手的问题。  </p>
<p>举个例子，铁道售票的12306网站，<br>在<strong>一个时间段</strong>内，可能有<strong>大量</strong>的用户过来进行买票，那么此时就需要进行保证卖出去的<strong>票的数量</strong>是<strong>正确</strong>的，既<strong>不能超卖</strong>也<strong>不能少卖</strong>。<br>另外还要保证整个执行过程的卖票的<strong>执行效率</strong>是比较<strong>高</strong>的。  </p>
<p>那么可以通过<strong>synchronized</strong>来进行<strong>保证卖票的数量</strong>是<strong>正确</strong>的，既<strong>不会超卖</strong>也<strong>不会少卖</strong>。  </p>
<p>但是又要去考虑这个<strong>性能问题</strong>，那么就可以看到<strong>synchronized</strong>在实际的企业开发当中也是一个棘手的问题。  </p>
<p><strong>第三</strong>： <strong>并发编程</strong>现在是一个热点面试题。  </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>当中出现了异常，会不会释放锁？</span><br><span class="line"><span class="keyword">synchronized</span>和Lock有什么区别？</span><br><span class="line"><span class="keyword">synchronized</span>和<span class="keyword">volatile</span>有什么区别？</span><br><span class="line">etc...</span><br></pre></td></tr></table></figure>

<p>面试官通过并发面试题来考查面试者的<strong>并发编程</strong>掌握情况，<br>来判断面试者是否能够满足企业需要，<br>另外也能够判断面试者的技术水平。  </p>
<blockquote>
<p>课程介绍</p>
</blockquote>
<p>深入学习<strong>并发编程</strong>中的<strong>synchronized</strong></p>
<ul>
<li>第一章：<strong>并发编程</strong>中的<strong>三个问题</strong><ul>
<li><strong>可见性</strong><ul>
<li>案例：<ul>
<li><font style="color:red;">共享变量</font>;</li>
<li>一个<font style="color:red;">线程A</font>不断地来<font style="color:red;">读</font>这个<font style="color:red;">共享变量的值</font>；</li>
<li>再用另一个<font style="color:red;">线程B</font>对该<font style="color:red;">共享变量的取值</font>进行<font style="color:red;">修改</font>；</li>
<li>可以观测到另一个<font style="color:red;">线程B</font>对该<font style="color:red;">共享变量的修改</font>；</li>
<li><font style="color:red;">A线程</font>并<font style="color:red;">不能够感知得到</font>；</li>
<li>这就出现了<strong>可见性</strong>问题</li>
</ul>
</li>
<li>目标<ul>
<li>学习什么是<strong>可见性</strong>问题</li>
</ul>
</li>
<li><strong>可见性</strong>概念<ul>
<li><strong>可见性（VIsibility）：是指当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。</strong></li>
</ul>
</li>
<li><strong>可见性</strong>演示<ul>
<li>案例演示：<ul>
<li>一个A线程根据boolean类型的标记flag；while循环；</li>
<li>另一个B线程改变这个flag变量的值；</li>
<li>而第一个while循环的A线程并不会停止循环。</li>
</ul>
</li>
</ul>
</li>
<li>小结<ul>
<li>什么是<strong>可见性</strong>?<br><strong>可见性（Visibility）：是指当一个线程对共享变量进行了修改，那么另外的线程可以理解看到修改后的最新值</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>原子性</strong><ul>
<li>案例：<br>使用i++，<br>通过5个线程分别来进行执行1000次i++，<br>最终可以发现加出来的效果并非是5000，<br>可能会少于5000，<br>那么这个问题的原因就在于<strong>i++</strong>并<strong>不是一个原子操作</strong>，<br>到时会通过<strong>java反汇编</strong>的方式来进行演示分析这个i++其实有4条指令</li>
<li>目标<ul>
<li>学习什么是原子性问题</li>
</ul>
</li>
<li><strong>原子性</strong>概念<ul>
<li><strong>原子性（Atomicity）：指在一次操作或多次操作中，呀么所有的操作全部得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</strong></li>
</ul>
</li>
<li><strong>原子性</strong>演示<ul>
<li>案例演示：5个线程各执行1000次i++</li>
</ul>
</li>
</ul>
</li>
<li><strong>有序性</strong><ul>
<li>一般来想的是程序会按照<strong>编写的代码的顺序</strong>来进行执行，<br>那么实际上<strong>程序</strong>会去做一些<strong>优化措施</strong>，<br>为了让代码的<strong>执行效率更高</strong>一点，<br>会做<strong>编译器和运行期的优化</strong>操作，<br>这其中也是用到了一个案例，</li>
<li><em>有序性问题*</em>有可能会被<strong>重排序</strong>，<br>那么导致在<strong>多线程</strong>的情况下，</li>
<li><em>数据*</em>会出现<strong>错乱</strong>。</li>
<li>目标<ul>
<li>学习什么是<strong>有序性</strong>问题</li>
</ul>
</li>
<li><strong>有序性</strong>概念<ul>
<li><strong>有序性（Ordering）: 是指程序代码在执行过程中的先后顺序，由于java在编译器以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序。</strong></li>
</ul>
</li>
<li><strong>有序性</strong>演示<ul>
<li>jcstress是java并发压测工具….</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第二章：<strong>java内存模型</strong>（<strong>JMM</strong>）（开始解决问题）<ul>
<li><strong>计算机结构</strong><ul>
<li>（<strong>CPU</strong>、<strong>内存</strong>、<strong>缓存</strong>由此来引出<strong>java内存模型</strong>，<strong>主内存</strong>、<strong>工作内存</strong>如何<strong>操作变量</strong>）</li>
</ul>
</li>
<li><strong>java内存模型</strong><ul>
<li><strong>主内存</strong>与<strong>工作内存</strong>之间的<strong>交互</strong></li>
</ul>
</li>
</ul>
</li>
<li>第三章：<strong>synchronized</strong>保证<strong>三大特性</strong><ul>
<li><strong>synchronized</strong>与<strong>原子性</strong><ul>
<li>目标</li>
<li>使用<strong>synchronized</strong>保证<strong>原子性</strong></li>
<li><strong>synchronized保证原子性的原理</strong></li>
<li>小结</li>
</ul>
</li>
<li><strong>synchronized</strong>与<strong>可见性</strong></li>
<li><strong>synchronized</strong>与<strong>有序性</strong></li>
</ul>
</li>
<li>第四章：<strong>synchronized</strong>的<strong>特性</strong>（<strong>同步锁机制</strong>，<strong>synchronized</strong>作为锁的特性）<ul>
<li><strong>可重入特性</strong><ul>
<li>指的是当一个线程进入到一个同步代码块当中时，</li>
<li>获取了某一个锁之后，</li>
<li>还能够再次进入同步代码块获取同一把锁。</li>
<li>即可以重新再进入。</li>
</ul>
</li>
<li><strong>不可中断特性</strong></li>
</ul>
</li>
<li>第五章：<strong>synchronized</strong>的原理<ul>
<li><strong>javap</strong> 反汇编</li>
<li>深入JVM源码<ul>
<li>目标</li>
<li><strong>monitor监视器锁</strong></li>
<li><strong>monitor竞争</strong></li>
<li><strong>monitor等待</strong></li>
<li><strong>monitor释放</strong></li>
<li><strong>monitor</strong>是<strong>重量级锁</strong></li>
</ul>
</li>
</ul>
</li>
<li>第六章：<strong>JDK6 synchronized优化</strong><ul>
<li><strong>CAS</strong></li>
<li><strong>java对象</strong>的<strong>布局</strong><ul>
<li><strong>锁升级</strong>过程</li>
</ul>
</li>
<li><strong>偏向锁</strong></li>
<li><strong>轻量级锁</strong></li>
<li><strong>重量级锁</strong></li>
<li><strong>锁消除</strong></li>
<li><strong>锁粗化</strong></li>
<li>平时写代码如何对<strong>synchronized优化</strong><ul>
<li><strong>减少synchronized的范围</strong></li>
<li><strong>降低synchronized锁的粒度</strong></li>
<li><strong>读写分离</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h2><p>第一章：<strong>并发编程</strong>中的<strong>三个问题</strong> (可见性、原子性、有序性)</p>
<p>在使用<strong>多线程</strong>进行<strong>并发编程</strong>的时候，如果存在有<strong>多个线程</strong>来<strong>操作共享数据</strong>，<br>那么很有可能这个<strong>共享数据的值</strong>会出现<strong>错乱</strong>。<br>那么以上称之为 <strong>线程安全问题</strong>。<br>那么导致 <strong>线程安全问题</strong>的<strong>根本原因</strong>有这三种：</p>
<ul>
<li><strong>可见性</strong></li>
<li><strong>原子性</strong></li>
<li><strong>有序性</strong></li>
</ul>
<p>在讲解<strong>可见性</strong>概念之前，要注意几个<strong>前提条件</strong>：<br><strong>1、</strong>  如果只有一个线程操作，那么就肯定不会存在线程之间的<strong>可见性</strong>问题。<br><strong>2、</strong> 还需要存在有<strong>共享数据</strong>，如果没有共享数据，那么也不会存在有可见性问题。<br><strong>可见性（Visibility）</strong>：是指一个线程对共享变量进行修改，另一个线程立即得到修改后的最新值。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>学习什么是<strong>可见性问题</strong></p>
<h3 id="可见性概念"><a href="#可见性概念" class="headerlink" title="可见性概念"></a>可见性概念</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可见性（<span class="keyword">Visibility</span>）：是指当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。</span><br></pre></td></tr></table></figure>

<h3 id="可见性演示"><a href="#可见性演示" class="headerlink" title="可见性演示"></a>可见性演示</h3><p>案例演示：<br>一个线程A根据boolean类型的标记flag，while循环；<br>另一个线程B改变这个flag变量的值；<br>那么线程A并不会停止循环。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">          一个线程对共享变量的修改，另一个线程不能立即得到最新值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Visibility</span>&#123;</span></span><br><span class="line">    <span class="comment">//多个线程都会访问的数据，我们成为线程的共享数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="built_in">run</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException</span>&#123;</span><br><span class="line">      <span class="comment">//t1线程不断的来读取run共享变量的取值</span></span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">run</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      t1.start();</span><br><span class="line"></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//t2线程对该共享变量的取值进行修改</span></span><br><span class="line">      Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="built_in">run</span> =  <span class="literal">false</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"时间到，线层2设置为false"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">      t2.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//可以观测得到t2线程对run共享变量的修改，t1线程并不能够读取到更改了之后的值；</span></span><br><span class="line">      <span class="comment">//这就出现了可见性问题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo01_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  目标：演示可见性问题</span></span><br><span class="line"><span class="comment">    1. 创建一个共享变量</span></span><br><span class="line"><span class="comment">    2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">    3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test01Visibility&#123;</span><br><span class="line">  <span class="comment">// 1. 创建一个共享变量；静态的成员变量；boolean类型名为flag；</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)&#123;</span><br><span class="line">    <span class="comment">/* 2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">          采用lambda表达式的方式进行创建线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        <span class="comment">/* 循环，如果该布尔类型变量的值为true则一直循环否则结束循环；</span></span><br><span class="line"><span class="comment">           在循环当中千万不要进行打印，打印了的话就看不到效果了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    沉睡两秒钟；</span></span><br><span class="line"><span class="comment">    让效果更加明显；</span></span><br><span class="line"><span class="comment">    这样则更加明显的来分析问题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">       放到lambda表达式中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将flag改为false；并且输出打印；</span></span><br><span class="line">      flag = <span class="keyword">false</span>;</span><br><span class="line">      System.out.<span class="keyword">println</span>(<span class="string">"线程修改了变量的值为false"</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  分析一下这段代码：</span></span><br><span class="line"><span class="comment">  程序从main方法开始执行；</span></span><br><span class="line"><span class="comment">  开启了线程A不断读取共享变量的取值进行循环；</span></span><br><span class="line"><span class="comment">  开启了线程B去进行修改共享变量的值并打印；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  多线程执行具有 fu jin/fu ji(我没听清)性，</span></span><br><span class="line"><span class="comment">  有可能先进行跑A线程也有可能跑B线程；</span></span><br><span class="line"><span class="comment">  如果先跑B线程那么则看不到A线程当中的循环；</span></span><br><span class="line"><span class="comment">  为了让这个效果更佳明显一点；</span></span><br><span class="line"><span class="comment">  所以后加了一个Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  首先执行main方法的时候；</span></span><br><span class="line"><span class="comment">  会创建出一个线程A；</span></span><br><span class="line"><span class="comment">  这个线程A会来进行读取共享变量A的取值；</span></span><br><span class="line"><span class="comment">  则读取到flag共享变量的取值为true；</span></span><br><span class="line"><span class="comment">  那么该while循环则将会一直进行循环；</span></span><br><span class="line"><span class="comment">  那么当主线程沉睡了两秒之后，又会启动一个新线程B；</span></span><br><span class="line"><span class="comment">  新线程B将flag共享变量的取值变为了false；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  问题就在于分析</span></span><br><span class="line"><span class="comment">  线程A当中通过flag来进行while循环当中的该flag共享变量</span></span><br><span class="line"><span class="comment">  是否也从一开始的取值true到后期的线程B当中对共享变量flag取值进行修改为false</span></span><br><span class="line"><span class="comment">  是否也是同时进行了更改取值true为false；</span></span><br><span class="line"><span class="comment">  如果线程A当中的共享变量flag的取值与线程B操作共享变量flag的取值同时进行了更改；</span></span><br><span class="line"><span class="comment">  那么线程A当中根据flag取值进行while循环的循环操作就会停下来；</span></span><br><span class="line"><span class="comment">  如果没有进行修改线程A当中的flag共享变量</span></span><br><span class="line"><span class="comment">  那么线程A当中的flag共享变量的取值就将还会是true，</span></span><br><span class="line"><span class="comment">  即while循环根据flag共享变量的取值true继续其循环操作；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  效果：</span></span><br><span class="line"><span class="comment">  等待两秒之后，输出了线程B当中的打印 “线程修改了变量的值为false”；</span></span><br><span class="line"><span class="comment">  然而但是运行Run的的红灯仍然开启显示在运行着；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  那么这个就意味着；</span></span><br><span class="line"><span class="comment">  上面的那个线程A还在while(true)执行当中；</span></span><br><span class="line"><span class="comment">  也就是线程A当中的共享变量</span></span><br><span class="line"><span class="comment">  没有受到线程B当中操作共享变量flag取值从true变为false操作的影响；</span></span><br><span class="line"><span class="comment">  flag在线程A当中取值依然还是true；</span></span><br><span class="line"><span class="comment">  所以while循环根据该flag共享变量的取值依旧在进行着循环操作。</span></span><br><span class="line"><span class="comment">  即线程A当中认为flag共享变量依旧是true，所以并没有去进行停止while循环。</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  这个时候就可以进行观察得到 可见性问题；</span></span><br><span class="line"><span class="comment">  下面的线程B对共享变量flag取值的修改，而上面的线程A并没有立即得到最新的结果；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  最后做个小结：</span></span><br><span class="line"><span class="comment">  当并发编程时，如果有多线程来进行操作共享变量；</span></span><br><span class="line"><span class="comment">  一个线程来进行读取操作；</span></span><br><span class="line"><span class="comment">  一个线程来进行写操作；</span></span><br><span class="line"><span class="comment">  那么这个当中就可能会出现 线程安全问题；</span></span><br><span class="line"><span class="comment">  即一个线程B进行修改，而另外一个线程A并没有得到修改后的最新取值；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>什么是<strong>可见性</strong>？</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可见性（<span class="keyword">Visibility</span>）：是指当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。</span><br></pre></td></tr></table></figure>

<h2 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h2><p>现在来看并发编程中的第二个问题：<strong>原子性</strong>问题；<br>前期讲的是并发编程中的第一个问题<strong>可见性</strong>问题；<br>后期要讲的是并发编程中的第三个问题<strong>有序性</strong>问题；<br>学习分两步第一步介绍<strong>原子性的概念</strong>；<br>第二步通过一个案例来进行演示<strong>原子性问题</strong>；</p>
<h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>学习什么是<strong>原子性问题</strong></p>
<h3 id="原子性概念"><a href="#原子性概念" class="headerlink" title="原子性概念"></a>原子性概念</h3><p>原子性的前提：</p>
<p><strong>1.</strong> 需要存在有<strong>多个线程</strong>；如果是一个线程，没有竞争的这种情况是看不出来问题所在的；<br><strong>2.</strong> 依然还是需要存在<strong>共享变量</strong>；即到时候多个线程来对共享变量来进行操作；</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">原子性（Atomicity）: 在一次或多次操作中，要么所有的操作都执行 并且 不会受 其他因素干扰 而 中断，要么所有的操作都不执行；</span></span><br></pre></td></tr></table></figure>

<h3 id="原子性演示"><a href="#原子性演示" class="headerlink" title="原子性演示"></a>原子性演示</h3><p>案例演示：5个线程各执行1000次i++</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo01_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    案例演示：5个线程各执行1000次 i++;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> class Test02Atomicity&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5个线程都执行1000次i++</span></span><br><span class="line">    Runnable increment = () -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        number++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5个线程</span></span><br><span class="line">    ArrayList&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">      t.start();</span><br><span class="line">      ts.<span class="built_in">add</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t : ts)&#123;</span><br><span class="line">      t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 最终的效果即，加出来的效果不是5000，可能会少于5000</span></span><br><span class="line"><span class="comment">        那么原因就在于i++并不是一个原子操作</span></span><br><span class="line"><span class="comment">        到时候会通过java反汇编的方式来进行演示和分析，这个i++其实有4条指令</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"number = "</span>+ number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo01_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  目标：演示原子性问题</span></span><br><span class="line"><span class="comment">      1. 定义一个共享变量 number</span></span><br><span class="line"><span class="comment">      2. 对number进行 1000次的++操作</span></span><br><span class="line"><span class="comment">      3. 使用5个线程来进行操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02Atomicity</span>&#123;</span></span><br><span class="line">  <span class="comment">// 1. 定义一个共享变量 number；先赋值为0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 存在有5个线程需要来对number共享变量1000次的++操作</span></span><br><span class="line"><span class="comment">     2. 对number进行1000的++操作</span></span><br><span class="line"><span class="comment">     做任务；使用lambda表达式来进行编写</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  Runnable increment = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">      number++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 使用5个线程来进行</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该5个线程所做的事情即为 上面的increment所实现的run()</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    ts.add(t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t : <span class="built_in">list</span>)&#123;</span><br><span class="line">      t.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印number的取值</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"number = "</span>+ number);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    由于有可能存在 主线程跑得更快；</span></span><br><span class="line"><span class="comment">    所以就有可能出现5个线程其run()当中的for循环没有跑完就有可能去执行输出number的取值了；</span></span><br><span class="line"><span class="comment">    为了一定要让5个线程当中的for循环跑完然后再来取number的取值；</span></span><br><span class="line"><span class="comment">    这个时候使用join的操作；</span></span><br><span class="line"><span class="comment">    先把这个5个线程放置到ArrayList集合ts当中；</span></span><br><span class="line"><span class="comment">    最后在打印之前遍历一下list集合ts；</span></span><br><span class="line"><span class="comment">    得到每个线程让其执行join();</span></span><br><span class="line"><span class="comment">    按照分析；每个线程都执行1000次number++；</span></span><br><span class="line"><span class="comment">    正常来说最后输出打印这个number时的打印结果应当为5000；</span></span><br><span class="line"><span class="comment">    那么这个运行结果有可能是5000也有可能会小于5000；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    效果：</span></span><br><span class="line"><span class="comment">    number = 5000</span></span><br><span class="line"><span class="comment">    多运行几次</span></span><br><span class="line"><span class="comment">    number = 4542（这次运行之后就会发现number的取值少了很多）</span></span><br><span class="line"><span class="comment">    那么为什么会出现number取值少了很多的这种情况呢？</span></span><br><span class="line"><span class="comment">    那么这是由于 i++（number++）这是多个操作；</span></span><br><span class="line"><span class="comment">    而且其是通过多线程来进行操作的；</span></span><br><span class="line"><span class="comment">    并没有来进行保证 i++(number++)这个操作的一个原子性；</span></span><br><span class="line"><span class="comment">    那么这个时候通过javap反汇编的方式来查看i++(number++)到底是由几个部分来组成的；</span></span><br><span class="line"><span class="comment">    找到编译后的结果（工程名/target/classes/com.xxx.demo01_concurrent_problem/Test02Atomicity.class）</span></span><br><span class="line"><span class="comment">    找到该文件之后通过使用Windows PowerShell打开或者是通过CMD等命令行进行打开也可以；</span></span><br><span class="line"><span class="comment">    键入命令：javap 可以对该字节码文件Test02Atomicity.class进行反汇编；</span></span><br><span class="line"><span class="comment">    从而看到一些字节码的指令；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    javap -p -v .\Test02Atomicity.class</span></span><br><span class="line"><span class="comment">    # -p 即显示私有的；-v 即详细信息也显示出来；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    通过反汇编之后可以看到很多的代码；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<strong>javap 反汇编</strong>class文件，得到下面的 字节码指令：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="built_in">void</span> lambda$main();</span><br><span class="line">  Code:</span><br><span class="line">     <span class="number">0</span>: iconst_0</span><br><span class="line">     <span class="number">1</span>: istore_0</span><br><span class="line">     <span class="number">2</span>: iload_0</span><br><span class="line">     <span class="number">3</span>: sipush        <span class="number">1000</span></span><br><span class="line">     <span class="number">6</span>: if_           <span class="number">23</span></span><br><span class="line">     <span class="number">9</span>: getstatic     #<span class="number">12</span>               <span class="comment">// Field number:I</span></span><br><span class="line">    <span class="number">12</span>: iconst_1</span><br><span class="line">    <span class="number">13</span>: iadd</span><br><span class="line">    <span class="number">14</span>: putstatic     #<span class="number">12</span>               <span class="comment">// Field number:I</span></span><br><span class="line">    <span class="number">17</span>: linc          <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="number">20</span>: goto</span><br><span class="line">    <span class="number">23</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><strong>反汇编</strong>内容：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    offset_delta = <span class="number">27</span></span><br><span class="line">  Exception:</span><br><span class="line">    throws java.lang.InterruptedException</span><br><span class="line"></span><br><span class="line"># 通过反汇编可以看到lambda表达式的代码在此处</span><br><span class="line"><span class="keyword">private</span> static <span class="built_in">void</span> lambda$main$<span class="number">0</span>()</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, loclas=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_0</span><br><span class="line">        <span class="number">2</span>: iload_0</span><br><span class="line">        <span class="number">3</span>: sipush       <span class="number">1000</span></span><br><span class="line">        <span class="number">6</span>: if_icmpge    <span class="number">23</span></span><br><span class="line">        <span class="number">9</span>: getstatic    #<span class="number">18</span>         <span class="comment">// Field number:I</span></span><br><span class="line">       <span class="number">12</span>: iconst_1</span><br><span class="line">       <span class="number">13</span>: iadd</span><br><span class="line">       <span class="number">14</span>: putstatic    #<span class="number">18</span>         <span class="comment">// Field number:I</span></span><br><span class="line">       <span class="number">17</span>: iinc         <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">       <span class="number">20</span>: goto</span><br><span class="line">       <span class="number">23</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">18</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">17</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">23</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length   Slot   Name   Signature</span><br><span class="line">            <span class="number">2</span>      <span class="number">21</span>      <span class="number">0</span>      <span class="number">1</span>   I</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">252</span> <span class="comment">/* append */</span></span><br><span class="line">          offset_delta = <span class="number">2</span></span><br><span class="line">          locals = [ <span class="built_in">int</span> ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">20</span></span><br><span class="line">  static &#123;&#125;:</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>,  locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">          <span class="number">0</span>: iconst_0</span><br><span class="line">          <span class="number">1</span>: putstatic  #<span class="number">18</span>         <span class="comment">// Field number:I</span></span><br><span class="line">          <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中，对于 number++ 而言（number为静态变量 ），实际会产生如下的JVM字节码指令：</p>
<blockquote>
<p>9: getstatic     #18     // Field number:I<br>12: iconst_1<br>13: iadd<br>14: putstatic    #18     // Field number:I</p>
</blockquote>
<blockquote>
<p>代码当中的<br>number++;<br>对应反汇编代码当中的4句<br>9: getstatic     #18     // Field number:I<br>12: iconst_1<br>13: iadd<br>14: putstatic    #18     // Field number:I</p>
</blockquote>
<p>即 <code>number++</code>是由<strong>四条字节码指令</strong>组成的；<br>那么其中在<strong>一个线程</strong>下是没有问题的；<br>但如果是放在<strong>多线程</strong>的情况下那么就是有问题的；<br>当前来进行分析下这个<strong>原子性问题</strong>：<br>程序有主方法main方法开始进行执行的；</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">public class Test02Atomicity&#123;</span><br><span class="line">  // <span class="number">1</span>. 定义一个共享变量<span class="keyword">number</span></span><br><span class="line">  private static int <span class="keyword">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  public static void main(<span class="keyword">String</span>[] args) throws InterruptedException&#123;</span><br><span class="line">    // <span class="number">2</span>. 对<span class="keyword">number</span>进行<span class="number">1000</span>的++操作</span><br><span class="line">    Runnable increment = ()-&gt;&#123;</span><br><span class="line">      for(int i = <span class="number">0</span>; i<span class="tag">&lt; 1000; i++)&#123;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        number++;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">/**</span></span><br><span class="line"><span class="tag">-------------             ------------------------------------------</span></span><br><span class="line"><span class="tag">|           |             |                                        |</span></span><br><span class="line"><span class="tag">|           |             | 9: getstatic    #18  // Field number:I |</span></span><br><span class="line"><span class="tag">| number++; |===========》|12: iconst_1                            |</span></span><br><span class="line"><span class="tag">|           |             |13: iadd                                |</span></span><br><span class="line"><span class="tag">|           |             |14: putstatic    #18  // Field number:I |</span></span><br><span class="line"><span class="tag">|           |             |                                        |</span></span><br><span class="line"><span class="tag">-------------             ------------------------------------------</span></span><br><span class="line"><span class="tag">*/</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">      &#125;</span></span><br><span class="line"><span class="tag">    &#125;;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    List&lt;Thread&gt;</span> list = new ArrayList<span class="tag">&lt;Thread&gt;</span>();</span><br><span class="line">    // <span class="number">3</span>. 使用<span class="number">5</span>个线程来进行</span><br><span class="line">    for(int i = <span class="number">0</span> ; i<span class="tag">&lt; 5; i++)&#123;</span></span><br><span class="line"><span class="tag">      Thread t = new Thread(increment);</span></span><br><span class="line"><span class="tag">      t.start();</span></span><br><span class="line"><span class="tag">      list.add(t);</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    for(Thread t: list)&#123;</span></span><br><span class="line"><span class="tag">      t.join();</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    System.out.println("number = " + number);</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  /**</span></span><br><span class="line"><span class="tag">  以下进行约定：红色的箭头代表主线程</span></span><br><span class="line"><span class="tag">  那么主线程先会进行执行（main()）；</span></span><br><span class="line"><span class="tag">  Runnable该语句先不会进行执行（Runnable increment=()-&gt;</span>&#123;...&#125;;）；</span><br><span class="line">  然后走下面的执行语句创建list集合（List<span class="tag">&lt;Thread&gt;</span> <span class="attr">list=</span>new ArrayList<span class="tag">&lt;Thread&gt;</span>();)）</span><br><span class="line">  以及for循环<span class="number">5</span>次创建生成<span class="number">5</span>个Thread线程；</span><br><span class="line">  然后这个时候每个线程才会去执行上面的Runnable；</span><br><span class="line">  <span class="number">5</span>个线程分析起来有点麻烦；</span><br><span class="line">  当前在for()循环创建生成<span class="number">5</span>个线程途中，</span><br><span class="line">  那么此时当前假设已经创建生成线程Thread A与线程Thread B；</span><br><span class="line">  </span><br><span class="line">  那么此时在Thread A与Thread B同时都运行<span class="literal">start</span>()方法的时候</span><br><span class="line">  那么就都将会去执行Runnable当中的run()方法即循环<span class="number">1000</span>次的<span class="keyword">number</span>++操作；</span><br><span class="line">  那么假设此时的<span class="keyword">number</span>取值为<span class="number">0</span>；</span><br><span class="line">  假设线程Thread A先进行走，那么即循环<span class="number">1000</span>次执行<span class="keyword">number</span>++；</span><br><span class="line">  那么这每一次的<span class="keyword">number</span>++都是在执行字节码的那<span class="number">4</span>条指令；</span><br><span class="line">  即</span><br><span class="line">  <span class="number">9</span>:  getstatic <span class="comment">#18</span></span><br><span class="line">  <span class="number">12</span>: iconst_1</span><br><span class="line">  <span class="number">13</span>: iadd</span><br><span class="line">  <span class="number">14</span>: putstatic <span class="comment">#18</span></span><br><span class="line">  <span class="comment">#9: getstatic该指令即为取到共享变量number的取值，此时为0</span></span><br><span class="line">  <span class="comment">#12: 字节码指令继续往下执行一步，iconst_1该字节码指令的含义为是在准备一个常量1</span></span><br><span class="line">  <span class="comment">#13: 假设再往下走一步执行字节码指令iadd；那么该指令执行后会让12: iconst_1 准备的常量1与9: getstatic #18 获取得到的number 该共享变量的取值进行相加操作；最终的结果是1；</span></span><br><span class="line">  </span><br><span class="line">  但是注意假设此时并没有真正发生赋值操作，即运算出结果为<span class="number">1</span>；</span><br><span class="line">  但是并没有赋值给<span class="keyword">number</span>该共享变量的取值上；</span><br><span class="line">  然后此时CPU切换到另外一个线程上面去即线程B上去执行了；</span><br><span class="line">  那么此时另外一个线程，即线程B，也进入了for循环来执行<span class="keyword">number</span>++操作；</span><br><span class="line">  那么线程B也有四条字节码指令需要进行执行；</span><br><span class="line">  </span><br><span class="line">  先执行字节码指令的第一条指令 <span class="number">9</span>: getstatic <span class="comment">#18 获取得到共享变量number的取值，</span></span><br><span class="line">  目前该共享变量的取值是没有线程进行改变的；</span><br><span class="line">  即也就是说线程A刚刚在操作<span class="keyword">number</span>++字节码指令操作的步骤三时只是运算得出运算结果为<span class="number">1</span>；</span><br><span class="line">  但是并没有进行赋值就进行了CPU切换到了线程B上，</span><br><span class="line">  所以相对于线程B当前的共享变量<span class="keyword">number</span>来说，线程B认为<span class="keyword">number</span>共享变量的取值是<span class="number">0</span>；</span><br><span class="line">  那么当getstatic获取得到共享变量<span class="keyword">number</span>的取值之后，</span><br><span class="line">  然后执行字节码指令的第二条指令 <span class="number">12</span>: iconst_1 即同样是准备一个常量<span class="number">1</span>；</span><br><span class="line">  再执行字节码指令的第三条指令 <span class="number">13</span>: iadd 这个时候同样是将<span class="keyword">number</span>++操作当中的第一条字节码指令当中<span class="number">9</span>: getstatic <span class="comment">#18 获取得到的 共享变量number的取值与 number++操作当中的第二条指令 12: iconst_1 所准备的常量1 这两者进行相加操作；</span></span><br><span class="line">  运算结果得到<span class="number">1</span>；</span><br><span class="line">  假设线程B再继续往下走，</span><br><span class="line">  那么此时到了<span class="keyword">number</span>++操作所对应字节码指令的第四个指令了；</span><br><span class="line">  即<span class="number">14</span>: putstatic   <span class="comment">#18 ；</span></span><br><span class="line">  那么该指令执行之后就会将指令三当中得到的结果<span class="number">1</span>赋值给共享变量<span class="keyword">number</span>的取值，</span><br><span class="line">  而<span class="keyword">number</span>变量的取值此时从<span class="number">0</span>变为<span class="number">1</span>；</span><br><span class="line">  那么此时该线程的一次<span class="keyword">number</span>++执行完成；</span><br><span class="line"></span><br><span class="line">  假设CPU又切换到前一条线程，即线程A；</span><br><span class="line">  那么在切换到线程B之前，</span><br><span class="line">  线程A的<span class="keyword">number</span>++操作的<span class="number">4</span>条字节码指令已经执行完了前三条即iadd执行运算得出运算结果为<span class="number">1</span>；</span><br><span class="line">  那么此时当CPU又切换回线程A则继续执行<span class="keyword">number</span>++操作字节码指令的第四条指令即<span class="number">14</span>: putstatic <span class="comment">#18该指令；</span></span><br><span class="line">  则该指令同样是需要进行put即给共享变量<span class="keyword">number</span>进行赋值操作；</span><br><span class="line">  即将A线程运算得到的<span class="number">1</span>赋值给已经被线程B之前赋值好<span class="keyword">number</span>为<span class="number">1</span>的共享变量取值为<span class="number">1</span>；</span><br><span class="line">  所以当前共享变量<span class="keyword">number</span>的取值依旧是<span class="number">1</span>；</span><br><span class="line">  那么这个时候就看到了，两个线程执行<span class="keyword">number</span>++；</span><br><span class="line">  按道理其值应该是<span class="number">2</span>；</span><br><span class="line">  那么因为<span class="keyword">number</span>++的字节码指令这<span class="number">4</span>条字节码指令没有保证其一个原子性；</span><br><span class="line">  所以发现导致最后的结果<span class="keyword">number</span>只加了<span class="number">1</span>；</span><br><span class="line">  就让数据产生了错误；</span><br><span class="line">  那么这个问题的原因就在于让两个线程来进行操作<span class="keyword">number</span>++；</span><br><span class="line">  而<span class="keyword">number</span>++的字节码指令又是多条指令（<span class="number">4</span>条指令）；</span><br><span class="line">  其中一个线程执行到一半的时候；</span><br><span class="line">  CPU又切换到另外一个线程，即另外一个线程又来执行了；</span><br><span class="line">  即第二个线程干扰了第一个线程的执行从而导致执行结果的错误；</span><br><span class="line">  即没有保证原子性；（即没有使得应该的结果正确）</span><br><span class="line"></span><br><span class="line">  小结：</span><br><span class="line">  在并发编程的时候，很有可能会出现原子性问题；</span><br><span class="line">  当一个线程对共享变量操作到一半的时候，</span><br><span class="line">  另外一个线程也有可能来对共享变量来进行操作；</span><br><span class="line">  那么此时另外一个线程就有可能会干扰前一个线程的操作；</span><br><span class="line">  让前一个线程的操作没有保证其原子性；</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见 number++ 是由多条<strong>字节码</strong>语句组成，<br>以上<strong>多条指令</strong> 在<strong>一个线程的情况下</strong> 是不会出问题的，<br>但是在<strong>多线程情况下</strong>就可能会出现问题。<br>比如一个线程在执行 13: iadd 时，<br>另一个线程又执行 9: getstatic，<br>会导致两次 number++，实际上只加了1。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>什么是<strong>原子性</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">原子性（Atomicity）: 在一次的操作或多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</span></span><br></pre></td></tr></table></figure>

<h2 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h2><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><p>学习什么是<strong>有序性问题</strong></p>
<p>学习分成两步；<br>第一步：学习有序性的概念；<br>第二步：通过一个案例来演示有序性问题<br>有序性（Ordering）：是指程序中代码的执行顺序<br>一般会认为编写代码的顺序就是代码最终的执行顺序；<br>那么实际上并不一定是这样的；<br>为了提高程序的执行效率；java在编译时和运行时会对代码进行优化，会导致程序最终的执行顺序不一定就是编写代码时的顺序。<br>接下来通过一个案例来演示有序性问题；</p>
<h3 id="有序性概念"><a href="#有序性概念" class="headerlink" title="有序性概念"></a>有序性概念</h3><p>有序性（Ordering）：是指程序代码在执行过程中的先后顺序，由于java在编译器以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码的顺序。</p>
<h3 id="有序性演示"><a href="#有序性演示" class="headerlink" title="有序性演示"></a>有序性演示</h3><p><strong>jcstress</strong> 是java并发压测工具： </p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>wiki.openjdk.java.net<span class="regexp">/display/</span>CodeTools<span class="regexp">/jcstress</span></span><br></pre></td></tr></table></figure>

<p>修改pom文件，添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jcstress<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcstress-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jcstress.version<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码<br>Test03Orderliness.java</p>
<figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@OutCome</span>(id = &#123;<span class="string">"1"</span> , <span class="string">"4"</span>&#125;, expect =  Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>)</span><br><span class="line"><span class="meta">@OutCome</span>(id = <span class="number">0</span>, expect = EXPECT.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger"</span>)</span><br><span class="line"><span class="meta">@State</span></span><br><span class="line">public class Test03Orderliness&#123;</span><br><span class="line">    int num = <span class="number">0</span>;</span><br><span class="line">    boolean ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    /* 线程一 执行的代码；先进行判断ready的值然后进行相关操作；</span><br><span class="line">       I_Result为并发压测工具自带的类；</span><br><span class="line">       <span class="meta">@Actor</span>注解：表示到时候有多个线程来执行这两个方法；</span><br><span class="line">       <span class="meta">@JCStressTest</span>注解：表示用这个并发压测工具来对这个类的方法进行测试</span><br><span class="line">       <span class="meta">@OutCome</span>注解：对输出结果的处理；</span><br><span class="line">       如果当id为&#123;<span class="string">"1"</span>,<span class="string">"4"</span>&#125;的时候，表示这种结果是我们所预期所接受的结果，则打印信息<span class="string">"ok"</span>;</span><br><span class="line">       如果程序最终I_Result当中保存的结果是<span class="number">0</span>；则也认为结果是可接受感兴趣的；然后打印信息<span class="string">"danger"</span></span><br><span class="line">       接下来分析下有几种运行结果；</span><br><span class="line">    */</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    public void actor1(I_Result r)&#123;</span><br><span class="line">      <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //线程二 执行的代码；对两个变量进行相应的修改；</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    public void actor2(I_Result r)&#123;</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      画两个箭头代表两个线程；</span><br><span class="line">      (蓝色箭头与紫色箭头)</span><br><span class="line">      而实际上这标有<span class="meta">@Actor</span>注解的两个方法有很多的线程来执行；</span><br><span class="line">      那么为了演示方法，一个线程一个方法也是可以的；</span><br><span class="line">      那么这里存在有几种情况；</span><br><span class="line">      分有线程A与线程B分别执行actor1(I_Result r)与actor2(I_Result r)；</span><br><span class="line">      第一种情况是上面的线程A先走；</span><br><span class="line">      执行actor1(I_Result r)方法；</span><br><span class="line">      则获取得到共享变量 ready取值为<span class="literal">false</span>；</span><br><span class="line">      则此时走<span class="keyword">else</span>块；</span><br><span class="line">      将<span class="number">1</span>赋值给I_Result r当中的成员变量r1，即将r.r1即I_Result成员变量r1属性的取值修改为<span class="number">1</span>；</span><br><span class="line"></span><br><span class="line">      记录一下r.r1(I_Result中r1属性取值的变化)：</span><br><span class="line">      结果<span class="number">1</span>：  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">      接着假设第二种情况下面的线程B先走；</span><br><span class="line">      执行actor2(I_Result r)方法；</span><br><span class="line">      执行代码语句给共享变量num以及ready重新赋值；</span><br><span class="line">      即num该数值变为了<span class="number">2</span>；</span><br><span class="line">      ready该布尔类型取值变为了<span class="literal">true</span>；</span><br><span class="line"></span><br><span class="line">      接着CPU又切换到上面的线程A当中进行执行；</span><br><span class="line">      由于线程B修改num以及ready这两个共享变量成功了；</span><br><span class="line">      即num取值为<span class="number">2</span>；ready取值为<span class="literal">true</span>；</span><br><span class="line">      则此时线程A再一次进行判断ready该变量的取值时此时ready为<span class="literal">true</span>；</span><br><span class="line">      则进入actor1(I_Result r)当中的<span class="keyword">if</span>块中；</span><br><span class="line">      执行赋值语句，此时num取值为<span class="number">2</span>；</span><br><span class="line">      那么此时I_Result r.r1取值又被重新赋值为num+num，即运算结果为<span class="number">4</span>；</span><br><span class="line">      r.r1取值重新赋值为<span class="number">4</span>；</span><br><span class="line"></span><br><span class="line">      记录一下r.r1(I_Result中r1属性取值的变化)：</span><br><span class="line">      结果<span class="number">2</span>：  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">      第三种可能性：</span><br><span class="line">      依然还是假设下面的线程先走即先走线程B；</span><br><span class="line">      执行actor2(I_Result r)方法；</span><br><span class="line">      执行到代码语句 num = <span class="number">2</span>; 时，CPU又切换到线程A中去执行actor1(I_Result r)方法了；</span><br><span class="line">      那么这个时候就是由线程A去执行actor1(I_Result r)方法；</span><br><span class="line">      此时线程A获取得到ready变量的取值：为<span class="literal">false</span>；</span><br><span class="line">      由于是执行线程B执行到num=<span class="number">2</span>;赋值完成之后但是并未执行ready=<span class="literal">true</span>该语句之前CPU进行切换到了线程A的操作上去了；</span><br><span class="line">      所以此时线程A去进行获取ready变量时，ready变量的取值依旧是<span class="literal">false</span>；</span><br><span class="line">      所以此时不会进入<span class="keyword">if</span>块当中而是进入<span class="keyword">else</span>块当中执行操作使得r.r1=<span class="number">1</span>;</span><br><span class="line">      即对I_Result r当中的成员变量r1进行重新赋值为<span class="number">1</span>；</span><br><span class="line"></span><br><span class="line">      记录一下r.r1(I_Result中r1属性取值的变化)：</span><br><span class="line">      结果<span class="number">3</span>：  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">      第四种可能性：</span><br><span class="line">      很难发现；这是由于java在编译时和运行时的优化；</span><br><span class="line">      就可能会对actor2(I_Result r)当中的代码语句</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">      进行重排序；</span><br><span class="line">      比如说有可能会被排成这样：</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">      因为这两句代码并没有什么直接间接的一个因果关系；</span><br><span class="line">      如果说通过编译时和运行时的优化代码变成了</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">      的这种顺序则再来进行分析一下：</span><br><span class="line">      依然还是假设下面的线程B先走，即执行actor2(I_Result r)；</span><br><span class="line">      则执行了第一句ready = <span class="literal">true</span>;</span><br><span class="line">      那么此时假设CPU正好在ready 赋值为 <span class="literal">true</span>之后以及num = <span class="number">2</span>赋值之前又切换到了上面的那个线程，即线程A即执行actor1(I_Result r)方法；</span><br><span class="line">      那么此时线程A在执行actor1(I_Result r)时首先会去获取ready该共享变量的取值，</span><br><span class="line">      则此时的ready变量的取值是在线程B的操作actor2(I_Result r)时进行了修改了的，并且赋值成功了；那么这个时候线程A获取得到ready的取值为<span class="literal">true</span>则进入<span class="keyword">if</span>块当中执行对I_Result r.r1的赋值语句，r.r1=num+num；那么此时的num在线程B的操作actor2(I_Result r)并没有进行执行，即没有赋值成功；所以此时线程A获取得到num的取值依然为<span class="number">0</span>；</span><br><span class="line">      则此时赋值给I_Result r.r1成员变量的取值为num+num=<span class="number">0</span>;即赋值给r1的取值为<span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">      记录一下r.r1(I_Result中r1属性取值的变化)：</span><br><span class="line">      结果<span class="number">4</span>：  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      此时出现结果<span class="number">4</span>: <span class="number">0</span>的原因就是因为actor2(I_Result r)中的两句代码的执行顺序被重排序过了从而导致的；</span><br><span class="line"></span><br><span class="line">      效果：</span><br><span class="line">      通过jcstress来进行检测结果；</span><br><span class="line">      打开idea终端；即Terminal；</span><br><span class="line">      键入命令行：mvn clean install</span><br><span class="line">      完成之后会在target目录当中形成两个jar包（前提是安装了jcstress的依赖；） - jcstress.jar、Synchronized<span class="number">-1.0</span>-SNAPSHOT.jar</span><br><span class="line">      此时运行jcstress.jar该jar包；</span><br><span class="line">      C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; java -jar target/jcstress.jar</span><br><span class="line">      运行之后，进行多轮的压力测试；</span><br><span class="line"></span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>压力测试结果（代码重排序所导致state结果出现了0）:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    [OK] com.xxx.demo02_concurrent_probleam.Test03Ordering</span><br><span class="line">  （JVM args: [-XX:-TieredCompilation]）</span><br><span class="line">Observed state Occurrences         Expectation     Interpretation</span><br><span class="line">             <span class="number">0</span>       <span class="number">5</span>,<span class="number">630</span>  ACCEPTABLE_INTERESTING  danger</span><br><span class="line">             <span class="number">1</span> <span class="number">150</span>,<span class="number">985</span>,<span class="number">557</span>          ACCEPTABLE      ok</span><br><span class="line">             <span class="number">4</span>  <span class="number">41</span>,<span class="number">594</span>,<span class="number">004</span>          ACCEPTABLE      ok</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_probleam.Test03Ordering</span><br><span class="line">  （JVM args: []）</span><br><span class="line">Observed state Occurrences         Expectation     Interpretation</span><br><span class="line">             <span class="number">0</span>       <span class="number">2</span>,<span class="number">787</span>  ACCEPTABLE_INTERESTING  danger</span><br><span class="line">             <span class="number">1</span> <span class="number">113</span>,<span class="number">540</span>,<span class="number">468</span>          ACCEPTABLE      ok</span><br><span class="line">             <span class="number">4</span>  <span class="number">46</span>,<span class="number">388</span>,<span class="number">436</span>          ACCEPTABLE      ok</span><br></pre></td></tr></table></figure>

<p>I_Result.class<br>jcstressjava并发压测工具当中并不只有I_Result这一个类；还存在有多个类似的类来进行保存各种不同的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.openjdk.jcstress.infra.results;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Result</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I_Result</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    成员变量r1 来保存一个int类型的结果</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Contended</span></span><br><span class="line">  <span class="meta">@jdk</span>.internal.vm.annotation.Contended</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> r1;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">I_Result</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">31</span> * result + <span class="keyword">this</span>.r1;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（有序性问题，有可能重排序从而导致在多线程的情况下，数据出现错乱问题。）</p>
<p>I_Result 是一个对象，有一个属性r1 用来保存结果，在多线程情况下可能出现几种结果？</p>
<p>情况1：线程1先执行actor1，这时 ready=false，所以进入else分支结果为1。<br>情况2：线程2执行到actor2，执行了num=2;和ready=true，线程1执行，这回进入if分支，结果为4；<br>情况3：线程2先执行actor2，只执行num=2; 但没来得及执行ready=true; 线程1执行，还是进入else分支，结果为1；<br><strong>还有一种结果为0</strong>；</p>
<p>运行测试：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn clean <span class="keyword">install</span></span><br><span class="line">java -jar <span class="keyword">target</span>/jcstress.jar</span><br></pre></td></tr></table></figure>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>程序代码在执行工程中的 先后顺序，<br>由于java在 编译期以及运行期的优化（为了提高执行效率），<br>导致了 代码的执行顺序 未必就是 开发者编写代码的顺序。（最终程序的执行顺序可能跟编写的顺序不一样）</p>
<p>最后也就能够了解到并发编程当中存在的三个问题；<br>可见性、原子性、有序性；这三个问题有可能会导致共享数据错乱；<br>会出现线程安全问题；</p>
<h2 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h2><p>第二章：Java内存模型（JMM）</p>
<p>在介绍 Java内存模型之前，先来看一下到底什么是计算机内存模型。</p>
<p>当使用多线程并发访问共享资源的时候，会出现可见性、原子性、有序性等线程安全问题；<br>为什么会出现这三种问题以及出现这三种问题如何来进行解决呢？</p>
<p>这也是第二章所需要学习的内容；java内存模型（JMM）；<br>在第二章中分成三部分来进行学习；<br>首先介绍计算机的结构；那么就需要了解知道计算机有哪些重要的组成部分；<br>第二来进行学习java内存模型；需要知道java内存模型的概念和作用；<br>最后来进行学习java内存模型当中的主内存和工作内存之间是如何进行数据交互的；</p>
<h3 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h3><p>学习计算机的主要组成<br>学习缓存的作用</p>
<h3 id="计算机结构简介"><a href="#计算机结构简介" class="headerlink" title="计算机结构简介"></a>计算机结构简介</h3><p>1945年6月，美籍 匈牙利 科学家 <strong>冯 诺依曼</strong> 最先提出把 <strong>计算机</strong>分作 <strong>五部分</strong>：<strong>计算器</strong>、<strong>控制器</strong>、<strong>存储器</strong>、<strong>输入和输出设备</strong>。<br>由于他对 现代计算机技术的特殊贡献，因此 冯 诺依曼 又被称为 “现代计算机之父”。  </p>
<blockquote>
<p>冯诺依曼，提出计算机由五大组成部分，输入设备、输出设备、存储器、控制器、运算器</p>
<ul>
<li>输入设备：键盘、鼠标、扫描仪、etc.</li>
<li>输出设备：显示器、打印机、etc.</li>
<li>存储器：内存条</li>
<li>控制器：控制器+运算器–→CPU</li>
<li>运算器：控制器+运算器–→CPU</li>
</ul>
</blockquote>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">--------------     -----------------        -------------</span><br><span class="line">|<span class="string"> 输入设备</span>|<span class="string"> ------→ </span>|<span class="string">    存储器    </span>|<span class="string"> -------→ </span>|<span class="string"> 输出设备 </span>|</span><br><span class="line">------------       -----------------         ------------</span><br><span class="line">     ↑                |<span class="string">  ↑    </span>|<span class="string">  ↑                 ↑</span></span><br><span class="line"><span class="string">     </span>|<span class="string">                </span>|<span class="string">  </span>|<span class="string">    </span>|<span class="string">  </span>|<span class="string">                 </span>|</span><br><span class="line">     |<span class="string">       ---------</span>|<span class="string">--</span>|<span class="string">----</span>|<span class="string">--</span>|<span class="string">----------       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">        </span>|<span class="string">  </span>|<span class="string">    </span>|<span class="string">  </span>|<span class="string">         </span>|<span class="string">       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">        ↓  </span>|<span class="string">    ↓  </span>|<span class="string">         </span>|<span class="string">       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">   ----------  -----------   </span>|<span class="string">       </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">   </span>|<span class="string"> 运算器 </span>|<span class="string">   </span>|<span class="string"> 控制器 </span>|<span class="string">----</span>|<span class="string">-------</span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">   ----------  -----------   </span>|</span><br><span class="line">     |<span class="string">       </span>|<span class="string">                    </span>|<span class="string">        </span>|</span><br><span class="line">     --------|<span class="string">---------------------        </span>|</span><br><span class="line">             |<span class="string">                        CPU  </span>|</span><br><span class="line">             -------------------------------</span><br></pre></td></tr></table></figure>

<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><strong>中央处理器</strong>（<strong>CPU</strong>，<strong>central processing unit</strong>）是<strong>计算机</strong>系统的<strong>运算</strong>和<strong>控制核心</strong>。（相当于人类的大脑）<br>计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。<br>程序最终都会变成 <strong>指令</strong> 让 <strong>CPU</strong> 去执行，处理程序中的数据。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>计算机中所有<strong>程序</strong>的<strong>运行</strong> 都是在 <strong>内存中</strong> 进行的， 内存的作用是 用于暂时存放 CPU的运算数据，以及与 硬盘等 外部存储器 交换的数据。</p>
<p>CPU自产生以来，在逻辑结构、运行效率以及功能外延上取得了巨大发展。<br>但受制于 制造工艺以及成本等的限制，计算机的内存反倒在访问速度上并没有多大的突破，<br>因此CPU的处理速度和内存的访问速度之间的差距越拉越大，通常这种差距可以达到上千倍，极端情况下甚至会在上万倍以上。<br>这就导致CPU每次操作内存都要耗费很多等待时间。<br>内存的读写速度成为了计算机运行的瓶颈。</p>
<p>（程序都是在内存中运行的，内存 会保存 程序运行时的数据，供CPU处理；CPU运行的时候，是需要到内存当中读取数据进行相关处理的；）</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>由于CPU和内存两边速度 严重的不对等，会导致CPU资源受到大量的限制，降低CPU整体的吞吐量，于是就有了在CPU与主内存之间增加缓存的设计，现在缓存的数量都可以增加到3级了，最靠近CPU的缓存称为L1，然后依次是L2，L3和主内存，CPU缓存模型如图 下图所示。  </p>
<p>CPU自从产生以来，在运行速度运行效率上得到了巨大的发展；<br>但是内存由于制造工艺制造成本的控制在访问速度上面并没有多大的提升。<br>因此CPU的运行速度和内存的读写速度其差距就将变得越来越大；<br>这样也就导致了CPU在运算的时候要花上很长的时间去等待内存的读取；<br>那么也就是说内存的读写速度成为了计算机运行的一个瓶颈；<br>那么如何来解决这个两面速度不对等的问题？<br>于是人们就在CPU与主内存之间增加了缓存的设计；</p>
<p>打开任务管理器[CTRL + ALT + DEL]，点开[性 能]菜单栏，可以看到；</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内核：      <span class="number">6</span>             # 我电脑只有<span class="number">4</span></span><br><span class="line">逻辑处理器: <span class="number">12</span>            # 我电脑只有<span class="number">8</span></span><br><span class="line">虚拟化：    已启用</span><br><span class="line">L1缓存：    <span class="number">384</span> KB</span><br><span class="line">L2缓存：    <span class="number">1.5</span> MB</span><br><span class="line">L3缓存：    <span class="number">12.0</span> MB</span><br></pre></td></tr></table></figure>

<p>其中缓存L1缓存最小；L2缓存较之L1缓存较大；L3缓存最大；<br>CPU的缓存是内置在CPU当中的；<br>首先离CPU最近的是L1缓存；其空间比较小但是速度比较快；价格也比较昂贵；<br>L2缓存空间稍大；速度稍慢些；价格的话也会更加便宜些；<br>L3缓存空间更大；速度较之前两者更慢，价格也更便宜些；</p>
<p>看图说话：<br>CPU 在操作内存的时候有59.4 ns(纳秒)的一个延迟(Latency)<br>CPU 在操作L1缓存的时候大约 1.2 ns(纳秒)<br>CPU 在操作L2缓存的时候大约 5.5 ns(纳秒)<br>CPU 在操作L3缓存的时候大约 15.9 ns(纳秒)</p>
<p>从中可以看到的是内存的速度要比缓存的速度慢很多；<br>当CPU有了缓存之后，其数据是如何进行处理的呢？<br>首先CPU运算的时候需要数据，那么CPU直接去一级缓存L1Cache当中找要查找的数据看是否能够查找得到；<br>如果命中了一级缓存则直接从一级缓存当中进行读取数据到CPU，处理完成之后就会将CPU当中处理后的结果又接着放回到缓存L1、L2、L3中以及内存中；<br>那么如果CPU需要数据时，但是此时并没有在一级缓存L1 Cache当中命中缓存；<br>那么这个时候CPU就会去进行读取二级缓存L2 Cache当中所需要查找的数据；<br>如果二级缓存L2 Cache当中也没有找到所需要查找得到的数据，即没有命中缓存；<br>那么这个时候CPU就会去进行读取三级缓存L3 Cache当中所需要查找的数据；<br>如果此时三级缓存L3 Cache当中也没有找到所需要查找得到的数据，即也没有命中缓存；<br>那么这个时候就会去查找内存Memory；从内存当中拿取到相应的所需要查找的数据之后，在CPU中运行计算之后；另外相应的其处理结果也会保存在缓存当中；</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                    单CPU双核的缓存结构</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">|<span class="string">--------------------------------------------</span>|</span><br><span class="line">|<span class="string">      -----------          -------------    </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">  Core1  </span>|<span class="string">           </span>|<span class="string">  Core 2  </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">      -----------          -------------    </span>|</span><br><span class="line">|<span class="string">           ↓                     ↓          </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">  L1 Cache </span>|<span class="string">         </span>|<span class="string"> L1 Cache </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">           ↓                    ↓           </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">  L2 Cache </span>|<span class="string">         </span>|<span class="string"> L2 Cache </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">      -------------         -------------   </span>|</span><br><span class="line">|<span class="string">           ↓                    ↓           </span>|</span><br><span class="line">|<span class="string">     ------------------------------------   </span>|</span><br><span class="line">|<span class="string">      </span>|<span class="string">          L3   Cache             </span>|<span class="string">   </span>|</span><br><span class="line">|<span class="string">     ------------------------------------   </span>|</span><br><span class="line">|<span class="string">                       </span>|<span class="string">                    </span>|</span><br><span class="line">|<span class="string">-----------------------</span>|<span class="string">---------------------</span></span><br><span class="line"><span class="string">                        ↓</span></span><br><span class="line"><span class="string">     ------------------------------------</span></span><br><span class="line"><span class="string">     </span>|<span class="string">              Memory              </span>|</span><br><span class="line">     ------------------------------------</span><br></pre></td></tr></table></figure>

<p><strong>CPU Cache</strong> 分成了三个级别：<strong>L1、L2、L3。</strong><br><strong>级别越小越接近CPU</strong>，<strong>速度也更快</strong>，同时也代表着<strong>容量越小</strong>。</p>
<p><strong>1.</strong> <strong>L1 Cache</strong>是<strong>最接近CPU</strong>的，它<strong>容量最小</strong>，例如32k，<strong>速度最快</strong>，每个核上都有一个L1 Cache。<br><strong>2.</strong> <strong>L2 Cache</strong> <strong>更大</strong>一些，例如256k，<strong>速度要慢</strong>一些，一般情况下每个核上都有一个独立的L2 Cache。<br><strong>3.</strong> <strong>L3 Cache</strong>是三级缓存中<strong>最大</strong>的一级，例如12MB，同时也是缓存中<strong>最慢</strong>的一级，在同一个CPU插槽之间的核共享一个L3 Cache。</p>
<p><strong>Cache的出现</strong>是为了<strong>解决 CPU直接访问内存效率低下问题的</strong>，<br>程序在运行的过程中，CPU接收到指令后，<br>它会最先向CPU中的一级缓存（L1 Cache）去寻找相关的数据，<br>如果命中缓存，CPU进行计算时就可以直接对CPU Cache中的数据进行读取和写入，<br>当运算结束之后，再将CPU Cache中的最新数据刷新到主内存当中，<br><strong>CPU</strong> 通过<strong>直接访问Cache</strong>的方式 <strong>代替</strong> <strong>直接访问主内存</strong>的方式 极大地<strong>提高</strong>了 <strong>CPU的吞吐能力</strong>。  </p>
<p>但是由于 <strong>一级缓存（L1 Cache）</strong> <strong>容量较小</strong>，<br>所以不可能每次都命中，<br>这时 <strong>CPU</strong> 会继续向下一级的<strong>二级缓存（L2 Cache）</strong> 寻找，<br>同样的道理，当所需要的数据在二级缓存中也没有的话，<br>会继续转向<strong>L3 Cache</strong>、<strong>内存（主存）</strong>和<strong>硬盘</strong>。  </p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>计算机的主要组成 <strong>CPU</strong>、<strong>内存</strong>、<strong>输入设备</strong>、<strong>输出设备</strong></p>
<blockquote>
<p><strong>CPU</strong>：计算机的核心；用来控制和处理的<br><strong>内存</strong>：用来保存正在运行的这些程序的数据；<br><strong>输入设备</strong>：<br><strong>输出设备</strong>：<br><strong>缓存</strong>：<br>  CPU的运算速度比内存的访问速度快很多；<br>  那么如果CPU直接从内存当中进行读取数据进行相关处理的话；<br>  则内存读取时间花费开销大就会导致拖累CPU的运算速度；<br>  所以在CPU与内存之间增加了缓存；<br>  缓存的读写速度较之内存的读写速度要快很多；<br>  因此可以让CPU的执行速度高一点；</p>
</blockquote>
<p><strong>1.</strong> 说出计算机的主要组成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU</span><br><span class="line">内存</span><br><span class="line">缓存</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> 为什么会出现缓存？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## java内存模型</span><br><span class="line"></span><br><span class="line">### 目标</span><br><span class="line"></span><br><span class="line">全称：**Java Memory Model**(翻译成中文名为:**Java内存模型**；一般简称为**JMM**)</span><br><span class="line">**Java 内存模型** **JMM**千万不要和**Java内存结构**混淆；</span><br><span class="line">以前学习Java的时候知道**JVM**会**对内存**进行一个**划分**；会划分成**栈**、**堆**、**方法区**、etc.那么这个是指的是**Java内存结构**；</span><br><span class="line">那么**java内存模型** **JMM**则**是一套规范**；关于**Java内存模型**的权威解释可以查看网址；（Oracle提供的纯英文版本，即Java内存模型的详细的说明文档，其实即一套规范，那么这套规范主要描述了两个关键字；一个是synchronized；一个是volatile；）</span><br><span class="line"></span><br><span class="line">学习java内存模型的概念和作用</span><br><span class="line">java内存模型（即 java Memory Model，简称JMM）。</span><br><span class="line">（java内存模型 和 以前学习的栈、堆、方法区、原空间这样的java内存结构是不一样的）</span><br><span class="line">很多小伙伴 将 “java内存结构” 与 “java内存模型”混淆。</span><br><span class="line">关于 “java内存模型”的权威解释，请参考 &#96;&#96;&#96;https:&#x2F;&#x2F;download.oracle.com&#x2F;otn-pub&#x2F;jcp&#x2F;memory_model-1.0-pfd-spec-oth-JSpec&#x2F;memory_model-1_0-pfd-spec.pdf</span><br></pre></td></tr></table></figure>

<p>为什么会出现Java内存模型；<br>Java是一门跨平台的语言；可以在不同的操作系统上运行；<br>那么其底层是依赖JVM虚拟机来进行实现的跨平台这一特性；<br>每一个平台都有其对应的一个虚拟机；<br>那么此时Java程序就可以跑在不同的操作系统上；<br>那么java内存模型是java虚拟机规范当中的一部分；<br>它主要是用来屏蔽java运行在不同操作系统上的一些细节问题；<br>那么java程序仅仅只需要关注java内存模型即可；</p>
<p>Java 内存模型，是 Java虚拟机规范 中 所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。<br>JMM是一套规范， 描述了 Java程序中 各种变量（线程共享变量）的访问规则，以及在 JVM中 将变量 存储到 内存和从内存中读取变量 这样的底层细节，具体如下。</p>
<p>（学习主内存和工作内存，以及它们是如何操作这些共享变量的）<br>Java内存模型主要分作两部分来看；<br>一部分叫做主内存；<br>另一部分叫做工作内存；<br>首先来看主内存，java当中的共享变量；都放在主内存当中；<br>比如说类的成员变量也称之为实例变量；还有静态的成员变量；或者说叫类变量；都是存储在主内存当中的；<br>那么每一个线程都可以来进行访问主内存；<br>接着来看第二部分工作内存；每一个线程都有其自己的工作内存；<br>当线程要执行代码的时候，就必须在工作内存当中来进行处理完成；</p>
<p>假设现在一个线程A要访问主内存当中的一个共享变量X；<br>要对该共享变量X进行操作；<br>那么线程是不能够在主内存当中来进行直接操作共享变量X的；<br>即该线程只能够将该共享变量先进行复制一份放到线程自己的工作内存当中，<br>然后才去进行数据的相关处理；<br>当线程在其工作内存对该复制过来的共享变量相应处理完成之后再将处理完成的结果同步回主内存当中去；</p>
<p>假设线程A想要对共享变量x操作；<br>此时共享变量x的取值在主内存当中为 int x = 10; 这样一个取值；<br>那么首先线程A需要将该共享变量x的取值从主内存当中进行拷贝一份放到自己的工作内存当中去；<br>然后进行相应处理，比方说这里处理为重新赋值为9，<br>即int x = 9;那么假设处理完成之后，<br>那么这个时候该线程A就需要将对该共享变量重新赋值的结果即9需要同步回主内存当中；<br>那么其他的线程也是一样的，<br>也是先要进行将共享变量先要从主内存当中进行拷贝一份放到自己的工作内存当中去；<br>然后再去进行操作for example：int x = 8;<br>最后相应操作（赋值）完成之后再由线程从工作内存同步至主内存当中去；</p>
<ul>
<li><strong>主内存</strong><ul>
<li><strong>主内存</strong>是 所有<strong>线程</strong>都<strong>共享</strong>的，都能访问的。所有的<strong>共享变量</strong>都<strong>存储于主内存</strong>。</li>
<li>共享变量主要包括类当中的成员变量，以及一些静态变量等；线程的局部变量是不会出现在主内存当中的；因为线程的局部变量只能够自己该线程进行使用；</li>
</ul>
</li>
<li><strong>工作内存</strong><ul>
<li>每一个线程有自己的<strong>工作内存</strong>，工作内存只存储 该线程 对<strong>共享变量的副本</strong>。 线程对变量的所有的操作（<strong>读、取</strong>）都必须在<strong>工作内存</strong>中完成，而<strong>不能直接读写主内存中的变量</strong>，不同线程之间也<strong>不能直接访问</strong> <strong>对方工作内存中的 变量</strong>。</li>
<li>线程对共享变量的操作都是对其副本进行操作，操作完成之后再同步回主内存当中去；</li>
</ul>
</li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">                    Java Memory Model(Java 内存模型)</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    --------------------------          ----------------------------</span><br><span class="line">    |<span class="string">        线程1           </span>|<span class="string">           </span>|<span class="string">          线程2           </span>|</span><br><span class="line">    |<span class="string">                        </span>|<span class="string">           </span>|<span class="string">                          </span>|</span><br><span class="line">    |<span class="string">  -------------------   </span>|<span class="string">           </span>|<span class="string">  --------------------    </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string">  线程1工作内存    </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string">  线程2工作内存    </span>|<span class="string">    </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string">                  </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string">                   </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string"> ---------------- </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string"> ----------------  </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string"> </span>|<span class="string"> 共享变量x副本 </span>|<span class="string"> </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string"> </span>|<span class="string"> 共享变量x副本 </span>|<span class="string">  </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string"> ---------------- </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string"> ----------------- </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  </span>|<span class="string">                  </span>|<span class="string">  </span>|<span class="string">           </span>|<span class="string">  </span>|<span class="string">                   </span>|<span class="string">   </span>|</span><br><span class="line">    |<span class="string">  --------------------  </span>|<span class="string">           </span>|<span class="string">  ---------------------   </span>|</span><br><span class="line">                ↑                                      ↑</span><br><span class="line">                |<span class="string">                                      </span>|</span><br><span class="line">                |<span class="string">←---------------JMM控制--------------→</span>|</span><br><span class="line">                |<span class="string">                                      </span>|</span><br><span class="line">                ↓                                      ↓</span><br><span class="line">   --------------------------------------------------------------------</span><br><span class="line">   |<span class="string">                            主内存                                </span>|</span><br><span class="line">   |<span class="string">  ------------------      ------------------     --------------   </span>|</span><br><span class="line">   |<span class="string">  </span>|<span class="string">   共享变量x    </span>|<span class="string">       </span>|<span class="string">   共享变量 y   </span>|<span class="string">      </span>|<span class="string"> 共享变量z  </span>|<span class="string">  </span>|</span><br><span class="line">   |<span class="string">  ------------------      -------------------    ---------------  </span>|</span><br><span class="line">   |<span class="string">                                                                  </span>|</span><br><span class="line">   --------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h3 id="Java内存模型的作用"><a href="#Java内存模型的作用" class="headerlink" title="Java内存模型的作用"></a>Java内存模型的作用</h3><p>java内存模型是一套规范；<br>主要的目的就是在多线程对共享变量进行读写时，来保证共享变量的可见性、有序性、原子性；<br>java内存模型该规范当中主要阐述了两个关键字；<br>一个是synchronized；一个是volatile；<br>那么在编程当中也是通过这两个关键字来进行保证共享变量的三个特性即可见性、有序性、原子性；</p>
<p>java内存模型 是一套在多线程读写共享数据时，对共享数据的可见性、有序性、原子性的规则和保障。</p>
<p>java内存模型与真实的计算机结构有什么关系？</p>
<h3 id="CPU缓存、内存与Java内存模型的关系"><a href="#CPU缓存、内存与Java内存模型的关系" class="headerlink" title="CPU缓存、内存与Java内存模型的关系"></a>CPU缓存、内存与Java内存模型的关系</h3><p>通过对前面的 <strong>CPU硬件内存架构</strong>、<strong>Java内存模型</strong> 以及 <strong>Java多线程的实现原理</strong> 的了解，应该已经意识到，<strong>多线程的执行</strong> <strong>最终</strong>都会<strong>映射</strong>到 <strong>硬件处理器</strong> 上进行<strong>执行</strong>。</p>
<p>但 <strong>Java内存模型</strong> 和 <strong>硬件内存架构</strong> 并<strong>不完全一致</strong>。<br>对于 <strong>硬件内存</strong> 来说只有 <strong>寄存器</strong>、<strong>缓存内存</strong>、<strong>主内存</strong>的概念，<br>并<strong>没有工作内存和主内存之分</strong>，<br>也就是说 <strong>Java内存模型对内存的划分</strong> 对 <strong>硬件内存</strong> 并<strong>没有任何问题</strong>，<br>因为<strong>JMM</strong>只是一种 <strong>抽象的概念</strong>，是<strong>一组规则</strong>，<br>不管是 <strong>工作内存的数据</strong> 还是 <strong>主内存的数据</strong>，<br>对于 <strong>计算机硬件</strong>来说 都会 <strong>存储在计算机主内存</strong>中，<br>当然也有可能 <strong>存储到CPU缓存</strong>或者<strong>寄存器</strong>中，<br>因此总体上来说，<strong>Java内存模型</strong>和<strong>计算机硬件内存架构</strong> 是一个<strong>相互交叉</strong>的关系，<br>是一种 <strong>抽象概念划分</strong> 与 <strong>真实物理硬件</strong>的<strong>交叉</strong>。</p>
<p>JMM内存模型与CPU硬件内存架构的关系：</p>
<p>图的右边是真实的CPU硬件内存架构；有CPU、CPU当中存在有CPU寄存器、CPU缓存、内存（RAM）；<br>图的左边是Java内存模型：线程、线程当中存在有工作内存、主内存；<br>Java内存模型是一套抽象出来的规范，抽象的概念，是一组规则；<br>java内存模型当中的线程中的工作内存有可能对应着 硬件内存架构当中的CPU寄存器也有可能对应着CPU缓存也有可能对应内存（RAM）；<br>java内存模型当中的主内存也有可能对应着 硬件内存架构当中的CPU寄存器、CPU缓存、内存（RAM）；</p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>java内存模型是一套规范（主要是让java程序来可以实现跨平台这一特性；又不需要去关注平台的底层细节），<br>描述了 java程序中各种变量 （线程共享变量）的访问规则，<br>以及在 JVM中将变量 存储到内存和从内存中读取变量这样的 底层细节，<br>java内存模型是对共享数据的可见性、有序性、原子性的规则和保障。</p>
<h2 id="主内存与工作内存之间的数据交互过程"><a href="#主内存与工作内存之间的数据交互过程" class="headerlink" title="主内存与工作内存之间的数据交互过程"></a>主内存与工作内存之间的数据交互过程</h2><p>java内存模型有主内存、工作内存之分；<br>当线程A需要进行操作一个共享变量X的时候，<br>需要将存在在主内存的共享变量X复制拷贝一份放到线程A自己的工作内存当中；<br>线程A即对自己工作内存当中拷贝过来的共享变量副本进行操作，<br>操作处理完成之后；<br>然后再将结果从工作内存同步回主内存当中去；<br>那么该过程当中其中详细的细节是怎样的？</p>
<h3 id="主内存与工作内存之间的交互"><a href="#主内存与工作内存之间的交互" class="headerlink" title="主内存与工作内存之间的交互"></a>主内存与工作内存之间的交互</h3><h3 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h3><p>了解主内存与工作内存之间的数据交互过程</p>
<p>Java内存模型 中定义了以下 8中操作来完成（为了保证主内存与工作内存之间的数据交互数据是正确的），<br>主内存与工作内存之间 具体的交互协议，<br>即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，<br>虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的；</p>
<p>对应的流程图如下：<br>这8个原子操作先不关心 Lock与Unlock操作；除此之外还余六个操作；<br>假设现在线程1想要来进行访问主内存当中的共享变量x，即当前主内存当中的共享变量x的取值为 boolean x = true;</p>
<p>那么该线程1首先会做一个原子操作叫做Read，那么也就是读取主内存当中的共享变量x的取值即boolean x = true的这样一个取值；<br>那么接下来就是执行一个操作叫做Load，即将该在主内存当中读取到的共享变量加载到了工作内存当中；<br>那么接着会做一个Use操作，也就是说如果该线程1需要对该共享变量x进行操作，即会取到这个从主内存当中加载过来的共享变量x的取值去进行一些操作；<br>那么操作之后会有一个新的结果进行返回；那么假设这个操作的新的结果令这个共享变量的取值变为了false；那么即给这个共享变量x进行赋值操作，即完成操作Assign；那么操作完成之后；就需要同步回主内存；<br>同步回主内存首先会完成一个 Store的这样一个原子操作；表示要来保存这个处理结果；<br>然后接着执行Write操作，即把在工作内存当中处理完成之后最新的取值，即Assign赋值给共享变量的值同步到主内存当中；即主内存中共享变量取值x由true更改为false；<br>另外还有两个操作即Lock与Unlock；这个是与锁相关的操作；<br>比如说加了synchronized，即加了锁；才会产生有lock与unlock操作；<br>如果共享变量的操作没有加这个synchronized即没有加锁；<br>那么也就不会产生有lock与unlock操作；</p>
<p>注意；<br>（对于lock有一些特殊的情况；）</p>
<ol>
<li>如果对一个变量执行 lock操作，将会清空工作内存中 此变量的值。</li>
<li>对一个变量执行unlock操作，必须先把此变量同步到主内存中。</li>
</ol>
<p>即如果线程1中在Read主内存当中的共享变量之前，线程1的工作内存当中已经存在有该共享变量的副本；那么又有lock操作的话则将会将该线程1当中的共享变量的副本进行清空掉，然后再去进行Read读取主内存当中共享变量取值的操作；即读取主内存当中有关该共享变量最新的取值；</p>
<p>unlock操作也需要注意；假设线程1当中的工作内存当中存在有该共享变量的副本；那么在执行unlock之前一定会先将工作内存当中该共享变量副本的取值同步到主内存当中去；然后再进行unlock操作；</p>
<p>synchronized如何保证可见性其实就与lock、unlock这两个原子操作有关；</p>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>主内存 与 工作内存 之间的 数据交互过程(即主内存与工作内存的交互过程中是通过这8个原子操作来进行保证数据的正确性；)</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">lock</span> --<span class="comment">→</span> <span class="comment">read</span> --<span class="comment">→</span> <span class="comment">load</span> --<span class="comment">→</span> <span class="comment">use</span> --<span class="comment">→</span> <span class="comment">assign</span> --<span class="comment">→</span> <span class="comment">store</span> --<span class="comment">→</span> <span class="comment">write</span> --<span class="comment">→</span> <span class="comment">unlock</span></span><br></pre></td></tr></table></figure>

<h2 id="synchronized保证原子性"><a href="#synchronized保证原子性" class="headerlink" title="synchronized保证原子性"></a>synchronized保证原子性</h2><p>（通过synchronized关键字和内存模型来详细的分析原子性问题，以及如何来进行解决原子性问题，如何解决可见性问题以及有序性问题等）</p>
<p>第三章：synchronized保证三大特性（即synchronized是如何进行来保证可见性、原子性、有序性）</p>
<h3 id="回顾synchronized的使用"><a href="#回顾synchronized的使用" class="headerlink" title="回顾synchronized的使用"></a>回顾synchronized的使用</h3><p>synchronized 能够保证在 同一时刻 最多只有一个线程执行该段代码，已达到保证并发安全的效果。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//到时候只有一个线程能够拿到获取锁进入同步代码块当中来；其他的线程拿不到获取不到锁；只能够在同步代码块外进行等待</span></span><br><span class="line"><span class="function"><span class="title">synchronized</span><span class="params">( 锁对象 )</span></span>&#123;</span><br><span class="line">  <span class="comment">// 受保护资源 / 临界区资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 与 原子性</p>
<h3 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h3><p>学习使用 synchronized 保证原子性的原理</p>
<h3 id="使用-synchronized-保证原子性"><a href="#使用-synchronized-保证原子性" class="headerlink" title="使用 synchronized 保证原子性"></a>使用 synchronized 保证原子性</h3><p>案例演示：5个线程各执行1000次 i++；<br>（回顾之前原子性问题的代码，<strong>产生原子性问题的原因</strong>）</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">    1. 定义一个共享变量number</span></span><br><span class="line"><span class="comment">    2. 对number进行1000的++操作</span></span><br><span class="line"><span class="comment">    3. 使用5个线程来进行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02Atomicity</span>&#123;</span></span><br><span class="line">  <span class="comment">// 1. 定义一个共享变量number</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">// 2. 对number进行1000的++操作</span></span><br><span class="line">    <span class="comment">// Runnable当中执行1000次的循环；每次循环使得number++</span></span><br><span class="line">    Runnable increment =  () -&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        number++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Thread&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">    <span class="comment">// 3. 使用5个线程来进行</span></span><br><span class="line">    <span class="comment">// 创建5个线程都去执行Runnable当中的run()</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">      t.start();</span><br><span class="line">      <span class="built_in">list</span>.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t : <span class="built_in">list</span>)&#123;</span><br><span class="line">      t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"number = "</span> + number);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    之前存在线程安全问题；</span></span><br><span class="line"><span class="comment">    即多次运行测试发现数据可能会小于5000；</span></span><br><span class="line"><span class="comment">    number = 5000;</span></span><br><span class="line"><span class="comment">    number = 4935;</span></span><br><span class="line"><span class="comment">    导致这种结果的原因是因为number++是由4条字节码指令进行组成的；</span></span><br><span class="line"><span class="comment">    并没有保证这4条字节码指令的原子性操作；</span></span><br><span class="line"><span class="comment">    接下来使用synchronized；synchronized需要一把锁对象；</span></span><br><span class="line"><span class="comment">    则创建一把锁；Object obj即可；</span></span><br><span class="line"><span class="comment">    那么使用了synchronized之后就可以保证number++是一个原子操作；</span></span><br><span class="line"><span class="comment">    再次多次运行就会发现number的取值不会进行变动了；而是直接就是5000；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<strong>synchronized</strong>来进行保证number++的原子性操作；即进行加锁</p>
</blockquote>
<p>再怎么多次运行得到的number的结果也会是5000；因为synchronized保证了number++的原子性；那么数据就不会错乱；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo02_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：5个线程各执行1000次 i++;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Atomicity</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">      Runnable increment = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Test01Atomicity<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">              number++;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      ArrayList&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList();</span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; <span class="number">50</span> ; i++)&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">        t.start();</span><br><span class="line">        ts.add(t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Thread t : ts)&#123;</span><br><span class="line">        t.join();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"number = "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">    synchronized( Test01Atomicity.<span class="keyword">class</span> )&#123;</span><br><span class="line">      number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示</span></span><br><span class="line"><span class="comment">    1. 定义一个共享变量number</span></span><br><span class="line"><span class="comment">    2. 对number进行1000次的++操作</span></span><br><span class="line"><span class="comment">    3. 使用5个线程来进行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test02Atomicity&#123;</span><br><span class="line">  <span class="comment">// 1. 定义一个共享变量number</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  priavte Object obj = <span class="keyword">new</span> Object();<span class="comment">//对象锁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)<span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="comment">// 2. 对number进行1000次的++操作</span></span><br><span class="line">    Runnable increment = ()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">          number++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">    <span class="comment">// 3. 使用5个线程来进行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">      t.start();</span><br><span class="line">      list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t : list)&#123;</span><br><span class="line">      t.<span class="keyword">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">"number = "</span> + number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  进行分析；为什么加了synchronized之后就可以保证number++是一个原子操作；</span></span><br><span class="line"><span class="comment">  还是通过javap反汇编的方式来进行查看number++这一块的字节码指令的变化；</span></span><br><span class="line"><span class="comment">  通过命令行（Windows PowerShell、CMD等）打开文件；</span></span><br><span class="line"><span class="comment">  目录（工程名/target/classes/com/xxx/demo02_concurrent_probleam/Test02Atomicity.class）</span></span><br><span class="line"><span class="comment">  通过键入命令javap对字节码文件进行反汇编；查看到字节码指令；</span></span><br><span class="line"><span class="comment">  &gt;PS C:\Users\13666\IdeaProjects\XXX\Synchronized\target\classes\com\xxx\demo02_concurrent_probleam&gt; javap -p -v .\Test02Atomicity.class</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  接着依旧是分析下synchronized保证原子性操作的原理；</span></span><br><span class="line"><span class="comment">  在第三步骤时创建了5个线程分别都来进行执行Runnable当中的run()操作；</span></span><br><span class="line"><span class="comment">  即进行循环1000次number++操作；</span></span><br><span class="line"><span class="comment">  分析的时候就以两个线程为例；线程A与线程B；</span></span><br><span class="line"><span class="comment">  假设第一个线程A先进行执行Runnable当中的1000次number++的循环；</span></span><br><span class="line"><span class="comment">  当线程A进入到synchronized的时候，如果发现对象锁obj没有线程在使用的话，</span></span><br><span class="line"><span class="comment">  那么线程A就会拿着对象锁obj进入同步代码块当中；</span></span><br><span class="line"><span class="comment">  那么进来之后就将执行number++操作；</span></span><br><span class="line"><span class="comment">  而number++操作所对应的字节码指令有4条字节码指令；</span></span><br><span class="line"><span class="comment">  那么首先来进行执行读取静态共享变量number的取值指令，</span></span><br><span class="line"><span class="comment">  即15: getstatic     #18   //Field number:I该指令；</span></span><br><span class="line"><span class="comment">  当前读取得到number的取值为0；那么读取之后就继续拿着对象锁obj往下进行执行；</span></span><br><span class="line"><span class="comment">  执行指令准备一个常量1即指令18: iconst_1</span></span><br><span class="line"><span class="comment">  准备一个常量1完成之后又接着往下继续执行；</span></span><br><span class="line"><span class="comment">  接着进行一个相加的操作即指令19: iadd的操作即指令15: getstatic当中获取得到静态共享变量number的取值0与18: iconst_1所准备的常量1进行相加得出运算结果为0+1=1；</span></span><br><span class="line"><span class="comment">  假设执行完该相加操作之后，即19: iadd操作完成之后CPU又切换到了第二个线程，即线程B；</span></span><br><span class="line"><span class="comment">  注意此时线程是在19: iadd执行之后但是在20: putstatic指令执行之前进行了CPU的切换，</span></span><br><span class="line"><span class="comment">  即共享变量并未被重新赋值之前只是得出了运算结果的时候进行了CPU切换到线程B上去了；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  第二个线程即线程B也是要来进行执行同步代码块synchronized()&#123;&#125;当中的代码；</span></span><br><span class="line"><span class="comment">  但是此时的这个对象锁obj已经被线程A锁获取得到了即线程A此时还并没有进行释放锁unlock的操作；所以导致尽管CPU切换到了线程B上但是由于线程A没有释放锁；</span></span><br><span class="line"><span class="comment">  线程B没有办法获取得到锁，</span></span><br><span class="line"><span class="comment">  就只能在synchronized同步代码块的外侧进行等待；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  那么CPU最终还是会切换到第一个线程即线程A上面来继续完成number++所对应的未完成的字节码指令的第四条指令即20: putstatic   #18   //Field number:I</span></span><br><span class="line"><span class="comment">  执行putstatic那么就会将19: iadd所运算得出的取值结果1赋值给静态共享变量number取值；</span></span><br><span class="line"><span class="comment">  最后线程A执行外字节码指令之后就会出同步代码块，</span></span><br><span class="line"><span class="comment">  就会将对象锁obj给还回去；</span></span><br><span class="line"><span class="comment">  那么此时CPU又切换回第二个线程，线程B当中上来了；</span></span><br><span class="line"><span class="comment">  线程B又来执行同步代码块synchronized()&#123;&#125;；</span></span><br><span class="line"><span class="comment">  这次就能够获取得到对像锁了；</span></span><br><span class="line"><span class="comment">  基于线程A完成了其在synchronized同步代码块当中的number++操作之后释放了锁，</span></span><br><span class="line"><span class="comment">  CPU又切换到了线程B上，</span></span><br><span class="line"><span class="comment">  所以此时线程B可以拿到获取得到对象锁obj；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  那么此时线程B也拿着对象锁obj进入同步代码块synchronized当中执行number++操作即所对应的4个字节码指令(getstatic、iconst_1、iadd、putstatic)；</span></span><br><span class="line"><span class="comment">  那么线程B先来进行执行number++操作的第一条字节码指令：15: getstatic    #18     // Field number:I 操作获取得到此时共享变量number的取值，</span></span><br><span class="line"><span class="comment">  那么此时线程B来获取共享变量number的取值时，</span></span><br><span class="line"><span class="comment">  共享变量number变量在之前的线程A当中的操作当中已经由0变为了1，</span></span><br><span class="line"><span class="comment">  所以此时线程B获取得到number共享变量的取值为1；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  接着执行number++操作的第二个字节码指令准备一个常量1即18: iconst_1操作；</span></span><br><span class="line"><span class="comment">  在往下继续执行number操作的第三个字节码指令19: iadd，即获取得到静态共享变量取值number为1 与 所准备的常量1进行相加得到运算结果 1+1=2；</span></span><br><span class="line"><span class="comment">  那么最后走到第四步进行执行20:putstatic   # 18   // Field number:I操作</span></span><br><span class="line"><span class="comment">  那么就会把从第三步字节码指令所运算得出的结果 2 赋值给共享变量number取值；</span></span><br><span class="line"><span class="comment">  那么此时静态共享变量的取值就由1更改为2了；</span></span><br><span class="line"><span class="comment">  这个时候可以看到两个线程进行执行number++操作；</span></span><br><span class="line"><span class="comment">  最终得到的number的结果为2；</span></span><br><span class="line"><span class="comment">  数据没有出现错乱；</span></span><br><span class="line"><span class="comment">  那么这里最根本的原因就是有了同步代码块之后；</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  当第一个线程进来执行number++所对应的其四个字节码操作指令；</span></span><br><span class="line"><span class="comment">  执行到一半，就算CPU切换到了第二个线程进行执行相同的操作也会由于没有对象锁而无法进入同步代码块只能够在同步代码块外侧进行等待第一个线程释放锁第二个线程才能够获取锁从而进入同步代码块；</span></span><br><span class="line"><span class="comment">  所以也就能够保证第一个线程在执行number++所对应的四个字节码指令时，</span></span><br><span class="line"><span class="comment">  不会受到其他线程的干扰，</span></span><br><span class="line"><span class="comment">  从而也就保证了操作的原子性。</span></span><br><span class="line"><span class="comment">  所以数据才不会出现错乱。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>字节码指令：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">      frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">27</span></span><br><span class="line">    Exceptions:</span><br><span class="line">      thows java.lang.InterruptedException</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> static <span class="built_in">void</span> lambda$main$<span class="number">0</span>();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">          <span class="number">0</span>: iconst_0</span><br><span class="line">          <span class="number">1</span>: istore_0</span><br><span class="line">          <span class="number">2</span>: iload_0</span><br><span class="line">          <span class="number">3</span>: sipush          <span class="number">1000</span></span><br><span class="line">          <span class="number">6</span>: if_icmpge       <span class="number">39</span></span><br><span class="line">          <span class="number">9</span>: getstatic       #<span class="number">22</span>             <span class="comment">// Field obj:Ljava/lang/Object;</span></span><br><span class="line">         <span class="number">12</span>: dup</span><br><span class="line">         <span class="number">13</span>: astore_1</span><br><span class="line">         <span class="number">14</span>: monitorenter</span><br><span class="line">         <span class="number">15</span>: getstatic       #<span class="number">18</span>             <span class="comment">// Field number:I</span></span><br><span class="line">         <span class="number">18</span>: iconst_1</span><br><span class="line">         <span class="number">20</span>: putstatic       #<span class="number">18</span>             <span class="comment">// Field number:I</span></span><br><span class="line">         <span class="number">23</span>: aload_1</span><br><span class="line">         <span class="number">24</span>: monitorexit</span><br><span class="line">         <span class="number">25</span>: goto            <span class="number">33</span></span><br><span class="line">         <span class="number">28</span>: astore_2</span><br><span class="line">         <span class="number">29</span>: aload_1</span><br><span class="line">         <span class="number">30</span>: monitorexit</span><br><span class="line">         <span class="number">31</span>: aload_2</span><br><span class="line">         <span class="number">32</span>: athrow</span><br><span class="line">         <span class="number">33</span>: iinc            <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">         <span class="number">36</span>: goto</span><br><span class="line">         <span class="number">39</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">          <span class="keyword">from</span>     to     target   type</span><br><span class="line">            <span class="number">15</span>     <span class="number">25</span>         <span class="number">28</span>     any</span><br><span class="line">            <span class="number">28</span>     <span class="number">31</span>         <span class="number">28</span>     any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">19</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">15</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">23</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">33</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>number++操作依旧对应着这四条字节码指令</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>: getstatic         #<span class="number">18</span>       <span class="comment">// Field number:I</span></span><br><span class="line"><span class="number">18</span>: iconst_1</span><br><span class="line"><span class="number">19</span>: iadd</span><br><span class="line"><span class="number">20</span>: putstatic         #<span class="number">18</span>       <span class="comment">// Field number:I</span></span><br></pre></td></tr></table></figure>

<p>而此时包含着这四条字节码指令的还有<code>monitorenter</code>以及<code>monitorexit</code>这两条指令；即；</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>: monitorenter</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>: getstatic        #<span class="number">18</span>        <span class="comment">// Field number:I</span></span><br><span class="line"><span class="number">18</span>: iconst_1</span><br><span class="line"><span class="number">19</span>: iadd</span><br><span class="line"><span class="number">20</span>: putstatic        #<span class="number">18</span>        <span class="comment">// Field number:I</span></span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">23</span>: aload_1</span><br><span class="line"><span class="number">24</span>: monitorexit</span><br></pre></td></tr></table></figure>

<h3 id="synchronized-保证原子性的原理"><a href="#synchronized-保证原子性的原理" class="headerlink" title="synchronized 保证原子性的原理"></a>synchronized 保证原子性的原理</h3><p>对 number++ ，增加同步代码块后，保证同一时间 只有 一个线程操作 number++; 就不会出现安全问题。</p>
<h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>synchronized保证原子性的原理: synchronized保证只有一个线程拿到锁，能够进入同步代码块中，当第一个线程进入了同步代码块当中即使操作到了一半没有操作完由于CPU切换，切换到了其他线程，其他线程也会由于没有对象锁的缘故无法进入同步代码块当中只能进行等待；即其他线程不会来干扰第一个线程的操作；就能够保证同步代码块当中的代码是一个原子性的操作，不会受到其他线程的干扰；</p>
<p>synchronized 保证原子性的原理</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对 <span class="built_in">number</span>++; 增加同步代码块后，保证同一时间只有一个线程操作 <span class="built_in">number</span>++;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized保证可见性"><a href="#synchronized保证可见性" class="headerlink" title="synchronized保证可见性"></a>synchronized保证可见性</h2><h3 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h3><p>学习使用 synchronized 保证可见性的原理</p>
<h3 id="使用synchronized保证可见性"><a href="#使用synchronized保证可见性" class="headerlink" title="使用synchronized保证可见性"></a>使用synchronized保证可见性</h3><p>案例演示： 一个线程根据 boolean类型的标记flag，while循环，另一个线程改变这个flag变量的值，根据boolean 类型的标记flag进行while循环的那个线程 并不会停止循环。</p>
<p>回顾之前的代码（<strong>可见性问题产生的原因</strong>）：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">    1. 创建一个共享变量</span></span><br><span class="line"><span class="comment">    2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">    3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test01Visibility&#123;</span><br><span class="line">  <span class="comment">// 1. 创建一个共享变量；</span></span><br><span class="line">  <span class="comment">// boolea布尔类型flag默认取值为true</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="comment">// 2. 创建一条线程不断读取共享变量；</span></span><br><span class="line">    <span class="comment">// 开启一条线程进行循环；</span></span><br><span class="line">    <span class="comment">// 如果flag变量一直为true则一直循环否则停止循环；</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">while</span>(flag)&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  </span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);<span class="comment">// 主线程沉睡两秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建一条线程修改共享变量flag取值为false</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      flag = <span class="keyword">false</span>;</span><br><span class="line">      System.out.<span class="keyword">println</span>(<span class="string">"线程修改了变量的值为false"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      之前的效果为；两秒之后进行打印了语句“线程修改了变量的值为false”；</span></span><br><span class="line"><span class="comment">      但是另外一个线程并没有获取得到最新值，</span></span><br><span class="line"><span class="comment">      也就是根据flag变量进行while循环的那个线程并没有获取得到最新flag取值从而也就导致这个线程一直在while(flag)/while(true)运行中；</span></span><br><span class="line"><span class="comment">      Run一直为红灯。</span></span><br><span class="line"><span class="comment">      接着来进行分析其原因以及如何来进行解决。</span></span><br><span class="line"><span class="comment">      为什么会出现可见性问题分析：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      首先Test01Visibility当中存在有一个成员变量flag取值为true；</span></span><br><span class="line"><span class="comment">      那么该成员变量是两个线程都会来进行操作的；</span></span><br><span class="line"><span class="comment">      线程A与线程B；</span></span><br><span class="line"><span class="comment">      线程A负责执行根据flag取值变化从而while循环的线程；</span></span><br><span class="line"><span class="comment">      线程B则是负责修改成员变量flag取值的线程；</span></span><br><span class="line"><span class="comment">      那么该成员变量位于主内存当中；即线程A与线程B的共享变量；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      红色的箭头代表主线程，主线程从main()开始执行；</span></span><br><span class="line"><span class="comment">      执行Test01Visibility当中mian()中的代码，创建线程A并启动线程A中的run();</span></span><br><span class="line"><span class="comment">      接着画一个新线程，该新线程用绿色箭头表示，表示的即为线程A，</span></span><br><span class="line"><span class="comment">      那么该A线程就会去进行执行while(flag)&#123;&#125;循环；</span></span><br><span class="line"><span class="comment">      当线程A进行执行的时候就需要用到共享变量flag的取值；</span></span><br><span class="line"><span class="comment">      而该共享变量位于主内存当中；</span></span><br><span class="line"><span class="comment">      那么这个时候线程A就会从主内存当中进行复制一份共享变量flag的取值boolean flag=true的副本放到线程A自己的工作内存当中来；</span></span><br><span class="line"><span class="comment">      那么当前进行循环这个flag为true那么也就会导致一直在进行循环的操作；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      主线程继续往下进行执行，Thread.sleep(2000);主线程沉睡两秒钟；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      那么当主线程沉睡完两秒之后，又会进行启动一个新的线程即线程B，也就是那个修改共享变量flag取值的那个线程；</span></span><br><span class="line"><span class="comment">      再画一个紫色的箭头来代表一个新的线程即线程B；</span></span><br><span class="line"><span class="comment">      那么线程B则对应着图中的右边的那块工作内存；</span></span><br><span class="line"><span class="comment">      那么线程B启动之后也是需要来进行执行线程B当中的run()当中的代码即修改共享变量flag的取值为false并打印输出日志；</span></span><br><span class="line"><span class="comment">      所以此时线程B需要做的是也是从主内存当中去进行读取复制拷贝获取得到一份共享变量flag的副本即boolean flag = true;到线程B自己的工作内存当中来；</span></span><br><span class="line"><span class="comment">      另外在线程B自己的工作内存当中对其共享变量副本进行相关操作即进行重新赋值为false；</span></span><br><span class="line"><span class="comment">      那么当线程B修改工作内存当中共享变量flag副本取值之后会将工作内存当中该共享变量副本的取值同步回主内存当中的共享变量取值；</span></span><br><span class="line"><span class="comment">      也就是主内存当中该共享变量flag取值就由true变为了false；</span></span><br><span class="line"><span class="comment">      那么接着线程B再去打印“线程修改了变量的值为false”信息；</span></span><br><span class="line"><span class="comment">      那么该线程B执行至此就结束了。</span></span><br><span class="line"><span class="comment">      那么可以看到的是线程B所进行修改线程B自己工作内存当中的共享变量副本flag的取值为false并且同步回到了主内存当中去了；</span></span><br><span class="line"><span class="comment">      那么此时的线程A并不知道主内存当中共享变量flag的取值被更改了，线程A依然在进行循环操作；</span></span><br><span class="line"><span class="comment">      即while(true)的循环操作；</span></span><br><span class="line"><span class="comment">      线程A使用到的共享变量依然还是线程A自己工作内存当中之前从主内存中复制拷贝过来的flag共享变量也就是那个flag=true那个时候的取值；</span></span><br><span class="line"><span class="comment">      所以线程A就一直循环一直循环根本停不下来；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      那么造成这种现象的原因就是因为：</span></span><br><span class="line"><span class="comment">      一个线程进行修改了共享变量副本的取值并且同步回了主内存当中；</span></span><br><span class="line"><span class="comment">      第二个线程即根据该共享变量副本的取值做while循环的线程并没有感知到主内存当中共享变量取值发生的变化，</span></span><br><span class="line"><span class="comment">      因为第二个线程当中使用的共享变量副本的取值并没有随着一同主内存当中的共享变量取值改变；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      那么解决方案有两种；先简单介绍下；有一个关键字叫做volatile；</span></span><br><span class="line"><span class="comment">      用该关键字volatile来进行修饰共享变量就可以解决可见性问题；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<strong>volatile</strong>关键字来进行解决可见性问题</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">    1. 创建一个共享变量</span></span><br><span class="line"><span class="comment">    2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">    3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Visibility</span>&#123;</span></span><br><span class="line">  <span class="comment">// 1. 创建一个共享变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span>throws InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">// 2. 创建一条线程不断读取共享变量</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">while</span>(flag)&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);<span class="comment">//主线程沉睡两秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      flag =  <span class="literal">false</span>;</span><br><span class="line">      System.out.<span class="built_in">println</span>(<span class="string">"线程修改了变量的值为false"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    那么此时就需要进行分析 volatile关键字是如何进行解决可见性问题的?</span></span><br><span class="line"><span class="comment">    简单介绍下；</span></span><br><span class="line"><span class="comment">    当共享变量flag添加了 volatile关键字之后，线程B进行修改了共享变量flag副本取值为false之后同步回主内存时；由于volatile关键字的修饰，会有一个缓存一致性协议；会把其他线程当中的工作内存中的该共享变量flag的副本全部进行设置为失效状态；那么这个时候其他线程由于线程自己内部工作内存中需要用到的共享变量flag数据失效的缘故就会重新到主内存当中来进行读取最新的共享变量取值；这是采用volatile的规则；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    那么现在不使用volatile，使用synchronized也可以解决这个可见性问题；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <strong>synchronized</strong> 关键字来进行解决可见性问题</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo02_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    案例演示：</span></span><br><span class="line"><span class="comment">      一个线程根据 boolean 类型的标记flag，while循环，另一个线程改变这个flag变量的值，</span></span><br><span class="line"><span class="comment">      根据boolean 类型的标记flag进行while循环的那个线程 并不会停止循环。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Visibility</span> &#123;</span></span><br><span class="line">    <span class="comment">// 多个线程都会访问的数据，我们称为 线程的共享变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="built_in">run</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException</span>&#123;</span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">run</span>)&#123;</span><br><span class="line">          <span class="comment">//增加对象共享数据的打印，println是同步方法</span></span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="string">"run = "</span> + <span class="built_in">run</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      t1.start();</span><br><span class="line"></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">      Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="built_in">run</span> = <span class="literal">false</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"时间到，线程2设置为 false"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  案例演示：</span></span><br><span class="line"><span class="comment">    1. 创建一个共享变量</span></span><br><span class="line"><span class="comment">    2. 创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment">    3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test01Visibility</span>&#123;</span></span><br><span class="line">  <span class="regexp">// 1. 创建一个共享变量</span></span><br><span class="line"><span class="regexp">  private static boolean flag = true;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  private static Object obj =  new Object();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  public static void main(String[] args) throws InterruptedException&#123;</span></span><br><span class="line"><span class="regexp">    //</span> <span class="number">2.</span> 创建一条线程不断读取共享变量</span><br><span class="line">    <span class="keyword">new</span> Tread<span class="function"><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">while</span>(flag)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        synchronized(obj)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">2000</span>)</span>;// 主线程沉睡两秒</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 3. 创建一条线程修改共享变量</span></span><br><span class="line"><span class="function">    <span class="title">new</span> <span class="title">Thread</span><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      flag = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">      System.out.println(<span class="string">"线程修改了变量的值为false"</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span>;</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  /**</span></span><br><span class="line"><span class="function">  分析<span class="title">synchronized</span>是如何进行解决的可见性问题？</span></span><br><span class="line"><span class="function">  那么<span class="title">synchronized</span>关键字其实会变成8个原子操作当中的<span class="title">lock</span>与<span class="title">unlock</span>原子操作；</span></span><br><span class="line"><span class="function">  即8个原子操作<span class="params">(主内存与工作内存之间具体的交互协议)</span>为</span></span><br><span class="line"><span class="function">  <span class="title">lock</span> --→<span class="title">read</span> --→ <span class="title">load</span>--→ <span class="title">use</span>--→ <span class="title">assign</span>--→ <span class="title">store</span>--→ <span class="title">write</span>--→ <span class="title">unlock</span>  </span></span><br><span class="line"><span class="function">  那么这个<span class="title">lock</span>原子操作之前就会让线程<span class="title">A</span>当中的工作内存进行去刷新，</span></span><br><span class="line"><span class="function">  也就是如果线程<span class="title">A</span>中存在有该共享变量的副本会被清除，</span></span><br><span class="line"><span class="function">  然后再去获取最新的共享变量<span class="title">flag</span>取值；</span></span><br><span class="line"><span class="function">  也就可以得到最新的<span class="title">false</span>取值；</span></span><br><span class="line"><span class="function">  由线程<span class="title">B</span>进行修改共享变量副本并同步回主内存后的那个最新值；</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  所以这个时候的效果就是线程<span class="title">A</span>当中由于接收到了主内存当中共享变量最新取值的副本<span class="title">flag</span>=<span class="title">false</span>;所以就会不再执行<span class="title">while</span>循环；</span></span><br><span class="line"><span class="function">  另外可以不用进行写 <span class="title">synchronized</span><span class="params">(obj)</span>&#123;&#125; ；</span></span><br><span class="line"><span class="function">  可以直接进行打印也是可以做到解决可见性问题的 <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(flag)</span>;</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  而分析下为什么通过打印语句<span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(flag)</span>;也可以使得<span class="title">while</span>循环停下来呢？</span></span><br><span class="line"><span class="function">  原因在于<span class="title">PrintStream</span>.<span class="title">java</span>中的<span class="title">println</span><span class="params">(boolean x)</span>方法中也使用到了<span class="title">synchronized</span>，</span></span><br><span class="line"><span class="function">  所以也就导致也会去刷新线程<span class="title">A</span>当中工作内存当中的变量从而去获取主内存当中最新的共享变量的取值：</span></span><br><span class="line"><span class="function">  -------------------------------------------------------------------</span></span><br><span class="line"><span class="function">  /**</span></span><br><span class="line"><span class="function">    <span class="title">Prints</span> <span class="title">a</span> <span class="title">boolean</span> <span class="title">and</span> <span class="title">then</span> <span class="title">terminate</span> <span class="title">the</span> <span class="title">line</span>.</span></span><br><span class="line"><span class="function">    <span class="title">This</span> <span class="title">method</span> <span class="title">behaves</span> <span class="title">as</span> <span class="title">though</span> <span class="title">it</span> <span class="title">invokes</span></span></span><br><span class="line"><span class="function">    &lt;<span class="title">code</span>&gt;&#123;@<span class="title">link</span> #<span class="title">print</span><span class="params">(boolean)</span>&#125;&lt;/<span class="title">code</span>&gt; <span class="title">and</span> <span class="title">then</span></span></span><br><span class="line"><span class="function">    &lt;<span class="title">code</span>&gt;&#123;@<span class="title">link</span> #<span class="title">println</span><span class="params">()</span>&#125;&lt;/<span class="title">code</span>&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    @<span class="title">param</span> <span class="title">x</span> <span class="title">The</span> &lt;<span class="title">code</span>&gt;<span class="title">boolean</span>&lt;/<span class="title">code</span>&gt; <span class="title">to</span> <span class="title">be</span> <span class="title">printed</span></span></span><br><span class="line"><span class="function">  */</span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">void</span> <span class="title">println</span><span class="params">(boolean x)</span>&#123;</span></span><br><span class="line"><span class="function">    <span class="title">synchronized</span><span class="params">(<span class="keyword">this</span>)</span>&#123;</span></span><br><span class="line"><span class="function">      <span class="title">print</span><span class="params">(x)</span>;</span></span><br><span class="line"><span class="function">      <span class="title">newLine</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  -------------------------------------------------------------------</span></span><br><span class="line"><span class="function">  */</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="synchronized-保证可见性的原理"><a href="#synchronized-保证可见性的原理" class="headerlink" title="synchronized 保证可见性的原理"></a>synchronized 保证可见性的原理</h3><p>synchronized同步的时候会对应8个原子操作当中的lock与unlock这两个原子操作；<br>那么lock操作执行时回去刷新该线程工作内存当中共享变量的取值；<br>从而该线程就会去主内存中去获取得到最新的值；<br>也就是说synchronized会刷新工作内存中的变量得到主内存中最新共享变量取值的副本；<br>从而保证可见性；</p>
<h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p>synchronized保证可见性的原理</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行<span class="keyword">synchronized</span>时，其对应的lock原子操作会刷新工作内存中共享变量的值</span><br></pre></td></tr></table></figure>

<h2 id="synchronized保证有序性"><a href="#synchronized保证有序性" class="headerlink" title="synchronized保证有序性"></a>synchronized保证有序性</h2><p>synchronized 与 有序性</p>
<h3 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h3><p>学习使用 synchronized 保证有序性的原理</p>
<h3 id="为什么要重排序"><a href="#为什么要重排序" class="headerlink" title="为什么要重排序"></a>为什么要重排序</h3><p>为了提高程序的执行效率，有可能所写的代码对CPU来说其执行效率并不高；<br>它可能经过重排序之后执行的效率更高一点；所以编译器和CPU会对程序中的代码进行重排序；（编译器和CPU不会进行乱排，会满足某种规则；所以就有一个<strong>as-if-serial语义</strong>）</p>
<p>重排序 是指 编译器 和 处理器 为了优化程序性能 而对 指令序列 进行 重新排序 的一种手段。  </p>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>as-if-serial 语义的意思是：</p>
<p>（不管编译器和CPU如何重排序。必须保证在单线程情况下程序的结果是正确的；那么在多线程的情况下就有可能是有问题存在问题的）<br>不管怎么 重排序（编译器和处理器 为了提高 并行度），单线程程序的执行结果不能被改变。<br>编译器、runtime和处理器 都必须遵守 as-if-serial 语义。</p>
<p>以下数据有依赖关系，不能 重排序。</p>
<p>写后读：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int <span class="keyword">a</span> = <span class="number">1</span>; <span class="comment"># 对一个变量进行写操作</span></span><br><span class="line">int b = <span class="keyword">a</span>; <span class="comment"># 在对一个变量写操作完成之后又将该变量的取值读取出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么在这种情况下是不能够进行重排序的；</span></span><br><span class="line"><span class="comment"># 即不能够换成</span></span><br><span class="line"><span class="comment"># int b = a;</span></span><br><span class="line"><span class="comment"># int a = 1;</span></span><br><span class="line"><span class="comment"># 那么在执行 int b = a;的时候，a是没有取值的；</span></span><br></pre></td></tr></table></figure>

<p>写后写：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; # 先给变量a进行赋值操作即写操作；</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>; # 再来给变量a进行赋值操作即写操作；</span><br><span class="line"></span><br><span class="line"><span class="meta"># 那么在这种情况下也是不能够进行重排序的；</span></span><br><span class="line"><span class="meta"># 即不能够换成</span></span><br><span class="line"><span class="meta"># int a = 2;</span></span><br><span class="line"><span class="meta"># int a = 1;</span></span><br><span class="line"><span class="meta"># 的这样一种情况，</span></span><br><span class="line"><span class="meta"># 因为在执行原来没有重排序的代码时最终获取得到a变量的结果为2；</span></span><br><span class="line"><span class="meta"># 而经过重排序之后a变量的取值被重新赋值为了1；</span></span><br><span class="line"><span class="meta"># 导致数据最终结果的不正确性；</span></span><br><span class="line"><span class="meta"># 所以在这种情况下也是不能够进行重排序；</span></span><br></pre></td></tr></table></figure>

<p>读后写：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; # 给变量a进行赋值写操作</span><br><span class="line"><span class="keyword">int</span> b = a; # 将变量a的取值进行读取出来</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>; # 再将变量a的取值进行重新赋值</span><br><span class="line"></span><br><span class="line"><span class="meta"># 这种情况下也是不能够进行重排序的；</span></span><br><span class="line"><span class="meta"># 即不能够换成</span></span><br><span class="line"><span class="meta"># int a = 1;</span></span><br><span class="line"><span class="meta"># int a = 2;</span></span><br><span class="line"><span class="meta"># int b = a;</span></span><br><span class="line"><span class="meta"># 这样一种顺序；</span></span><br><span class="line"><span class="meta"># 如果是这样排序的话；将会导致变量b取值的变化；</span></span><br><span class="line"><span class="meta"># 在原来没有进行重排序的时候变量b原本正确赋有的值应该是1；</span></span><br><span class="line"><span class="meta"># 而当重新排序之后变量b的取值发生了改变，即变成了2；</span></span><br><span class="line"><span class="meta"># 同样是导致了数据的最终不正确性；</span></span><br><span class="line"><span class="meta"># 所以在这种情况下也是不能够进行重排序的；</span></span><br></pre></td></tr></table></figure>

<p>编译器 和 处理器不会对 存在数据依赖关系的 操作 做重排序，<br>因为这种 重排序 会改变执行结果。</p>
<p>但是，如果操作之间 不存在数据依赖关系，这些操作就可能被 编译器和处理器 重排序。</p>
<p>（在有些时候是可以进行重排序的；只要没有影响到单线程执行运行结果的正确性；比如说下面这种情况就是可以进行重排序的；即int a =1;int b=2;这两句代码是可以进行互换位置的；彼此互不影响；即int b = 2; int a=1;但是int c =a +b;一定要处于最下面；否则不能得到变量a与变量b的取值；）</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int a</span> = 1;</span><br><span class="line"><span class="attribute">int b</span> = 2;</span><br><span class="line"><span class="attribute">int c</span> = a + b;</span><br></pre></td></tr></table></figure>

<p>上面3个操作的数据依赖关系如图所示：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line">                                  ---------</span><br><span class="line">-------                            |<span class="string">     </span>|</span><br><span class="line">|<span class="string">  a  </span>|<span class="string">---------------------------→</span>|<span class="string">     </span>|</span><br><span class="line">-------                            |<span class="string">     </span>|</span><br><span class="line">                                   |<span class="string">  c  </span>|</span><br><span class="line">-------                            |<span class="string">     </span>|</span><br><span class="line">|<span class="string">  b  </span>|<span class="string">---------------------------→</span>|<span class="string">     </span>|</span><br><span class="line">-------                            |<span class="string">     </span>|</span><br><span class="line">                                  ---------</span><br><span class="line">-------------------------------------------</span><br><span class="line">/<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">即 变量c 依赖 变量a与变量b 的取值；</span><br><span class="line">但是 变量a 与 变量b 并没有直接的依赖关系；</span><br><span class="line">所以这种情况下是可以进行重排序的；</span><br><span class="line"><span class="symbol">*</span>/</span><br></pre></td></tr></table></figure>

<p>如上图所示 a和c 之间存在数据依赖关系，<br>同时 b和c 之间也存在数据依赖关系。<br>因此在最终执行的指令序列中，<br>c 不能被重排序到 a和b 的前面。<br>但 a和b 之间没有数据依赖关系，<br>编译器和处理器 可以重排序 a和b 之间的执行顺序。<br>下图是该程序的两种执行顺序。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="comment">|</span>  <span class="comment">a</span>  <span class="comment">|</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">→|</span>  <span class="comment">b</span>  <span class="comment">|</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">→|</span>  <span class="comment">c</span>  <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="comment">|</span>  <span class="comment">b</span>  <span class="comment">|</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">→|</span>  <span class="comment">a</span>  <span class="comment">|</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">→|</span>  <span class="comment">c</span>  <span class="comment">|</span></span><br><span class="line"><span class="comment"></span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>         --<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">可以这样：</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">a</span> <span class="comment">=</span> <span class="comment">1;</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">b</span> <span class="comment">=</span> <span class="comment">2;</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">c</span> <span class="comment">=</span> <span class="comment">a</span> <span class="literal">+</span> <span class="comment">b;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">也可可以重排序这样：</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">b</span> <span class="comment">=</span> <span class="comment">2;</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">a</span> <span class="comment">=</span> <span class="comment">1;</span></span><br><span class="line"><span class="comment">int</span> <span class="comment">c</span> <span class="comment">=</span> <span class="comment">a</span> <span class="literal">+</span> <span class="comment">b;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用synchronized保证有序性"><a href="#使用synchronized保证有序性" class="headerlink" title="使用synchronized保证有序性"></a>使用synchronized保证有序性</h3><p>Test03Ordering.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.results.I_Result;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"1"</span>, <span class="string">"4"</span>&#125;, expect = Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>)</span><br><span class="line"><span class="meta">@OUtcome</span>(id = <span class="string">"0"</span>, expect =  Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger"</span>)</span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 线程一 执行的代码</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">      r.r1 = num + num;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程二 执行的代码</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾代码分析有序性问题产生的原因</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome</span>( id = &#123;<span class="string">"1"</span>, <span class="string">"4"</span>&#125;, expect =  Expect.ACCEPTABLE, desc=<span class="string">"ok"</span>)</span><br><span class="line"><span class="meta">@Outcome</span>( id = <span class="string">"0"</span>, expect =  Expect.ACCEPTABLE_INTERESTING, desc=<span class="string">"danger"</span>)</span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程一 执行的代码</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">      r.r1 = num + num;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//线程二 执行的代码</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  以前会观察得到4种可能性；3种结果为0,1,4</span></span><br><span class="line"><span class="comment">  分析回顾下：</span></span><br><span class="line"><span class="comment">  假设有两个线程在执行；分别是线程A与线程B；</span></span><br><span class="line"><span class="comment">  线程A执行actor1(I_Result r)；线程B执行actor2(I_Result r)；</span></span><br><span class="line"><span class="comment">  当初出现0的结果是这样来的：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  是actor2(I_Result r)当中的代码</span></span><br><span class="line"><span class="comment">  num = 2;</span></span><br><span class="line"><span class="comment">  ready = true;</span></span><br><span class="line"><span class="comment">  经过了重排序变成了</span></span><br><span class="line"><span class="comment">  ready = true;</span></span><br><span class="line"><span class="comment">  num = 2;</span></span><br><span class="line"><span class="comment">  的一个顺序；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  假设下面的这个线程，也就是执行actor2(I_Result r)的线程B先走；</span></span><br><span class="line"><span class="comment">  那么走了第一句也就是执行了第一句ready=true该句话；</span></span><br><span class="line"><span class="comment">  但是注意并没有执行num=2;</span></span><br><span class="line"><span class="comment">  所以此时共享变量当中的num仍然为0；而ready为true;</span></span><br><span class="line"><span class="comment">  然后此时CPU切换线程到了第二个线程当中来了；</span></span><br><span class="line"><span class="comment">  那么这个时候线程A进行执行actor1(I_Result r)方法；</span></span><br><span class="line"><span class="comment">  那么这个时候线程A就会进入到判断if(ready)&#123;&#125;代码块中；</span></span><br><span class="line"><span class="comment">  因为此时获取得到的ready变量已经由线程B在actor2(I_Result r)中进行了修改取值；</span></span><br><span class="line"><span class="comment">  所以也就会得到 r.r1 = num + num;</span></span><br><span class="line"><span class="comment">  而此时的num并未被重新赋值也就是说此时的num依旧是取值为0；</span></span><br><span class="line"><span class="comment">  所以得到结果记录 r.r1 为0；</span></span><br><span class="line"><span class="comment">  那么这是之前出现的有序性问题分析；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  那么现在来进行添加synchronized来解决有序性问题；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>synchronized关键字解决有序性问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"1"</span> , <span class="string">"4"</span>&#125;, expect = Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>)</span><br><span class="line"><span class="meta">@Outcome</span>(id = <span class="string">"0"</span>, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger"</span>)</span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 先搞一个对象作为对象锁</span></span><br><span class="line">  <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> ready = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程一 执行的代码</span></span><br><span class="line">  <span class="comment">// 测试方法actor1(I_Result r)进行添加synchronized</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">       <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">         r.r1 = num + num;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         r.r1 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程二 执行的代码</span></span><br><span class="line">  <span class="comment">// 下面的测试方法actor2(I_Result r)同样进行添加synchronized</span></span><br><span class="line">  <span class="meta">@Actor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">     num = <span class="number">2</span>;</span><br><span class="line">     ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>压力测试指令以及结果查看</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">Terminal执行指令(进行多轮压力测试)：</span><br><span class="line"></span><br><span class="line">C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; mvn clean install</span><br><span class="line">C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; java -jar target/jcstress.jar</span><br><span class="line"></span><br><span class="line">测试结果打印：</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">    [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">(ETA:  <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>) (Rate: <span class="number">4.15E+07</span> samples/sec) (Tests: <span class="number">1</span> of <span class="number">1</span>) (Forks: <span class="number">4</span> of <span class="number">4</span>) (Iterations: <span class="number">15</span> of <span class="number">24</span>; <span class="number">15</span> passed, <span class="number">0</span> failed, <span class="number">0</span> soft errs, <span class="number">0</span> hard....)</span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">(ETA:  <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>) (Rate: <span class="number">3.97E+07</span> samples/sec) (Tests: <span class="number">1</span> of <span class="number">1</span>) (Forks: <span class="number">4</span> of <span class="number">4</span>) (Iterations: <span class="number">15</span> of <span class="number">24</span>; <span class="number">15</span> passed, <span class="number">0</span> failed, <span class="number">0</span> soft errs, <span class="number">0</span> hard....)</span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">(ETA:  <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>) (Rate: <span class="number">3.53E+07</span> samples/sec) (Tests: <span class="number">1</span> of <span class="number">1</span>) (Forks: <span class="number">4</span> of <span class="number">4</span>) (Iterations: <span class="number">15</span> of <span class="number">24</span>; <span class="number">15</span> passed, <span class="number">0</span> failed, <span class="number">0</span> soft errs, <span class="number">0</span> hard....)</span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">(ETA:  <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>) (Rate: <span class="number">3.83E+07</span> samples/sec) (Tests: <span class="number">1</span> of <span class="number">1</span>) (Forks: <span class="number">4</span> of <span class="number">4</span>) (Iterations: <span class="number">15</span> of <span class="number">24</span>; <span class="number">15</span> passed, <span class="number">0</span> failed, <span class="number">0</span> soft errs, <span class="number">0</span> hard....)</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">结果分析：</span><br><span class="line">  发现并没有出现那几种结果出现的次数；</span><br><span class="line">  说明这个代码就没有问题；即没有出现这种<span class="number">0</span>的情况；</span><br><span class="line">  如果真的想看的话；可以这么做；</span><br><span class="line">  假设将取值为<span class="number">4</span>也变为感兴趣的则重新来进行压力测试</span><br><span class="line"></span><br><span class="line">@JCStressTest</span><br><span class="line">@Outcome(id = <span class="string">"1"</span>, expect = Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>)</span><br><span class="line">@Outcome(id = <span class="string">"4"</span>, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger2"</span>)</span><br><span class="line">@Outcome(id = <span class="string">"0"</span>, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"danger"</span>)</span><br><span class="line">@State</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">Terminal执行指令(进行多轮压力测试)：</span><br><span class="line"></span><br><span class="line">C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; mvn clean install</span><br><span class="line">C:\Users\<span class="number">13666</span>\IdeaProjects\XXX\Synchronized&gt; java -jar target/jcstress.jar</span><br><span class="line"></span><br><span class="line">测试结果打印：</span><br><span class="line">      [OK] com.xxx.demo02_concurrent_problem.Test03Ordering</span><br><span class="line">    (JVM args: [-XX:TieredStopAtLevel=<span class="number">1</span>])</span><br><span class="line">Observed state Occurrences         Expectation     Interpretation</span><br><span class="line">             <span class="number">0</span>       <span class="number">0</span>      ACCEPTABLE_INTERESTING  danger</span><br><span class="line">             <span class="number">1</span>   <span class="number">5</span>,<span class="number">427</span>,<span class="number">079</span>          ACCEPTABLE      ok</span><br><span class="line">             <span class="number">4</span>   <span class="number">5</span>,<span class="number">672</span>,<span class="number">602</span>  ACCEPTABLE_INTERESTING  danger2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [OK] com.xxx.demo02_concurrent_probleam.Test03Ordering</span><br><span class="line">  （JVM args: []）</span><br><span class="line">Observed state Occurrences         Expectation     Interpretation</span><br><span class="line">             <span class="number">0</span>       <span class="number">0</span>      ACCEPTABLE_INTERESTING  danger</span><br><span class="line">             <span class="number">1</span>  <span class="number">42</span>,<span class="number">176</span>,<span class="number">771</span>          ACCEPTABLE      ok</span><br><span class="line">             <span class="number">4</span>  <span class="number">26</span>,<span class="number">991</span>,<span class="number">710</span>  ACCEPTABLE_INTERESTING  danger2</span><br><span class="line">....</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">结果分析：</span><br><span class="line">  此时可以看到的是出现<span class="number">0</span>的此时已经为<span class="number">0</span>了；</span><br><span class="line">  即都不会再出现<span class="number">0</span>了也就表示有序性问题得到了解决；</span><br><span class="line"></span><br><span class="line">分析synchronized是如何进行解决有序性问题的？</span><br><span class="line">当前假设actor2(I_Result r)当中的代码已经出现了重排序，</span><br><span class="line">即</span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line">变为了</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line">这样一个顺序；</span><br><span class="line"></span><br><span class="line">其实会产生很多的线程来执行actor1(I_Result r)与actor2(I_Result r)方法；</span><br><span class="line">那么这个时候举例各有一个线程A、B来分别进行执行actor1(I_Result r)与actor2(I_Result r)；</span><br><span class="line">那么还是一样假设下面的线程先走，即线程B先来执行代码块actor2(I_Result r)当中的同步代码块；</span><br><span class="line">那么线程B就会拿着对象锁Object obj进入actor2(I_Result r)的同步代码块当中执行已经重排序过了的代码即；</span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line">那么拿着对象锁obj的线程B就先会去执行ready=<span class="literal">true</span>该句代码；</span><br><span class="line">那么假设此时CPU又切换到另外一个线程上面去了，</span><br><span class="line">注意是在线程B执行ready=<span class="literal">true</span>;之后但是并没有执行num=<span class="number">2</span>该句代码之前进行了CPU切换；</span><br><span class="line">也就是说当前的共享变量当中num取值仍然为<span class="number">0</span>；但是ready的取值已经变为了<span class="literal">true</span>；</span><br><span class="line">即切换到线程A上去执行actor1(I_Result r)方法当中的同步代码块了；</span><br><span class="line">那么到actor1(I_Result r)当中来看，</span><br><span class="line">线程A如果想要进入同步代码块则首先需要去获取拿到对象锁Object obj；</span><br><span class="line">但是该对象锁Object obj现在仍然在线程B当中，</span><br><span class="line">即线程B获取拿到对象锁obj之后还没有释放锁没有执行完成，</span><br><span class="line">CPU就切换到了线程A上了，</span><br><span class="line">导致线程A没有办法拿到获取对象锁Object obj，</span><br><span class="line">从而只能够在同步代码块外侧进行等待；</span><br><span class="line"></span><br><span class="line">等待CPU又切换到线程B上，让线程B执行完流程后释放锁；</span><br><span class="line">这个时候CPU再切换到线程B上时，没有其它线程竞争的话，</span><br><span class="line">那么这个时候线程B就能够获取得到对象锁从而进入同步代码块当中；</span><br><span class="line"></span><br><span class="line">所以来看，即使actor2(I_Result r)当中的代码发生了重排序，也没有问题了；</span><br><span class="line">接着CPU又切换到线程B上来执行actor2(I_Result r)没有执行完成的内容；</span><br><span class="line">即执行num = <span class="number">2</span>; 那么这个时候此时的共享变量 num被更新赋值为<span class="number">2</span>，以及ready取值为<span class="literal">true</span>；</span><br><span class="line">最后线程B出同步代码块，出了同步代码块之后线程B才会将对象锁Object obj还回去。</span><br><span class="line"></span><br><span class="line">假设线程B当前已经执行完成出了同步代码块也已经释放了锁，</span><br><span class="line">此时CPU再次切换到线程A上，</span><br><span class="line">那么这个时候线程A就可以能够获取得到对象锁Object obj了；</span><br><span class="line">那么得到对象锁之后就可以进入到同步代码块中了；</span><br><span class="line">通过判断ready取值进入<span class="keyword">if</span>/<span class="keyword">else</span>块；</span><br><span class="line">由于共享变量ready以及num在线程B的actor2(I_Result r)中被进行了修改；</span><br><span class="line">当前线程A读取到变量ready取值为<span class="literal">true</span>；num取值为<span class="number">2</span>；</span><br><span class="line">所以此时线程A就将会拿着对象锁Object obj 进入到<span class="keyword">if</span>(ready)块当中去；</span><br><span class="line">I_Result r.r1将会被重新赋值为 <span class="number">2</span>+<span class="number">2</span>=<span class="number">4</span>；</span><br><span class="line">所以此时的一个记录结果为<span class="number">4</span>；</span><br><span class="line">现在可以观察到的是：</span><br><span class="line">尽管加了同步代码块synchronized，</span><br><span class="line">但是actor2(I_Result r)当中依然会发生重排序；</span><br><span class="line">但是发生了重排序也没有问题；</span><br><span class="line">因为actor1(I_Result r)与actor2(I_Result r)都添加了同步代码块synchronized，</span><br><span class="line">保证只有一个线程来进行执行；</span><br><span class="line">就算actor2(I_Result r)中线程B执行到ready=<span class="literal">true</span>之后CPU又切换到线程A上面去了；那么线程A将由于无法获取得到对象锁Object obj也无法进入同步代码块当中去；由于线程B没有执行完成，即没有释放锁；所以线程A只能够进行等待；</span><br><span class="line">那么也就相当于是单线程在执行这些代码；</span><br><span class="line">那么重排序是能够保证单线程的执行效果没有问题；</span><br></pre></td></tr></table></figure>

<h3 id="synchronized-保证有序性的原理"><a href="#synchronized-保证有序性的原理" class="headerlink" title="synchronized 保证有序性的原理"></a>synchronized 保证有序性的原理</h3><p>synchronized后，虽然进行了重排序，保证只有一个线程会进入同步代码块，也能保证有序性。</p>
<h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><p>synchronized保证有序性的原理：加synchronized，依然会发生重排序，只不过，存在有同步代码块，可以保证只有一个线程执行同步代码块当中的代码。<br>也就能保证有序性。</p>
<p>有序性除了可以使用synchronized来进行解决，还能够进行给 共享变量num以及ready变量进行添加volatile关键字来进行解决有序性问题。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  添加了volatile关键字之后，</span></span><br><span class="line"><span class="comment">  可以保证共享变量num以及ready变量不会发生重排序；</span></span><br><span class="line"><span class="comment">  也就不会发生有序性问题了；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03Ordering</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span> Object obj =  <span class="keyword">new</span> Object();<span class="comment">//对象锁</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> <span class="built_in">ready</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程一 执行的代码</span></span><br><span class="line">  @Actor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ready</span>)&#123;</span><br><span class="line">      r.r1 = num + num;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程二 执行的代码</span></span><br><span class="line">  @Actor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">ready</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized的可重入特性"><a href="#synchronized的可重入特性" class="headerlink" title="synchronized的可重入特性"></a>synchronized的可重入特性</h2><p>第四章：synchronized的特性</p>
<blockquote>
<p>synchronized属于同步锁机制，<br>第四章介绍synchronized作为锁的两个特性：<br>1、 可重入性（当一个线程执行到同步代码块，获取了某一个锁之后，还能够再次进入同步代码块当中，获取同样的一把锁，这个是可以的，可以重新再次进入，将分析其原理以及其可重入性的好处）；<br>2、不可中断性（synchronized是不可中断的：当一个线程进入了同步代码块，那么另外一个线程只能够在外面进行等待，这个处于等待的线程会一直处于等待状态，不会中断，所以也就叫做不可中断；<br>另外还会通过ReentrantLock的代码来进行演示ReentrantLock是可以进行中断的）</p>
</blockquote>
<p>可重入特性</p>
<p>synchronized作为锁，具有两个特性；<br>一个是 可重入性；一个是不可中断性；</p>
<h3 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h3><p>了解什么是可重入<br>了解可重入的原理</p>
<h3 id="什么是可重入"><a href="#什么是可重入" class="headerlink" title="什么是可重入"></a>什么是可重入</h3><p>指的是 同一个线程的 可以多次获得 同一把锁。<br>（一个线程可以多次执行synchronized，重复获取同一把锁；）</p>
<p>(当一个线程执行到同步代码块获取到某一个锁之后，还能再次进入同步代码块，获取同样的一把锁，这是可以的，可以重新再进入)</p>
<h3 id="演示可重入特性"><a href="#演示可重入特性" class="headerlink" title="演示可重入特性"></a>演示可重入特性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  可重入特性</span></span><br><span class="line"><span class="comment">    指的是 同一个线程获得锁之后，可以直接再次获取该锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Runnable sellTicket =  <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(Demo01<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是run"</span>);</span><br><span class="line">            test01();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(Demo01<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是test01"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Thread(sellTicket).start();</span><br><span class="line">      <span class="keyword">new</span> Thread(sellTicket).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>演示</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：演示synchronized可重入</span></span><br><span class="line"><span class="comment">    1. 自定义一个线程类</span></span><br><span class="line"><span class="comment">    2. 在线程类的run方法中使用 嵌套的代码同步块</span></span><br><span class="line"><span class="comment">    3. 使用两个线程来执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span></span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">MyThread</span>().start();</span><br><span class="line">      <span class="keyword">new</span> <span class="type">MyThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 自定义一个线程类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  如果一个线程能够获取得到MyThread.class这把锁从而进入同步代码块1并打印；</span></span><br><span class="line"><span class="comment">  还依然能够拿着相同的一把锁再次进入同步代码块2，</span></span><br><span class="line"><span class="comment">  这就说明synchronized是可重入的；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  public void run()&#123;</span><br><span class="line">    synchronized(<span class="type">MyThread</span><span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">      <span class="type">System</span>.out.println(getName() + <span class="string">"进入了同步代码块1"</span>);</span><br><span class="line"></span><br><span class="line">      synchronized(<span class="type">MyThread</span><span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">         <span class="type">System</span>.out.println(getName() + <span class="string">"进入了同步代码块2"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果并分析synchronized可重入性执行流程</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">结果:</span><br><span class="line">Thread-<span class="number">0</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">-------------------------</span><br><span class="line"></span><br><span class="line">先画一个红色的箭头代表主线程；</span><br><span class="line">主线程从main<span class="literal">()</span>方法开始执行；</span><br><span class="line">那么就会启动两个线程即<span class="keyword">new</span> <span class="constructor">MyThread()</span>.start<span class="literal">()</span><span class="operator"> * </span><span class="number">2</span>；</span><br><span class="line">那么画两个箭头，一个绿色的箭头一个紫色的箭头即分别代表A线程与B线程；</span><br><span class="line">那么这两个线程A、B会来进行执行MyThread当中实现的run<span class="literal">()</span>方法；</span><br><span class="line">假设线程A先执行；</span><br><span class="line">那么线程A会获取得到锁<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>从而能够进入代码块当中；</span><br><span class="line">那么这个锁对象<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中存在一个计数器，</span><br><span class="line">该锁对象<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中的计数器会记录自己被获取了几次，</span><br><span class="line">那么当前是线程A第一次获取得到该锁<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>；即计数器取值加<span class="number">1</span>；</span><br><span class="line">那么线程A进入到同步代码块<span class="number">1</span>当中即会进行打印 线程名+<span class="string">"进入了同步代码块1"</span>信息；</span><br><span class="line">接着该线程A继续往下进行执行发现又是一个同步代码块，且还是获取的一个相同的锁；那么这个时候；会将锁对象<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中计数器的取值再次++，设置为<span class="number">2</span>；</span><br><span class="line">假设CPU此时依然在该线程A上，而线程A继续往下进行执行，那么此时就会进行打印 线程名++<span class="string">"进入了同步代码块2"</span>信息；</span><br><span class="line">那么也就可以观察得到同一个线程多次执行synchronized拿到同一把锁；</span><br><span class="line">那么这个锁当中存在有一个计数器，这个计数器当中会进行记录自己被拿到了几次。</span><br><span class="line"></span><br><span class="line">那么假设此时CPU又切换到了另外一个线程；即线程B；</span><br><span class="line">那么此时线程B也会来进行执行MyThread当中实现的run<span class="literal">()</span>方法；</span><br><span class="line">但是会发现<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>该对象锁依然在线程A那里，即线程A还并没有进行释放锁CPU就切换到了线程B上；</span><br><span class="line">所以也就导致了线程B无法获取得到锁从而也就无法进入同步代码块<span class="number">1</span>中，只能够在同步代码块<span class="number">1</span>的外侧进行等待；</span><br><span class="line"></span><br><span class="line">那么这个时候CPU又切换回来到了线程A上；</span><br><span class="line">那么线程A继续接着CPU切换之前的的那个地方往下进行执行；</span><br><span class="line">即当时已经打印完成 线程名称+“进入了同步代码块<span class="number">2</span>”信息了；</span><br><span class="line">即线程A走到了同步代码块<span class="number">2</span>的大括号处说明同步代码块<span class="number">2</span>要结束了；</span><br><span class="line">那么此时同步代码块<span class="number">2</span>结束的时候就会将该同步代码块<span class="number">2</span>的锁给释放掉；</span><br><span class="line">也就意味着对象锁<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中的计数器会进行减<span class="number">1</span>操作；</span><br><span class="line">即此时计数器取值由<span class="number">2</span>变成了<span class="number">1</span>；</span><br><span class="line">那么接着继续往下走；那么线程A就又走到了同步代码块<span class="number">1</span>的结束大括号上，也就意味着此时线程A要出同步代码块<span class="number">1</span>，即又释放一次，即锁对象<span class="module-access"><span class="module"><span class="identifier">MyThread</span>.</span></span><span class="keyword">class</span>当中的计数器又会发生一次减<span class="number">1</span>操作；即此时计数器的取值由<span class="number">1</span>变为<span class="number">0</span>；</span><br><span class="line">计数器取值为<span class="number">0</span>也就意味着当前没有线程来进行获取这把锁了；</span><br><span class="line">也就是相当于线程A将锁还回去了；</span><br><span class="line">那么此时其他线程就可以去进行竞争获取得到该锁进入同步代码块当中来；</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实也可以不用两个synchronized同步代码块嵌套；<br>可以放到两个不同的方法也可以完成；</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">MyThread</span> <span class="symbol">extends</span> <span class="symbol">Thread</span>&#123;</span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> run()&#123;</span><br><span class="line">    synchronized(MyThread.<span class="keyword">class</span>)&#123;</span><br><span class="line">      System.<span class="keyword">out</span>.println(getName() + <span class="string">"进入了同步代码块1"</span>);</span><br><span class="line"></span><br><span class="line">      test01();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> test01()&#123;</span><br><span class="line">    synchronized(MyThread.<span class="keyword">class</span>)&#123;</span><br><span class="line">         System.<span class="keyword">out</span>.println(getName() + <span class="string">"进入了同步代码块2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment">// 再次运行，线程依旧可以重入拿到锁两次；</span></span><br><span class="line">结果:</span><br><span class="line">Thread<span class="number">-0</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread<span class="number">-0</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">Thread<span class="number">-1</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread<span class="number">-1</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">-----------------------------------------</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外不仅是放到同一个类的方法可以实现，放到不同类的方法也可以实现；</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：演示synchronized可重入</span></span><br><span class="line"><span class="comment">    1. 自定义一个线程类</span></span><br><span class="line"><span class="comment">    2. 在线程类的run方法中使用 嵌套的代码同步块</span></span><br><span class="line"><span class="comment">    3. 使用两个线程来执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Demo01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args)&#123;</span><br><span class="line">      new MyThread().start();</span><br><span class="line">      new MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> test01()&#123;</span><br><span class="line">      synchronized(MyThread.<span class="keyword">class</span>)&#123;</span><br><span class="line">          String name = Thread.currentThread.getName();</span><br><span class="line">          System.<span class="keyword">out</span>.println(name + <span class="string">"进入了同步代码块2"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 自定义一个线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">MyThread</span> <span class="symbol">extends</span> <span class="symbol">Thread</span>&#123;</span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> run()&#123;</span><br><span class="line">    synchronized(MyThread.<span class="keyword">class</span>)&#123;</span><br><span class="line">      System.<span class="keyword">out</span>.println(getName() + <span class="string">"进入了同步代码块1"</span>);</span><br><span class="line"></span><br><span class="line">      Demo01.test01();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment">// 再次运行，线程依旧可以重入拿到锁两次；</span></span><br><span class="line">结果:</span><br><span class="line">Thread<span class="number">-0</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread<span class="number">-0</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">Thread<span class="number">-1</span>进入了同步代码块<span class="number">1</span></span><br><span class="line">Thread<span class="number">-1</span>进入了同步代码块<span class="number">2</span></span><br><span class="line">-----------------------------------------</span><br></pre></td></tr></table></figure>

<p>由此说明了synchronized的可重入特性与调用哪一个对象的哪一个方法无关；<br>主要是看线程，看锁；</p>
<h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><p>synchronized的锁对象中有一个计数器（recursions变量）会记录线程获得几次锁；<br>加锁次数 计数器（recursions 变量）</p>
<h3 id="可重入的好处"><a href="#可重入的好处" class="headerlink" title="可重入的好处"></a>可重入的好处</h3><ol>
<li>可以避免死锁</li>
<li>更好的封装代码</li>
</ol>
<p>依然是上述存在有两个同步代码块嵌套的代码；<br>即如果一个线程A进入了一个同步代码块当中去了；<br>那么假设synchronized没有可重入特性；<br>那么就会导致无法再次进入同步代码块当中；<br>那么这个时候就会卡在一个地方；<br>这个地方即为进入到synchronized同步代码块1之后，<br>打印执行完成 线程名+“进入了同步代码块1”之后；<br>没有办法进入下一句代码，即下一个同步代码块2synchronized中；<br>从而无法结束该流程也没有办法释放锁；<br>而其他线程也由于无法获取得到锁从而无法进入同步代码块1只能够在同步代码块1外层进行等待；<br>也就造成了死锁的状态；就相当于是线程A被困在同步代码块1当中了；<br>那么有了synchronized的可重入特性就可以避免死锁；</p>
<p>因为可以在同步代码块1当中调用其他方法，即比如说上述代码中的Demo01.test01();而Demo01.test01()中也存在有同步代码块，那么也就方便了使用方法来进行封装代码；</p>
<h3 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h3><p>synchronized是可重入锁；内部锁对象中会有一个计数器记录线程获取了几次锁了；在执行完同步代码块时，计数器的数量会-1，直到计数器的数量为0，就释放这个锁。</p>
<p>什么是可重入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指的是 同一个线程的 可以 多次 获得 同一把锁</span><br></pre></td></tr></table></figure>

<p>可重入的原理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加锁次数计数器。（recursions变量）</span><br></pre></td></tr></table></figure>

<h2 id="synchronized的不可中断性"><a href="#synchronized的不可中断性" class="headerlink" title="synchronized的不可中断性"></a>synchronized的不可中断性</h2><h3 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a>目标</h3><p>了解什么是不可中断<br>学习<strong>synchronized</strong>的<strong>不可中断特性</strong>；<br>学习<strong>Lock</strong>的<strong>可中断特性</strong>；</p>
<h3 id="什么是不可中断"><a href="#什么是不可中断" class="headerlink" title="什么是不可中断"></a>什么是不可中断</h3><p>一旦这个锁 被别人 获得了，如果里另一个锁想获得锁，只能等待或者阻塞，直到别的线程释放这个锁，如果别人永远不释放锁，这个线程只能永远等下去，很执着！<br>（一个线程获得锁后，另一个线程想要锁，必须处于阻塞或等待状态；如果第一个线程不释放锁，第二个线程会一直处于阻塞或等待状态，在阻塞或者等待过程中，不可被中断，将一直等待或阻塞；）</p>
<h3 id="synchronized-不可中断演示"><a href="#synchronized-不可中断演示" class="headerlink" title="synchronized 不可中断演示"></a>synchronized 不可中断演示</h3><p>synchronized 是不可中断，处于阻塞状态的线程会一直等待锁。</p>
<p>(当一个线程进入一个同步代码块，那么另外一个线程只能在外面等待，这个处于等待的线程将会一直等待，不会中断，所以就叫做不可中断)</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Demo02_Uninterruptible&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Object</span> o1 = <span class="keyword">new</span> <span class="keyword">Object</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    Runnable runnable =  () - &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>( <span class="number">01</span> )&#123;</span><br><span class="line">        <span class="keyword">String</span> name = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(name + <span class="string">"start"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(name + <span class="string">"interrupted"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>演示synchronized的不可中断特性</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------</span><br><span class="line">package com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：演示synchronized不可中断</span></span><br><span class="line"><span class="comment">    1. 定义一个Runnable</span></span><br><span class="line"><span class="comment">    2. 在Runnable定义同步代码块</span></span><br><span class="line"><span class="comment">    3. 先开启一个线程来执行同步代码块，保证不退出同步代码块</span></span><br><span class="line"><span class="comment">    4. 后开启一个线程来执行同步代码块（阻塞状态）</span></span><br><span class="line"><span class="comment">    5. 停止第二个线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="keyword">class</span> Demo02_Uninterruptible&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> static Object obj = <span class="keyword">new</span> <span class="constructor">Object()</span>;<span class="comment">//定义锁对象</span></span><br><span class="line"></span><br><span class="line">  public static void main(String<span class="literal">[]</span> args)&#123;</span><br><span class="line">      <span class="comment">// 1. 定义一个Runnable</span></span><br><span class="line">      Runnable run = <span class="literal">()</span>-&gt;&#123;</span><br><span class="line">        <span class="comment">// 2. 在Runnable定义同步代码块；</span></span><br><span class="line">        <span class="comment">// 同步代码块需要一个锁对象；</span></span><br><span class="line">        synchronized(obj)&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 进行打印是哪一个线程进入的同步代码块</span></span><br><span class="line">          String name = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>;</span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(name + <span class="string">"进入同步代码块"</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 需要进行保证不进行退出同步代码块；</span></span><br><span class="line">          <span class="comment">// 所以让此线程进行沉睡sleep</span></span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">888888</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 先开启一个线程来执行同步代码块</span></span><br><span class="line">      Thread t1 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">run</span>)</span>;</span><br><span class="line">      t1.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 沉睡一秒钟；</span></span><br><span class="line">      <span class="comment">// 保证第一个线程先去执行同步代码块之后再来创建第二个线程；</span></span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      4. 后开启一个线程来执行同步代码块（阻塞状态）</span></span><br><span class="line"><span class="comment">      到时候第二个线程去执行同步代码块的时候，</span></span><br><span class="line"><span class="comment">      锁已经被t1线程锁获取得到了；</span></span><br><span class="line"><span class="comment">      所以线程t2是无法获取得到Object obj对象锁的；</span></span><br><span class="line"><span class="comment">      那么也就将会在同步代码块外处于阻塞状态。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      Thread t2 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">run</span>)</span>;</span><br><span class="line">      t2.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 5. 停止第二个线程；</span></span><br><span class="line"><span class="comment">      观察此线程t2能够被中断；</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"停止线程前"</span>);</span><br><span class="line">      t2.interrupt<span class="literal">()</span>;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"停止线程后"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最后得到两个线程的执行状态</span></span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t1.get<span class="constructor">State()</span>);</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t2.get<span class="constructor">State()</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line">运行效果：</span><br><span class="line">(Run显示红灯即没有停止运行依然在继续)</span><br><span class="line">Thread-<span class="number">0</span>进入同步代码块</span><br><span class="line">停止线程前</span><br><span class="line">停止线程后</span><br><span class="line">TIMED_WAITING</span><br><span class="line">BLOCKED</span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">通过interrupt<span class="literal">()</span>方法给t2线程进行强行中断；</span><br><span class="line">最后进行打印t2的状态及State发现状态依然为BLOCKED；</span><br><span class="line">即线程不可中断；</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">synchronized的不可中断性具体分析流程</span><br><span class="line">红色的箭头表示主线程；主线程从main<span class="literal">()</span>方法开始执行；</span><br><span class="line">然后执行到步骤<span class="number">3</span>（<span class="number">3.</span> 先开启一个线程来执行同步代码块）启动第一个线程t1；</span><br><span class="line">那么再画一个箭头代表启动的这第一个线程t1，用线程A表示；</span><br><span class="line">那么线程A启动之后就会去执行Runnable run中的所重写的run方法；</span><br><span class="line">那么线程A第一次执行同步代码块；获取得到对象锁Object obj；</span><br><span class="line">然后进入同步代码块中打印 线程名称+“进入同步代码块”；</span><br><span class="line">继续往下进行执行就会使得线程A进行入沉睡状态；</span><br><span class="line">那么此时CPU再切换到另外一个线程；即主线程继续往下执行；</span><br><span class="line">当主线程沉睡一秒之后，接下来又会启动一个线程即t2，用线程B表示；</span><br><span class="line">线程B启动之后也会来进行执行Runnable当中重写的run<span class="literal">()</span>方法；</span><br><span class="line">但是由于在CPU切换之前线程A并没有释放锁；</span><br><span class="line">即第一个线程，即线程A由于沉睡时间过长；没有办法释放锁；</span><br><span class="line">所以导致线程B无法获取得到锁；</span><br><span class="line">从而只能在同步代码块外侧进行等待锁，处于阻塞状态；</span><br><span class="line">那么此时CPU再次切换到主线程，主线程继续往下进行执行；</span><br><span class="line">进行打印输出“停止线程前”；后继续往下执行；</span><br><span class="line">准备强行将等待锁对象的线程B进行停止掉，即使用了interrupt<span class="literal">()</span>方法（但是停不掉；就是因为synchronized是不可中断的；这个处于阻塞等待的线程是无法被中断的；这个线程会一直处于等待锁状态即不可被中断）；</span><br><span class="line">主线程继续往下执行输出打印“停止线程后”；</span><br><span class="line">最后打印线程A与线程B这两个线程的状态；</span><br><span class="line">线程A由于执行了<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">888888</span>);所以导致线程A的状态处于TIMED_WAITING；</span><br><span class="line">线程B由于synchronized的不可中断性所以一直在同步代码块外侧进行等待获取锁处于等待阻塞状态，所以其状态为BLOCKED；不可被中断；</span><br><span class="line"></span><br><span class="line">至此，可以观察到的是synchronized是不可被中断的；</span><br><span class="line">它会导致没有获取得到锁的线程一直在同步代码块外侧一直处于一个等待阻塞获取锁的一个状态；</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantLock可中断演示"><a href="#ReentrantLock可中断演示" class="headerlink" title="ReentrantLock可中断演示"></a>ReentrantLock可中断演示</h3><p>ReentrantLock可中断</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.<span class="keyword">Lock</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Demo03_INterruptible&#123;</span><br><span class="line">    private static final <span class="keyword">Lock</span> o1 = <span class="built_in">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws InterruptedException&#123;</span><br><span class="line">      Runnable runnable = () -&gt; &#123;</span><br><span class="line">        String <span class="type">name</span> =  Thread.currentThread().getName();</span><br><span class="line">        <span class="type">boolean</span> isLock = <span class="keyword">false</span>;</span><br><span class="line">        try&#123;</span><br><span class="line">            isLock = o1.tryLock( <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">              <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + "lock");</span><br><span class="line">              Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">          <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + "interrupted");</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">              o1.unlock();</span><br><span class="line">              <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + "unlock");</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="type">name</span> + "指定时间内没有得到锁，中断，不等了，可以接着做其他事情。");</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>演示 ReentrantLock 的可中断和不可中断特性</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.demo03_synchronized_nature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  目标：</span></span><br><span class="line"><span class="comment">    演示Lock不可中断和可中断特性</span></span><br><span class="line"><span class="comment">    Lock具有两种特性（一种是可中断；另外一种是不可中断；）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="keyword">class</span> Demo03_Interruptible&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在类的成员变量位置来进行创建一个Lock对象</span></span><br><span class="line">  <span class="keyword">private</span> static Lock lock = <span class="keyword">new</span> <span class="constructor">ReentrantLock()</span>;</span><br><span class="line"></span><br><span class="line">  public static void main(String<span class="literal">[]</span> args)throws InterruptedException&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 演示 Lock 不可中断</span></span><br><span class="line">  public static void test01<span class="literal">()</span>&#123;</span><br><span class="line">    Runnable run = <span class="literal">()</span>-&gt;&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        这种方式是属于不可中断的；</span></span><br><span class="line"><span class="comment">        可以看到的是:lock() void</span></span><br><span class="line"><span class="comment">        即该方法是没有返回值的；</span></span><br><span class="line"><span class="comment">        那么这种情况就属于不可中断；</span></span><br><span class="line"><span class="comment">        它也会一直等待锁；</span></span><br><span class="line"><span class="comment">        另外获取锁之后一定要记得unlock()；</span></span><br><span class="line"><span class="comment">        那么将unlock()操作放入到finally块当中进行执行；</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      String name =<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        lock.lock<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">//获取线程的名字</span></span><br><span class="line">        <span class="comment">//打印当前进入run()中的线程名称</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(name + <span class="string">"获得锁，进入锁执行"</span>);</span><br><span class="line">        <span class="comment">//加一个睡眠保证该线程一直在里面进行执行不退出</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">888888</span>);</span><br><span class="line"></span><br><span class="line">      &#125;catch(InterruptedException e)&#123;</span><br><span class="line">          e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">      &#125;finally&#123;</span><br><span class="line">        <span class="comment">//同样unlock也是没有返回值的；void</span></span><br><span class="line">        lock.unlock<span class="literal">()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(name + <span class="string">"释放锁"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">run</span>)</span>;</span><br><span class="line">    t1.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让主线程沉睡一秒；</span></span><br><span class="line">    <span class="comment">//让第一个线程t1启动之后去进行执行Runnable当中的所实现的run()</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续创建第二个线程</span></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">run</span>)</span>;</span><br><span class="line">    t2.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//终止一下t2线程看是否能够进行终止；</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"终止t2线程前"</span>);</span><br><span class="line">    t2.interrupt<span class="literal">()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"终止t2线程后"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//让主线程沉睡一秒</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取两个线程的状态</span></span><br><span class="line">    <span class="comment">//第二个线程t2是后来的即在第一个线程t1创建并启动之后以及主线程沉睡了1秒之后才创建的第二个线程t2；</span></span><br><span class="line">    <span class="comment">//即第一个线程t1已经获取得到锁了；</span></span><br><span class="line">    <span class="comment">//由于第一个线程t1在Runnable所实现的run()方法当中进行了长时间的沉睡又没有办法释放锁；</span></span><br><span class="line">    <span class="comment">//所导致第二个线程，即线程t2只能够在同步代码块外进行阻塞等待获取锁；</span></span><br><span class="line">    <span class="comment">//看第二个线程t2是否能够被中断以及观察这两个线程的状态；</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t1.get<span class="constructor">State()</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t2.get<span class="constructor">State()</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------</span><br><span class="line">运行效果：</span><br><span class="line">(Run显示红灯即没有停止运行依然在继续)</span><br><span class="line">Thread-<span class="number">0</span>进入同步代码块</span><br><span class="line">停止t2线程前</span><br><span class="line">停止t2线程后</span><br><span class="line">TIMED_WAITING</span><br><span class="line">WAITING</span><br><span class="line">--------------------------------------------------</span><br><span class="line">那么通过运行结果可以看出t2.interrupt<span class="literal">()</span>是没有执行成功的；</span><br><span class="line">因为t2进行打印其线程状态发现依旧处于等待状态即WAITING；</span><br><span class="line">也就是说t2线程没有抢到锁所以导致一直处于等待状态；</span><br></pre></td></tr></table></figure>

<h2 id="javap反汇编学习synchronized的原理"><a href="#javap反汇编学习synchronized的原理" class="headerlink" title="javap反汇编学习synchronized的原理"></a>javap反汇编学习synchronized的原理</h2><p>第五章：synchronized原理</p>
<p>（较难的一块，由浅入深，涉及<strong>synchronized的原理</strong>讲解；）</p>
<blockquote>
<ul>
<li>首先会通过<strong>javap反汇编</strong>的方式，</li>
<li><em>synchronized*</em>其实被转换成了<strong>两条字节码指令</strong>，<br>分别是<strong>monitorenter</strong>以及<strong>monitorexit</strong>；<br>然后会通过Oracle的官方文档即<strong>JVM规范</strong>来对<strong>字节码指令</strong> <strong>monitorenter</strong>以及<strong>monitorexit</strong>的一个简单的介绍，<br>介绍这<strong>两个指令</strong>时如何来进行<strong>加锁和解锁</strong>的，<br>通过<strong>字节码指令</strong>来介绍<strong>synchronized</strong>属于比较深入，<br>但是有并不是特别的深入，<br>那么为了更加深层次的理解<strong>synchronized的底层机制</strong>，<br>将会深入<strong>JVM的源码</strong>来进行源码分析。</li>
<li><strong>JVM底层</strong>是使用<strong>c、c++</strong>所编写的；</li>
<li><em>synchronized*</em>是一个<strong>关键字</strong>，</li>
<li><em>底层*</em>由<strong>c、c++</strong>来编写。<br>会进行分析这一块的代码；<br>到时候就可以清晰的知道<strong>synchronized</strong>的一个清晰的<strong>底层结构</strong>以及如何<strong>获得锁</strong>、<strong>等待锁</strong>以及如何<strong>释放锁</strong>的；</li>
<li>另外还会去介绍<strong>synchronized</strong>为什么是一个<strong>重量级的锁</strong>，<br>以及<strong>synchronized</strong>为什么会<strong>开销比较大</strong>；<br>因为<strong>synchronized</strong>是一个<strong>重量级的锁</strong>，<br>所以其<strong>效率不高</strong>，<br>那么在第六章就会来进行介绍<strong>JDK6</strong>当中对<strong>synchronized</strong>的一个<strong>优化措施</strong>，<strong>synchronized</strong>的涉及到一个叫做<strong>CAS操作</strong>，<br>那么就会先去进行介绍<strong>CAS</strong>的一个<strong>原理</strong>，<br>那么其实<strong>CAS</strong>也属于一个<strong>原子操作</strong>，<br>可以将<strong>CAS操作</strong>看做是一个<strong>轻量级的synchronized</strong>，<br>它能够<strong>保证变量修改</strong>的这样一个<strong>原子操作</strong>；<br>介绍了<strong>CAS</strong>之后就将会介绍<strong>锁升级</strong>的一个<strong>过程</strong>，</li>
<li><em>锁升级*</em>是由 <strong>无锁-→偏向锁-→轻量级锁-→重量级锁</strong> ；</li>
<li>由浅入深的来进行学习，那么存在这么多锁就会存在一个问题；<br>如何来得知是<strong>属于哪一种锁</strong>，<br>那么这个时候会先进行了解<strong>JAVA对象的布局</strong>；<br>以前对java对象的理解是这样的-→java对象是存在在堆中，然后有一块空间可以来进行存放其对象当中的成员变量；<br>那么介绍的<strong>java对象布局</strong>，其当中不仅会有<strong>java对象的实例数据</strong>还会有<strong>对象头</strong>以及一些<strong>对齐数据</strong>；<br>那么<strong>锁升级过程</strong>中的这些<strong>锁</strong>是<strong>存在于对象头当中的Mark Word</strong>当中的，<br>到时候通过c++的源码来进行详细分析；</li>
<li>另外<strong>JDK6</strong>还对<strong>synchronized</strong>做了一些<strong>锁消除和锁粗化的优化</strong>操作，<br>经过对<strong>synchronized的原理</strong>的学习之后就可以总结出写代码应该如何对<strong>synchronized优化</strong>，写出更<strong>高效</strong>更<strong>好</strong>的代码；<br>那么会从以下几个方面进行来介绍；<br>第一个：<strong>减少synchronized的范围</strong>；<br>第二个：<strong>降低synchronized锁的粒度</strong><br>（这当中有一个经典的例子就是<strong>HashTable</strong>，<strong>HashTable</strong>会<strong>锁</strong>住所有的<strong>数据</strong>；而后又推出了一个叫做<strong>ConcurrentHashMap</strong>，那么<strong>ConcurrentHashMap</strong> <strong>只</strong>会<strong>锁</strong>住<strong>一个桶</strong>当中的<strong>数据</strong>）；<br>第三个：通过<strong>读写分离</strong>的方式来进行<strong>提高效率</strong>；<br>以上就是<strong>synchronized</strong>课程的主要内容；</li>
</ul>
</blockquote>
<p>javap 反汇编</p>
<h3 id="目标-10"><a href="#目标-10" class="headerlink" title="目标"></a>目标</h3><p>通过 javap 反汇编学习 synchronized的原理</p>
<p>编写一个简单的synchronized代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo04_synchronized_monitor;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Increment</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>( obj )&#123;</span><br><span class="line">        number ++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"a"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">      Runnable increment = <span class="keyword">new</span> Increment();</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">      t.start();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"number = "</span> + Increment.number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要看 synchronized的原理，但是 synchronized是一个关键字，看不到源码。</p>
<p>可以将class文件进行反汇编。  </p>
<p>JDK自带的一个工具: javap，对字节码进行反汇编，查看字节码指令。</p>
<p>在DOS命令行输入：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javap -p -v -c</span><br><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3666<span class="symbol">\I</span>deaProjects<span class="symbol">\X</span>xx<span class="symbol">\S</span>ynchronized<span class="symbol">\t</span>arget<span class="symbol">\c</span>lasses<span class="symbol">\c</span>om<span class="symbol">\x</span>xx<span class="symbol">\d</span>emo04_synchronized_monitor<span class="symbol">\I</span>ncrement.class</span><br></pre></td></tr></table></figure>

<p>反汇编后的效果如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">class</span> <span class="string">com.xxx.demo04_synchronized_monitor.Increment</span> <span class="string">implements</span> <span class="string">java.lang.Runnable&#123;</span></span><br><span class="line">  <span class="string">public</span> <span class="string">static</span> <span class="string">int</span> <span class="string">number;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">private</span> <span class="string">static</span> <span class="string">java.lang.Object</span> <span class="string">obj;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">com.xxx.demo04_synchronized_monitor.Increment();</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="attr">0 :</span> <span class="string">aload_0</span></span><br><span class="line">      <span class="attr">1 :</span> <span class="string">invokespecial</span>   <span class="comment">#1       // Method java/lang/Object."&lt;init&gt;":()v</span></span><br><span class="line">      <span class="attr">4 :</span> <span class="string">return</span></span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">void</span> <span class="string">run();</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="attr">0 :</span> <span class="string">iconst_0</span></span><br><span class="line">      <span class="attr">1 :</span> <span class="string">istore_1</span></span><br><span class="line">      <span class="attr">2 :</span> <span class="string">iload_1</span></span><br><span class="line">      <span class="attr">3 :</span> <span class="string">sipush</span>    <span class="number">1000</span></span><br><span class="line">      <span class="attr">6 :</span> <span class="string">if_icmpge</span> <span class="number">39</span></span><br><span class="line">      <span class="attr">9 :</span> <span class="string">getstatic</span> <span class="comment">#2           // Field obj:Ljava/lang/Object</span></span><br><span class="line">      <span class="attr">12:</span> <span class="string">dup</span></span><br><span class="line">      <span class="attr">13:</span> <span class="string">astore_2</span></span><br><span class="line">      <span class="attr">14:</span> <span class="string">monitorenter</span></span><br><span class="line">      <span class="attr">15:</span> <span class="string">getstatic</span> <span class="comment">#3           // Field number:I</span></span><br><span class="line">      <span class="attr">18:</span> <span class="string">iconst_1</span></span><br><span class="line">      <span class="attr">19:</span> <span class="string">iadd</span></span><br><span class="line">      <span class="attr">20:</span> <span class="string">putstatic</span> <span class="comment">#3           // Field number:I</span></span><br><span class="line">      <span class="attr">23:</span> <span class="string">aload_2</span></span><br><span class="line">      <span class="attr">24:</span> <span class="string">monitorexit</span></span><br><span class="line">      <span class="attr">25:</span> <span class="string">goto</span>      <span class="number">33</span></span><br><span class="line">      <span class="attr">28:</span> <span class="string">astore_3</span></span><br><span class="line">      <span class="attr">29:</span> <span class="string">aload_2</span></span><br><span class="line">      <span class="attr">30:</span> <span class="string">monitorexit</span></span><br><span class="line">      <span class="attr">31:</span> <span class="string">aload_3</span></span><br><span class="line">      <span class="attr">32:</span> <span class="string">athrow</span></span><br><span class="line">      <span class="attr">33:</span> <span class="string">iinc</span>      <span class="number">1</span><span class="string">,</span>  <span class="number">1</span></span><br><span class="line">      <span class="attr">36:</span> <span class="string">goto</span>      <span class="number">2</span></span><br><span class="line">      <span class="attr">39:</span> <span class="string">return</span></span><br><span class="line">   <span class="attr">Exception table:</span></span><br><span class="line">        <span class="string">from</span>   <span class="string">to</span>  <span class="string">target</span> <span class="string">type</span></span><br><span class="line">          <span class="number">15</span>   <span class="number">25</span>    <span class="number">29</span>    <span class="string">any</span></span><br><span class="line">          <span class="number">28</span>   <span class="number">31</span>    <span class="number">28</span>    <span class="string">any</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">synchronized</span> <span class="string">void</span> <span class="string">test();</span></span><br><span class="line">    <span class="attr">descriptor:</span> <span class="string">()V</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">ACC_PUBLIC,</span> <span class="string">ACC_SYNCHRONIZED</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">        <span class="string">stack=2,</span>  <span class="string">locals=1,</span>  <span class="string">args_size=1</span></span><br><span class="line">            <span class="attr">0:</span> <span class="string">getstatic</span>     <span class="comment">#4              // Field</span></span><br><span class="line"><span class="attr">java/lang/System.out:Ljava/io/PrintStream:</span></span><br><span class="line">            <span class="attr">3:</span> <span class="string">ldc</span>           <span class="comment">#5              // String a</span></span><br><span class="line">            <span class="attr">5:</span> <span class="string">invokevirtual</span> <span class="comment">#6              // Method java/io/PrintStream.println:(Ljava/lang.String;)V</span></span><br><span class="line">            <span class="attr">8:</span> <span class="string">return</span></span><br><span class="line">        <span class="attr">LineNumberTable:</span></span><br><span class="line">          <span class="attr">line 16:</span> <span class="number">0</span></span><br><span class="line">          <span class="attr">line 17:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">LocalVariableTable:</span></span><br><span class="line">          <span class="string">Start</span>     <span class="string">Length</span>    <span class="string">Slot</span>  <span class="string">Name</span>  <span class="string">Signature</span></span><br><span class="line">            <span class="number">0</span>          <span class="number">9</span>       <span class="number">0</span>     <span class="string">this</span>   <span class="string">Lcom/xxx/demo04_synchronized_monitor/Increment;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">static</span> <span class="string">&#123;&#125;;</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">       <span class="attr">0:</span> <span class="string">iconst_0</span></span><br><span class="line">       <span class="attr">1:</span> <span class="string">putstatic</span>       <span class="comment">#3       // Field number:I</span></span><br><span class="line">       <span class="attr">4:</span> <span class="string">new</span>             <span class="comment">#4       // class java/lang/Object</span></span><br><span class="line">       <span class="attr">7:</span> <span class="string">dup</span></span><br><span class="line">       <span class="attr">8:</span> <span class="string">invokespecial</span>   <span class="comment">#1       // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">      <span class="attr">11:</span> <span class="string">putstatic</span>       <span class="comment">#2       // Field obj:Ljava/lang/Object</span></span><br><span class="line">      <span class="attr">14:</span> <span class="string">return</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h3><p>首先来看一下JVM规范中对于 monitorenter 和 monitorexit 的描述：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>docs.oracle.com<span class="regexp">/javase/</span>specs<span class="regexp">/jvms/</span>se8<span class="regexp">/html/</span>jvms-<span class="number">6</span>.html<span class="comment">#jvms-6.5.monitorenter</span></span><br><span class="line"></span><br><span class="line">https:<span class="regexp">//</span>docs.oracle.com<span class="regexp">/javase/</span>specs<span class="regexp">/jvms/</span>se8<span class="regexp">/html/i</span>ndex.html</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Each object is associlated with a monitor.<br>A monitor is locked if and only if it has an owner.<br>The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p>
</blockquote>
<ul>
<li>If the entry count of the monitor associated with objectref is zero,<br>the thread enters the monitor and sets its entry count to one.<br>The thread is then the owner of the monitor.</li>
<li>If the thread already owns the monitor associated with objectref,<br>it reenters the monitor, incrementing its entry count.</li>
<li>If another thread already owns the monitor associated with objectref,<br>the thread blocks until the monitor’s entry count is zero,<br>then tries again to gain ownership.</li>
</ul>
<p>翻译过来：<br>  每一个对象 都会和 一个监视器monitor关联。<br>  监视器被占用时会被锁住，其他线程无法来获取该monitor。<br>  当JVM执行某个线程的某个方法内部的monitorenter时，它会尝试去获取当前对象对应的monitor的所有权。<br>  其过程如下：</p>
<ol>
<li>若monitor的进入数为0，线程可以进入 monitor，并将 monitor的进入数 置为1。 当前线程成为 monitor的 owner（所有者）。</li>
<li>若线程已拥有 monitor的所有权，允许它 重入 monitor，则进入monitor的进入数加1。</li>
<li>若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，直到monitor的进入数变为0，才能重新尝试获取monitor的所有权。</li>
</ol>
<p>monitorenter线程获取锁，宁进入同步代码块。<br>同时只能有一个线程获取锁。</p>
<p>monitorenter 插入在同步代码块的开始位置，当底代码执行到该指令时，将会尝试获取该对象monitor的所有权，即尝试获得该对象的锁。</p>
<h3 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h3><p>首先来看一下 JVM规范 中对于 monitorenter和monitorexit的描述：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>docs.oracle.com<span class="regexp">/javase/</span>specs<span class="regexp">/jvms/</span>se8<span class="regexp">/html/</span>jvms-<span class="number">6</span>.html<span class="comment">#jvms-6.5.monitorexit</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced ny objectref.<br>  The thread decrements the entry count of the monitor associated with objectref.<br>  iIf as a result the value of the entry count is zero , the thread exits the monitor and is no longer its owner.<br>  Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>翻译过来：</p>
<ol>
<li>能执行 monitorexit 指令的线程 一定是 拥有当前对象的 monitor的所有权的线程。</li>
<li>执行 monitorexit时 会将 monitor的进入数减1。 当monitor的进入数减为0时，当前线程退出monitor，不再拥有monitor的所有权，此时其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。</li>
</ol>
<h2 id="面试题：synchronized与Lock的区别"><a href="#面试题：synchronized与Lock的区别" class="headerlink" title="面试题：synchronized与Lock的区别"></a>面试题：synchronized与Lock的区别</h2><h2 id="深入JVM源码-monitor监视器锁"><a href="#深入JVM源码-monitor监视器锁" class="headerlink" title="深入JVM源码-monitor监视器锁"></a>深入JVM源码-monitor监视器锁</h2><p>深入JVM源码</p>
<h3 id="目标-11"><a href="#目标-11" class="headerlink" title="目标"></a>目标</h3><p>通过JVM源码 分析 synchronized的原理</p>
<h3 id="monitor监视器锁"><a href="#monitor监视器锁" class="headerlink" title="monitor监视器锁"></a>monitor监视器锁</h3><p>(JVM底层由C++实现)</p>
<p>可以看出 无论是 synchronized代码块 还是 synchronized方法，<br>其线程安全的语义实现 最终依赖一个叫 monitor的东西，那么这个神秘的东西是什么呢？<br>下面来详细介绍一下。</p>
<p>在HotSpot虚拟机中，monitor是由ObjectMonitor实现的。<br>其源码是用c、c++来实现的，位于HotSpot虚拟机源码 ObjectMonitor.hpp文件中（src/share/vm/runtime/objectMonitor.hpp）。<br>ObjectMonitor主要数据结构如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ObjectMonitor()</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">_header</span>              <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span><br><span class="line">  <span class="string">_count</span>               <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line">  <span class="string">_waiters</span>             <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line">  <span class="string">_recursions</span>          <span class="string">=</span> <span class="number">0</span><span class="string">;</span> <span class="string">//</span> <span class="string">线程的重入次数</span></span><br><span class="line">  <span class="string">_object</span>              <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span> <span class="string">//存储该monitor的对象</span></span><br><span class="line">  <span class="string">_owner</span>               <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span> <span class="string">//标识拥有该monitor的线程</span></span><br><span class="line">  <span class="string">_WaitSet</span>             <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span> <span class="string">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">  <span class="string">_WaitSetLock</span>         <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line">  <span class="string">_Responsible</span>         <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span><br><span class="line">  <span class="string">_succ</span>                <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span><br><span class="line">  <span class="string">_cxq</span>                 <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span> <span class="string">//</span> <span class="string">多线程竞争锁时的单项列表</span></span><br><span class="line">  <span class="string">FreeNext</span>             <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span><br><span class="line">  <span class="string">_EntryList</span>           <span class="string">=</span> <span class="literal">NUll</span><span class="string">;</span> <span class="string">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">  <span class="string">_SpinFreq</span>            <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line">  <span class="string">_SpinClock</span>           <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line">  <span class="string">OwnerIsThread</span>        <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>_owner: 初始化为NUll，当有线程占有该monitor时，owner标记为该线程的唯一表示。当线程释放monitor时，owner又恢复到NULL。owner是一个临界资源，JVM是通过CAS操作来保证其线程安全的。</li>
<li>_cxq: 竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。_cxq是一个临界资源，JVM通过CAS原子指令来修改_cxq队列。 修改前 _cxq的旧值 填入了 node的next字段， _cxq指向新值（新线程）。因此 _cxq是一个后进先出的stack(栈)。</li>
<li>_EntryList: _cxq队列中 有资格成为 候选资源的 线程 会被移动到该队列中。</li>
<li>_WaitSet: 因为调用wait方法而被阻塞的 线程会被放在该队列中。</li>
</ol>
<p>每一个java对象都可以与一个监视器 monitor关联，<br>可以把它理解成为一把锁，<br>当一个线程想要执行一段被synchronized圈起来的同步方法或者代码块时，<br>该线程得 先获取到 synchronized修饰的对象 对应的monitor。</p>
<p>java代码里不会 显式地去创造这么一个 monitor对象，<br>也无需创建，<br>事实上可以这么理解：<br>monitor并不是随着对象创建而创建的。<br>是通过 synchronized 修饰符 告诉 JVM 需要为 某个对象创建关联的 monitor对象。<br>每个线程都存在两个ObjectMonitor对象列表，分别为 free和 used列表。<br>同时JVM中也维护着 global locklist。<br>当线程需要 ObjectMonitor对象时，首先从线程自身的free表中申请，若存在则使用，若不存在则从 globallist 中申请。</p>
<p>ObjectMonitor 的数据结构包含三种队列： _cxq、_WaitSet和 _EntryList，他们之间的关系转换可以用下图表示：</p>
<h2 id="深入JVM源码-monitor竞争"><a href="#深入JVM源码-monitor竞争" class="headerlink" title="深入JVM源码-monitor竞争"></a>深入JVM源码-monitor竞争</h2><p>synchronized为什么是重量级锁，为什么开销比较大？<br>synchronized是重量级的锁，效率不高。<br>synchronized的优化涉及到一个叫做CAS的操作。<br>CAS也属于一个原子操作，可以将其看做是一个轻量级的synchronized。</p>
<p>monitor竞争</p>
<ol>
<li>执行 monitorenter时，会调用 InterpreterRuntime.cpp</li>
</ol>
<p>（位于：src/share/vm/interpreterRuntime.cpp）的InterpreterRuntime::monitorenter 函数。</p>
<p>具体代码可参见 HotSpot源码。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">IRT_ENTRY_NO_ASYNC(<span class="params">void</span>, InterpreterRuntime:<span class="params">monitorenter</span>(JavaThread<span class="operator">*</span>  <span class="params">thread</span>, BasicObjectLock<span class="operator">*</span> <span class="params">elem</span>)</span>)</span><br><span class="line">#ifdef ASSERT</span><br><span class="line">  thread-&gt;last<span class="constructor">_frame()</span>.interpreter<span class="constructor">_frame_verify_monitor(<span class="params">elem</span>)</span>;</span><br><span class="line">#endif</span><br><span class="line">  <span class="keyword">if</span>(PrintBiasedLockingStatistics)&#123;</span><br><span class="line">    Atomic::inc(BiasedLocking::slow<span class="constructor">_path_entry_count_addr()</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Handle h<span class="constructor">_obj(<span class="params">thread</span>, <span class="params">elem</span>-&gt;<span class="params">obj</span>()</span>);</span><br><span class="line">  <span class="keyword">assert</span>(Universe::heap<span class="literal">()</span>-&gt;is<span class="constructor">_in_reserved_or_null(<span class="params">h_obj</span>()</span>),</span><br><span class="line">          <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">  <span class="keyword">if</span>(UseBiasedLocking)&#123;</span><br><span class="line">    <span class="comment">//Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast<span class="constructor">_entry(<span class="params">h_obj</span>, <span class="params">elem</span>-&gt;<span class="params">lock</span>()</span>, <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ObjectSynchronizer::slow<span class="constructor">_enter(<span class="params">h_obj</span>, <span class="params">elem</span>-&gt;<span class="params">lock</span>()</span>, CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">assert</span>(Universe::heap<span class="literal">()</span>-&gt;is<span class="constructor">_in_reserved_or_null(<span class="params">elem</span>-&gt;<span class="params">obj</span>)</span>),</span><br><span class="line">          <span class="string">"must be NULL or an object"</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对于重量级锁，monitorenter的函数中会调用ObjectSynchronizer::slow_enter</li>
<li>最终调用 ObjectMonitor::enter(位于：src/share/vm/runtime/objectMonitor.cpp)，源码如下：</li>
</ol>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void ATTR ObjectMonitor::enter(TRAPS)&#123;</span><br><span class="line">  // The following code is ordered to<span class="built_in"> check </span>the most common cases first</span><br><span class="line">  //<span class="built_in"> and </span>to reduce RTS-&gt;RTO cache line upgrades on SPARC<span class="built_in"> and </span>IA32 processors.</span><br><span class="line">  Thread *<span class="built_in"> const </span>Self = THREAD;</span><br><span class="line">  void * cur ;</span><br><span class="line"></span><br><span class="line">  //通过 CAS 操作尝试把<span class="built_in"> monitor </span>的 _owner 字段设置为当前线程</span><br><span class="line">  cur = Atomic::cmpxchg_ptr(Self, &amp;_owner, NU<span class="class">LL);</span></span><br><span class="line">  if(cur == NULL)&#123;</span><br><span class="line">    // Either ASSERT _recursions == 0<span class="built_in"> or </span>explicitly Set _recursions = 0.</span><br><span class="line">    assert (_recursions == 0 ,   <span class="string">"invariant"</span>) ;</span><br><span class="line">    assert (_owner      == Self, <span class="string">"invariant"</span>) ;</span><br><span class="line">    // CONSIDER: set<span class="built_in"> or </span>assert OwnerIsThread == 1</span><br><span class="line">   <span class="built_in"> return </span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //线程重入；recursions++</span><br><span class="line">  if(cur == Self)&#123;</span><br><span class="line">    // TODO:<span class="keyword"> :</span><span class="built_in"> check </span>for integer overflow! BUGID 6557169</span><br><span class="line">    _recursions ++;</span><br><span class="line">   <span class="built_in"> return </span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 省略一些代码</span><br><span class="line">  for (;;)&#123;</span><br><span class="line">    jt-&gt;set_suspend_equivalent();</span><br><span class="line">    // cleared by handle_special_suspend_equivalent_condition()</span><br><span class="line">    //<span class="built_in"> or </span>java_suspend_self()</span><br><span class="line"></span><br><span class="line">    // 如果获取锁失败，则等待锁的释放</span><br><span class="line">    EnterI(THREAD);</span><br><span class="line"></span><br><span class="line">    if(!ExitSuspendEquivalent(jt)) break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // we have acquired the contended monitor, but while we were</span><br><span class="line">    // waiting another thread suspended us. We don't want to enter</span><br><span class="line">    // the<span class="built_in"> monitor </span>while suspend because that would surprise the</span><br><span class="line">    // thread that suspended us.</span><br><span class="line">    //</span><br><span class="line"></span><br><span class="line">      _recursions = 0;</span><br><span class="line">    _succ = NU<span class="class">LL;</span></span><br><span class="line">    exit(false, Self);</span><br><span class="line"></span><br><span class="line">    jt-&gt;java_suspend_self();</span><br><span class="line">  &#125;</span><br><span class="line">  Self-&gt;set_current_pending_monitor(NU<span class="class">LL);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处省略锁的自旋优化等操作，统一放在后面synchronized优化中说。<br>以上代码的具体流程概括如下：</p>
<h2 id="深入JVM源码-monitor等待"><a href="#深入JVM源码-monitor等待" class="headerlink" title="深入JVM源码-monitor等待"></a>深入JVM源码-monitor等待</h2><h3 id="monitor是重量级锁"><a href="#monitor是重量级锁" class="headerlink" title="monitor是重量级锁"></a>monitor是重量级锁</h3><p>在虚拟机规范对 monitorenter 和 monitorexit 的行为描述中，<br>有两点是需要特别注意的。  </p>
<p>首先，synchronized同步块 对 同一条线程来说是可重入的，不会出现自己把自己锁死的问题。</p>
<p>其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。  </p>
<p>第12章讲过，java的线程 是 映射到 操作系统的 原生线程 之上的，<br>如果要 阻塞或唤醒 一个线程，都需要操作系统来帮忙完成， 这就需要从用户态转换到核心态中，因此 状态转换需要耗费很多的处理器时间。</p>
<p>对于代码简单的同步块（如被synchronized修饰的 getter()或setter()方法），<br>状态转换消耗的时间 有可能比 用户代码执行的时间还要长。</p>
<p>所以 synchronized 是java语言中一个重量级（Heavyweight）的操作，有经验的程序员都会在确实必要的情况下才使用这种操作。  </p>
<p>而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态之中。  </p>
<p>可以看到ObjectMonitor的函数调用中会涉及到 Atomic::cmpxchg_ptr，Atomic::inc_prt等内核函数，这个时候就会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。</p>
<p>用户态和内核态是什么东西呢？<br>要想了解用户态和内核态还需要先了解一下Linux系统的体系架构：</p>
<h2 id="深入JVM源码-monitor释放"><a href="#深入JVM源码-monitor释放" class="headerlink" title="深入JVM源码-monitor释放"></a>深入JVM源码-monitor释放</h2><h2 id="深入JVM源码-monitor是重量级锁"><a href="#深入JVM源码-monitor是重量级锁" class="headerlink" title="深入JVM源码-monitor是重量级锁"></a>深入JVM源码-monitor是重量级锁</h2><h2 id="synchronized优化-CAS-AtomicInteger使用"><a href="#synchronized优化-CAS-AtomicInteger使用" class="headerlink" title="synchronized优化_CAS_AtomicInteger使用"></a>synchronized优化_CAS_AtomicInteger使用</h2><p>第六章：JDK6 synchronized优化</p>
<p>CAS</p>
<h3 id="目标-12"><a href="#目标-12" class="headerlink" title="目标"></a>目标</h3><p>学习CAS的作用<br>学习CAS的原理</p>
<h3 id="CAS概述和作用"><a href="#CAS概述和作用" class="headerlink" title="CAS概述和作用"></a>CAS概述和作用</h3><p>CAS的全称是 Compare And Swap（比较再交换）。<br>是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。</p>
<p>CAS的作用是：CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理器保证。  </p>
<p>(可以看做是一个轻量级的synchronized，它能保证变量修改的原子操作)</p>
<h4 id="CAS和volatile实现无锁并发"><a href="#CAS和volatile实现无锁并发" class="headerlink" title="CAS和volatile实现无锁并发"></a>CAS和volatile实现无锁并发</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.demo05_cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)<span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    Runnable mr = ()-&gt;&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(mr);</span><br><span class="line">      t.start();</span><br><span class="line">      ts.<span class="built_in">add</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Thread t:ts)&#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"number = "</span> + atomicInteger.<span class="built_in">get</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized优化-CAS原理"><a href="#synchronized优化-CAS原理" class="headerlink" title="synchronized优化_CAS原理"></a>synchronized优化_CAS原理</h2><p>CAS 原理</p>
<p>通过刚才 AtomicInteger 的源码可以看到， Unsafe类提供了原子操作。</p>
<h3 id="Unsafe类介绍"><a href="#Unsafe类介绍" class="headerlink" title="Unsafe类介绍"></a>Unsafe类介绍</h3><p>Unsafe类使java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。<br>过渡的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。<br>Unsafe对象不能直接调用，只能通过反射获得。  </p>
<h3 id="Unsafe实现CAS"><a href="#Unsafe实现CAS" class="headerlink" title="Unsafe实现CAS"></a>Unsafe实现CAS</h3><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>悲观锁 从悲观的角度出发：</p>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞。<br>因此synchronized也将其称之为悲观锁。<br>JDK中的ReentrantLock也是一种悲观锁。<br>性能较差！</p>
<p>乐观锁从乐观的角度出发：<br>总是假设最好的情况，每次去拿数据的会后都认为别人不会修改，就算改了也没关系，再重试即可。<br>所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如果没有人修改则更新，如果有人修改则重试。</p>
<p>CAS这种机制也可以将其称之为乐观锁，综合性能较好！</p>
<blockquote>
<p>CAS获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰，结合CAS和volatile可以实现无锁并发，适用于竞争不激烈，多核CPU的场景下。</p>
<ol>
<li>因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</li>
</ol>
</blockquote>
<h3 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h3><p>CAS的作用是什么？</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAS</span>可以将比较和交换转换为原子操作，这个原子操作直接由处理器保证。</span><br></pre></td></tr></table></figure>

<p>CAS的原理是什么？</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CAS需要<span class="number">3</span>个值：内存地址V，旧的预期值<span class="keyword">A</span>，要修改的新值B</span><br><span class="line">如果内存地址V和旧的预期值<span class="keyword">A</span>相等就修改内存地址值为B</span><br></pre></td></tr></table></figure>

<h2 id="synchronized优化锁升级过程"><a href="#synchronized优化锁升级过程" class="headerlink" title="synchronized优化锁升级过程"></a>synchronized优化锁升级过程</h2><h2 id="synchronized优化-对象的布局"><a href="#synchronized优化-对象的布局" class="headerlink" title="synchronized优化-对象的布局"></a>synchronized优化-对象的布局</h2><p>Java对象的布局</p>
<h3 id="目标-13"><a href="#目标-13" class="headerlink" title="目标"></a>目标</h3><p>学习java对象的布局</p>
<p>术语参考：<code>http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</code></p>
<p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>当一个线程尝试访问 synchronized修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？是存在在锁对象的对象头中的。</p>
<p>Hotspot采用 instanceOopDesc和arrayOopDesc来描述对象头: arrayOopDesc对象用来描述数组类型。<br>instanceOopDesc的定义的在Hotspot源码的 instanceOop.hpp 文件中，另外， arrayOopDesc的定义对应 arrayOop.hpp。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">instanceOopDesc</span> :</span> <span class="keyword">public</span> oopDesc&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// aligned header size.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">header_size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">sizeof</span>(instanceOopDesc)/HeapWordSize; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If compressed. the offset of the fields of the instance may not be aligned.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">base_offset_in_bytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">/* offset computation code breaks if useCompressedClassPointers</span></span><br><span class="line"><span class="comment">         only is true</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> (UseCompressedOops &amp;&amp; UseCompressedClassPointers) ? klass_gap_offset_in_bytes() : <span class="keyword">sizeof</span>(instanceOopDesc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">contains_field_offset</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">int</span> nonstatic_field_size)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> base_in_bytes = base_offset_in_bytes();</span><br><span class="line">      <span class="keyword">return</span> (offset &gt;= base_in_bytes &amp;&amp; (offset-base_in_bytes) &lt; nonstatic_field_size = heapOopSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。</p>
<p>Mark Word对应的类型是markOop。<br>源码位于 <code>markOop.hpp</code> 中。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/<span class="strong">*</span></span><br><span class="line"><span class="strong">Bit-format of an object header (most significant first , big endian layout below):</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">32 bits:</span></span><br><span class="line"><span class="strong">---------</span></span><br><span class="line"><span class="strong">          hash:25 --------------&gt;| age:4   biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="strong">          JavaThread*</span>:23 epoch:2   age:4   biased<span class="emphasis">_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="emphasis">          size；32 -------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="emphasis">          PromotedObject*:29 ------------&gt; promo_</span>bits:3 ------&gt;| (CMS promoted object)</span><br><span class="line"></span><br><span class="line">64 bits:</span><br><span class="line">----------</span><br><span class="line"><span class="strong">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="synchronized优化-偏向锁"><a href="#synchronized优化-偏向锁" class="headerlink" title="synchronized优化-偏向锁"></a>synchronized优化-偏向锁</h2><h3 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h3><p>高效并发是从JDK1.5到JDK1.6的一个重要改进。<br>HotSpot虚拟机开发团队在这个版本上花费了大量的精力趋实现各种锁优化技术，<br>如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，<br>这些技术都是为了 在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<p>无锁–→偏向锁–→轻量级锁–→重量级锁</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><h3 id="目标-14"><a href="#目标-14" class="headerlink" title="目标"></a>目标</h3><p>学习偏向锁的原理和好处</p>
<h3 id="什么是偏向锁"><a href="#什么是偏向锁" class="headerlink" title="什么是偏向锁"></a>什么是偏向锁</h3><p>偏向锁是JDK6中的重要引进，因为HotSpot作者经过研究实践发现，<br>在大多数情况下，锁不仅不存在多线程竞争而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。<br>减少不必要的CAS操作。</p>
<p>偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及ThreadID即可。</p>
<h2 id="synchronized优化-轻量级锁"><a href="#synchronized优化-轻量级锁" class="headerlink" title="synchronized优化-轻量级锁"></a>synchronized优化-轻量级锁</h2><h2 id="synchronized优化-自旋锁"><a href="#synchronized优化-自旋锁" class="headerlink" title="synchronized优化-自旋锁"></a>synchronized优化-自旋锁</h2><h2 id="synchronized优化-锁消除"><a href="#synchronized优化-锁消除" class="headerlink" title="synchronized优化-锁消除"></a>synchronized优化-锁消除</h2><h3 id="目标-15"><a href="#目标-15" class="headerlink" title="目标"></a>目标</h3><p>学习锁消除的原理</p>
<p>锁消除 是指 虚拟机 即时编译器（JIT）在 运行时，<br>对一些代码上要求同步，但是被检测到 不可能存在共享数据竞争的锁 进行消除。</p>
<p>锁消除 的主要判定依据 来源于 逃逸分析的数据支持，<br>如果判断在一段代码中，堆上的所有数据 都不会逃逸出去 从而被其他线程 访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，<br>同步加锁 自然就无需进行。</p>
<p>变量是否逃逸，对于虚拟机来说 需要使用 数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在 明知道不存在数据争用的情况下 要求同步呢？</p>
<p>实际上有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的想象。<br>下面这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">    concatString(<span class="string">"aa"</span> , <span class="string">"bb"</span> , <span class="string">"cc"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">concatString</span><span class="params">(<span class="keyword">String</span> s1, <span class="keyword">String</span> s2, <span class="keyword">String</span> s3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后：</p>
<h2 id="synchronized优化-锁粗化"><a href="#synchronized优化-锁粗化" class="headerlink" title="synchronized优化-锁粗化"></a>synchronized优化-锁粗化</h2><p>锁粗化</p>
<h3 id="目标-16"><a href="#目标-16" class="headerlink" title="目标"></a>目标</h3><p>学习锁粗化的原理</p>
<p>原则上，在编写代码的时候，总是推荐将 同步亏啊的作用范围 限制得尽量小，<br>只在共享数据的实际作用域中 才进行同步，<br>这样是为了使得需要同步的操作数量 尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>大部分情况下，上面的原则都是正确地，但是如果一些列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能消耗。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Demo01&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">new</span> StringBuffer()</span><br><span class="line">          .<span class="built_in">append</span>(<span class="string">"aa"</span>).<span class="built_in">append</span>(<span class="string">"bb"</span>).<span class="built_in">append</span>(<span class="string">"cc"</span>).toString();</span><br><span class="line">    </span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"aa"</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"bb"</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"cc"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果虚拟机检测到有这样一串 零碎小的操作 都是用一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，这样只需要加锁一次就可以了。</p>
<h2 id="平时写代码如何对synchronized优化"><a href="#平时写代码如何对synchronized优化" class="headerlink" title="平时写代码如何对synchronized优化"></a>平时写代码如何对synchronized优化</h2><h3 id="减少synchronized的范围"><a href="#减少synchronized的范围" class="headerlink" title="减少synchronized的范围"></a>减少synchronized的范围</h3><p>同步代码块中尽量短，禁烧同步代码块中代码的执行时间，减少锁的竞争。</p>
<h3 id="降低synchronized锁的粒度"><a href="#降低synchronized锁的粒度" class="headerlink" title="降低synchronized锁的粒度"></a>降低synchronized锁的粒度</h3><p>将一个锁拆分为多个锁提高并发度</p>
<p>HashTable：锁定整个哈希表，一个操作正在进行时，其他操作也同时锁定，效率低下：</p>
<p>ConcurrentHashMap：局部锁定，只锁定桶，当对当前元素锁定时，其他元素不锁定。</p>
<p>LinkedBlockingQueue入队和出队使用不同的锁，相对于读写只有一个锁效率要高。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------</span><br><span class="line">|<span class="string"> 元素1 </span>|<span class="string"> 元素2 </span>|<span class="string"> 元素3 </span>|<span class="string"> 元素4 </span>|<span class="string"> 元素5 </span>|</span><br><span class="line">----↑------------------------------↑-----</span><br><span class="line">    |<span class="string">                              </span>|</span><br><span class="line">take添加元素使用一把锁objb          put添加元素使用一把锁objA</span><br></pre></td></tr></table></figure>

<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>ConcurrentHashMap: CopyOnWriteArrayList和ConyOnWriteSet</p>
<p>读取时不加锁，写入和删除时加锁</p>

      
    </div>
    
    
    



<div>
    
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>Java面试热点问题，synchronized原理剖析与优化📝</a></p>
  <p><span>文章作者:</span>Fsn✨🧙‍♀️✨</a></p>
  <p><span>发布时间:</span>2020年06月06日 - 20:20:50🌞</p>
  <p><span>最后更新:</span>2020年06月06日 - 20:37:47🌜</p>
  <p><span>原始链接:</span><a href="/2020/06/06/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/" title="Java面试热点问题，synchronized原理剖析与优化">https://fengshana.github.io/2020/06/06/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://fengshana.github.io/2020/06/06/%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/%E3%80%90%E9%94%81%E3%80%91Java%E9%9D%A2%E8%AF%95%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8Csynchronized%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。🎄	</p>  
</div>
<style>
</style>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        //swal({   
          //title: "",   
         // text: '<div style="width:300px;height:100px;font-size:14px;">道友，复制成功了哟(＾Ｕ＾)ノ~</div>',   
          //html: true,
          //timer: 500,   
        //showConfirmButton: false
        //});
      });
      new ClipboardJS('.fa-clipboard', {
          target: function(trigger) {
              $('<div>').appendTo('body').addClass('alert alert-success').html('🤠道友ᕦ(･ㅂ･)ᕤ，🥭复制成功了哟(^_−)☆').show().delay(1500).fadeOut();
              return trigger.nextElementSibling;
            }
      });
    }));  
</script>


    
</div>



    








<div>
  
    <div>
    
        <br/>
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------🍓🍇本文结束🤞感谢道友的阅读🍍🍒-------------</div>
    
</div>
  
</div>












    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>🥕🍆坚持原创技术分享🐳，🌽🥬您的支持将鼓励我继续创作！🐬</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatreward.png" alt="Fsn✨🧙‍♀️✨ 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipayreward.png" alt="Fsn✨🧙‍♀️✨ 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    










    <footer class="post-footer">
      
        <div class="post-tags" style="text-align:center">
          
            <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">🌟面试</i></a>
          
            <a href="/tags/%E9%94%81/" rel="tag">🌟锁</i></a>
          
            <a href="/tags/synchronized/" rel="tag">🌟synchronized</i></a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/04/%E3%80%90JDK8%E3%80%91/%E6%9C%80%E6%96%B0JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%86%E9%A2%91_Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F+%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B+%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8BStreamAPI/" rel="next" title="最新JDK8新特性视频_Lambda表达式+函数式编程+流式编程StreamAPI">
                👈 最新JDK8新特性视频_Lambda表达式+函数式编程+流式编程StreamAPI
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80ODk3My8yNTQ2Nw=="></div>
    </div>

  
  
  

  
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/fsn.jpg"
                alt="Fsn✨🧙‍♀️✨" />
            
              <p class="site-author-name" itemprop="name">Fsn✨🧙‍♀️✨</p>
              <p class="site-description motion-element" itemprop="description">🌈勿忘初心💫 🌞，🌜方得始终⭐</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!--<a href="/archives/%7C%7Carchive">-->
                <a href="/archives/">
              
                  <span class="site-state-item-count">151</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">81</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/fengshana" target="_blank" title="GitHub">
                      
                        <i 

                          
                          class="fa fa-fw fa-github">
                          
                         
                        
                        </i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://space.bilibili.com/475144966" target="_blank" title="Bilibili">
                      
                        <i 

                          
                            class="">🏃‍♂️
                          
                         
                        
                        </i>Bilibili</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#课程介绍"><span class="nav-number">2.</span> <span class="nav-text">课程介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#深入学习并发编程中的synchronized"><span class="nav-number">2.1.</span> <span class="nav-text">深入学习并发编程中的synchronized</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可见性问题"><span class="nav-number">3.</span> <span class="nav-text">可见性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标"><span class="nav-number">3.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可见性概念"><span class="nav-number">3.2.</span> <span class="nav-text">可见性概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可见性演示"><span class="nav-number">3.3.</span> <span class="nav-text">可见性演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">3.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子性问题"><span class="nav-number">4.</span> <span class="nav-text">原子性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-1"><span class="nav-number">4.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性概念"><span class="nav-number">4.2.</span> <span class="nav-text">原子性概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性演示"><span class="nav-number">4.3.</span> <span class="nav-text">原子性演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-1"><span class="nav-number">4.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序性问题"><span class="nav-number">5.</span> <span class="nav-text">有序性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-2"><span class="nav-number">5.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序性概念"><span class="nav-number">5.2.</span> <span class="nav-text">有序性概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序性演示"><span class="nav-number">5.3.</span> <span class="nav-text">有序性演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-2"><span class="nav-number">5.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机结构"><span class="nav-number">6.</span> <span class="nav-text">计算机结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-3"><span class="nav-number">6.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机结构简介"><span class="nav-number">6.2.</span> <span class="nav-text">计算机结构简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU"><span class="nav-number">6.3.</span> <span class="nav-text">CPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存"><span class="nav-number">6.4.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存"><span class="nav-number">6.5.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-3"><span class="nav-number">6.6.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java内存模型的作用"><span class="nav-number">6.7.</span> <span class="nav-text">Java内存模型的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU缓存、内存与Java内存模型的关系"><span class="nav-number">6.8.</span> <span class="nav-text">CPU缓存、内存与Java内存模型的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-4"><span class="nav-number">6.9.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主内存与工作内存之间的数据交互过程"><span class="nav-number">7.</span> <span class="nav-text">主内存与工作内存之间的数据交互过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主内存与工作内存之间的交互"><span class="nav-number">7.1.</span> <span class="nav-text">主内存与工作内存之间的交互</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-4"><span class="nav-number">7.2.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-5"><span class="nav-number">7.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized保证原子性"><span class="nav-number">8.</span> <span class="nav-text">synchronized保证原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回顾synchronized的使用"><span class="nav-number">8.1.</span> <span class="nav-text">回顾synchronized的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-5"><span class="nav-number">8.2.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-synchronized-保证原子性"><span class="nav-number">8.3.</span> <span class="nav-text">使用 synchronized 保证原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-保证原子性的原理"><span class="nav-number">8.4.</span> <span class="nav-text">synchronized 保证原子性的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-6"><span class="nav-number">8.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized保证可见性"><span class="nav-number">9.</span> <span class="nav-text">synchronized保证可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-6"><span class="nav-number">9.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用synchronized保证可见性"><span class="nav-number">9.2.</span> <span class="nav-text">使用synchronized保证可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-保证可见性的原理"><span class="nav-number">9.3.</span> <span class="nav-text">synchronized 保证可见性的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-7"><span class="nav-number">9.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized保证有序性"><span class="nav-number">10.</span> <span class="nav-text">synchronized保证有序性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-7"><span class="nav-number">10.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要重排序"><span class="nav-number">10.2.</span> <span class="nav-text">为什么要重排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#as-if-serial语义"><span class="nav-number">10.3.</span> <span class="nav-text">as-if-serial语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用synchronized保证有序性"><span class="nav-number">10.4.</span> <span class="nav-text">使用synchronized保证有序性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-保证有序性的原理"><span class="nav-number">10.5.</span> <span class="nav-text">synchronized 保证有序性的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-8"><span class="nav-number">10.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized的可重入特性"><span class="nav-number">11.</span> <span class="nav-text">synchronized的可重入特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-8"><span class="nav-number">11.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是可重入"><span class="nav-number">11.2.</span> <span class="nav-text">什么是可重入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#演示可重入特性"><span class="nav-number">11.3.</span> <span class="nav-text">演示可重入特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重入原理"><span class="nav-number">11.4.</span> <span class="nav-text">可重入原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重入的好处"><span class="nav-number">11.5.</span> <span class="nav-text">可重入的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-9"><span class="nav-number">11.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized的不可中断性"><span class="nav-number">12.</span> <span class="nav-text">synchronized的不可中断性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-9"><span class="nav-number">12.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是不可中断"><span class="nav-number">12.2.</span> <span class="nav-text">什么是不可中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-不可中断演示"><span class="nav-number">12.3.</span> <span class="nav-text">synchronized 不可中断演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock可中断演示"><span class="nav-number">12.4.</span> <span class="nav-text">ReentrantLock可中断演示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javap反汇编学习synchronized的原理"><span class="nav-number">13.</span> <span class="nav-text">javap反汇编学习synchronized的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-10"><span class="nav-number">13.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitorenter"><span class="nav-number">13.2.</span> <span class="nav-text">monitorenter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitorexit"><span class="nav-number">13.3.</span> <span class="nav-text">monitorexit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题：synchronized与Lock的区别"><span class="nav-number">14.</span> <span class="nav-text">面试题：synchronized与Lock的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入JVM源码-monitor监视器锁"><span class="nav-number">15.</span> <span class="nav-text">深入JVM源码-monitor监视器锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-11"><span class="nav-number">15.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monitor监视器锁"><span class="nav-number">15.2.</span> <span class="nav-text">monitor监视器锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入JVM源码-monitor竞争"><span class="nav-number">16.</span> <span class="nav-text">深入JVM源码-monitor竞争</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入JVM源码-monitor等待"><span class="nav-number">17.</span> <span class="nav-text">深入JVM源码-monitor等待</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#monitor是重量级锁"><span class="nav-number">17.1.</span> <span class="nav-text">monitor是重量级锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入JVM源码-monitor释放"><span class="nav-number">18.</span> <span class="nav-text">深入JVM源码-monitor释放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入JVM源码-monitor是重量级锁"><span class="nav-number">19.</span> <span class="nav-text">深入JVM源码-monitor是重量级锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-CAS-AtomicInteger使用"><span class="nav-number">20.</span> <span class="nav-text">synchronized优化_CAS_AtomicInteger使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-12"><span class="nav-number">20.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS概述和作用"><span class="nav-number">20.2.</span> <span class="nav-text">CAS概述和作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS和volatile实现无锁并发"><span class="nav-number">20.2.1.</span> <span class="nav-text">CAS和volatile实现无锁并发</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-CAS原理"><span class="nav-number">21.</span> <span class="nav-text">synchronized优化_CAS原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsafe类介绍"><span class="nav-number">21.1.</span> <span class="nav-text">Unsafe类介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsafe实现CAS"><span class="nav-number">21.2.</span> <span class="nav-text">Unsafe实现CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乐观锁和悲观锁"><span class="nav-number">21.3.</span> <span class="nav-text">乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-10"><span class="nav-number">21.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化锁升级过程"><span class="nav-number">22.</span> <span class="nav-text">synchronized优化锁升级过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-对象的布局"><span class="nav-number">23.</span> <span class="nav-text">synchronized优化-对象的布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-13"><span class="nav-number">23.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象头"><span class="nav-number">23.2.</span> <span class="nav-text">对象头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mark-Word"><span class="nav-number">23.3.</span> <span class="nav-text">Mark Word</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-偏向锁"><span class="nav-number">24.</span> <span class="nav-text">synchronized优化-偏向锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#锁升级过程"><span class="nav-number">24.1.</span> <span class="nav-text">锁升级过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁"><span class="nav-number">24.2.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-14"><span class="nav-number">24.3.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是偏向锁"><span class="nav-number">24.4.</span> <span class="nav-text">什么是偏向锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-轻量级锁"><span class="nav-number">25.</span> <span class="nav-text">synchronized优化-轻量级锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-自旋锁"><span class="nav-number">26.</span> <span class="nav-text">synchronized优化-自旋锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-锁消除"><span class="nav-number">27.</span> <span class="nav-text">synchronized优化-锁消除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-15"><span class="nav-number">27.1.</span> <span class="nav-text">目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized优化-锁粗化"><span class="nav-number">28.</span> <span class="nav-text">synchronized优化-锁粗化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目标-16"><span class="nav-number">28.1.</span> <span class="nav-text">目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平时写代码如何对synchronized优化"><span class="nav-number">29.</span> <span class="nav-text">平时写代码如何对synchronized优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#减少synchronized的范围"><span class="nav-number">29.1.</span> <span class="nav-text">减少synchronized的范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#降低synchronized锁的粒度"><span class="nav-number">29.2.</span> <span class="nav-text">降低synchronized锁的粒度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写分离"><span class="nav-number">29.3.</span> <span class="nav-text">读写分离</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      


      
<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
<div class="widget-wrap">
    <div id="myCanvasContainer" class="widget tagcloud">
        <canvas width="300" height="300" id="resCanvas" style="width=100%; background-color:transparent;">
            <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ArrayList/" rel="tag">ArrayList</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B-%E6%A0%91/" rel="tag">B+树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B%E6%A0%91/" rel="tag">B树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CORS/" rel="tag">CORS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git%E5%B7%A5%E4%BD%9C%E6%B5%81/" rel="tag">Git工作流</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HASH%E8%A1%A8/" rel="tag">HASH表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">JVM虚拟机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MICROSERVICES/" rel="tag">MICROSERVICES</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql%E7%B4%A2%E5%BC%95/" rel="tag">MySql索引</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/" rel="tag">Oracle</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PayPal/" rel="tag">PayPal</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/" rel="tag">RabbitMQ实战指南</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" rel="tag">Redis设计与实现</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SendGrid/" rel="tag">SendGrid</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SprigBoot/" rel="tag">SprigBoot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/" rel="tag">Spring技术内幕</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sql/" rel="tag">Sql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vuejs/" rel="tag">Vuejs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaScript/" rel="tag">javaScript</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdk8/" rel="tag">jdk8</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/motto/" rel="tag">motto</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oss/" rel="tag">oss</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/synchronized/" rel="tag">synchronized</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/" rel="tag">tomcat</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%B2/" rel="tag">串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BF%A1666/" rel="tag">信666</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BF%A1666%E5%B7%A5%E4%BD%9C%E4%BA%A4%E6%8E%A5/" rel="tag">信666工作交接</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E9%A1%B5/" rel="tag">分页</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">前端面试题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E8%89%B2%E7%90%83/" rel="tag">双色球</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%A3%E8%AF%AD/" rel="tag">口语</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE/" rel="tag">图</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" rel="tag">存储过程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/" rel="tag">微信公众号</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E6%80%81/" rel="tag">心态</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E6%80%81%E8%AF%BE%E7%A8%8B/" rel="tag">心态课程</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E6%83%85/" rel="tag">心情</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%AF%E4%BB%98/" rel="tag">支付</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" rel="tag">数据库优化</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9F%A5%E6%89%BE/" rel="tag">查找</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" rel="tag">栈与队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/" rel="tag">流程图</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90/" rel="tag">理解分析</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%90%86%E8%B4%A2/" rel="tag">理财</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%90%86%E8%B4%A2%E5%AD%A6%E4%B9%A0/" rel="tag">理财学习</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%B4%E6%92%AD/" rel="tag">直播</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%8E%A5%E7%8F%AD%E4%BA%BA/" rel="tag">社会主义接班人</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" rel="tag">红黑树</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="tag">线性表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8B%B1%E8%AF%AD/" rel="tag">英语</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%8D%E6%B1%87/" rel="tag">词汇</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1/" rel="tag">邮件服务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%86%E8%B5%AB/" rel="tag">领赫</a><span class="tag-list-count">11</span></li></ul>
        </canvas>
    </div>
</div>



    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">🌱2019 🍄 🌳

<span itemprop="copyrightYear">2020</span>
  <span class="with-love">
  <!--user-->
    🍉
  </span>
 
 <span class="author" itemprop="copyrightHolder">Fsn✨🧙‍♀️✨</span>

  





  <script async src="http://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
 
     🏃‍♂️ 
    <span class="post-meta-item-icon">
      📈
    </span>
    
      <span class="post-meta-item-text">小屋💒总字数：</span>
    
	<span title="Site words total count">
     544.2k🌟 </span>
    <!--<span title="symbols_count_time.count_total">1m</span>-->
  
</div>



  <!-- <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>-->






<!--



 -->
 






        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-beta.2/lazyload.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  













  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  
  <script type="text/javascript" src="/js/src/exturl.js?v=5.1.4"></script>


  
  
  
  <!-- 
  
  -->
  <link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>

  <!-- 代码块复制功能    <script src="dist/clipboard.min.js"></script>-->
  <script type="text/javascript" src="/js/src/clipboard.min.js"></script>
  <script type="text/javascript" src="/js/src/clipboard-use.js"></script>
  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":250,"vOffset":-10},"mobile":{"show":false},"log":false,"tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>

<!--崩溃欺骗 <script type="text/javascript" src="/js/src/crash_cheat.js"></script> -->




