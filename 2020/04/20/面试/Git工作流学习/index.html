<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script>
	(function(){
		if(''){
			if (prompt('请输入文章密码','') !== ''){
				alert('密码错误！');
				history.back();
			}
		}
	})();
</script>









<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #A0A0A0; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #A0A0A0, 0 0 5px     #A0A0A0; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #A0A0A0;    /*上边框颜色*/
        border-left-color: #A0A0A0;    /*左边框颜色*/
    }
</style>

<meta name="theme-color" content="#222">










<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
    
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/fsn-16x16.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/fsn-32x32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/fsn-16x16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/fsn-16x16.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="笔记,Git工作流," />





  <link rel="alternate" href="/atom.xml" title="Fsn" type="application/atom+xml" />






<meta name="description" content="Git工作流指南 分布式版本控制系统观看笔记：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1dW411U7ER?p&#x3D;1老师笔记： http:&#x2F;&#x2F;www.funtl.com&#x2F;zh&#x2F;git&#x2F;   Git简介 什么是版本控制系统 什么是Git 如何安装Git  什么是版本控制系统为什么需要版本控制在软件开发过程中，每天都会产生新的代码，代码合并的过程中可能会出现如下问题：    代">
<meta property="og:type" content="article">
<meta property="og:title" content="Git工作流学习笔记">
<meta property="og:url" content="https://fengshana.github.io/2020/04/20/%E9%9D%A2%E8%AF%95/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Fsn">
<meta property="og:description" content="Git工作流指南 分布式版本控制系统观看笔记：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1dW411U7ER?p&#x3D;1老师笔记： http:&#x2F;&#x2F;www.funtl.com&#x2F;zh&#x2F;git&#x2F;   Git简介 什么是版本控制系统 什么是Git 如何安装Git  什么是版本控制系统为什么需要版本控制在软件开发过程中，每天都会产生新的代码，代码合并的过程中可能会出现如下问题：    代">
<meta property="og:image" content="http://r.photo.store.qq.com/psc?/V11rBmNJ1xB9lV/hsnfJ.a5yg7.BhItQyNwPel5t8xZU7rWNhfTxPiI2RfvYvQ6DvosmE1pGIqWlqAV7PfqYumXBoiVQ8HSQ88KfHkmwZxDHt.ymsgsHJsmdgw!/r">
<meta property="article:published_time" content="2020-04-20T02:21:22.445Z">
<meta property="article:modified_time" content="2020-04-24T01:36:46.271Z">
<meta property="article:author" content="Fsn">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="Git工作流">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://r.photo.store.qq.com/psc?/V11rBmNJ1xB9lV/hsnfJ.a5yg7.BhItQyNwPel5t8xZU7rWNhfTxPiI2RfvYvQ6DvosmE1pGIqWlqAV7PfqYumXBoiVQ8HSQ88KfHkmwZxDHt.ymsgsHJsmdgw!/r">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fengshana.github.io/2020/04/20/面试/Git工作流学习/"/>









  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "07d52b28"
    });
  daovoice('update');
  </script>

  <title>Git工作流学习笔记 | Fsn</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2a839053bb6194637483460a0f428730";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.js"></script>
<script src="https://unpkg.com/minigrid@3.1.1/dist/minigrid.min.js"></script>
<link rel="stylesheet" href="/photos/photos.css">
<script type="text/javascript" src="/photos/photo.js"></script>


<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fsn</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-camera">
          <a href="/photos/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-camera"></i> <br />
            
            相册
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sentence">
          <a href="/shuoshuo" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-commenting"></i> <br />
            
            小心情
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>







 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>[诗酒年华]</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>

        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fengshana.github.io/2020/04/20/%E9%9D%A2%E8%AF%95/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fsn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/fsn.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fsn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Git工作流学习笔记</h1>
        

        <div class="post-meta">
		

          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-20T10:21:22+08:00">
                2020-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  47
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox"
                 href="http://r.photo.store.qq.com/psc?/V11rBmNJ1xB9lV/hsnfJ.a5yg7.BhItQyNwPel5t8xZU7rWNhfTxPiI2RfvYvQ6DvosmE1pGIqWlqAV7PfqYumXBoiVQ8HSQ88KfHkmwZxDHt.ymsgsHJsmdgw!/r" rel="gallery_ck9zhhs9d00c2wgum97pzgxdu"
                 itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="http://r.photo.store.qq.com/psc?/V11rBmNJ1xB9lV/hsnfJ.a5yg7.BhItQyNwPel5t8xZU7rWNhfTxPiI2RfvYvQ6DvosmE1pGIqWlqAV7PfqYumXBoiVQ8HSQ88KfHkmwZxDHt.ymsgsHJsmdgw!/r" itemprop="contentUrl"/>
              </a>
            
          

          
          </div>
        </div>
      

      
        <h2 id="Git工作流指南-分布式版本控制系统"><a href="#Git工作流指南-分布式版本控制系统" class="headerlink" title="Git工作流指南 分布式版本控制系统"></a>Git工作流指南 分布式版本控制系统</h2><p>观看笔记：<a href="https://www.bilibili.com/video/BV1dW411U7ER?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1dW411U7ER?p=1</a><br>老师笔记： <a href="http://www.funtl.com/zh/git/" target="_blank" rel="noopener">http://www.funtl.com/zh/git/</a>  </p>
<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><ul>
<li>什么是版本控制系统</li>
<li>什么是Git</li>
<li>如何安装Git</li>
</ul>
<h3 id="什么是版本控制系统"><a href="#什么是版本控制系统" class="headerlink" title="什么是版本控制系统"></a>什么是版本控制系统</h3><h4 id="为什么需要版本控制"><a href="#为什么需要版本控制" class="headerlink" title="为什么需要版本控制"></a>为什么需要版本控制</h4><p>在软件开发过程中，每天都会产生新的代码，代码合并的过程中可能会出现如下问题：  </p>
<ul>
<li>代码被覆盖或丢失；</li>
<li>代码写的不理想，希望还原之前的版本；</li>
<li>希望知道与之前版本的差别；</li>
<li>是谁修改了代码以及为什么修改；</li>
<li>发版时希望分成不同的版本（测试版本、发行版本等）；</li>
</ul>
<p>因此，希望有一种机制，能够帮助我们：  </p>
<ul>
<li>可以随时回滚到之前的版本；</li>
<li>协同开发时，不会覆盖别人的代码；</li>
<li>留下修改记录，以便随时查看；</li>
<li>发版时可以方便的管理不同的版本；</li>
</ul>
<h4 id="什么是版本控制系统-1"><a href="#什么是版本控制系统-1" class="headerlink" title="什么是版本控制系统"></a>什么是版本控制系统</h4><p>一个标准的版本控制系统 Version Control System（VCS），通常需要有以下功能：  </p>
<ul>
<li>能够创建Repository（仓库），用来保存代码；</li>
<li>协同开发时，方便将代码分发给团队成员；</li>
<li>记录每次修改代码的内容、时间、原因等信息；</li>
<li>能够创建Branch（分支），可以根据不同的场景进行开发；</li>
<li>能够创建Tag（标签），建立项目里程碑；</li>
</ul>
<h4 id="版本控制系统的发展史"><a href="#版本控制系统的发展史" class="headerlink" title="版本控制系统的发展史"></a>版本控制系统的发展史</h4><p>版本控制系统发展至今有几种不同的模式：  </p>
<h5 id="Local-VCS"><a href="#Local-VCS" class="headerlink" title="Local VCS"></a>Local VCS</h5><p>本地使用 复制/粘贴 的方式进行管理，缺点是无法协同开发</p>
<h5 id="Gentralized-VCS（Lock，悲观锁）"><a href="#Gentralized-VCS（Lock，悲观锁）" class="headerlink" title="Gentralized VCS（Lock，悲观锁）"></a>Gentralized VCS（Lock，悲观锁）</h5><p>中央集中式版本控制系统团队共用仓库，当某人需要编辑文件时，进行锁定，以免其他人同时编辑时造成冲突，但不是很方便，其他人需要排队才能编辑文件，如果有人编辑了很久或是忘记解锁会造成其他人长时间等待的情况；  </p>
<p>如何理解悲观锁：总有刁民想害朕。<br>我要是面试这么答，会怎么样？  </p>
<h5 id="Gentralized-VCS（Merge，乐观锁）"><a href="#Gentralized-VCS（Merge，乐观锁）" class="headerlink" title="Gentralized VCS（Merge，乐观锁）"></a>Gentralized VCS（Merge，乐观锁）</h5><p>中央集中式版本控制系统团队共用仓库，不采用悲观锁方式来避免冲突，而是时候发现如果别人也修改相同文件（冲突），再进行手动修改解决。  </p>
<p>有很多VCS属于这种类型，如：CVS、Subversion、Perforce等；  </p>
<p>中央集中式版本控制系统的共同问题是，做任何操作都需要和服务器同步，如果服务器宕机则会造成无法继续工作的窘迫；  </p>
<p>如何理解乐观锁：天网恢恢疏而不漏。<br>我想给自己两锤子；  </p>
<h5 id="Distributed-VCS"><a href="#Distributed-VCS" class="headerlink" title="Distributed VCS"></a>Distributed VCS</h5><p>分布式版本控制系统，本地也拥有完整的代码仓库，就不会出现上述集中式管理的问题，即使没有网络，依然可以commit和看log，也无需担心服务器同步问题；  </p>
<p>如：Git、Mercurial、Bazaar等就属于分布式版本控制系统。缺点是功能比较复杂，上手需要一定的学习时间；  </p>
<p>（分布式版本控制系统都有一个本地化的这样一个概念；区块链系统也能称之为一个分布式系统）  </p>
<h2 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h2><p>Git工作流：代码管理的工作流程、方式  </p>
<ul>
<li>Git工作流简介</li>
<li>集中式工作流</li>
<li>功能分支工作流</li>
<li>GitFlow工作流</li>
<li>Forking工作流</li>
<li>Pull Requests</li>
</ul>
<h3 id="Git工作流简介"><a href="#Git工作流简介" class="headerlink" title="Git工作流简介"></a>Git工作流简介</h3><p>工作流有各式各样的用法，但也正因此使得在实际工作中如何上手使用增加了难度。  </p>
<p>这篇指南通过总览公司团队中最常用的集中Git工作流让大家可以上手使用；  </p>
<p>在阅读的过程中请记住，本文中的集中工作流是作为方案指导而不是条例规定，在展示了各种工作流可能的用法后，可以从不同的工作流中挑选或揉合出一个满足自己需求的工作流；  </p>
<h4 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXyIW2ezMoDhUXO*s5pTGue2N753CPNKcE42sPIP6l3d0rpu2DZjcGmC.Kga3cDUruqQwuWnPoetw.KevCfGSm5U!/r" alt="集中式工作流"></p>
<p>如果开发团队成员已经很熟Subversion，集中式工作流让你无需去适应一个全新流程就可以体验Git带来的收益。  </p>
<p>这个工作流也可以作为向更Git风格工作流迁移的友好过渡。  </p>
<p>（个人、三五个人的小团队）  </p>
<h4 id="功能分支工作流"><a href="#功能分支工作流" class="headerlink" title="功能分支工作流"></a>功能分支工作流</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX.QLkS1nyIjv6HHWnbV4dX7srariw7MEQpLi1gOAxL3ou18PqhQZr1mrBrEaIbVs5JuQWzjNbAd8lfxuJK8OGPM!/r" alt="功能分支工作流"></p>
<p>功能分支工作流以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发。  </p>
<p>这样可以在把新功能继承到正式项目前，用Pull  Requests的方式讨论变更；  </p>
<p>（达到约12个人的团队）  </p>
<h4 id="Git-Flow工作流"><a href="#Git-Flow工作流" class="headerlink" title="Git Flow工作流"></a>Git Flow工作流</h4><p>Git Flow工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更顺畅。  </p>
<p>严格的分支模型也为大型项目提供了一些非常必要的结构。  </p>
<p>（整个公司，这么一个团队的规模）  </p>
<h4 id="Forking工作流"><a href="#Forking工作流" class="headerlink" title="Forking工作流"></a>Forking工作流</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7NQkdqkFQWuuELLHKCcql5ABKaPDZFUejww*HH9qtsi8qr7IlATkqBkQ9PV1LJ9rT6faqWzcfgS3pJZnzLSzVg!/r" alt="Forking工作流"></p>
<p>Forking工作流是分布式工作流，充分利用了Git在分支和克隆上的优势。  </p>
<p>可以安全可靠地管理大团队的开发者（developer），并能接受不信任贡献者（contributor）的提交。  </p>
<p>（跨国合作。跨国团队的使用，一般用于Forking工作流）  </p>
<h4 id="Pull-Requests"><a href="#Pull-Requests" class="headerlink" title="Pull Requests"></a>Pull Requests</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXzYbgZ.02.6Smac50apszMyWGwg89uQEVJSVU01e69u2Dts1al5lueZ4HgBrr.WyV.0GtO*ZTdT3LpQtilbX2Vk!/r" alt="Pull Requests"></p>
<p>功能分支工作流、GitFlow工作流、Forking工作流都会穿插一个Pull Requests的一个东西。  </p>
<p>Pull Requests通常称为请求合并（Merge Pull Requests）；  </p>
<p>Pull Requests让开发者更方便地进行协作的功能，提供了友好的Web界面可以在提议的修改合并到正式项目之前对修改进行讨论。  </p>
<p>（相当于一个评论系统）；</p>
<h3 id="集中式工作流-1"><a href="#集中式工作流-1" class="headerlink" title="集中式工作流"></a>集中式工作流</h3><p>转到分布式版本控制系统看起来像个令人生畏的任务，但不改变已用的工作流你也可以用上Git带来的收益。  </p>
<p>团队可以用和Subversion完全不变的方式来开发项目。  </p>
<p>但使用Git加强开发的工作流，Git比SVN有几个优势。  </p>
<p>（1）首先，每个开发者可以有属于自己的整个工程的本地拷贝。隔离的环境让各个开发者的工作和项目的其他部分（修改）独立开来——-即自由地提交到自己的本地仓库，先完全忽略上游的开发，直到方便的时候再把修改反馈上去。  </p>
<p>（2）其次，Git提供了强壮的分支和合并模型。不像SVN，Git的分支设计成可以作为一种用来在仓库之间集成代码和分享修改的【失败安全】的机制。  </p>
<h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX58rubGqwbukXS4rvP.hcw8vVDFpcMEKyanOzFC60vYY7EfnKsFaNa8DYFcGkpbCkTOCu8b0QXObUxn8ABvZn4U!/r" alt="工作方式"></p>
<p>像Subversion一样，集中式工作流以中央仓库作为项目所有修改的单点实体。  </p>
<p>相比SVN缺省的开发分支trunk，Git叫做master，所有修改提交到这个分支上。  </p>
<p>该工作流只用到master这一个分支。  </p>
<p>开发者开始先克隆中央仓库。  </p>
<p>在自己的项目拷贝中，像SVN一样的编辑文件和提交修改；  </p>
<p>但修改是存在本地的，和中央仓库完全隔离的；  </p>
<p>开发者可以把和上游的同步延后到一个方便时间点；  </p>
<p>要发布修改到正式项目中，开发者要把本地master分支的修改【推（push）】到中央仓库中。  </p>
<p>这相当于svn  commit操作，但push操作会把所有还不在中央仓库的本地提交都推上去。  </p>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7NAq94egRJ5nBPO8Co87th*P0cTdtAGYXp43mklxBxvhd73.i5d8Lm58WdsFYNrarV7XZaiqfrmkd3gUFAFW0o!/r" alt="解决冲突"></p>
<p>中央仓库代表了正式项目，所以提交历史应该被尊重且是稳定不变的。  </p>
<p>如果开发者本地的提交历史和中央仓库有分歧，Git会拒绝push提交否则会覆盖已经在中央库的正式提交。  </p>
<p>在开发者提交自己功能修改到中央库前，需要先fetch在中央库的新增提交，rebase自己提交到中央库提交历史之上。  </p>
<p>这样做的意思是在说，【我要把自己的修改加到别人已经完成的修改上。】最终的结果是一个完美的线性历史，就像以前的SVN的工作流中一样；  </p>
<p>如果本地修改和上游提交有冲突，Git会暂停rebase过程，给你手动解决冲突的机会。  </p>
<p>Git解决合并冲突，用和生成提交一样的git  status和git add命令，很一致方便。  </p>
<p>还有一点，如果解决冲突时遇到麻烦，Git可以很简单中止整个rebase操作，重来一次（或者让别人来帮助解决）。  </p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>一起逐步分解来看看一个常见的小团队如何用这个工作流来协作的。  </p>
<p>有两个开发者小明和小红，看他们是如何开发自己的功能并提交到中央仓库上的。  </p>
<h5 id="有人先初始化好中央仓库"><a href="#有人先初始化好中央仓库" class="headerlink" title="有人先初始化好中央仓库"></a>有人先初始化好中央仓库</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX9UbT3uXKi44e*o.QOIDNJOk403REJAlPsZkIyST70GEweXbAbks3cFR7TqiVMFHAtTg9MXSvYT6HSyIH1eLii4!/r" alt="有人先初始化好中央仓库"></p>
<p>第一步，有人在服务器上创建好中央仓库。  </p>
<p>如果是新项目，可以初始化一个空仓库；否则要导入已有的Git或SVN仓库。  </p>
<p>中央仓库应该是个裸仓库（bare repository），即没有工作目录（working directory）的仓库。  </p>
<h5 id="所有人克隆中央仓库"><a href="#所有人克隆中央仓库" class="headerlink" title="所有人克隆中央仓库"></a>所有人克隆中央仓库</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX8lXRlkamDF*h*SxpL42PuUsH4aIULseTwL66K.p5pWkVzGz*Bh8Nih.I7qaVf43t7zoP8GGUp44vHNS*NRccIY!/r" alt="所有人克隆中央仓库"></p>
<p>下一步，各个开发者创建整个项目的本地拷贝。  </p>
<p>通过git clone命令完成。  </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span>  <span class="title">https</span>://github.com/path/to/repo.git</span><br></pre></td></tr></table></figure>

<p>基于后续会持续和克隆的仓库做交互的假设，克隆仓库时Git会自动添加远程别名origin指回【父】仓库。  </p>
<p>github即git的中央仓库；版本控制系统有一个版本仓库。  </p>
<p>github上public即开源，公开的意思，代码开源。  </p>
<p>如果是私有private则需要进行CreditCard 信用卡支付相应的金额；收费；  </p>
<h5 id="小明开发功能"><a href="#小明开发功能" class="headerlink" title="小明开发功能"></a>小明开发功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX3cSXX6681Ge8WeUymk3FFjspNtDVB3t7XeHuVufMD05ZhJzX9OyWJDCYAlloD65QJLNRkDaLpYfFLKjESAA0SM!/r" alt="小明开发功能"></p>
<p>在小明的本地仓库中，他使用标准的Git过程开发功能：编辑、暂存（Stage）和提交。  </p>
<p>如果你不熟悉暂存区（Stageing Area），这里说明一下：暂存区的用来准备一个提交，但可以不用把工作目录中所有的修改内容都包含进来。  </p>
<p>这样可以创建一个高度聚焦的提交，尽管本地修改很多内容。  </p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status <span class="comment"># 查看本地仓库的修改状态</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> <span class="comment"># 暂存文件</span></span></span><br><span class="line">git commit <span class="comment"># 提交文件</span></span><br></pre></td></tr></table></figure>

<p>请记住，因为这些命令生成的是本地提交，小明可以按自己需求反复操作多次，而不用担心中央仓库有了什么操作。  </p>
<p>对需要多个更简单更原子分块的大功能，这个做法是很有用的；  </p>
<h5 id="小红开发功能"><a href="#小红开发功能" class="headerlink" title="小红开发功能"></a>小红开发功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX3AhXN0w*Kh7FwIloQiq3PMOUwp*anqXsBqPo.yaxL1hWnR.kZm*XseG5RhBNtuoS8.PVSKuKSdHEw1x7MixOxA!/r" alt="小红开发功能"></p>
<p>与此同时，小红在自己的本地仓库中用相同的编辑、暂存和提交过程开发功能。  </p>
<p>和小明一样，她也不关心中央仓库有没有新提交；当然更不关心小明在他的本地仓库中的操作，因为所有本地仓库都是私有的。  </p>
<h5 id="小明发布功能"><a href="#小明发布功能" class="headerlink" title="小明发布功能"></a>小明发布功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX2DDMKOOXZiA6a0j82260kNXKGqba7MbMMt5OmvuzTfK3A*Lxszb8CTdFEjjZXvIDOZez3cKxhQHt2dZMB.G9S4!/r" alt="小明发布功能"></p>
<p>一旦小明完成了他的功能开发，会发布他的本地提交到中央仓库中，这样其他团队成员可以看到他的修改。  </p>
<p>他可以用下面的git push  命令：  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure>

<p>注意，origin是小明克隆仓库时Git创建的远程中央仓库别名。  </p>
<p>master参数告诉Git推送的分支。  </p>
<p>由于中央仓库自从小明克隆以来还没有被更新过，所以push操作不会有冲突，成功完成。  </p>
<h5 id="小红试着发布功能"><a href="#小红试着发布功能" class="headerlink" title="小红试着发布功能"></a>小红试着发布功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX49Hssuuk2yHbmsbkSdUuOtLRbTxRlP3xEORKm5txDWaExKbZyYnyzyBD0oDqcjETeUWkabVFxZpo*3gs9yQWHs!/r" alt="小红试着发布功能"></p>
<p>一起来看看在小明发布修改后，小红push修改会怎么样？  </p>
<p>她使用完全一样的push命令：  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure>

<p>但她的本地历史已经和中央仓库有分歧了，Git拒绝操作并给出下面很长的出错消息：  </p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error: failed <span class="keyword">to</span> push some refs <span class="keyword">to</span> <span class="string">'/path/to/repo.git'</span></span><br><span class="line">hin<span class="variable">t:</span> Updates were rejected because the tip of your current branch <span class="keyword">is</span> behind</span><br><span class="line">hin<span class="variable">t:</span> its remote counterpart. Merge the remote <span class="keyword">changes</span>(<span class="keyword">e</span>.g. <span class="string">'git pull'</span>)</span><br><span class="line">hin<span class="variable">t:</span> before pushing again.</span><br><span class="line">hin<span class="variable">t:</span> See the <span class="string">'Note about fast-forwards'</span> in <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>这避免了小红覆写正式的提交。  </p>
<p>她要先pull小明的更新到她本地仓库合并上她的本地修改后，再重试。  </p>
<h5 id="小红在小明的提交之上rebase"><a href="#小红在小明的提交之上rebase" class="headerlink" title="小红在小明的提交之上rebase"></a>小红在小明的提交之上rebase</h5><p>小红用git pull 合并上游的修改到自己的仓库中。  </p>
<p>这条命令类似svn update ——-拉取所有上游提交命令到小红的本地仓库，并尝试和她本地修改合并。  </p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">--rebase origin master</span></span><br></pre></td></tr></table></figure>

<p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXyi6Y8l5sb1aRwQRlb0CiRDNdgM9NZtfk5D41PvfJEccriZP3FT6WnQ4PWKvEqz*e7LpBOfcXui.l9nUXAPUgd4!/r" alt="images"></p>
<p>–rebase 选项告诉Git把小红的提交移到同步了中央仓库修改后的master分支的顶部；  </p>
<p>如果忘了加这个选项，pull操作仍然可以完成，但每次pull操作要同步中央仓库别人修改时，提交历史会以一个多余的【合并提交】结尾。  </p>
<p>对于集中式工作流，最好是使用rebase而不是生成一个合并提交。  </p>
<h5 id="小红解决合并冲突"><a href="#小红解决合并冲突" class="headerlink" title="小红解决合并冲突"></a>小红解决合并冲突</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7FxPBYYYsKKPOWXqC*0rCPhZKJRqU86pJwCJIVi3g31ZcpHEH2b76upvPK6lrEAQ9UWa9VqeFjlEC4dX2PAHTw!/r" alt="小红解决合并冲突"></p>
<p>rebase操作过程是把本地提交一次一个地迁移到更新了的中央仓库master分支之上，这意味着可能要解决在迁移某个提交时出现的合并冲突，而不是解决包含了所有提交的大型合并时所出现的冲突。  </p>
<p>这样的方式让你尽可能保持每个提交的聚焦和项目历史的整洁。  </p>
<p>反过来，简化了哪里引入Bug的分析，如果有必要，回滚修改也可以做到对项目影响最小。  </p>
<p>如果小红和小明的功能是相关的，不大可能在rebase过程中有冲突。  </p>
<p>如果有，Git在合并有冲突的提交出暂停rebase过程，输出下面的信息并带上相关的指令：  </p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONFLICT</span> (content): Merge <span class="keyword">conflict</span> <span class="keyword">in</span></span><br></pre></td></tr></table></figure>

<p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX5fiCqpawh2bvFoyuusAOSGHKu5sc59EGgvKP1aVmHVmey3BEhEwMSvuvtOXh1oSZU1zNvf5QV2G*SN2a1sgwiA!/r" alt="images"></p>
<p>Git 很赞的一点是，任何人可以解决他自己的冲突。  </p>
<p>在这个例子中，小红可以简单的运行 git status 命令来查看哪里有问题。  </p>
<p>冲突文件列在 Unmerged paths（未合并路径）一节中：  </p>
<figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Unmerged paths：</span><br><span class="line"><span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">use</span> <span class="string">"git reset HEAD &lt;some-file&gt;..."</span> <span class="variable">to</span> <span class="variable">unstage</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">use</span> <span class="string">"git add/rm &lt;some-file&gt;..."</span> <span class="variable">as</span> <span class="variable">appropriate</span> <span class="variable">to</span> <span class="variable">mark</span> <span class="variable">resolution</span>)</span></span></span><br><span class="line">#</span><br><span class="line"># both modified:&lt;some-file&gt;</span><br></pre></td></tr></table></figure>

<p>接着小红编辑这些文件。  </p>
<p>修改完成后，用老套路暂存这些文件，并让git rebase 完成剩下的事情：  </p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span></span><br><span class="line"><span class="bash">git rebase --<span class="built_in">continue</span></span></span><br></pre></td></tr></table></figure>

<p>要做的就这些了。  </p>
<p>Git会继续一个一个的合并后面的提交，如其他的提交有冲突就重复这个过程。  </p>
<p>如果你碰到了冲突，但是发现搞不定，不要惊慌。  </p>
<p>只要执行下面这条命令，就可以回到你执行git pull –rebase命令前的样子：  </p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase <span class="comment">--abort</span></span><br></pre></td></tr></table></figure>

<h5 id="小红成功发布功能"><a href="#小红成功发布功能" class="headerlink" title="小红成功发布功能"></a>小红成功发布功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX0kBnWeNL8ejRYU6ro4.2u6jfdf4WmDKrAtmoAnmJ9TQ4sDBTQl0i3xlqRsJMoYZns72c0lo3zm5ObKWH4CoUG0!/r" alt="小红成功发布功能"></p>
<p>小红完成和中央仓库的同步之后，就能成功发布她的修改了。  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>如你所见，仅仅使用几个Git命令，就可以模拟出传统Subversion开发环境。  </p>
<p>对于要从SVN迁移过来的团队来说这太好了，但是没有发挥出Git分布式本质的优势。  </p>
<p>如果你的团队适应了集中式工作流，但想要更流畅的协作效果，绝对值得探索一下功能分支工作流的收益。  </p>
<p>通过为一个功能分配一个专门的分支，能够做到一个新增功能集成到正式项目之前对新功能进行深入讨论。  </p>
<h3 id="功能分支工作流-1"><a href="#功能分支工作流-1" class="headerlink" title="功能分支工作流"></a>功能分支工作流</h3><p>一旦玩转了集中式工作流，在开发过程中可以很简单地加上功能分支，用来鼓励开发者之间协作和简化交流。  </p>
<p>功能分支工作流背后的核心思路是所有的功能开发应该在一个专门的分支，而不是在master分支上。  </p>
<p>这个隔离可以方便多个开发者在各自的功能上开发而不会弄乱主干代码。  </p>
<p>另外，也保证了master分支的代码一定不会是有问题的，极大有利于集成环境。  </p>
<p>功能开发隔离也让pull  requests工作流成为可能， pull requests工作流能为每一个分支发起一个讨论，在分支合入正式项目之前，给其它开发者有表示赞同的机会。  </p>
<p>另外，如果你在功能开发中有问题卡出了，可以开一个pull Requests来向同学们征求建议。  </p>
<p>这些做法的重点就是，pull Requests让团队成员之间互相评论工作变成非常方便！  </p>
<h4 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h4><p>功能分支工作流仍然用中央仓库，并且master分支还是代表了正式项目的历史。  </p>
<p>但不是直接提交本地历史到各自的本地master分支，开发者每次在开始新功能前先创建一个新分支。  </p>
<p>功能分支应该有个描述性的名字，比如 animated-menu-items 或者  issue-#1061，这样可以让分支有个清楚且高聚焦的用途。  </p>
<p>在master分支和功能分支之间，Git是没有技术上的区别，所以开发者可以用和集中式工作流完全一样的方式编辑、暂存和提交修改到功能分支上。  </p>
<p>另外，功能分支也可以（且应该）push到中央仓库中。  </p>
<p>这样不修改正是代码就可以和其他开发者分享提交的功能。  </p>
<p>由于master仅有的一个【特殊】分支，在中央仓库上存在多个功能分支不会有任何问题。  </p>
<p>当然这样做也可以很方便地备份各自的本地提交。  </p>
<h4 id="Pull-Requests-1"><a href="#Pull-Requests-1" class="headerlink" title="Pull Requests"></a>Pull Requests</h4><p>功能分支除了可以隔离功能的开发，也使得通过 Pull Requests讨论变更称为可能。  </p>
<p>一旦某个开发完成一个功能，不是立即合并到master，而是push到中央仓库的功能分支上并发起一个Pull Requests的请求去合并并修改到master。  </p>
<p>在修改成为主干代码之前，这让其他的开发者有机会先去Review变更。  </p>
<p>Code Review是Pull Requests的一个重要的收益。  </p>
<p>但是pull Requests目的是讨论代码一个通用方式。  </p>
<p>你可以把Pull  Requests作为专门给某个分支的讨论。  </p>
<p>这意味着可以在更早的开发过程中就可以进行Code Review。  </p>
<p>比如，一个开发者开发功能需要帮助时，要做的就是发起一个Pull Requests，相关的人就会自动收到通知，在相关的提交旁边能看到需要帮助解决的问题。  </p>
<p>一旦Pull  Requests被接受了，发布功能要做的就和集中式工作流就很像了。  </p>
<p>（1）首先，确定本地的master分支和上游的master分支是同步的。  </p>
<p>（2）然后合并功能分支到本地master分支，并push已经更新的本地master分支到中央仓库。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>下面的示例演示了如何把Pull Requests作为Code Review的方式，但注意Pull Requests可以用于很多其他的目的。  </p>
<h5 id="小红开始开发一个新功能"><a href="#小红开始开发一个新功能" class="headerlink" title="小红开始开发一个新功能"></a>小红开始开发一个新功能</h5><p>在开始开发功能之前，小红需要一个独立的分支。  </p>
<p>使用下面的命令新建一个分支。  </p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> checkout -<span class="keyword">b </span><span class="keyword">marys-feature </span>master</span><br></pre></td></tr></table></figure>

<p>这个命令检出一个基于master名为marys-feature的分支，Git的-b选项表示如果分支还不存在则新建分支。  </p>
<p>这个新分支上，小红按照老套路编辑、暂存和提交修改，按需要提交以实现功能：  </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span>  <span class="string">status</span></span><br><span class="line"><span class="attr">git</span> <span class="string">add</span></span><br><span class="line"><span class="attr">git</span> <span class="string">commit</span></span><br></pre></td></tr></table></figure>

<h5 id="小红要去吃个午饭"><a href="#小红要去吃个午饭" class="headerlink" title="小红要去吃个午饭"></a>小红要去吃个午饭</h5><p>（两个人、多个人同时开发，称之为协同开发）  </p>
<p>仓库：github、码云、码市、gitlab  </p>
<p>review 代码审核；  </p>
<p>早上小红为新功能添加了一些提交。  </p>
<p>去吃午饭前，push功能分支到中央仓库是很好的做法，这样可以方便地备份，如果和其他开发协作，也让他们可以看到小红的提交。  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> -u <span class="built_in">origin</span> marys-<span class="built_in">feature</span></span><br></pre></td></tr></table></figure>

<p>这条命令  push marys-feature 分支到中央仓库（origin），-u选项设置本地分支去跟踪远程对应的分支。  </p>
<p>设置好跟踪的分支后，小红就可以使用git push 命令省去指定推送分支的参数。  </p>
<h5 id="小红完成功能开发"><a href="#小红完成功能开发" class="headerlink" title="小红完成功能开发"></a>小红完成功能开发</h5><p>小红吃完午饭回来，完成整个功能的开发。  </p>
<p>在合并到master之前，她发起一个Pull Requests让团队的其他人知道功能已经完成。  </p>
<p>但是首先，她要确认中央仓库中已经有她最近的提交。  </p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure>

<p>然后，在她的Git GUI客户端中发起Pull Request，请求合并marys-feature到master，团队成员会自动收到通知。  </p>
<p>Pull Request很酷的是可以在相关的提交旁边显示评注，所以你可以很对某个变更集提问。  </p>
<h5 id="小黑收到Pull-Request"><a href="#小黑收到Pull-Request" class="headerlink" title="小黑收到Pull  Request"></a>小黑收到Pull  Request</h5><p>小黑收到Pull Request后会查看marys-feature的修改。  </p>
<p>决定在合并到正式项目前是否要做些修改，且通过Pull Request和小红来回的讨论。  </p>
<h5 id="小红再做修改"><a href="#小红再做修改" class="headerlink" title="小红再做修改"></a>小红再做修改</h5><p>要在做修改，小红用和功能第一个迭代完全一样的过程。  </p>
<p>编辑、暂存、提交并push更新到中央仓库。  </p>
<p>小红这些活动都会显示在Pull Request上，小黑可以断续做评注。  </p>
<p>如果小黑有需要，也可以把marys-feature分支拉到本地，自己来修改，他加的提交也会一样显示在Pull Request上。  </p>
<h5 id="小红发布她的功能"><a href="#小红发布她的功能" class="headerlink" title="小红发布她的功能"></a>小红发布她的功能</h5><p>一旦小黑可以接受Pull Request，就可以合并功能到稳定项目代码中（可以由小黑或者是小红来做这个操作）：  </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">checkout master</span></span><br><span class="line"><span class="attr">git</span> <span class="string">pull</span></span><br><span class="line"><span class="attr">git</span> <span class="string">pull origin marys-feature</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push</span></span><br></pre></td></tr></table></figure>

<p>无论谁来做合并，首先要检出master分支并确认它是最新的。  </p>
<p>然后执行 git pull origin marys-feature 合并 marys-feature 分支到已经和远程一直的本地 master分支。  </p>
<p>你可以使用简单 git merge marys-feature命令，但是前面的命令可以保证总是最新的新功能分支。  </p>
<p>最后更新的master分支要重新push回到origin。  </p>
<p>这个过程常常会生成一个和并提交。  </p>
<p>有些开发者喜欢有合并提交。  </p>
<p>因为它像一个新功能和原来代码基线的连通符。  </p>
<p>但如果你偏爱线性的提交历史，可以在执行合并rebase新功能到master分支的顶部，这样生成一个快进（fast-forward）的合并。  </p>
<p>一些GUI客户端只要点一下【接受】按钮执行好上面的命令来自动化Pull Request接受过程。  </p>
<p>如果你的不能这样，至少在功能合并到master分子后自动关闭Pull Request。  </p>
<h5 id="与此同时，小明在做和小红一样的事情"><a href="#与此同时，小明在做和小红一样的事情" class="headerlink" title="与此同时，小明在做和小红一样的事情"></a>与此同时，小明在做和小红一样的事情</h5><p>当小红和小黑在marys-feature上工作并讨论她的Pull  Request的时候，小明在自己的功能分支上做完全一样的事情。  </p>
<p>通过隔离功能能到独立的分支上，每个人都可以自主的工作，当然必要的时候在开发者之间分享变更还是比较繁琐的。  </p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>到了这里，但愿你发现了功能分支可以很直接地在集中式工作流的仅有的master分支上完成多功能的开发。  </p>
<p>另外，功能分支还使用了Pull Request，使得可以在你的版本控制GUI客户端中讨论某个提交。  </p>
<p>功能分支工作流是开发项目异常灵活的方式。  </p>
<p>问题是，有时候太灵活了。  </p>
<p>对于大型团队，常常需要给不同分支分配一个更具体的角色。  </p>
<p>GitFlow工作流是管理功能开发、发布准备和维护的常用模式。  </p>
<h3 id="GitFlow工作流"><a href="#GitFlow工作流" class="headerlink" title="GitFlow工作流"></a>GitFlow工作流</h3><p>在实际开发当中，可能通常使用GitFlow工作流。  </p>
<p>GitFlow工作流定义了一个围绕项目发布的严格分支模型。  </p>
<p>虽然比功能分支工作流复杂几分，但是提供了一个用于健壮的用于管理大型项目的框架。  </p>
<p>GitFlow工作流没有用超出功能分支工作流的概念和命令。  </p>
<p>而是为不同的分支分配了一个很明确的角色，并定义分支之间如何交互和什么时候进行交互。  </p>
<p>除了使用功能分支，在做准备、维护和记录发布也是用各自的分支。  </p>
<p>当然你可以用上功能分支工作流所有的好处：Pull Request、隔离实验性开发和更高效的工作。  </p>
<h4 id="工作方式-2"><a href="#工作方式-2" class="headerlink" title="工作方式"></a>工作方式</h4><p>GitFlow工作流仍然用中央仓库作为所有开发者的交互中心。  </p>
<p>和其他工作流一样，开发者在本地工作并push分子到中央分支去。  </p>
<h5 id="历史分支"><a href="#历史分支" class="headerlink" title="历史分支"></a>历史分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX0DucqArpSZN8V1mN.Djx7WchltIFUxePFkxo0wF6tL9hJ92GPpyK1meBHYC6jQnh92Uk6*6zENCWbjq21uqLsI!/r" alt="历史分支"></p>
<p>相对使用仅有的一个master分支，GitFlow工作流使用两个分支来记录项目的历史。  </p>
<p>master分支存储了正式发布的历史，而develop分支作为功能的集成分支，这样也方便master分支上的所有提交分配一个版本号。  </p>
<p>剩下要说明的问题就是围绕这两个分支的区别展开。  </p>
<h5 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX4suzD8O2OoWbYPwQ150IFWgQS3qSKoLWdglLxIjfri4eWAHC*W6m9OYJM0vFH4CxIhXiOdTBQYoWLsUJ3d8M.k!/r" alt="功能分支"></p>
<p>每个新功能位于一个自己的分支，这样可以push到中央仓库以备份和协作。  </p>
<p>但是功能分支不是从master分支上拉出新分支，而是使用develop分支作为父分支。  </p>
<p>当新功能完成时，合并会develop分支。  </p>
<p>新功能提交应该从不直接与master分支交互。  </p>
<p>开源软件基本上是使用GitFlow来做代码版本管理的控制。  </p>
<p>注意，从各种含义和目的上来看，功能分支加上develop分支就是功能分支工作流的用法。  </p>
<p>但是GitFlow工作流没有在这里止步。  </p>
<h5 id="发布分支"><a href="#发布分支" class="headerlink" title="发布分支"></a>发布分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX1K5y5ivKrS*rhk3l.NtQVVaNHmKMdlqKelqYaRENh70*1X*IrEmFCJIhfs5U7wXELfZbYI1tihPDOGBwBPqt6E!/r" alt="发布分支"></p>
<p>一旦develop分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从develop分支上fork一个发布分支。  </p>
<p>新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上——-这个分支只应该叫Bug修复、文档生成或其他面向发布任务。  </p>
<p>一旦对外发布的工作都完成了，发布分支合并到master分支并飞配一个版本号打好Tag。  </p>
<p>另外，这些新建发部分之以来做的修改要合并回develop分支。  </p>
<p>使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。  </p>
<p>这也打造定义良好的开发阶段（比如，可以很轻松的说，【这周我们要做准备发布版本4.0】，并且在仓库的目录结构中可以实际看到）  </p>
<p>常用的分支约定：  </p>
<ul>
<li>用于新建发布分支的分支：develop</li>
<li>用于合并的分支：master</li>
<li>分支命名：release- 或 release/</li>
</ul>
<h5 id="维护分支"><a href="#维护分支" class="headerlink" title="维护分支"></a>维护分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX8qfvx9q8UhYcwpU4tSoxZoCzp2TGnchoEgJnBAd**ejGrSWx7H1n1RbZFVAdVlD7v3kEO6EHjpPFNMCD9pabTQ!/r" alt="维护分支"></p>
<p>维护分支或者说是热修复（hotfix）分支用于生成快速给产品发布版本（production release）打补丁，这是唯一可以从master分支fork出来的分支。  </p>
<p>修复完成，修改应该马上合并回master分支和develop分支（当前的发部分支），master分支应该用新的版本号打好Tag。  </p>
<p>为了Bug修复使用专门分支，让团队可以处理问题而不用打断其他工作或者是等待下一个发布循环。  </p>
<p>你可以把维护分支想成是一个直接在master分支上处理的临时发布。  </p>
<p>即hotfix，维护的是v1.0.0—&gt;v1.0.1这种；<br>第三位数修改的是Bug（hotfix维护版本第三位数）；第二位数修改的是功能（功能分支维护的是版本的第二位数）；第一位为大架构改变的时候进行修改（维护版本的第一位数）；  </p>
<p>GitFlow从这点上就可以与语义化规范牵扯上联系；  </p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>下面的示例演示本工作流如何用于管理单个发布循环。  </p>
<p>假设你已经创建了一个中央仓库。  </p>
<h5 id="创建开发分支"><a href="#创建开发分支" class="headerlink" title="创建开发分支"></a>创建开发分支</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX4Xsg92Awirp0bThQ4n*YW8UWB.U5*XFBFsn5hkNOcst0hBz.q1uwuu*KDADM.W9naZBQq8eKQyo4iLkzk28e1g!/r" alt="创建开发分支"></p>
<p>第一步为master分支配套一个develop分支。  </p>
<p>简单来做可以本地创建一个空的develop分支，push到服务器上：  </p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>develop</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>-u origin master</span><br></pre></td></tr></table></figure>

<p>以后这个分支将会包含了项目的全部历史。  </p>
<p>而master分支将只包含部分历史。  </p>
<p>其他开发者这时应该克隆中央仓库，建好develop分支的跟踪分支：  </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">ssh</span>://user@host/path/to/repo.git</span><br><span class="line">git checkout -b develop origin/develop</span><br></pre></td></tr></table></figure>

<p>现在每个开发都有了这些历史分支的本地拷贝。  </p>
<h5 id="小红和小明开始开发新功能"><a href="#小红和小明开始开发新功能" class="headerlink" title="小红和小明开始开发新功能"></a>小红和小明开始开发新功能</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX2X16EiSaoizI9a2HRgo6HRlddb*dD0yGRzorFtrKInoqDMveDkX4.ujU1ZgrgxXoZf1vY83YLzd6Dl2YO5SDUc!/r" alt="小红和小明开始开发新功能"></p>
<p>这个示例中，小红和小明开始各自的功能开发。  </p>
<p>他们需要为各自的功能创建相应的分支。  </p>
<p>新分支不是基于master分支，而是应该基于develop分支：  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="built_in">some</span>-<span class="built_in">feature</span> develop</span><br></pre></td></tr></table></figure>

<p>他们用老套路添加提交到各自功能分支上：编辑、暂存、提交；  </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">status</span></span><br><span class="line"><span class="attr">git</span> <span class="string">add</span></span><br><span class="line"><span class="attr">git</span> <span class="string">commit</span></span><br></pre></td></tr></table></figure>

<h5 id="小红完成功能开发-1"><a href="#小红完成功能开发-1" class="headerlink" title="小红完成功能开发"></a>小红完成功能开发</h5><p>添加了提交后，小红觉得她的功能OK了。  </p>
<p>如果团队使用Pull Requests，这时候可以发起一个用于合并到develop分支。  </p>
<p>否则她可以直接合并到她本地的develop分之后push到中央仓库：  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="built_in">origin</span> develop</span><br><span class="line">git checkout develop</span><br><span class="line">git merge <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line">git <span class="built_in">push</span></span><br><span class="line">git branch -d <span class="built_in">some</span>-<span class="built_in">feature</span></span><br></pre></td></tr></table></figure>

<p>第一条命令在合并功能前确保develop分支是最新的。  </p>
<p>注意，功能绝不应该直接合并到master分支。  </p>
<p>冲突解决方法和集中式工作流一样。  </p>
<h5 id="小红开始准备发布"><a href="#小红开始准备发布" class="headerlink" title="小红开始准备发布"></a>小红开始准备发布</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXxm6aYd1gMGOxylETc6cDcj7kTwBnGuyoyzYDL7pNxxvtXeo*D5bCxnVfWE*k.cQe8O4lhgkHo2zR.IIDII1kmA!/r" alt="小红开始准备发布"></p>
<p>这个时候小明正在实现他的功能。  </p>
<p>小红开始准备她的第一个项目正式发布（发布分支也叫预发布分支，预发布分支基于develop，只有预发布版本分支才能够去合并到master分支，而预发布版本是经过测试人员测试之后的没有问题的一个版本；master分支代码必须可以执行，没有被污染）。  </p>
<p>像功能开发一样，她用一个新的分支来做发布准备。  </p>
<p>这一步也确定了发布的版本号：  </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b release<span class="number">-0.1</span> develop</span><br></pre></td></tr></table></figure>

<p>这个分支是清理分支、执行所有测试、更新文档和其他为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。  </p>
<p>只要小红创建的这个分支push到中央仓库，这个发布就是功能冻结的。  </p>
<p>任何不在develop分支中的新功能都推到下一个发布循环中。  </p>
<h5 id="小红完成发布"><a href="#小红完成发布" class="headerlink" title="小红完成发布"></a>小红完成发布</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXx2fdZ*.CxsTwPMg235DDXkchbPbk7hNVec6.FIcmcf72k0vjzhdQvVlYt8u8ao*65n3gyQAyN5GOxndJKhwiNk!/r" alt="小红完成发布"></p>
<p>一旦准备好了对外发布，小红合并修改到master分支和develop分支上，删除发布分支。  </p>
<p>合并回develop分支很重要，因为在发布分支中已经提交的更新需要在后面的新功能中也要是可用的。  </p>
<p>另外，如果小红的团队要求Code  Review，这是一个发起Pull Request的理想时机。  </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">checkout master</span></span><br><span class="line"><span class="attr">git</span> <span class="string">merge release-0.1</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push</span></span><br><span class="line"><span class="attr">git</span> <span class="string">checkout develop</span></span><br><span class="line"><span class="attr">git</span> <span class="string">merge release-0.1</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push</span></span><br><span class="line"><span class="attr">git</span> <span class="string">branch -d release-0.1</span></span><br></pre></td></tr></table></figure>

<p>发布分支是作为功能开发（develop分支）和对外发布（master分支）间的缓冲。  </p>
<p>只要有合并到master分支，就应该打好Tag以方便跟踪。  </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-a</span> <span class="number">0.1</span> -m <span class="string">"Initial public release"</span> <span class="literal">master</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<p>Git有提供各种钩子（hook），即仓库有时间发生时触发执行的脚本。  </p>
<p>可以配置一个钩子，在你push中央仓库的master分支时，自动构建好对外发布。  </p>
<h5 id="最终用户发现Bug"><a href="#最终用户发现Bug" class="headerlink" title="最终用户发现Bug"></a>最终用户发现Bug</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXzsQH1hJotlrx1khR6EZ0dUlyxkaf9L1Yi66Fs6sohYE0UTifJNygNHa*okiIgZc5dg2qSXBW*VyQGtiyMr0yo8!/r" alt="最终用户发现Bug"></p>
<p>对外发布后，小红回去和小明一起做下个发布的新功能开发，直到有最终用户开了一个Ticket抱怨当前版本的一个Bug。  </p>
<p>为了处理Bug，小红（或者小明）从master分支上来去了一个维护分支（hotfix），提交修改以解决问题，然后直接合并回master分支：  </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b issue-<span class="comment">#001 master</span></span><br><span class="line"><span class="comment"># Fix the bug</span></span><br><span class="line">git checkout <span class="literal">master</span></span><br><span class="line">git merge issue-<span class="comment">#001</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>就像发布分支，维护分支中新加这些重要修改需要包含到develop分支中，所以小红要执行一个合并操作，然后就可以安全地删除这个分支了：  </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">checkout develop</span></span><br><span class="line"><span class="attr">git</span> <span class="string">merge issue-#001</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push</span></span><br><span class="line"><span class="attr">git</span> <span class="string">branch -d issue-#001</span></span><br></pre></td></tr></table></figure>

<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>到了这里，但愿你对集中式工作流、功能分支工作流和GitFlow工作流已经感觉很舒适了。  </p>
<p>你应该也牢固的掌握了本地仓库的潜能，push/pull模式和Git健壮的分支和合并模型。  </p>
<p>记住，这里演示的工作流只是可能用法的例子，而不是在实际工作中使用Git不可违逆的条例。  </p>
<p>所以不要畏惧按自己需要对工作流的用法做取舍，不变的目标就是让Git为你所用。  </p>
<p>（在整个GitFlow工作流当中，只会去进行省略功能分支Feature，Master、HotFix、Release、Develop是必不可少的分支，以便控制每一次版本的迭代）  </p>
<h3 id="Forking工作流-1"><a href="#Forking工作流-1" class="headerlink" title="Forking工作流"></a>Forking工作流</h3><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX2qjPC0eDN.Xf29HcBYoAsTtpBFvJhu8qPVkh5cv575QWLsHx3q8JbFYK3X5cts.Zn43gkCjc7OzyBcDFaNdl.g!/r" alt="Forking工作流"></p>
<p>Forking工作流和前面讨论的几种工作流有根本的不同。  </p>
<p>这种工作流不是适用单个服务器端仓库作为【中央】代码基线，而让各个开发者都有一个服务端仓库。  </p>
<p>这意味着各个代码贡献者有2个Git仓库而不是1个：一个本地私有的，另一个服务端公开的。  </p>
<p>Forking工作流的一个主要优势是，贡献的代码可以被集成，而不需要所有人都能push代码到仅有的中央仓库中。  </p>
<p>开发者push到自己的服务端仓库，而只有项目维护者才能push到正式仓库。  </p>
<p>这样项目维护者可以接受任何开发者的提交，但无需给他正式代码库的写权限。  </p>
<p>效果就是一个分布式的工作流，能为大型、自发性的团队（包括了不受信的第三方）提供灵活的方式来安全的写作。  </p>
<p>也让这个工作流称为开源项目的理想工作流。  </p>
<h4 id="工作方式-3"><a href="#工作方式-3" class="headerlink" title="工作方式"></a>工作方式</h4><p>和其他的Git工作流一样，Forking工作流要先有一个公开的正式仓库存储在服务器上，但一个新的开发者想要在项目上工作时，不是直接从正式仓库克隆，而是fork正式项目在服务器上创建一个拷贝。  </p>
<p>这个仓库拷贝作为他人公开仓库—–其他开发者不允许push到这个仓库，但可以pull到修改（后面很快就会看到这点很重要）。  </p>
<p>在创建了自己服务端拷贝之后，和之前的工作流一样，开发者执行git clone命令克隆仓库到本地机器上，作为私有的开发环境。  </p>
<p>要提交本地修改时，push提交到自己公开仓库中——-而不是正式仓库中。  </p>
<p>然后，给正式仓库发起一个pull request，让项目维护者知道有更新已经准备好可以集成了。  </p>
<p>对于贡献的代码，pull request也可以很方便地作为一个讨论的地方。  </p>
<p>为了集成功能到正式代码库，维护者pull贡献者的变更到自己的本地仓库中，检查变更以确保不会让项目出错，合并变更到自己本地的master分支，然后push master分支到服务器的正式仓库中。  </p>
<p>到此，贡献的提交成为了项目的一部分，其他的开发者应该执行pull操作与正式仓库同步自己本地仓库。  </p>
<h5 id="正式仓库"><a href="#正式仓库" class="headerlink" title="正式仓库"></a>正式仓库</h5><p>在Forking工作流中，【官方】仓库的叫法只是一个约定，理解这点很重要。  </p>
<p>从技术上来看，各个开发者仓库和正式仓库在Git卡那里没有任何区别。  </p>
<p>事实上，让正式仓库之所以正式的唯一原因是他是项目维护者的公开仓库。  </p>
<h5 id="Forking工作流的分支使用方式"><a href="#Forking工作流的分支使用方式" class="headerlink" title="Forking工作流的分支使用方式"></a>Forking工作流的分支使用方式</h5><p>所有的个人公开仓库实际商只是为了方便和其他的开发者共享分支。  </p>
<p>各个开发者应该用分支隔离各个功能，就像功能分支工作流和GitFlow工作流一样。  </p>
<p>唯一的区别是这些分支被共享了。  </p>
<p>在Forking工作流中这些分支会被pull到另一个开发者的本地仓库中，而在功能分支工作流和GitFlow工作流中是直接被push到正式仓库当中。  </p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><h5 id="项目维护者初始化正式仓库"><a href="#项目维护者初始化正式仓库" class="headerlink" title="项目维护者初始化正式仓库"></a>项目维护者初始化正式仓库</h5><p>和任何使用Git项目一样，第一步还是创建在服务器上一个正式仓库，让所有团队成员都可以访问到。  </p>
<p>通常这个仓库也会作为项目维护者的公开仓库。  </p>
<p>公开仓库应该是裸仓库，不管是不是正式代码库。  </p>
<p>所以项目维护者会运行像下面的命令来搭建正式仓库：  </p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh user<span class="symbol">@host</span></span><br><span class="line">git init --bare /path/<span class="keyword">to</span>/repo.git</span><br></pre></td></tr></table></figure>

<p>Bitbucket和Stash提供了一个方便的GUI客户端已完成上面命令行做的事。  </p>
<p>这个搭建中央仓库的过程和前面提到的工作流完全一样。  </p>
<p>如果有现存的代码库，维护者也要push到这个仓库中。  </p>
<h5 id="开发者fork正式仓库"><a href="#开发者fork正式仓库" class="headerlink" title="开发者fork正式仓库"></a>开发者fork正式仓库</h5><p>其他所有的开发需要fork正式仓库。  </p>
<p>可以用git clone命令用SSH协议连通到服务器，拷贝仓库到服务器另一个位置—–是的，fork操作基本上就只是一个服务端的克隆。  </p>
<p>Bitbucket和Stash上可以点一下按钮就让开发者完成仓库的fork操作。  </p>
<p>这一步完成后，每个开发都在服务端有一个自己的仓库。  </p>
<p>和正式仓库一样，这些仓库应该是裸仓库。  </p>
<h5 id="开发者克隆自己fork出来的仓库"><a href="#开发者克隆自己fork出来的仓库" class="headerlink" title="开发者克隆自己fork出来的仓库"></a>开发者克隆自己fork出来的仓库</h5><p>下一步，各个开发者要克隆自己的公开仓库，用熟悉的git clone命令。  </p>
<p>在这个示例中，假定用Bitbucket托管了仓库。  </p>
<p>记住，如果这样的话各个开发者需要有各自的Bitbucket账号，使用下面命令克隆服务端自己的仓库。  </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://user@bitbucket.org/user/repo.git</span><br></pre></td></tr></table></figure>

<p>相比前面介绍的工作流只用了一个origin远程别名指向中央仓库，Forking工作流需要2个远程别名——-一个指向正式仓库，另一个指向开发者自己的服务端仓库。  </p>
<p>别名的名字可以任意命名，常见的约定是使用origin作为远程克隆的仓库的别名（这个别名会在运行git clone自动创建），upstream（上游）作为正式仓库的别名。  </p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span> upstream https://bitbucket<span class="meta">.org</span>/maintainer/repo</span><br></pre></td></tr></table></figure>

<p>需要自己用上面的命令创建upstream别名。  </p>
<p>这样可以简单地保持本地仓库和正式仓库的同步更新。  </p>
<p>注意，如果上游仓库需要认证（比如不是开源的），你需要提供用户：  </p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span> upstream https://user@bitbucket<span class="meta">.org</span>/maintainer/repo</span><br></pre></td></tr></table></figure>

<p>这时在克隆和pull正式仓库时，需要提供用户的密码。  </p>
<h5 id="开发者开发自己的功能"><a href="#开发者开发自己的功能" class="headerlink" title="开发者开发自己的功能"></a>开发者开发自己的功能</h5><p>在刚克隆的本地仓库中，开发者可以向其他工作流一样的编辑代码、提交修改和新建分支：  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line">// Edit <span class="built_in">some</span> code</span><br><span class="line">git commit -a -m <span class="string">"Add first draft of some feature"</span></span><br></pre></td></tr></table></figure>

<p>所有的修改都是私有的直到push到自己公开仓库中。  </p>
<p>如果正式项目已经向前走了，可以用git pull命令获得新的提交：  </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull upstream <span class="literal">master</span></span><br></pre></td></tr></table></figure>

<p>由于开发者应该都在专门的功能分支上工作，pull操作结果会都是快进合并。  </p>
<h5 id="开发者发布自己的功能"><a href="#开发者发布自己的功能" class="headerlink" title="开发者发布自己的功能"></a>开发者发布自己的功能</h5><p>一旦开发者准备好了分享新功能，需要做两件事。  </p>
<p>（1）首先，通过push他的贡献代码到自己的公开仓库中，让其他的开发者都可以访问到。他的origin远程别名应该已经有了，所有要做的就是：  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span>  <span class="built_in">feature</span>-branch</span><br></pre></td></tr></table></figure>

<p>这里和之前的工作流的差异是，origin远程别名指向开发者自己的服务端仓库，而不是正式仓库。  </p>
<p>（2）第二件事，开发者要通知项目维护者，想要合并他的新功能到正式库中。Bitbucket和Stash提供了Pull Request按钮，弹出个表单让你指定哪个分支要合并到正式仓库。一般你会想集成你的功能分支到上游远程仓库的master分支中。  </p>
<h5 id="项目维护者集成开发者的功能"><a href="#项目维护者集成开发者的功能" class="headerlink" title="项目维护者集成开发者的功能"></a>项目维护者集成开发者的功能</h5><p>当项目维护者收到pull request时，他要做的是决定是否集成它到正式代码库中。  </p>
<p>有两种方式来做：  </p>
<ul>
<li>直接在pull request中查看代码</li>
<li>pull代码到他自己的本地仓库，再手动合并</li>
</ul>
<p>第一种做法更简单，维护者可以在GUI中查看变更的差异，做评注和执行合并。  </p>
<p>但如果出现了合并冲突，需要第二种做法来解决。  </p>
<p>这种情况下，维护者需要从开发者的服务端仓库中fetch功能分支，合并到他本地的master分支，解决冲突：  </p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch https:<span class="regexp">//</span>bitbucket.org<span class="regexp">/user/</span>repo feature-branch</span><br><span class="line"><span class="regexp">//</span>查看变更</span><br><span class="line">git checkout master</span><br><span class="line">git merge FETCH_HEAD</span><br></pre></td></tr></table></figure>

<p>变更集成到本地的master分支后，维护者要push变更到服务器上的正式仓库，这样其他的开发者都能访问到：  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure>

<p>注意，维护者的origin是指向他自己公开仓库的，即是项目的正式代码库。  </p>
<p>到此，开发者的贡献完全集成到了项目中。  </p>
<h5 id="开发者和正式仓库做同步"><a href="#开发者和正式仓库做同步" class="headerlink" title="开发者和正式仓库做同步"></a>开发者和正式仓库做同步</h5><p>由于正式代码库往前走了，其他的开发需要和正式仓库做同步：  </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull upstream <span class="literal">master</span></span><br></pre></td></tr></table></figure>

<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>如果你之前是使用SVN，Forking工作流可能看起来像是一个激进的范式切换（paradigm shift）。  </p>
<p>但是不要害怕，这个工作流实际上就是在功能分支工作流之上引入了另一个抽象层。  </p>
<p>不是直接通过单个中央仓库来分享分支，而是把贡献代码发布到开发者自己的服务端仓库中。  </p>
<p>示例中解释了，一个贡献如何从一个开发者流到正式的master分支中，但是同样的方法可以把贡献集中到任意一个仓库中。  </p>
<p>比如，如果团队的几个人协作实现一个功能，可以在开发之间用相同的方法分享变更，完全不涉及正式仓库。  </p>
<p>这使得Forking工作流对于松散组织的团队来说是个非常强大的工具。  </p>
<p>任一开发者可以方便地和另一开发者分享变更，任何分支都能有效地合并到正式代码库中。  </p>
<h3 id="Pull-Requests-2"><a href="#Pull-Requests-2" class="headerlink" title="Pull Requests"></a>Pull Requests</h3><p>Pull Requests 是Bitbucket上方便开发者之间协作的功能。  </p>
<p>提供了一个用户友好的Web界面，在集成提交的变更到正式向目前可以对变更进行讨论。  </p>
<p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX1zLLMp65VmnavK5XDJUKS6zYUJDvvIJN*Lt1FNUoIJG0DkTCKRNuOGToGtjWmjIrVLu*fSpHVogAtzO4DgCm80!/r" alt="images"></p>
<p>开发者向团队成员通知功能开发已经完成，pull Requests是最简单的用法。  </p>
<p>开发者完成功能开发后，通过Bitbucket账号发起一个pull Request。这样让涉及这个功能的所有人知道，要去做Code Review和合并到master分支。  </p>
<p>但是，Pull  Request远不止一个简单的通知，而是为讨论提交的功能的一个专门论坛。  </p>
<p>如果变更有任何问题，团队成员反馈在Pull Request中，甚至pull新的提交微调功能。  </p>
<p>所有的这些活动都直接跟踪在Pull Request中。  </p>
<p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7SLIJSUYxrmcZpwuXYsQB1Ya2zpcBawWJ7atpdZcoSsGWSrxt3XnkjpSfeaAffmHrs3SyEpgZCaBKHAdN3ReSA!/r" alt="images"></p>
<p>相比其他的协作模型，这种分享提交的形式有助于打造一个更流畅的工作流。  </p>
<p>SVN和Git都能通过一个简单的脚本收到通知邮件；  </p>
<p>但是，讨论变更时，开发者通常只能去回复邮件。  </p>
<p>这样做会变得杂乱，尤其还要涉及后面的几个提交时。  </p>
<p>Pull Requests吧所有相关功能整合到一个和Bitbucket仓库界面集成的用户友好Web界面中。  </p>
<h4 id="解析Pull-Request"><a href="#解析Pull-Request" class="headerlink" title="解析Pull Request"></a>解析Pull Request</h4><p>当腰发起一个pull Request，你所要做的就是请求（Request）另一个开发者（比如项目的维护者），来pull你仓库中一个分支到他的仓库中。  </p>
<p>这意味着你要提供4个信息（源仓库、源分支、目的仓库、目的分支），以发起Pull Request。  </p>
<p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX7SLIJSUYxrmcZpwuXYsQB1Ya2zpcBawWJ7atpdZcoSsGWSrxt3XnkjpSfeaAffmHrs3SyEpgZCaBKHAdN3ReSA!/r" alt="images"></p>
<h4 id="工作方式-4"><a href="#工作方式-4" class="headerlink" title="工作方式"></a>工作方式</h4><p>Pull Request可以和功能分支工作流、GitFlow工作流或Forking工作流一起使用。  </p>
<p>但Pull Request要求要么分支不同，要么仓库不同，所以不能用于集中式工作流。  </p>
<p>在不同的工作流中使用pull  Request会有一些不同，但基本的过程是这样的：  </p>
<ul>
<li>开发者在本地仓库新建一个专门的分支开发功能；</li>
<li>开发者push分支修改到公开的Bitbucket仓库中；</li>
<li>开发者通过Bitbucket发起一个Pull Request；</li>
<li>团队的其他成员review code，讨论并修改；</li>
<li>项目维护者合并功能到官方仓库中并关闭Pull Request；</li>
</ul>
<h4 id="在功能分支工作流中使用Pull-Request"><a href="#在功能分支工作流中使用Pull-Request" class="headerlink" title="在功能分支工作流中使用Pull Request"></a>在功能分支工作流中使用Pull Request</h4><p>功能分支工作流用一个共享的Bitbucket仓库来管理协作，开发者在专门的分支上开发功能。  </p>
<p>但不是立即合并到master分支上，而是在合并到主代码之前开发这应该开一个Pull Request发起功能的讨论。  </p>
<p>功能分支工作流只有一个公开的仓库，所以Pull Request的目的仓库和源仓库总是同一个。  </p>
<p>通常开发者会指定他的功能分支作为源分支，master分支作为目的分支。  </p>
<p>收到Pull Request后，项目维护者要决定如何做。  </p>
<p>如果功能没问题，就简单地合并到master分支，关闭Pull Request。  </p>
<p>但如果提交的变更有问题，他可以在Pull Request中反馈，之后的新加的评论也会评论之后接着显示出来。  </p>
<p>在功能还没有完全开发完的时候，也可能发起一个pull Request。  </p>
<p>比如开发者在实现某个需求时遇到了麻烦。  </p>
<p>他可以发一个包含正在进行工作的Pull Request。  </p>
<p>其他的开发者可以在Pull Request提供建议，或者甚至直接添加提交来解决问题。  </p>
<h4 id="在GitFlow工作流中使用Pull-Request"><a href="#在GitFlow工作流中使用Pull-Request" class="headerlink" title="在GitFlow工作流中使用Pull Request"></a>在GitFlow工作流中使用Pull Request</h4><p>GitFlow工作流和功能分支工作流类似，单围绕项目发布定义一个严格的分支模型。  </p>
<p>在GitFlow工作流中使用Pull Request让开发者在发布分支或者是维护分支上工作时，可以有个方便的地方对关于发布分支或者是维护分支的问题进行交流。  </p>
<p>GitFlow工作流中Pull Request的使用过程和上一节中完全一致：当一个功能、发布或者是热修复分支需要Review时，开发者简单发起一个Pull Request，团队的其他成员会通过Bitbucket收到通知。  </p>
<p>新功能一般合并到develop分支，而发布和热修复则要同时合并到develop分支和master分支上。  </p>
<p>Pull Request可能用作所有合并的正式管理。  </p>
<h4 id="在Forking工作流中使用Pull-Request"><a href="#在Forking工作流中使用Pull-Request" class="headerlink" title="在Forking工作流中使用Pull Request"></a>在Forking工作流中使用Pull Request</h4><p>在Forking工作流中，开发者push完成的功能到他自己的仓库中，而不是共享仓库。  </p>
<p>然后，他发一个Pull  Request，让项目维护者知道他的功能已经可以Review了。  </p>
<p>在这个工作流，Pull Request的通知功能非常有用，因为项目维护者不可能知道其他开发者在他们自己的仓库添加了提交。  </p>
<p>由于各个开发者有自己的公开仓库，Pull Request的源仓库和目标仓库不是同一个。  </p>
<p>源仓库是开发者的公开仓库，源分支是包含了修改的分支。  </p>
<p>如果开发者要合并修改到正式代码库中，那么目标仓库是正式仓库，目标分支是master分支。  </p>
<p>Pull Request也可以用于正式项目之外的其他开发者之间的协作。  </p>
<p>比如，如果一个开发者和一个团队成员一起开发一个功能，他们可以发起一个Pull Request，用团队成员的Bitbucket仓库作为目标，而不是正式项目的仓库。  </p>
<p>然后使用相同的功能分支作为源和目标分支。  </p>
<p>2个开发者之间可以在Pull Request中讨论和开发功能。  </p>
<p>完成开发后，他们可以发起另一个Pull  Request，请求合并功能到正式的master分支。  </p>
<p>在Forking工作流中，这样的灵活性称为一个强有力的协作工具。  </p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>下面的示例演示了Pull Request如何在Forking工作流中使用。  </p>
<p>也同样适用于小团队的开发协作和第三方开发者向开源项目的贡献。  </p>
<p>在示例中，小红是个开发，小明是项目维护者。  </p>
<p>他们各自有一个公开的Bitbucket仓库，而小明的仓库包含了正式工程。  </p>
<h5 id="小红fork正式项目"><a href="#小红fork正式项目" class="headerlink" title="小红fork正式项目"></a>小红fork正式项目</h5><p>小红先要fork小明的Bitbucket仓库，开始项目的开发。  </p>
<p>她登录Bitbucket，浏览到小明的仓库页面，点fork按钮。  </p>
<p>然后为fork出来的仓库填写名字和描述，这样小红就有了服务端的项目拷贝了。  </p>
<h5 id="小红克隆她的Bitbucket仓库"><a href="#小红克隆她的Bitbucket仓库" class="headerlink" title="小红克隆她的Bitbucket仓库"></a>小红克隆她的Bitbucket仓库</h5><p>下一步，小红克隆自己刚才fork出来的Bitbucket仓库，以在本机上准备出工作拷贝。  </p>
<p>命令如下：  </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://user@bitbucket.org/user/repo.git</span><br></pre></td></tr></table></figure>

<p>请记住，git clone 会自动创建origin远程别名，是指向小红fork出来的仓库。  </p>
<h5 id="小红开发新功能"><a href="#小红开发新功能" class="headerlink" title="小红开发新功能"></a>小红开发新功能</h5><p>在开始改代码前，小红要为新功能新建一个新分支。  </p>
<p>她会用这个分支作为Pull Request的源分支。  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="built_in">some</span>-<span class="built_in">feature</span></span><br></pre></td></tr></table></figure>

<h5 id="编辑代码"><a href="#编辑代码" class="headerlink" title="编辑代码"></a>编辑代码</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -<span class="keyword">a</span> -m <span class="string">"Add first draft of some feature"</span></span><br></pre></td></tr></table></figure>

<p>在新功能分支上，小红按照需要添加提交。  </p>
<p>甚至如果小红觉得功能分支上的提交历史太乱了，她可以用交互式rebase来删除或者压制提交。  </p>
<p>对于大型项目，整理功能分支的历史可以让项目维护者更容易看出在pull Request中做了什么内容。  </p>
<h5 id="小红push功能到她的Bitbucket仓库中"><a href="#小红push功能到她的Bitbucket仓库中" class="headerlink" title="小红push功能到她的Bitbucket仓库中"></a>小红push功能到她的Bitbucket仓库中</h5><p>小红完成功能后，push功能到她自己的Bitbucket仓库中（不是正是仓库），用下面简单的命令。  </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> <span class="built_in">some</span>-branch</span><br></pre></td></tr></table></figure>

<p>这时她的变更可以让项目维护者看到了（后者任何想要看的协作者）  </p>
<h5 id="小红发起Pull-Request"><a href="#小红发起Pull-Request" class="headerlink" title="小红发起Pull Request"></a>小红发起Pull Request</h5><p>Bitbucket上有了她的功能分支后，小红可以用她的Bitbucket账号浏览到她fork出来的仓库页面，点右上角的[ Pull Request ]按钮，发起一个Pull Request。  </p>
<p>弹出的表单自动设置小红的仓库为源仓库，询问小红以指定源分支、目标仓库和目标分支。  </p>
<p>小红想要合并功能到正式仓库，所以源分支是她的功能分支，目标仓库是小明的公开仓库，而目标分支是master分支。  </p>
<p>另外，小红需要提供Pull Request的标题和描述信息。  </p>
<p>如果需要小明以外的人审核批准diamante，她可以把这些人填在[ Reviewers ]文本框中。  </p>
<p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANX4eBUNEH.PnD8cXLFX3FNQ1TY28uOV3j2Ic*FLo6qk1HERoVGDzy.ccPi6KWHQ1Ha7aF4qrprhr6a71aswRPe1s!/r" alt="images"></p>
<p>创建好了Pull Request，通知会通过Bitbucket系统消息或者邮件（可选）发给小明。  </p>
<h5 id="小明-review-Pull-Request"><a href="#小明-review-Pull-Request" class="headerlink" title="小明 review Pull Request"></a>小明 review Pull Request</h5><p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXz.TEdJt9fHfFvRXR*aihUCZBZl8OSFD1T7r*7GIRRSRDePO5EI5YO0pxG7Qo02eHht0.LfxlnFiUPPKgPzRY4U!/r" alt="images"></p>
<p>在小明的Bitbucket仓库页面的[ Pull Request ]Tab可以看到所有人发起的Pull Request。  </p>
<p>点击小红的Pull Request会显示Pull Request的描述、功能的提交历史和每个变更的差异（diff）。  </p>
<p>如果小明想要合并到项目中，只要点一下[ Merge ]按钮，就可以同意Pull Request并合并到master分支。  </p>
<p>但如果像这个示例中一样，小明发现了在小红的代码中的一个小Bug，要在小红合并前修复。  </p>
<p>小明可以在整个Pull Request上加上评注，或者是选择历史中的某个提交加上评注。  </p>
<p><img src="http://r.photo.store.qq.com/psc?/V13IdniL4CDhqM/TCfiP1YaPeRT4Jil9RANXywJcEdXUnF5drr2Tn8vpOshxucsOMz.iW9qg*vXiM80CBz6VcPZTn4e7NC2txFi9Xf.oe9HyW39vilYdBhizv0!/r" alt="images"></p>
<h5 id="小红补加提交"><a href="#小红补加提交" class="headerlink" title="小红补加提交"></a>小红补加提交</h5><p>如果小红对反馈有任何疑问，可以在Pull Request中响应，把Pull Request当做是她功能讨论的论坛。  </p>
<p>小红在她的功能分支新加提交以解决代码问题，并push到她的Bitbucket仓库中，就像前一轮中的做饭一样。  </p>
<p>这些提交会进入到Pull Request，小明在原来的评注旁边可以再次Review 变更。  </p>
<h5 id="小明接受Pull-Request"><a href="#小明接受Pull-Request" class="headerlink" title="小明接受Pull Request"></a>小明接受Pull Request</h5><p>最终，小明接受变更，合并功能分支到master分支，并关闭Pull Request。  </p>
<p>至此，功能集成到项目中，其他的项目开发者可以用标准的git pull命令pull这些变更到自己的本地仓库中。  </p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>到了这里，你应该有了所有需要的工具来集成Pull Request到你自己的工作流。  </p>
<p>请记住，Pull Request并不是为了替代任何基于Git的协作工作流，而是它们的一个便利的补充，让团队成员间的协作更加轻松方便。  </p>

      
    </div>
    
    
    



<div>
    
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>Git工作流学习笔记</a></p>
  <p><span>文章作者:</span>Fsn</a></p>
  <p><span>发布时间:</span>2020年04月20日 - 10:21:22</p>
  <p><span>最后更新:</span>2020年04月24日 - 09:36:46</p>
  <p><span>原始链接:</span><a href="/2020/04/20/%E9%9D%A2%E8%AF%95/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AD%A6%E4%B9%A0/" title="Git工作流学习笔记">https://fengshana.github.io/2020/04/20/%E9%9D%A2%E8%AF%95/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AD%A6%E4%B9%A0/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://fengshana.github.io/2020/04/20/%E9%9D%A2%E8%AF%95/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AD%A6%E4%B9%A0/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        swal({   
          title: "",   
          text: '复制成功',   
          html: false,
          timer: 500,   
          showConfirmButton: false
        });
      });
    }));  
</script>


    
</div>



    








<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  
</div>












    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatreward.png" alt="Fsn 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipayreward.png" alt="Fsn 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    










    <footer class="post-footer">
      
        <div class="post-tags" style="text-align:center">
          
            <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag">笔记</i></a>
          
            <a href="/tags/Git%E5%B7%A5%E4%BD%9C%E6%B5%81/" rel="tag"><i class="fa fa-tag">Git工作流</i></a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/20/%E9%9D%A2%E8%AF%95/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="next" title="微服务架构的分布式事务控制解决方案">
                <i class="fa fa-chevron-left"></i> 微服务架构的分布式事务控制解决方案
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/20/%E4%BB%8A%E5%B9%B4%E8%A6%81%E4%B9%B0%E7%9A%84%E4%B8%9C%E8%A5%BF/" rel="prev" title="想一想自己为什么要去面试？">
                想一想自己为什么要去面试？ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80ODk3My8yNTQ2Nw=="></div>
    </div>

  
  
  

  
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/fsn.jpg"
                alt="Fsn" />
            
              <p class="site-author-name" itemprop="name">Fsn</p>
              <p class="site-description motion-element" itemprop="description">勿忘初心，方得始终</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!--<a href="/archives/%7C%7Carchive">-->
                <a href="/archives/">
              
                  <span class="site-state-item-count">135</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/fengshana" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Git工作流指南-分布式版本控制系统"><span class="nav-number">1.</span> <span class="nav-text">Git工作流指南 分布式版本控制系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git简介"><span class="nav-number">2.</span> <span class="nav-text">Git简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是版本控制系统"><span class="nav-number">2.1.</span> <span class="nav-text">什么是版本控制系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么需要版本控制"><span class="nav-number">2.1.1.</span> <span class="nav-text">为什么需要版本控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是版本控制系统-1"><span class="nav-number">2.1.2.</span> <span class="nav-text">什么是版本控制系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#版本控制系统的发展史"><span class="nav-number">2.1.3.</span> <span class="nav-text">版本控制系统的发展史</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Local-VCS"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">Local VCS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Gentralized-VCS（Lock，悲观锁）"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">Gentralized VCS（Lock，悲观锁）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Gentralized-VCS（Merge，乐观锁）"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">Gentralized VCS（Merge，乐观锁）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Distributed-VCS"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">Distributed VCS</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git工作流"><span class="nav-number">3.</span> <span class="nav-text">Git工作流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Git工作流简介"><span class="nav-number">3.1.</span> <span class="nav-text">Git工作流简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#集中式工作流"><span class="nav-number">3.1.1.</span> <span class="nav-text">集中式工作流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#功能分支工作流"><span class="nav-number">3.1.2.</span> <span class="nav-text">功能分支工作流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Git-Flow工作流"><span class="nav-number">3.1.3.</span> <span class="nav-text">Git Flow工作流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Forking工作流"><span class="nav-number">3.1.4.</span> <span class="nav-text">Forking工作流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pull-Requests"><span class="nav-number">3.1.5.</span> <span class="nav-text">Pull Requests</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集中式工作流-1"><span class="nav-number">3.2.</span> <span class="nav-text">集中式工作流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#工作方式"><span class="nav-number">3.2.1.</span> <span class="nav-text">工作方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决冲突"><span class="nav-number">3.2.2.</span> <span class="nav-text">解决冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例"><span class="nav-number">3.2.3.</span> <span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#有人先初始化好中央仓库"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">有人先初始化好中央仓库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#所有人克隆中央仓库"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">所有人克隆中央仓库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小明开发功能"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">小明开发功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红开发功能"><span class="nav-number">3.2.3.4.</span> <span class="nav-text">小红开发功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小明发布功能"><span class="nav-number">3.2.3.5.</span> <span class="nav-text">小明发布功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红试着发布功能"><span class="nav-number">3.2.3.6.</span> <span class="nav-text">小红试着发布功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红在小明的提交之上rebase"><span class="nav-number">3.2.3.7.</span> <span class="nav-text">小红在小明的提交之上rebase</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红解决合并冲突"><span class="nav-number">3.2.3.8.</span> <span class="nav-text">小红解决合并冲突</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红成功发布功能"><span class="nav-number">3.2.3.9.</span> <span class="nav-text">小红成功发布功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结"><span class="nav-number">3.2.3.10.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#功能分支工作流-1"><span class="nav-number">3.3.</span> <span class="nav-text">功能分支工作流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#工作方式-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">工作方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pull-Requests-1"><span class="nav-number">3.3.2.</span> <span class="nav-text">Pull Requests</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例-1"><span class="nav-number">3.3.3.</span> <span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#小红开始开发一个新功能"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">小红开始开发一个新功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红要去吃个午饭"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">小红要去吃个午饭</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红完成功能开发"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">小红完成功能开发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小黑收到Pull-Request"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">小黑收到Pull  Request</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红再做修改"><span class="nav-number">3.3.3.5.</span> <span class="nav-text">小红再做修改</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红发布她的功能"><span class="nav-number">3.3.3.6.</span> <span class="nav-text">小红发布她的功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#与此同时，小明在做和小红一样的事情"><span class="nav-number">3.3.3.7.</span> <span class="nav-text">与此同时，小明在做和小红一样的事情</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-1"><span class="nav-number">3.3.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GitFlow工作流"><span class="nav-number">3.4.</span> <span class="nav-text">GitFlow工作流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#工作方式-2"><span class="nav-number">3.4.1.</span> <span class="nav-text">工作方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#历史分支"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">历史分支</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#功能分支"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">功能分支</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#发布分支"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">发布分支</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#维护分支"><span class="nav-number">3.4.1.4.</span> <span class="nav-text">维护分支</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例-2"><span class="nav-number">3.4.2.</span> <span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建开发分支"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">创建开发分支</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红和小明开始开发新功能"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">小红和小明开始开发新功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红完成功能开发-1"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">小红完成功能开发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红开始准备发布"><span class="nav-number">3.4.2.4.</span> <span class="nav-text">小红开始准备发布</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红完成发布"><span class="nav-number">3.4.2.5.</span> <span class="nav-text">小红完成发布</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最终用户发现Bug"><span class="nav-number">3.4.2.6.</span> <span class="nav-text">最终用户发现Bug</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-2"><span class="nav-number">3.4.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Forking工作流-1"><span class="nav-number">3.5.</span> <span class="nav-text">Forking工作流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#工作方式-3"><span class="nav-number">3.5.1.</span> <span class="nav-text">工作方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#正式仓库"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">正式仓库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Forking工作流的分支使用方式"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">Forking工作流的分支使用方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例-3"><span class="nav-number">3.5.2.</span> <span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#项目维护者初始化正式仓库"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">项目维护者初始化正式仓库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#开发者fork正式仓库"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">开发者fork正式仓库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#开发者克隆自己fork出来的仓库"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">开发者克隆自己fork出来的仓库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#开发者开发自己的功能"><span class="nav-number">3.5.2.4.</span> <span class="nav-text">开发者开发自己的功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#开发者发布自己的功能"><span class="nav-number">3.5.2.5.</span> <span class="nav-text">开发者发布自己的功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#项目维护者集成开发者的功能"><span class="nav-number">3.5.2.6.</span> <span class="nav-text">项目维护者集成开发者的功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#开发者和正式仓库做同步"><span class="nav-number">3.5.2.7.</span> <span class="nav-text">开发者和正式仓库做同步</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-3"><span class="nav-number">3.5.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pull-Requests-2"><span class="nav-number">3.6.</span> <span class="nav-text">Pull Requests</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解析Pull-Request"><span class="nav-number">3.6.1.</span> <span class="nav-text">解析Pull Request</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工作方式-4"><span class="nav-number">3.6.2.</span> <span class="nav-text">工作方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在功能分支工作流中使用Pull-Request"><span class="nav-number">3.6.3.</span> <span class="nav-text">在功能分支工作流中使用Pull Request</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在GitFlow工作流中使用Pull-Request"><span class="nav-number">3.6.4.</span> <span class="nav-text">在GitFlow工作流中使用Pull Request</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在Forking工作流中使用Pull-Request"><span class="nav-number">3.6.5.</span> <span class="nav-text">在Forking工作流中使用Pull Request</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例-4"><span class="nav-number">3.6.6.</span> <span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#小红fork正式项目"><span class="nav-number">3.6.6.1.</span> <span class="nav-text">小红fork正式项目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红克隆她的Bitbucket仓库"><span class="nav-number">3.6.6.2.</span> <span class="nav-text">小红克隆她的Bitbucket仓库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红开发新功能"><span class="nav-number">3.6.6.3.</span> <span class="nav-text">小红开发新功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#编辑代码"><span class="nav-number">3.6.6.4.</span> <span class="nav-text">编辑代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红push功能到她的Bitbucket仓库中"><span class="nav-number">3.6.6.5.</span> <span class="nav-text">小红push功能到她的Bitbucket仓库中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红发起Pull-Request"><span class="nav-number">3.6.6.6.</span> <span class="nav-text">小红发起Pull Request</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小明-review-Pull-Request"><span class="nav-number">3.6.6.7.</span> <span class="nav-text">小明 review Pull Request</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小红补加提交"><span class="nav-number">3.6.6.8.</span> <span class="nav-text">小红补加提交</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小明接受Pull-Request"><span class="nav-number">3.6.6.9.</span> <span class="nav-text">小明接受Pull Request</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-4"><span class="nav-number">3.6.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; 

<span itemprop="copyrightYear">2020</span>
  <span class="with-love">
  <!--user-->
    <i class="fa fa-heart"></i>
  </span>
 
 <span class="author" itemprop="copyrightHolder">Fsn</span>

  





  <script async src="http://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
 
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
	<span title="Site words total count">
     446.6k字 </span>
    <!--<span title="symbols_count_time.count_total">850k</span>-->
  
</div>



  <!-- <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>-->






<!--



 -->
 






        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-beta.2/lazyload.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  













  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  
  <script type="text/javascript" src="/js/src/exturl.js?v=5.1.4"></script>


  
  
  
  <!-- 
  
  -->
  <link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":100,"vOffset":-10},"mobile":{"show":false},"log":false,"tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>

<!--崩溃欺骗 <script type="text/javascript" src="/js/src/crash_cheat.js"></script> -->




